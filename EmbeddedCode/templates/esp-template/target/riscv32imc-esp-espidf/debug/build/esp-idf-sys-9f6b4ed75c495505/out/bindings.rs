/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const CONFIG_SOC_EFUSE_HAS_EFUSE_RST_BUG: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_HMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_AES_GDMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 5;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 8;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_FILTER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_APB_BACKUP_DMA: u32 = 1;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_MEMORY_IBANK_SIZE: u32 = 16384;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 1;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC: u32 = 1;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 8;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 8;
pub const CONFIG_SOC_CPU_WATCHPOINT_SIZE: u32 = 2147483648;
pub const CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const CONFIG_SOC_GDMA_GROUPS: u32 = 1;
pub const CONFIG_SOC_GDMA_PAIRS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_GDMA_TX_RX_SHARE_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 22;
pub const CONFIG_SOC_GPIO_SUPPORTS_RTC_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP: u32 = 1;
pub const CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK: u32 = 0;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 4194240;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE: u32 = 1;
pub const CONFIG_SOC_I2C_NUM: u32 = 1;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const CONFIG_SOC_I2S_NUM: u32 = 1;
pub const CONFIG_SOC_I2S_HW_VERSION_2: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_CODEC: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 6;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDE_NUM: u32 = 14;
pub const CONFIG_SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH: u32 = 128;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM: u32 = 108;
pub const CONFIG_SOC_RTC_SLOW_CLOCK_SUPPORT_8MD256: u32 = 1;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 0;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 3072;
pub const CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const CONFIG_SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const CONFIG_SOC_SHA_GDMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const CONFIG_SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const CONFIG_SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const CONFIG_SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const CONFIG_SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MAX: u32 = 16384;
pub const CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_PAD_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const CONFIG_SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 32;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 512;
pub const CONFIG_SOC_UART_NUM: u32 = 2;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const CONFIG_SOC_UART_REQUIRE_CORE_RESET: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const CONFIG_SOC_COEX_HW_PTI: u32 = 1;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_MAC_BB_PD_MEM_SIZE: u32 = 192;
pub const CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_PD: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_WIFI_HW_TSF: u32 = 1;
pub const CONFIG_SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_BLE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_50_SUPPORTED: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH_RISCV: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 6usize] = b"riscv\0";
pub const CONFIG_IDF_TARGET: &[u8; 8usize] = b"esp32c3\0";
pub const CONFIG_IDF_TARGET_ESP32C3: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 5;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 0;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_PREFERRED: u32 = 1;
pub const CONFIG_SECURE_ROM_DL_MODE_ENABLED: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 16;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CRC_BE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_MZ_CRC32: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_JPEG_DECODE: u32 = 1;
pub const CONFIG_ESP_ROM_UART_CLK_IS_XTAL: u32 = 1;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: u32 = 3;
pub const CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ERASE_0_REGION_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_GET_CLK_FREQ: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ETS_PRINTF_BUG: u32 = 1;
pub const CONFIG_BOOT_ROM_LOG_ALWAYS_ON: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4usize] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4usize] = b"80m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4usize] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_UART_NONE: u32 = 1;
pub const CONFIG_APPTRACE_UART_TASK_PRIO: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 256;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP_TLS_USE_DS_PERIPHERAL: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP32C3_REV_MIN_3: u32 = 1;
pub const CONFIG_ESP32C3_REV_MIN_FULL: u32 = 3;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 3;
pub const CONFIG_ESP32C3_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ESP32C3_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32C3_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_SYSTIMER_STALL_WORKAROUND: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_RTC_CLOCK_BBPLL_POWER_ON_WITH_USB: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_LCD_PANEL_IO_FORMAT_BUF_SIZE: u32 = 32;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_REDUCE_TX_POWER: u32 = 1;
pub const CONFIG_ESP_PHY_ENABLE_USB: u32 = 1;
pub const CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 8000;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_INTERRUPT_LEVEL: u32 = 1;
pub const CONFIG_ESP_TIMER_IMPL_SYSTIMER: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA: u32 = 1;
pub const CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM: u32 = 7;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_VOLUME_COUNT: u32 = 2;
pub const CONFIG_FATFS_SECTOR_4096: u32 = 1;
pub const CONFIG_FATFS_SECTORS_PER_CLUSTER_1: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_AUTO_TYPE: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FREERTOS_UNICORE: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_OPTIMIZED_SCHEDULER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &[u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_ESP_MLDV6_REPORT: u32 = 1;
pub const CONFIG_LWIP_MLDV6_TMR_INTERVAL: u32 = 40;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID: u32 = 1;
pub const CONFIG_LWIP_DHCP_OPTIONS_LEN: u32 = 68;
pub const CONFIG_LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const CONFIG_LWIP_DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_SNTP_MAX_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_BRIDGEIF_MAX_PORTS: u32 = 7;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_ND6_GET_GW_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_INPUT_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS: u32 = 200;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_AES_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_MPI_USE_INTERRUPT: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8usize] = b"pthread\0";
pub const CONFIG_MMU_PAGE_SIZE_64KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5usize] = b"64KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 65536;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_HAS_ROM_IMPL: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_TH_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN: u32 = 1;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_WPA_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32C3_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32C3_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP32C3_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP32C3_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32C3_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32C3_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32C3_LIGHTSLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP32C3_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP32C3_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP32C3_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32C3_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32C3_TIME_SYSCALL_USE_RTC_SYSTIMER: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 8000;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const ESP_OK: i32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: i32 = 257;
pub const ESP_ERR_INVALID_ARG: i32 = 258;
pub const ESP_ERR_INVALID_STATE: i32 = 259;
pub const ESP_ERR_INVALID_SIZE: i32 = 260;
pub const ESP_ERR_NOT_FOUND: i32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: i32 = 262;
pub const ESP_ERR_TIMEOUT: i32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: i32 = 264;
pub const ESP_ERR_INVALID_CRC: i32 = 265;
pub const ESP_ERR_INVALID_VERSION: i32 = 266;
pub const ESP_ERR_INVALID_MAC: i32 = 267;
pub const ESP_ERR_NOT_FINISHED: i32 = 268;
pub const ESP_ERR_WIFI_BASE: i32 = 12288;
pub const ESP_ERR_MESH_BASE: i32 = 16384;
pub const ESP_ERR_FLASH_BASE: i32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: i32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: i32 = 53248;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const BIT63: i64 = -9223372036854775808;
pub const BIT62: u64 = 4611686018427387904;
pub const BIT61: u64 = 2305843009213693952;
pub const BIT60: u64 = 1152921504606846976;
pub const BIT59: u64 = 576460752303423488;
pub const BIT58: u64 = 288230376151711744;
pub const BIT57: u64 = 144115188075855872;
pub const BIT56: u64 = 72057594037927936;
pub const BIT55: u64 = 36028797018963968;
pub const BIT54: u64 = 18014398509481984;
pub const BIT53: u64 = 9007199254740992;
pub const BIT52: u64 = 4503599627370496;
pub const BIT51: u64 = 2251799813685248;
pub const BIT50: u64 = 1125899906842624;
pub const BIT49: u64 = 562949953421312;
pub const BIT48: u64 = 281474976710656;
pub const BIT47: u64 = 140737488355328;
pub const BIT46: u64 = 70368744177664;
pub const BIT45: u64 = 35184372088832;
pub const BIT44: u64 = 17592186044416;
pub const BIT43: u64 = 8796093022208;
pub const BIT42: u64 = 4398046511104;
pub const BIT41: u64 = 2199023255552;
pub const BIT40: u64 = 1099511627776;
pub const BIT39: u64 = 549755813888;
pub const BIT38: u64 = 274877906944;
pub const BIT37: u64 = 137438953472;
pub const BIT36: u64 = 68719476736;
pub const BIT35: u64 = 34359738368;
pub const BIT34: u64 = 17179869184;
pub const BIT33: u64 = 8589934592;
pub const BIT32: u64 = 4294967296;
pub const ESP_IDF_VERSION_MAJOR: u32 = 5;
pub const ESP_IDF_VERSION_MINOR: u32 = 0;
pub const ESP_IDF_VERSION_PATCH: u32 = 2;
pub const LOG_LOCAL_LEVEL: u32 = 3;
pub const LOG_COLOR_BLACK: &[u8; 3usize] = b"30\0";
pub const LOG_COLOR_RED: &[u8; 3usize] = b"31\0";
pub const LOG_COLOR_GREEN: &[u8; 3usize] = b"32\0";
pub const LOG_COLOR_BROWN: &[u8; 3usize] = b"33\0";
pub const LOG_COLOR_BLUE: &[u8; 3usize] = b"34\0";
pub const LOG_COLOR_PURPLE: &[u8; 3usize] = b"35\0";
pub const LOG_COLOR_CYAN: &[u8; 3usize] = b"36\0";
pub const LOG_RESET_COLOR: &[u8; 5usize] = b"\x1B[0m\0";
pub const DR_REG_SYSTEM_BASE: u32 = 1611399168;
pub const DR_REG_SENSITIVE_BASE: u32 = 1611403264;
pub const DR_REG_INTERRUPT_BASE: u32 = 1611407360;
pub const DR_REG_EXTMEM_BASE: u32 = 1611415552;
pub const DR_REG_MMU_TABLE: u32 = 1611419648;
pub const DR_REG_AES_BASE: u32 = 1610850304;
pub const DR_REG_SHA_BASE: u32 = 1610854400;
pub const DR_REG_RSA_BASE: u32 = 1610858496;
pub const DR_REG_HMAC_BASE: u32 = 1610866688;
pub const DR_REG_DIGITAL_SIGNATURE_BASE: u32 = 1610862592;
pub const DR_REG_GDMA_BASE: u32 = 1610870784;
pub const DR_REG_ASSIST_DEBUG_BASE: u32 = 1611456512;
pub const DR_REG_DEDICATED_GPIO_BASE: u32 = 1611460608;
pub const DR_REG_WORLD_CNTL_BASE: u32 = 1611464704;
pub const DR_REG_UART_BASE: u32 = 1610612736;
pub const DR_REG_SPI1_BASE: u32 = 1610620928;
pub const DR_REG_SPI0_BASE: u32 = 1610625024;
pub const DR_REG_GPIO_BASE: u32 = 1610629120;
pub const DR_REG_FE2_BASE: u32 = 1610633216;
pub const DR_REG_FE_BASE: u32 = 1610637312;
pub const DR_REG_RTCCNTL_BASE: u32 = 1610645504;
pub const DR_REG_IO_MUX_BASE: u32 = 1610649600;
pub const DR_REG_RTC_I2C_BASE: u32 = 1610670080;
pub const DR_REG_UART1_BASE: u32 = 1610678272;
pub const DR_REG_I2C_EXT_BASE: u32 = 1610690560;
pub const DR_REG_UHCI0_BASE: u32 = 1610694656;
pub const DR_REG_RMT_BASE: u32 = 1610702848;
pub const DR_REG_LEDC_BASE: u32 = 1610715136;
pub const DR_REG_EFUSE_BASE: u32 = 1610647552;
pub const DR_REG_NRX_BASE: u32 = 1610730496;
pub const DR_REG_BB_BASE: u32 = 1610731520;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1610739712;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1610743808;
pub const DR_REG_SYSTIMER_BASE: u32 = 1610756096;
pub const DR_REG_SPI2_BASE: u32 = 1610760192;
pub const DR_REG_SYSCON_BASE: u32 = 1610768384;
pub const DR_REG_APB_CTRL_BASE: u32 = 1610768384;
pub const DR_REG_TWAI_BASE: u32 = 1610788864;
pub const DR_REG_I2S0_BASE: u32 = 1610797056;
pub const DR_REG_APB_SARADC_BASE: u32 = 1610874880;
pub const DR_REG_USB_SERIAL_JTAG_BASE: u32 = 1610887168;
pub const DR_REG_AES_XTS_BASE: u32 = 1611448320;
pub const PRO_CPU_NUM: u32 = 0;
pub const APB_CLK_FREQ_ROM: u32 = 40000000;
pub const CPU_CLK_FREQ_ROM: u32 = 40000000;
pub const EFUSE_CLK_FREQ_ROM: u32 = 20000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const RTC_CLK_FREQ: u32 = 20000000;
pub const XTAL_CLK_FREQ: u32 = 40000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 40;
pub const GPIO_MATRIX_DELAY_NS: u32 = 0;
pub const SOC_DROM_LOW: u32 = 1006632960;
pub const SOC_DROM_HIGH: u32 = 1015021568;
pub const SOC_IROM_LOW: u32 = 1107296256;
pub const SOC_IROM_HIGH: u32 = 1115684864;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074135040;
pub const SOC_DROM_MASK_LOW: u32 = 1072693248;
pub const SOC_DROM_MASK_HIGH: u32 = 1072824320;
pub const SOC_IRAM_LOW: u32 = 1077395456;
pub const SOC_IRAM_HIGH: u32 = 1077805056;
pub const SOC_DRAM_LOW: u32 = 1070071808;
pub const SOC_DRAM_HIGH: u32 = 1070465024;
pub const SOC_RTC_IRAM_LOW: u32 = 1342177280;
pub const SOC_RTC_IRAM_HIGH: u32 = 1342185472;
pub const SOC_RTC_DRAM_LOW: u32 = 1342177280;
pub const SOC_RTC_DRAM_HIGH: u32 = 1342185472;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1077411840;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1077805056;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1070071808;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1070465024;
pub const SOC_I_D_OFFSET: u32 = 7340032;
pub const SOC_DMA_LOW: u32 = 1070104576;
pub const SOC_DMA_HIGH: u32 = 1070596096;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1070104576;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1070596096;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1070071808;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1070465024;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 409600;
pub const SOC_PERIPHERAL_LOW: u32 = 1610612736;
pub const SOC_PERIPHERAL_HIGH: u32 = 1611661312;
pub const SOC_DEBUG_LOW: u32 = 536870912;
pub const SOC_DEBUG_HIGH: u32 = 671088640;
pub const SOC_ROM_STACK_START: u32 = 1070458640;
pub const SOC_ROM_STACK_SIZE: u32 = 8192;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_MEMPROT_ERR_INUM: u32 = 26;
pub const ETS_MAX_INUM: u32 = 31;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_SPI2_INUM: u32 = 1;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_INVALID_INUM: u32 = 0;
pub const SOC_INTERRUPT_LEVEL_MEDIUM: u32 = 4;
pub const ETS_INT_WDT_INUM: u32 = 24;
pub const SOC_ADC_SUPPORTED: u32 = 1;
pub const SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const SOC_GDMA_SUPPORTED: u32 = 1;
pub const SOC_TWAI_SUPPORTED: u32 = 1;
pub const SOC_BT_SUPPORTED: u32 = 1;
pub const SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const SOC_WIFI_SUPPORTED: u32 = 1;
pub const SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const SOC_EFUSE_HAS_EFUSE_RST_BUG: u32 = 1;
pub const SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const SOC_I2S_SUPPORTED: u32 = 1;
pub const SOC_RMT_SUPPORTED: u32 = 1;
pub const SOC_SDM_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const SOC_AES_SUPPORTED: u32 = 1;
pub const SOC_MPI_SUPPORTED: u32 = 1;
pub const SOC_SHA_SUPPORTED: u32 = 1;
pub const SOC_HMAC_SUPPORTED: u32 = 1;
pub const SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const SOC_AES_SUPPORT_DMA: u32 = 1;
pub const SOC_AES_GDMA: u32 = 1;
pub const SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const SOC_ADC_FILTER_SUPPORTED: u32 = 1;
pub const SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const SOC_ADC_PERIPH_NUM: u32 = 2;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 5;
pub const SOC_ADC_ATTEN_NUM: u32 = 4;
pub const SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 1;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 8;
pub const SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const SOC_ADC_DIGI_FILTER_NUM: u32 = 2;
pub const SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const SOC_APB_BACKUP_DMA: u32 = 1;
pub const SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const SOC_CACHE_MEMORY_IBANK_SIZE: u32 = 16384;
pub const SOC_CPU_CORES_NUM: u32 = 1;
pub const SOC_CPU_INTR_NUM: u32 = 32;
pub const SOC_CPU_HAS_FLEXIBLE_INTC: u32 = 1;
pub const SOC_CPU_BREAKPOINTS_NUM: u32 = 8;
pub const SOC_CPU_WATCHPOINTS_NUM: u32 = 8;
pub const SOC_CPU_WATCHPOINT_SIZE: u32 = 2147483648;
pub const SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 3072;
pub const SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const SOC_GDMA_GROUPS: u32 = 1;
pub const SOC_GDMA_PAIRS_PER_GROUP: u32 = 3;
pub const SOC_GDMA_TX_RX_SHARE_INTERRUPT: u32 = 1;
pub const SOC_GPIO_PORT: u32 = 1;
pub const SOC_GPIO_PIN_COUNT: u32 = 22;
pub const SOC_GPIO_SUPPORTS_RTC_INDEPENDENT: u32 = 1;
pub const SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP: u32 = 1;
pub const SOC_GPIO_VALID_GPIO_MASK: u32 = 4194303;
pub const SOC_GPIO_VALID_OUTPUT_GPIO_MASK: u32 = 4194303;
pub const SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK: u32 = 63;
pub const SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 4194240;
pub const SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const SOC_DEDIC_PERIPH_ALWAYS_ENABLE: u32 = 1;
pub const SOC_I2C_NUM: u32 = 1;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const SOC_I2S_NUM: u32 = 1;
pub const SOC_I2S_HW_VERSION_2: u32 = 1;
pub const SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_CODEC: u32 = 1;
pub const SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const SOC_LEDC_CHANNEL_NUM: u32 = 6;
pub const SOC_LEDC_TIMER_BIT_WIDE_NUM: u32 = 14;
pub const SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const SOC_MPU_CONFIGURABLE_REGIONS_SUPPORTED: u32 = 0;
pub const SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const SOC_MPU_REGION_RO_SUPPORTED: u32 = 0;
pub const SOC_MPU_REGION_WO_SUPPORTED: u32 = 0;
pub const SOC_RMT_GROUPS: u32 = 1;
pub const SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 2;
pub const SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 2;
pub const SOC_RMT_CHANNELS_PER_GROUP: u32 = 4;
pub const SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const SOC_RMT_SUPPORT_APB: u32 = 1;
pub const SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH: u32 = 128;
pub const SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM: u32 = 108;
pub const SOC_RTC_CNTL_CPU_PD_DMA_ADDR_ALIGN: u32 = 16;
pub const SOC_RTC_CNTL_CPU_PD_DMA_BLOCK_SIZE: u32 = 16;
pub const SOC_RTC_CNTL_CPU_PD_RETENTION_MEM_SIZE: u32 = 1728;
pub const SOC_RTC_SLOW_CLOCK_SUPPORT_8MD256: u32 = 1;
pub const SOC_RTCIO_PIN_COUNT: u32 = 0;
pub const SOC_RSA_MAX_BIT_LEN: u32 = 3072;
pub const SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const SOC_SHA_GDMA: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const SOC_SDM_GROUPS: u32 = 1;
pub const SOC_SDM_CHANNELS_PER_GROUP: u32 = 4;
pub const SOC_SPI_PERIPH_NUM: u32 = 2;
pub const SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_IDLE_INTR: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_CHECK_SUS: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const SOC_TIMER_GROUPS: u32 = 2;
pub const SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 1;
pub const SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 2;
pub const SOC_TWAI_BRP_MIN: u32 = 2;
pub const SOC_TWAI_BRP_MAX: u32 = 16384;
pub const SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const SOC_EFUSE_DIS_PAD_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 32;
pub const SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 512;
pub const SOC_UART_NUM: u32 = 2;
pub const SOC_UART_FIFO_LEN: u32 = 128;
pub const SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const SOC_UART_REQUIRE_CORE_RESET: u32 = 1;
pub const SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const SOC_COEX_HW_PTI: u32 = 1;
pub const SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 84;
pub const SOC_MAC_BB_PD_MEM_SIZE: u32 = 768;
pub const SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const SOC_PM_SUPPORT_WIFI_PD: u32 = 1;
pub const SOC_PM_SUPPORT_BT_PD: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL: u32 = 1;
pub const SOC_WIFI_HW_TSF: u32 = 1;
pub const SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const SOC_BLE_SUPPORTED: u32 = 1;
pub const SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const SOC_BLE_50_SUPPORTED: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_INTR_ENA_REG: u32 = 1611456512;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_ENA_S: u32 = 11;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_ENA_S: u32 = 10;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_ENA_S: u32 = 9;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_ENA_S: u32 = 8;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_ENA_S: u32 = 7;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_ENA_S: u32 = 6;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_ENA_S: u32 = 5;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_ENA_S: u32 = 4;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_ENA_S: u32 = 3;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_ENA_S: u32 = 2;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_ENA_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_ENA_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_ENA_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_INTR_RAW_REG: u32 = 1611456516;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_RAW_S: u32 = 11;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_RAW_S: u32 = 10;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_RAW_S: u32 = 9;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_RAW_S: u32 = 8;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_RAW_S: u32 = 7;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_RAW_S: u32 = 6;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_RAW_S: u32 = 5;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_RAW_S: u32 = 4;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_RAW_S: u32 = 3;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_RAW_S: u32 = 2;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_RAW_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_RAW_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_RAW_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_INTR_RLS_REG: u32 = 1611456520;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_RLS_S: u32 = 11;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_RLS_S: u32 = 10;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_RLS_S: u32 = 9;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_RLS_S: u32 = 8;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_RLS_S: u32 = 7;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_RLS_S: u32 = 6;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_RLS_S: u32 = 5;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_RLS_S: u32 = 4;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_RLS_S: u32 = 3;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_RLS_S: u32 = 2;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_RLS_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_RLS_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_RLS_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_INTR_CLR_REG: u32 = 1611456524;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_CLR_S: u32 = 11;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_CLR_S: u32 = 10;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MAX_CLR_S: u32 = 9;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_SP_SPILL_MIN_CLR_S: u32 = 8;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_WR_CLR_S: u32 = 7;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_RD_CLR_S: u32 = 6;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_WR_CLR_S: u32 = 5;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_RD_CLR_S: u32 = 4;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_WR_CLR_S: u32 = 3;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_RD_CLR_S: u32 = 2;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_WR_CLR_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_CLR_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_RD_CLR_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_REG: u32 = 1611456528;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_REG: u32 = 1611456532;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_REG: u32 = 1611456536;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_REG: u32 = 1611456540;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_REG: u32 = 1611456544;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_REG: u32 = 1611456548;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_REG: u32 = 1611456552;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_REG: u32 = 1611456556;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_PC_REG: u32 = 1611456560;
pub const ASSIST_DEBUG_CORE_0_AREA_PC: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PC_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_PC_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_AREA_SP_REG: u32 = 1611456564;
pub const ASSIST_DEBUG_CORE_0_AREA_SP: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_SP_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_AREA_SP_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_SP_MIN_REG: u32 = 1611456568;
pub const ASSIST_DEBUG_CORE_0_SP_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_SP_MAX_REG: u32 = 1611456572;
pub const ASSIST_DEBUG_CORE_0_SP_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_SP_PC_REG: u32 = 1611456576;
pub const ASSIST_DEBUG_CORE_0_SP_PC: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_PC_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_SP_PC_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_RCD_EN_REG: u32 = 1611456580;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGEN_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGEN_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_RCD_RECORDEN_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_RCD_RECORDEN_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_REG: u32 = 1611456584;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_REG: u32 = 1611456588;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_0_REG: u32 = 1611456592;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_LOADSTORE_0_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_LOADSTORE_0_S: u32 = 25;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_WR_0_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_WR_0_S: u32 = 24;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_0: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_0_V: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_0_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_REG: u32 = 1611456596;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_LOADSTORE_1_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_LOADSTORE_1_S: u32 = 25;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_WR_1_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_WR_1_S: u32 = 24;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_1: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_1_V: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_IRAM0_RECORDING_ADDR_1_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_REG: u32 = 1611456600;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_0: u32 = 15;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_0_V: u32 = 15;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_0_S: u32 = 25;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_WR_0_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_WR_0_S: u32 = 24;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_0: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_0_V: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_0_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_REG: u32 = 1611456604;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_0: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_0_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_0_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_2_REG: u32 = 1611456608;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_1: u32 = 15;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_1_V: u32 = 15;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_BYTEEN_1_S: u32 = 25;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_WR_1_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_WR_1_S: u32 = 24;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_1: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_1_V: u32 = 16777215;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_ADDR_1_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_3_REG: u32 = 1611456612;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_1: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_1_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_DRAM0_RECORDING_PC_1_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_REG: u32 = 1611456616;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0: u32 = 1048575;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0_V: u32 = 1048575;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_REG: u32 = 1611456620;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1: u32 = 1048575;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1_V: u32 = 1048575;
pub const ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_SETTING_REG: u32 = 1611456624;
pub const ASSIST_DEBUG_LOG_MEM_LOOP_ENABLE_V: u32 = 1;
pub const ASSIST_DEBUG_LOG_MEM_LOOP_ENABLE_S: u32 = 7;
pub const ASSIST_DEBUG_LOG_MODE: u32 = 15;
pub const ASSIST_DEBUG_LOG_MODE_V: u32 = 15;
pub const ASSIST_DEBUG_LOG_MODE_S: u32 = 3;
pub const ASSIST_DEBUG_LOG_ENA: u32 = 7;
pub const ASSIST_DEBUG_LOG_ENA_V: u32 = 7;
pub const ASSIST_DEBUG_LOG_ENA_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_DATA_0_REG: u32 = 1611456628;
pub const ASSIST_DEBUG_LOG_DATA_0: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_DATA_0_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_DATA_0_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_DATA_MASK_REG: u32 = 1611456632;
pub const ASSIST_DEBUG_LOG_DATA_SIZE: u32 = 65535;
pub const ASSIST_DEBUG_LOG_DATA_SIZE_V: u32 = 65535;
pub const ASSIST_DEBUG_LOG_DATA_SIZE_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MIN_REG: u32 = 1611456636;
pub const ASSIST_DEBUG_LOG_MIN: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MIN_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MIN_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MAX_REG: u32 = 1611456640;
pub const ASSIST_DEBUG_LOG_MAX: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MAX_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MAX_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MEM_START_REG: u32 = 1611456644;
pub const ASSIST_DEBUG_LOG_MEM_START: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_START_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_START_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MEM_END_REG: u32 = 1611456648;
pub const ASSIST_DEBUG_LOG_MEM_END: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_END_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_END_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MEM_WRITING_ADDR_REG: u32 = 1611456652;
pub const ASSIST_DEBUG_LOG_MEM_WRITING_ADDR: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_WRITING_ADDR_V: u32 = 4294967295;
pub const ASSIST_DEBUG_LOG_MEM_WRITING_ADDR_S: u32 = 0;
pub const ASSIST_DEBUG_LOG_MEM_FULL_FLAG_REG: u32 = 1611456656;
pub const ASSIST_DEBUG_CLR_LOG_MEM_FULL_FLAG_V: u32 = 1;
pub const ASSIST_DEBUG_CLR_LOG_MEM_FULL_FLAG_S: u32 = 1;
pub const ASSIST_DEBUG_LOG_MEM_FULL_FLAG_V: u32 = 1;
pub const ASSIST_DEBUG_LOG_MEM_FULL_FLAG_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_LASTPC_BEFORE_EXCEPTION_REG: u32 = 1611456660;
pub const ASSIST_DEBUG_CORE_0_LASTPC_BEFORE_EXC: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_LASTPC_BEFORE_EXC_V: u32 = 4294967295;
pub const ASSIST_DEBUG_CORE_0_LASTPC_BEFORE_EXC_S: u32 = 0;
pub const ASSIST_DEBUG_CORE_0_DEBUG_MODE_REG: u32 = 1611456664;
pub const ASSIST_DEBUG_CORE_0_DEBUG_MODULE_ACTIVE_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DEBUG_MODULE_ACTIVE_S: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DEBUG_MODE_V: u32 = 1;
pub const ASSIST_DEBUG_CORE_0_DEBUG_MODE_S: u32 = 0;
pub const ASSIST_DEBUG_DATE_REG: u32 = 1611457020;
pub const ASSIST_DEBUG_DATE: u32 = 268435455;
pub const ASSIST_DEBUG_DATE_V: u32 = 268435455;
pub const ASSIST_DEBUG_DATE_S: u32 = 0;
pub const DR_REG_INTERRUPT_CORE0_BASE: u32 = 1611407360;
pub const INTERRUPT_CORE0_MAC_INTR_MAP_REG: u32 = 1611407360;
pub const INTERRUPT_CORE0_MAC_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_MAC_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_MAC_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_MAC_NMI_MAP_REG: u32 = 1611407364;
pub const INTERRUPT_CORE0_MAC_NMI_MAP: u32 = 31;
pub const INTERRUPT_CORE0_MAC_NMI_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_MAC_NMI_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_PWR_INTR_MAP_REG: u32 = 1611407368;
pub const INTERRUPT_CORE0_PWR_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_PWR_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_PWR_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_BB_INT_MAP_REG: u32 = 1611407372;
pub const INTERRUPT_CORE0_BB_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_BB_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_BB_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_BT_MAC_INT_MAP_REG: u32 = 1611407376;
pub const INTERRUPT_CORE0_BT_MAC_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_BT_MAC_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_BT_MAC_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_BT_BB_INT_MAP_REG: u32 = 1611407380;
pub const INTERRUPT_CORE0_BT_BB_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_BT_BB_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_BT_BB_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_BT_BB_NMI_MAP_REG: u32 = 1611407384;
pub const INTERRUPT_CORE0_BT_BB_NMI_MAP: u32 = 31;
pub const INTERRUPT_CORE0_BT_BB_NMI_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_BT_BB_NMI_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RWBT_IRQ_MAP_REG: u32 = 1611407388;
pub const INTERRUPT_CORE0_RWBT_IRQ_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RWBT_IRQ_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RWBT_IRQ_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RWBLE_IRQ_MAP_REG: u32 = 1611407392;
pub const INTERRUPT_CORE0_RWBLE_IRQ_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RWBLE_IRQ_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RWBLE_IRQ_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RWBT_NMI_MAP_REG: u32 = 1611407396;
pub const INTERRUPT_CORE0_RWBT_NMI_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RWBT_NMI_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RWBT_NMI_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RWBLE_NMI_MAP_REG: u32 = 1611407400;
pub const INTERRUPT_CORE0_RWBLE_NMI_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RWBLE_NMI_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RWBLE_NMI_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_I2C_MST_INT_MAP_REG: u32 = 1611407404;
pub const INTERRUPT_CORE0_I2C_MST_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_I2C_MST_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_I2C_MST_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SLC0_INTR_MAP_REG: u32 = 1611407408;
pub const INTERRUPT_CORE0_SLC0_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SLC0_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SLC0_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SLC1_INTR_MAP_REG: u32 = 1611407412;
pub const INTERRUPT_CORE0_SLC1_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SLC1_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SLC1_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_APB_CTRL_INTR_MAP_REG: u32 = 1611407416;
pub const INTERRUPT_CORE0_APB_CTRL_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_APB_CTRL_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_APB_CTRL_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_UHCI0_INTR_MAP_REG: u32 = 1611407420;
pub const INTERRUPT_CORE0_UHCI0_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_UHCI0_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_UHCI0_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_MAP_REG: u32 = 1611407424;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_MAP: u32 = 31;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP_REG: u32 = 1611407428;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP: u32 = 31;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_GPIO_INTERRUPT_PRO_NMI_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SPI_INTR_1_MAP_REG: u32 = 1611407432;
pub const INTERRUPT_CORE0_SPI_INTR_1_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SPI_INTR_1_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SPI_INTR_1_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SPI_INTR_2_MAP_REG: u32 = 1611407436;
pub const INTERRUPT_CORE0_SPI_INTR_2_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SPI_INTR_2_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SPI_INTR_2_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_I2S1_INT_MAP_REG: u32 = 1611407440;
pub const INTERRUPT_CORE0_I2S1_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_I2S1_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_I2S1_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_UART_INTR_MAP_REG: u32 = 1611407444;
pub const INTERRUPT_CORE0_UART_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_UART_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_UART_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_UART1_INTR_MAP_REG: u32 = 1611407448;
pub const INTERRUPT_CORE0_UART1_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_UART1_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_UART1_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_LEDC_INT_MAP_REG: u32 = 1611407452;
pub const INTERRUPT_CORE0_LEDC_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_LEDC_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_LEDC_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_EFUSE_INT_MAP_REG: u32 = 1611407456;
pub const INTERRUPT_CORE0_EFUSE_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_EFUSE_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_EFUSE_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CAN_INT_MAP_REG: u32 = 1611407460;
pub const INTERRUPT_CORE0_CAN_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CAN_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CAN_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_USB_INTR_MAP_REG: u32 = 1611407464;
pub const INTERRUPT_CORE0_USB_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_USB_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_USB_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RTC_CORE_INTR_MAP_REG: u32 = 1611407468;
pub const INTERRUPT_CORE0_RTC_CORE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RTC_CORE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RTC_CORE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RMT_INTR_MAP_REG: u32 = 1611407472;
pub const INTERRUPT_CORE0_RMT_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RMT_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RMT_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_I2C_EXT0_INTR_MAP_REG: u32 = 1611407476;
pub const INTERRUPT_CORE0_I2C_EXT0_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_I2C_EXT0_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_I2C_EXT0_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TIMER_INT1_MAP_REG: u32 = 1611407480;
pub const INTERRUPT_CORE0_TIMER_INT1_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TIMER_INT1_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TIMER_INT1_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TIMER_INT2_MAP_REG: u32 = 1611407484;
pub const INTERRUPT_CORE0_TIMER_INT2_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TIMER_INT2_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TIMER_INT2_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TG_T0_INT_MAP_REG: u32 = 1611407488;
pub const INTERRUPT_CORE0_TG_T0_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TG_T0_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TG_T0_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TG_WDT_INT_MAP_REG: u32 = 1611407492;
pub const INTERRUPT_CORE0_TG_WDT_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TG_WDT_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TG_WDT_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TG1_T0_INT_MAP_REG: u32 = 1611407496;
pub const INTERRUPT_CORE0_TG1_T0_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TG1_T0_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TG1_T0_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_TG1_WDT_INT_MAP_REG: u32 = 1611407500;
pub const INTERRUPT_CORE0_TG1_WDT_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_TG1_WDT_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_TG1_WDT_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CACHE_IA_INT_MAP_REG: u32 = 1611407504;
pub const INTERRUPT_CORE0_CACHE_IA_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CACHE_IA_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CACHE_IA_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET0_INT_MAP_REG: u32 = 1611407508;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET0_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET0_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET0_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET1_INT_MAP_REG: u32 = 1611407512;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET1_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET1_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET1_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET2_INT_MAP_REG: u32 = 1611407516;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET2_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET2_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SYSTIMER_TARGET2_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SPI_MEM_REJECT_INTR_MAP_REG: u32 = 1611407520;
pub const INTERRUPT_CORE0_SPI_MEM_REJECT_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SPI_MEM_REJECT_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SPI_MEM_REJECT_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_ICACHE_PRELOAD_INT_MAP_REG: u32 = 1611407524;
pub const INTERRUPT_CORE0_ICACHE_PRELOAD_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_ICACHE_PRELOAD_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_ICACHE_PRELOAD_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_ICACHE_SYNC_INT_MAP_REG: u32 = 1611407528;
pub const INTERRUPT_CORE0_ICACHE_SYNC_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_ICACHE_SYNC_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_ICACHE_SYNC_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_APB_ADC_INT_MAP_REG: u32 = 1611407532;
pub const INTERRUPT_CORE0_APB_ADC_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_APB_ADC_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_APB_ADC_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_DMA_CH0_INT_MAP_REG: u32 = 1611407536;
pub const INTERRUPT_CORE0_DMA_CH0_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH0_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH0_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_DMA_CH1_INT_MAP_REG: u32 = 1611407540;
pub const INTERRUPT_CORE0_DMA_CH1_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH1_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH1_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_DMA_CH2_INT_MAP_REG: u32 = 1611407544;
pub const INTERRUPT_CORE0_DMA_CH2_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH2_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_DMA_CH2_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_RSA_INT_MAP_REG: u32 = 1611407548;
pub const INTERRUPT_CORE0_RSA_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_RSA_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_RSA_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_AES_INT_MAP_REG: u32 = 1611407552;
pub const INTERRUPT_CORE0_AES_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_AES_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_AES_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_SHA_INT_MAP_REG: u32 = 1611407556;
pub const INTERRUPT_CORE0_SHA_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_SHA_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_SHA_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_0_MAP_REG: u32 = 1611407560;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_0_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_0_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_0_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_1_MAP_REG: u32 = 1611407564;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_1_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_1_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_1_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_2_MAP_REG: u32 = 1611407568;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_2_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_2_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_2_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_3_MAP_REG: u32 = 1611407572;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_3_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_3_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CPU_INTR_FROM_CPU_3_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_ASSIST_DEBUG_INTR_MAP_REG: u32 = 1611407576;
pub const INTERRUPT_CORE0_ASSIST_DEBUG_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_ASSIST_DEBUG_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_ASSIST_DEBUG_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP_REG: u32 = 1611407580;
pub const INTERRUPT_CORE0_DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_REG: u32 = 1611407584;
pub const INTERRUPT_CORE0_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_REG: u32 = 1611407588;
pub const INTERRUPT_CORE0_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP_REG: u32 = 1611407592;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP_REG: u32 = 1611407596;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_BACKUP_PMS_VIOLATE_INTR_MAP_REG: u32 = 1611407600;
pub const INTERRUPT_CORE0_BACKUP_PMS_VIOLATE_INTR_MAP: u32 = 31;
pub const INTERRUPT_CORE0_BACKUP_PMS_VIOLATE_INTR_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_BACKUP_PMS_VIOLATE_INTR_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CACHE_CORE0_ACS_INT_MAP_REG: u32 = 1611407604;
pub const INTERRUPT_CORE0_CACHE_CORE0_ACS_INT_MAP: u32 = 31;
pub const INTERRUPT_CORE0_CACHE_CORE0_ACS_INT_MAP_V: u32 = 31;
pub const INTERRUPT_CORE0_CACHE_CORE0_ACS_INT_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_INTR_STATUS_0_REG: u32 = 1611407608;
pub const INTERRUPT_CORE0_INTR_STATUS_0: u32 = 4294967295;
pub const INTERRUPT_CORE0_INTR_STATUS_0_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_INTR_STATUS_0_S: u32 = 0;
pub const INTERRUPT_CORE0_INTR_STATUS_1_REG: u32 = 1611407612;
pub const INTERRUPT_CORE0_INTR_STATUS_1: u32 = 4294967295;
pub const INTERRUPT_CORE0_INTR_STATUS_1_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_INTR_STATUS_1_S: u32 = 0;
pub const INTERRUPT_CORE0_CLOCK_GATE_REG: u32 = 1611407616;
pub const INTERRUPT_CORE0_CLK_EN_V: u32 = 1;
pub const INTERRUPT_CORE0_CLK_EN_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_ENABLE_REG: u32 = 1611407620;
pub const INTERRUPT_CORE0_CPU_INT_ENABLE: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_ENABLE_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_ENABLE_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_TYPE_REG: u32 = 1611407624;
pub const INTERRUPT_CORE0_CPU_INT_TYPE: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_TYPE_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_TYPE_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_CLEAR_REG: u32 = 1611407628;
pub const INTERRUPT_CORE0_CPU_INT_CLEAR: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_CLEAR_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_CLEAR_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_EIP_STATUS_REG: u32 = 1611407632;
pub const INTERRUPT_CORE0_CPU_INT_EIP_STATUS: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_EIP_STATUS_V: u32 = 4294967295;
pub const INTERRUPT_CORE0_CPU_INT_EIP_STATUS_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_0_REG: u32 = 1611407636;
pub const INTERRUPT_CORE0_CPU_PRI_0_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_0_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_0_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_1_REG: u32 = 1611407640;
pub const INTERRUPT_CORE0_CPU_PRI_1_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_1_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_1_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_2_REG: u32 = 1611407644;
pub const INTERRUPT_CORE0_CPU_PRI_2_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_2_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_2_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_3_REG: u32 = 1611407648;
pub const INTERRUPT_CORE0_CPU_PRI_3_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_3_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_3_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_4_REG: u32 = 1611407652;
pub const INTERRUPT_CORE0_CPU_PRI_4_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_4_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_4_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_5_REG: u32 = 1611407656;
pub const INTERRUPT_CORE0_CPU_PRI_5_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_5_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_5_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_6_REG: u32 = 1611407660;
pub const INTERRUPT_CORE0_CPU_PRI_6_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_6_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_6_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_7_REG: u32 = 1611407664;
pub const INTERRUPT_CORE0_CPU_PRI_7_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_7_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_7_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_8_REG: u32 = 1611407668;
pub const INTERRUPT_CORE0_CPU_PRI_8_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_8_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_8_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_9_REG: u32 = 1611407672;
pub const INTERRUPT_CORE0_CPU_PRI_9_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_9_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_9_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_10_REG: u32 = 1611407676;
pub const INTERRUPT_CORE0_CPU_PRI_10_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_10_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_10_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_11_REG: u32 = 1611407680;
pub const INTERRUPT_CORE0_CPU_PRI_11_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_11_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_11_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_12_REG: u32 = 1611407684;
pub const INTERRUPT_CORE0_CPU_PRI_12_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_12_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_12_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_13_REG: u32 = 1611407688;
pub const INTERRUPT_CORE0_CPU_PRI_13_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_13_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_13_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_14_REG: u32 = 1611407692;
pub const INTERRUPT_CORE0_CPU_PRI_14_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_14_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_14_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_15_REG: u32 = 1611407696;
pub const INTERRUPT_CORE0_CPU_PRI_15_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_15_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_15_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_16_REG: u32 = 1611407700;
pub const INTERRUPT_CORE0_CPU_PRI_16_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_16_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_16_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_17_REG: u32 = 1611407704;
pub const INTERRUPT_CORE0_CPU_PRI_17_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_17_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_17_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_18_REG: u32 = 1611407708;
pub const INTERRUPT_CORE0_CPU_PRI_18_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_18_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_18_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_19_REG: u32 = 1611407712;
pub const INTERRUPT_CORE0_CPU_PRI_19_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_19_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_19_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_20_REG: u32 = 1611407716;
pub const INTERRUPT_CORE0_CPU_PRI_20_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_20_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_20_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_21_REG: u32 = 1611407720;
pub const INTERRUPT_CORE0_CPU_PRI_21_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_21_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_21_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_22_REG: u32 = 1611407724;
pub const INTERRUPT_CORE0_CPU_PRI_22_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_22_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_22_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_23_REG: u32 = 1611407728;
pub const INTERRUPT_CORE0_CPU_PRI_23_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_23_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_23_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_24_REG: u32 = 1611407732;
pub const INTERRUPT_CORE0_CPU_PRI_24_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_24_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_24_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_25_REG: u32 = 1611407736;
pub const INTERRUPT_CORE0_CPU_PRI_25_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_25_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_25_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_26_REG: u32 = 1611407740;
pub const INTERRUPT_CORE0_CPU_PRI_26_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_26_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_26_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_27_REG: u32 = 1611407744;
pub const INTERRUPT_CORE0_CPU_PRI_27_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_27_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_27_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_28_REG: u32 = 1611407748;
pub const INTERRUPT_CORE0_CPU_PRI_28_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_28_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_28_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_29_REG: u32 = 1611407752;
pub const INTERRUPT_CORE0_CPU_PRI_29_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_29_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_29_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_30_REG: u32 = 1611407756;
pub const INTERRUPT_CORE0_CPU_PRI_30_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_30_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_30_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_PRI_31_REG: u32 = 1611407760;
pub const INTERRUPT_CORE0_CPU_PRI_31_MAP: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_31_MAP_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_PRI_31_MAP_S: u32 = 0;
pub const INTERRUPT_CORE0_CPU_INT_THRESH_REG: u32 = 1611407764;
pub const INTERRUPT_CORE0_CPU_INT_THRESH: u32 = 15;
pub const INTERRUPT_CORE0_CPU_INT_THRESH_V: u32 = 15;
pub const INTERRUPT_CORE0_CPU_INT_THRESH_S: u32 = 0;
pub const INTERRUPT_CORE0_INTERRUPT_DATE_REG: u32 = 1611409404;
pub const INTERRUPT_CORE0_INTERRUPT_DATE: u32 = 268435455;
pub const INTERRUPT_CORE0_INTERRUPT_DATE_V: u32 = 268435455;
pub const INTERRUPT_CORE0_INTERRUPT_DATE_S: u32 = 0;
pub const ARG_MAX: u32 = 4096;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NBBY: u32 = 8;
pub const HZ: u32 = 60;
pub const NOFILE: u32 = 60;
pub const PATHSIZE: u32 = 1024;
pub const MAXPATHLEN: u32 = 1024;
pub const MSTATUS_UIE: u32 = 1;
pub const MSTATUS_SIE: u32 = 2;
pub const MSTATUS_HIE: u32 = 4;
pub const MSTATUS_MIE: u32 = 8;
pub const MSTATUS_UPIE: u32 = 16;
pub const MSTATUS_SPIE: u32 = 32;
pub const MSTATUS_HPIE: u32 = 64;
pub const MSTATUS_MPIE: u32 = 128;
pub const MSTATUS_SPP: u32 = 256;
pub const MSTATUS_VS: u32 = 1536;
pub const MSTATUS_MPP: u32 = 6144;
pub const MSTATUS_FS: u32 = 24576;
pub const MSTATUS_XS: u32 = 98304;
pub const MSTATUS_MPRV: u32 = 131072;
pub const MSTATUS_SUM: u32 = 262144;
pub const MSTATUS_MXR: u32 = 524288;
pub const MSTATUS_TVM: u32 = 1048576;
pub const MSTATUS_TW: u32 = 2097152;
pub const MSTATUS_TSR: u32 = 4194304;
pub const MSTATUS32_SD: u32 = 2147483648;
pub const MSTATUS_UXL: u64 = 12884901888;
pub const MSTATUS_SXL: u64 = 51539607552;
pub const MSTATUS64_SD: i64 = -9223372036854775808;
pub const SSTATUS_UIE: u32 = 1;
pub const SSTATUS_SIE: u32 = 2;
pub const SSTATUS_UPIE: u32 = 16;
pub const SSTATUS_SPIE: u32 = 32;
pub const SSTATUS_SPP: u32 = 256;
pub const SSTATUS_VS: u32 = 1536;
pub const SSTATUS_FS: u32 = 24576;
pub const SSTATUS_XS: u32 = 98304;
pub const SSTATUS_SUM: u32 = 262144;
pub const SSTATUS_MXR: u32 = 524288;
pub const SSTATUS32_SD: u32 = 2147483648;
pub const SSTATUS_UXL: u64 = 12884901888;
pub const SSTATUS64_SD: i64 = -9223372036854775808;
pub const USTATUS_UIE: u32 = 1;
pub const USTATUS_UPIE: u32 = 16;
pub const DCSR_XDEBUGVER: u32 = 3221225472;
pub const DCSR_NDRESET: u32 = 536870912;
pub const DCSR_FULLRESET: u32 = 268435456;
pub const DCSR_EBREAKM: u32 = 32768;
pub const DCSR_EBREAKH: u32 = 16384;
pub const DCSR_EBREAKS: u32 = 8192;
pub const DCSR_EBREAKU: u32 = 4096;
pub const DCSR_STOPCYCLE: u32 = 1024;
pub const DCSR_STOPTIME: u32 = 512;
pub const DCSR_CAUSE: u32 = 448;
pub const DCSR_DEBUGINT: u32 = 32;
pub const DCSR_HALT: u32 = 8;
pub const DCSR_STEP: u32 = 4;
pub const DCSR_PRV: u32 = 3;
pub const DCSR_CAUSE_NONE: u32 = 0;
pub const DCSR_CAUSE_SWBP: u32 = 1;
pub const DCSR_CAUSE_HWBP: u32 = 2;
pub const DCSR_CAUSE_DEBUGINT: u32 = 3;
pub const DCSR_CAUSE_STEP: u32 = 4;
pub const DCSR_CAUSE_HALT: u32 = 5;
pub const DCSR_CAUSE_GROUP: u32 = 6;
pub const MCONTROL_SELECT: u32 = 524288;
pub const MCONTROL_TIMING: u32 = 262144;
pub const MCONTROL_ACTION: u32 = 258048;
pub const MCONTROL_CHAIN: u32 = 2048;
pub const MCONTROL_MATCH: u32 = 1920;
pub const MCONTROL_M: u32 = 64;
pub const MCONTROL_H: u32 = 32;
pub const MCONTROL_S: u32 = 16;
pub const MCONTROL_U: u32 = 8;
pub const MCONTROL_EXECUTE: u32 = 4;
pub const MCONTROL_STORE: u32 = 2;
pub const MCONTROL_LOAD: u32 = 1;
pub const MCONTROL_TYPE_NONE: u32 = 0;
pub const MCONTROL_TYPE_MATCH: u32 = 2;
pub const MCONTROL_ACTION_DEBUG_EXCEPTION: u32 = 0;
pub const MCONTROL_ACTION_DEBUG_MODE: u32 = 1;
pub const MCONTROL_ACTION_TRACE_START: u32 = 2;
pub const MCONTROL_ACTION_TRACE_STOP: u32 = 3;
pub const MCONTROL_ACTION_TRACE_EMIT: u32 = 4;
pub const MCONTROL_MATCH_EQUAL: u32 = 0;
pub const MCONTROL_MATCH_NAPOT: u32 = 1;
pub const MCONTROL_MATCH_GE: u32 = 2;
pub const MCONTROL_MATCH_LT: u32 = 3;
pub const MCONTROL_MATCH_MASK_LOW: u32 = 4;
pub const MCONTROL_MATCH_MASK_HIGH: u32 = 5;
pub const PRV_U: u32 = 0;
pub const PRV_S: u32 = 1;
pub const PRV_H: u32 = 2;
pub const PRV_M: u32 = 3;
pub const SATP32_MODE: u32 = 2147483648;
pub const SATP32_ASID: u32 = 2143289344;
pub const SATP32_PPN: u32 = 4194303;
pub const SATP64_MODE: i64 = -1152921504606846976;
pub const SATP64_ASID: u64 = 1152903912420802560;
pub const SATP64_PPN: u64 = 17592186044415;
pub const SATP_MODE_OFF: u32 = 0;
pub const SATP_MODE_SV32: u32 = 1;
pub const SATP_MODE_SV39: u32 = 8;
pub const SATP_MODE_SV48: u32 = 9;
pub const SATP_MODE_SV57: u32 = 10;
pub const SATP_MODE_SV64: u32 = 11;
pub const PMP_R: u32 = 1;
pub const PMP_W: u32 = 2;
pub const PMP_X: u32 = 4;
pub const PMP_A: u32 = 24;
pub const PMP_L: u32 = 128;
pub const PMP_SHIFT: u32 = 2;
pub const PMP_TOR: u32 = 8;
pub const PMP_NA4: u32 = 16;
pub const PMP_NAPOT: u32 = 24;
pub const IRQ_U_SOFT: u32 = 0;
pub const IRQ_S_SOFT: u32 = 1;
pub const IRQ_H_SOFT: u32 = 2;
pub const IRQ_M_SOFT: u32 = 3;
pub const IRQ_U_TIMER: u32 = 4;
pub const IRQ_S_TIMER: u32 = 5;
pub const IRQ_H_TIMER: u32 = 6;
pub const IRQ_M_TIMER: u32 = 7;
pub const IRQ_U_EXT: u32 = 8;
pub const IRQ_S_EXT: u32 = 9;
pub const IRQ_H_EXT: u32 = 10;
pub const IRQ_M_EXT: u32 = 11;
pub const IRQ_COP: u32 = 12;
pub const IRQ_HOST: u32 = 13;
pub const DEFAULT_RSTVEC: u32 = 4096;
pub const CLINT_BASE: u32 = 33554432;
pub const CLINT_SIZE: u32 = 786432;
pub const EXT_IO_BASE: u32 = 1073741824;
pub const DRAM_BASE: u32 = 2147483648;
pub const PTE_V: u32 = 1;
pub const PTE_R: u32 = 2;
pub const PTE_W: u32 = 4;
pub const PTE_X: u32 = 8;
pub const PTE_U: u32 = 16;
pub const PTE_G: u32 = 32;
pub const PTE_A: u32 = 64;
pub const PTE_D: u32 = 128;
pub const PTE_SOFT: u32 = 768;
pub const PTE_PPN_SHIFT: u32 = 10;
pub const MSTATUS_SD: u32 = 2147483648;
pub const SSTATUS_SD: u32 = 2147483648;
pub const RISCV_PGLEVEL_BITS: u32 = 10;
pub const SATP_MODE: u32 = 2147483648;
pub const RISCV_PGSHIFT: u32 = 12;
pub const RISCV_PGSIZE: u32 = 4096;
pub const CSR_PMPCFG0: u32 = 928;
pub const CSR_PMPADDR0: u32 = 944;
pub const PMPADDR_ALL: u32 = 4294967295;
pub const CSR_TCONTROL: u32 = 1957;
pub const CSR_TDATA1: u32 = 1953;
pub const TCONTROL_MTE: u32 = 8;
pub const TCONTROL_MPTE: u32 = 128;
pub const TDATA1_LOAD: u32 = 1;
pub const TDATA1_STORE: u32 = 2;
pub const TDATA1_EXECUTE: u32 = 4;
pub const TDATA1_USER: u32 = 8;
pub const TDATA1_MACHINE: u32 = 64;
pub const TDATA1_MATCH: u32 = 128;
pub const TDATA1_MATCH_V: u32 = 15;
pub const TDATA1_MATCH_S: u32 = 7;
pub const CSR_PCER_MACHINE: u32 = 2016;
pub const CSR_PCMR_MACHINE: u32 = 2017;
pub const CSR_PCCR_MACHINE: u32 = 2018;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_UNUSED_INTR_SOURCE: i32 = -99;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const ESP_CPU_INTR_DESC_FLAG_SPECIAL: u32 = 1;
pub const ESP_CPU_INTR_DESC_FLAG_RESVD: u32 = 2;
pub const TOUCH_PAD_SLEEP_CYCLE_DEFAULT: u32 = 15;
pub const TOUCH_PAD_MEASURE_CYCLE_DEFAULT: u32 = 500;
pub const TOUCH_PROXIMITY_MEAS_NUM_MAX: u32 = 255;
pub const TOUCH_DEBOUNCE_CNT_MAX: u32 = 7;
pub const TOUCH_NOISE_THR_MAX: u32 = 3;
pub const TOUCH_JITTER_STEP_MAX: u32 = 15;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configMAX_API_CALL_INTERRUPT_PRIORITY: u32 = 0;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const STACK_OVERHEAD_CHECKER: u32 = 0;
pub const STACK_OVERHEAD_OPTIMIZATION: u32 = 0;
pub const STACK_OVERHEAD_APPTRACE: u32 = 0;
pub const STACK_OVERHEAD_WATCHPOINT: u32 = 0;
pub const configSTACK_OVERHEAD_TOTAL: u32 = 0;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configCPU_CLOCK_HZ: u32 = 160000000;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configMINIMAL_STACK_SIZE: u32 = 768;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configUSE_NEWLIB_REENTRANT: u32 = 1;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 1;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_xTaskAbortDelay: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const INCLUDE_xTaskGetHandle: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_pxTaskGetStackStart: u32 = 1;
pub const portNUM_PROCESSORS: u32 = 1;
pub const configNUM_CORES: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1536;
pub const configCHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const SPINLOCK_FREE: u32 = 3007315967;
pub const SPINLOCK_WAIT_FOREVER: i32 = -1;
pub const SPINLOCK_NO_WAIT: u32 = 0;
pub const CORE_ID_REGVAL_XOR_SWAP: u32 = 26214;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_IRAM_8BIT: u32 = 8192;
pub const MALLOC_CAP_RETENTION: u32 = 16384;
pub const MALLOC_CAP_RTCRAM: u32 = 32768;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const RVHAL_EXCM_LEVEL: u32 = 4;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 16;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portTcbMemoryCaps: u32 = 2052;
pub const portStackMemoryCaps: u32 = 2052;
pub const portBYTE_ALIGNMENT_MASK: u32 = 15;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configENABLE_MPU: u32 = 0;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const ESP_TASK_PRIO_MAX: u32 = 25;
pub const ESP_TASK_PRIO_MIN: u32 = 0;
pub const ESP_TASK_BT_CONTROLLER_PRIO: u32 = 23;
pub const TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const BT_TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const ESP_TASK_BT_CONTROLLER_STACK: u32 = 4096;
pub const ESP_TASK_PING_STACK: u32 = 2560;
pub const ESP_TASK_TIMER_PRIO: u32 = 22;
pub const ESP_TASK_TIMER_STACK: u32 = 4096;
pub const ESP_TASKD_EVENT_PRIO: u32 = 20;
pub const ESP_TASKD_EVENT_STACK: u32 = 2816;
pub const ESP_TASK_TCPIP_PRIO: u32 = 18;
pub const ESP_TASK_TCPIP_STACK: u32 = 3584;
pub const ESP_TASK_MAIN_PRIO: u32 = 1;
pub const ESP_TASK_MAIN_STACK: u32 = 8512;
pub const ESP_TASK_MAIN_CORE: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 8usize] = b"V10.4.3\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 4;
pub const tskKERNEL_VERSION_BUILD: u32 = 3;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub const tskNO_AFFINITY: u32 = 2147483647;
pub const MACSTR: &[u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const TWO_UNIVERSAL_MAC_ADDR: u32 = 2;
pub const FOUR_UNIVERSAL_MAC_ADDR: u32 = 4;
pub const UNIVERSAL_MAC_ADDR_NUM: u32 = 4;
pub const ATOMIC_COMPARE_AND_SWAP_SUCCESS: u32 = 1;
pub const ATOMIC_COMPARE_AND_SWAP_FAILURE: u32 = 0;
pub const MWDT0_TICK_PRESCALER: u32 = 40000;
pub const MWDT0_TICKS_PER_US: u32 = 500;
pub const MWDT1_TICK_PRESCALER: u32 = 40000;
pub const MWDT1_TICKS_PER_US: u32 = 500;
pub const IWDT_PRESCALER: u32 = 40000;
pub const IWDT_TICKS_PER_US: u32 = 500;
pub const IWDT_INITIAL_TIMEOUT_S: u32 = 5;
pub const _CLOCKS_PER_SEC_: u32 = 1000000;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLK_TCK: u32 = 1000000;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const ARG_REX_ICASE: u32 = 1;
pub const ARG_DSTR_SIZE: u32 = 200;
pub const ARG_CMD_NAME_LEN: u32 = 100;
pub const ARG_CMD_DESCRIPTION_LEN: u32 = 256;
pub const ARG_REPLACE_GETOPT: u32 = 0;
pub const ESP_ERR_EFUSE: i32 = 5632;
pub const ESP_OK_EFUSE_CNT: u32 = 5633;
pub const ESP_ERR_EFUSE_CNT_IS_FULL: i32 = 5634;
pub const ESP_ERR_EFUSE_REPEATED_PROG: i32 = 5635;
pub const ESP_ERR_CODING: i32 = 5636;
pub const ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS: i32 = 5637;
pub const ESP_ERR_DAMAGED_READING: i32 = 5638;
pub const ESP_ERR_FLASH_NOT_INITIALISED: i32 = 24579;
pub const ESP_ERR_FLASH_UNSUPPORTED_HOST: i32 = 24580;
pub const ESP_ERR_FLASH_UNSUPPORTED_CHIP: i32 = 24581;
pub const ESP_ERR_FLASH_PROTECTED: i32 = 24582;
pub const SPI_FLASH_OPI_FLAG: u32 = 16;
pub const ESP_ERR_FLASH_OP_FAIL: i32 = 24577;
pub const ESP_ERR_FLASH_OP_TIMEOUT: i32 = 24578;
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const SPI_FLASH_MMU_PAGE_SIZE: u32 = 65536;
pub const ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED: u32 = 1;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const IPSTR: &[u8; 12usize] = b"%d.%d.%d.%d\0";
pub const IPV6STR: &[u8; 40usize] = b"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\0";
pub const ESP_IPADDR_TYPE_V4: u32 = 0;
pub const ESP_IPADDR_TYPE_V6: u32 = 6;
pub const ESP_IPADDR_TYPE_ANY: u32 = 46;
pub const ESP_ERR_ESP_NETIF_BASE: i32 = 20480;
pub const ESP_ERR_ESP_NETIF_INVALID_PARAMS: i32 = 20481;
pub const ESP_ERR_ESP_NETIF_IF_NOT_READY: i32 = 20482;
pub const ESP_ERR_ESP_NETIF_DHCPC_START_FAILED: i32 = 20483;
pub const ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED: i32 = 20484;
pub const ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED: i32 = 20485;
pub const ESP_ERR_ESP_NETIF_NO_MEM: i32 = 20486;
pub const ESP_ERR_ESP_NETIF_DHCP_NOT_STOPPED: i32 = 20487;
pub const ESP_ERR_ESP_NETIF_DRIVER_ATTACH_FAILED: i32 = 20488;
pub const ESP_ERR_ESP_NETIF_INIT_FAILED: i32 = 20489;
pub const ESP_ERR_ESP_NETIF_DNS_NOT_CONFIGURED: i32 = 20490;
pub const ESP_ERR_ESP_NETIF_MLD6_FAILED: i32 = 20491;
pub const ESP_ERR_ESP_NETIF_IP6_ADDR_FAILED: i32 = 20492;
pub const ESP_ERR_ESP_NETIF_DHCPS_START_FAILED: i32 = 20493;
pub const ESP_NETIF_BR_FLOOD: i32 = -1;
pub const ESP_NETIF_BR_DROP: u32 = 0;
pub const ESP_NETIF_BR_FDW_CPU: i64 = -9223372036854775808;
pub const WIFI_OFFCHAN_TX_REQ: u32 = 1;
pub const WIFI_OFFCHAN_TX_CANCEL: u32 = 0;
pub const WIFI_ROC_REQ: u32 = 1;
pub const WIFI_ROC_CANCEL: u32 = 0;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_FILTER_MASK_FCSFAIL: u32 = 64;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const MAX_SSID_LEN: u32 = 32;
pub const MAX_PASSPHRASE_LEN: u32 = 64;
pub const MAX_WPS_AP_CRED: u32 = 3;
pub const WIFI_STATIS_BUFFER: u32 = 1;
pub const WIFI_STATIS_RXTX: u32 = 2;
pub const WIFI_STATIS_HW: u32 = 4;
pub const WIFI_STATIS_DIAG: u32 = 8;
pub const WIFI_STATIS_PS: u32 = 16;
pub const WIFI_STATIS_ALL: i32 = -1;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 8;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const ESP_ERR_WIFI_NOT_INIT: i32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: i32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: i32 = 12291;
pub const ESP_ERR_WIFI_IF: i32 = 12292;
pub const ESP_ERR_WIFI_MODE: i32 = 12293;
pub const ESP_ERR_WIFI_STATE: i32 = 12294;
pub const ESP_ERR_WIFI_CONN: i32 = 12295;
pub const ESP_ERR_WIFI_NVS: i32 = 12296;
pub const ESP_ERR_WIFI_MAC: i32 = 12297;
pub const ESP_ERR_WIFI_SSID: i32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: i32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: i32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: i32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: i32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: i32 = 12303;
pub const ESP_ERR_WIFI_POST: i32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: i32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: i32 = 12308;
pub const ESP_ERR_WIFI_NOT_ASSOC: i32 = 12309;
pub const ESP_ERR_WIFI_TX_DISALLOW: i32 = 12310;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_CACHE_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_AMSDU_TX_ENABLED: u32 = 0;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const WIFI_STA_DISCONNECTED_PM_ENABLED: u32 = 1;
pub const CONFIG_FEATURE_WPA3_SAE_BIT: u32 = 1;
pub const CONFIG_FEATURE_CACHE_TX_BUF_BIT: u32 = 2;
pub const CONFIG_FEATURE_FTM_INITIATOR_BIT: u32 = 4;
pub const CONFIG_FEATURE_FTM_RESPONDER_BIT: u32 = 8;
pub const ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE: u32 = 0;
pub const MAX_WIFI_IFS: u32 = 2;
pub const ESP_ERR_ESPNOW_BASE: i32 = 12388;
pub const ESP_ERR_ESPNOW_NOT_INIT: i32 = 12389;
pub const ESP_ERR_ESPNOW_ARG: i32 = 12390;
pub const ESP_ERR_ESPNOW_NO_MEM: i32 = 12391;
pub const ESP_ERR_ESPNOW_FULL: i32 = 12392;
pub const ESP_ERR_ESPNOW_NOT_FOUND: i32 = 12393;
pub const ESP_ERR_ESPNOW_INTERNAL: i32 = 12394;
pub const ESP_ERR_ESPNOW_EXIST: i32 = 12395;
pub const ESP_ERR_ESPNOW_IF: i32 = 12396;
pub const ESP_NOW_ETH_ALEN: u32 = 6;
pub const ESP_NOW_KEY_LEN: u32 = 16;
pub const ESP_NOW_MAX_TOTAL_PEER_NUM: u32 = 20;
pub const ESP_NOW_MAX_ENCRYPT_PEER_NUM: u32 = 6;
pub const ESP_NOW_MAX_DATA_LEN: u32 = 250;
pub const WIFI_LOG_SUBMODULE_ALL: u32 = 0;
pub const WIFI_LOG_SUBMODULE_INIT: u32 = 1;
pub const WIFI_LOG_SUBMODULE_IOCTL: u32 = 2;
pub const WIFI_LOG_SUBMODULE_CONN: u32 = 4;
pub const WIFI_LOG_SUBMODULE_SCAN: u32 = 8;
pub const MESH_MAX_CONNECTIONS: u32 = 10;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 125;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 126;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 127;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 128;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 129;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 130;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 131;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 132;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 133;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 134;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 135;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 136;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 137;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 138;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 139;
pub const _SC_POSIX_26_VERSION: u32 = 140;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const _FOPEN: i32 = -1;
pub const _FREAD: u32 = 1;
pub const _FWRITE: u32 = 2;
pub const _FAPPEND: u32 = 8;
pub const _FMARK: u32 = 16;
pub const _FDEFER: u32 = 32;
pub const _FASYNC: u32 = 64;
pub const _FSHLOCK: u32 = 128;
pub const _FEXLOCK: u32 = 256;
pub const _FCREAT: u32 = 512;
pub const _FTRUNC: u32 = 1024;
pub const _FEXCL: u32 = 2048;
pub const _FNBIO: u32 = 4096;
pub const _FSYNC: u32 = 8192;
pub const _FNONBLOCK: u32 = 16384;
pub const _FNDELAY: u32 = 16384;
pub const _FNOCTTY: u32 = 32768;
pub const _FNOINHERIT: u32 = 262144;
pub const _FDIRECT: u32 = 524288;
pub const _FNOFOLLOW: u32 = 1048576;
pub const _FDIRECTORY: u32 = 2097152;
pub const _FEXECSRCH: u32 = 4194304;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_APPEND: u32 = 8;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_SYNC: u32 = 8192;
pub const O_NONBLOCK: u32 = 16384;
pub const O_NOCTTY: u32 = 32768;
pub const O_CLOEXEC: u32 = 262144;
pub const O_NOFOLLOW: u32 = 1048576;
pub const O_DIRECTORY: u32 = 2097152;
pub const O_EXEC: u32 = 4194304;
pub const O_SEARCH: u32 = 4194304;
pub const O_DIRECT: u32 = 524288;
pub const FAPPEND: u32 = 8;
pub const FSYNC: u32 = 8192;
pub const FASYNC: u32 = 64;
pub const FNBIO: u32 = 4096;
pub const FNONBIO: u32 = 16384;
pub const FNDELAY: u32 = 16384;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const FMARK: u32 = 16;
pub const FDEFER: u32 = 32;
pub const FSHLOCK: u32 = 128;
pub const FEXLOCK: u32 = 256;
pub const FOPEN: i32 = -1;
pub const FCREAT: u32 = 512;
pub const FTRUNC: u32 = 1024;
pub const FEXCL: u32 = 2048;
pub const FNOCTTY: u32 = 32768;
pub const FNONBLOCK: u32 = 16384;
pub const FD_CLOEXEC: u32 = 1;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_RGETLK: u32 = 10;
pub const F_RSETLK: u32 = 11;
pub const F_CNVT: u32 = 12;
pub const F_RSETLKW: u32 = 13;
pub const F_DUPFD_CLOEXEC: u32 = 14;
pub const F_RDLCK: u32 = 1;
pub const F_WRLCK: u32 = 2;
pub const F_UNLCK: u32 = 3;
pub const F_UNLKSYS: u32 = 4;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 1;
pub const AT_SYMLINK_NOFOLLOW: u32 = 2;
pub const AT_SYMLINK_FOLLOW: u32 = 4;
pub const AT_REMOVEDIR: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const _IFMT: u32 = 61440;
pub const _IFDIR: u32 = 16384;
pub const _IFCHR: u32 = 8192;
pub const _IFBLK: u32 = 24576;
pub const _IFREG: u32 = 32768;
pub const _IFLNK: u32 = 40960;
pub const _IFSOCK: u32 = 49152;
pub const _IFIFO: u32 = 4096;
pub const S_BLKSIZE: u32 = 1024;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_ENFMT: u32 = 1024;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFIFO: u32 = 4096;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const DEFFILEMODE: u32 = 438;
pub const POLLIN: u32 = 1;
pub const POLLRDNORM: u32 = 2;
pub const POLLRDBAND: u32 = 4;
pub const POLLPRI: u32 = 4;
pub const POLLOUT: u32 = 8;
pub const POLLWRNORM: u32 = 8;
pub const POLLWRBAND: u32 = 16;
pub const POLLERR: u32 = 32;
pub const POLLHUP: u32 = 64;
pub const POLLNVAL: u32 = 128;
pub const IPV6_MULTICAST_IF: u32 = 768;
pub const IPV6_MULTICAST_HOPS: u32 = 769;
pub const IPV6_MULTICAST_LOOP: u32 = 770;
pub const ERR_NEED_SCHED: u32 = 123;
pub const LWIP_COMPAT_MUTEX: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 1;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEMP_NUM_NETCONN: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 16;
pub const MEMP_NUM_UDP_PCB: u32 = 16;
pub const ARP_QUEUEING: u32 = 1;
pub const LWIP_IPV4: u32 = 1;
pub const IP_REASSEMBLY: u32 = 0;
pub const IP_FRAG: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_NAPT: u32 = 0;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const LWIP_ICMP: u32 = 1;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const DHCP_DOES_ARP_CHECK: u32 = 1;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const ESP_DHCP_DISABLE_CLIENT_ID: u32 = 0;
pub const DHCP_OPTIONS_LEN: u32 = 68;
pub const ESP_DHCP_DISABLE_VENDOR_CLASS_IDENTIFIER: u32 = 1;
pub const DHCP_DEFINE_CUSTOM_TIMEOUTS: u32 = 1;
pub const DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const DHCP_NEXT_TIMEOUT_THRESHOLD: u32 = 3;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_MAX_SERVERS: u32 = 3;
pub const DNS_FALLBACK_SERVER_INDEX: u32 = 2;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_WND: u32 = 5744;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 12;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const LWIP_TCP_SACK_OUT: u32 = 0;
pub const TCP_MSS: u32 = 1440;
pub const TCP_SND_BUF: u32 = 5744;
pub const TCP_LISTEN_BACKLOG: u32 = 1;
pub const TCP_OVERSIZE: u32 = 1440;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const TCP_TMR_INTERVAL: u32 = 250;
pub const TCP_MSL: u32 = 60000;
pub const TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const LWIP_TCP_RTO_TIME: u32 = 1500;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_EXT_STATUS_CALLBACK: u32 = 1;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_ESP_NETIF_DATA: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const BRIDGEIF_MAX_PORTS: u32 = 7;
pub const LWIP_HAVE_LOOPIF: u32 = 1;
pub const LWIP_NETIF_LOOPBACK: u32 = 1;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const TCPIP_THREAD_NAME: &[u8; 4usize] = b"tiT\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 3584;
pub const TCPIP_THREAD_PRIO: u32 = 18;
pub const TCPIP_MBOX_SIZE: u32 = 32;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 6;
pub const DEFAULT_THREAD_STACKSIZE: u32 = 3584;
pub const DEFAULT_THREAD_PRIO: u32 = 18;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 6;
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 1;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 1;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 0;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_SOCKET_OFFSET: u32 = 54;
pub const LWIP_SO_SNDTIMEO: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 1;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_SO_LINGER: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 1;
pub const SO_REUSE_RXTOALL: u32 = 1;
pub const LWIP_TIMEVAL_PRIVATE: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const ESP_STATS_MEM: u32 = 0;
pub const PPP_SUPPORT: u32 = 0;
pub const CHECKSUM_CHECK_IP: u32 = 0;
pub const CHECKSUM_CHECK_UDP: u32 = 0;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 1;
pub const LWIP_IPV6_REASS: u32 = 0;
pub const ESP_IPV6_AUTOCONFIG: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 5;
pub const LWIP_HOOK_FILENAME: &[u8; 21usize] = b"lwip_default_hooks.h\0";
pub const SNTP_MAX_SERVERS: u32 = 1;
pub const SNTP_SERVER_DNS: u32 = 1;
pub const ESP_LWIP_IGMP_TIMERS_ONDEMAND: u32 = 1;
pub const ESP_LWIP_MLD6_TIMERS_ONDEMAND: u32 = 1;
pub const ESP_LWIP_DHCP_FINE_TIMERS_ONDEMAND: u32 = 1;
pub const ESP_LWIP_DNS_TIMERS_ONDEMAND: u32 = 1;
pub const ESP_GRATUITOUS_ARP: u32 = 1;
pub const ESP_GRATUITOUS_ARP_INTERVAL: u32 = 60000;
pub const ESP_MLDV6_REPORT: u32 = 1;
pub const ESP_LWIP: u32 = 1;
pub const ESP_LWIP_ARP: u32 = 1;
pub const ESP_PER_SOC_TCP_WND: u32 = 0;
pub const ESP_THREAD_SAFE: u32 = 1;
pub const ESP_DHCP: u32 = 1;
pub const ESP_DNS: u32 = 1;
pub const ESP_STATS_TCP: u32 = 0;
pub const ESP_PING: u32 = 1;
pub const ESP_HAS_SELECT: u32 = 1;
pub const ESP_IP4_ROUTE: u32 = 1;
pub const ESP_AUTO_IP: u32 = 1;
pub const ESP_PBUF: u32 = 1;
pub const ESP_PPP: u32 = 1;
pub const ESP_IPV6: u32 = 1;
pub const ESP_SOCKET: u32 = 1;
pub const ESP_LWIP_SELECT: u32 = 1;
pub const ESP_LWIP_LOCK: u32 = 1;
pub const ESP_THREAD_PROTECTION: u32 = 1;
pub const LWIP_SUPPORT_CUSTOM_PBUF: u32 = 1;
pub const ESP_DHCPS: u32 = 1;
pub const ESP_DHCPS_TIMER: u32 = 0;
pub const __error_t_defined: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const ESHUTDOWN: u32 = 110;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const S16_F: &[u8; 2usize] = b"d\0";
pub const U16_F: &[u8; 2usize] = b"d\0";
pub const X16_F: &[u8; 2usize] = b"x\0";
pub const S32_F: &[u8; 2usize] = b"d\0";
pub const U32_F: &[u8; 2usize] = b"u\0";
pub const X32_F: &[u8; 2usize] = b"x\0";
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_HAVE_INT64: u32 = 1;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const LWIP_UINT32_MAX: u32 = 4294967295;
pub const LWIP_NO_CTYPE_H: u32 = 0;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _N: u32 = 4;
pub const _S: u32 = 8;
pub const _P: u32 = 16;
pub const _C: u32 = 32;
pub const _X: u32 = 64;
pub const _B: u32 = 128;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const NO_SYS: u32 = 0;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEMP_MEM_INIT: u32 = 0;
pub const MEM_SIZE: u32 = 1600;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_OVERFLOW_CHECK: u32 = 0;
pub const MEM_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_ALTCP_PCB: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_SELECT_CB: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const PBUF_POOL_SIZE: u32 = 16;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const ICMP_TTL: u32 = 255;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_MAX_DNS_SERVERS: u32 = 3;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_RETRIES: u32 = 4;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const TCP_TTL: u32 = 255;
pub const LWIP_TCP_MAX_SACK_NUM: u32 = 4;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_QUEUELEN: u32 = 16;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_TCP_PCB_NUM_EXT_ARGS: u32 = 0;
pub const LWIP_ALTCP: u32 = 0;
pub const LWIP_ALTCP_TLS: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_SINGLE_NETIF: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5usize] = b"lwIP\0";
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LWIP_SOCKET_SELECT: u32 = 1;
pub const LWIP_SOCKET_POLL: u32 = 1;
pub const LINK_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const IP6_STATS: u32 = 0;
pub const ICMP6_STATS: u32 = 0;
pub const IP6_FRAG_STATS: u32 = 0;
pub const MLD6_STATS: u32 = 0;
pub const ND6_STATS: u32 = 0;
pub const MIB2_STATS: u32 = 0;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const IPV6_REASS_MAXAGE: u32 = 60;
pub const LWIP_IPV6_SCOPES_DEBUG: u32 = 0;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 1;
pub const LWIP_IPV6_ADDRESS_LIFETIMES: u32 = 1;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 1;
pub const LWIP_ICMP6_DATASIZE: u32 = 0;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 1;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 1;
pub const ESP_ND6_QUEUEING: u32 = 1;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_IPV6_DHCP6_STATEFUL: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATELESS: u32 = 0;
pub const LWIP_DHCP6_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP6_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP6_MAX_DNS_SERVERS: u32 = 3;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const API_MSG_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DHCP6_DEBUG: u32 = 0;
pub const LWIP_TESTMODE: u32 = 0;
pub const NAPT_DEBUG: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IP6_NO_ZONE: u32 = 0;
pub const IPV6_CUSTOM_SCOPES: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED0: u32 = 0;
pub const IP6_MULTICAST_SCOPE_INTERFACE_LOCAL: u32 = 1;
pub const IP6_MULTICAST_SCOPE_LINK_LOCAL: u32 = 2;
pub const IP6_MULTICAST_SCOPE_RESERVED3: u32 = 3;
pub const IP6_MULTICAST_SCOPE_ADMIN_LOCAL: u32 = 4;
pub const IP6_MULTICAST_SCOPE_SITE_LOCAL: u32 = 5;
pub const IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL: u32 = 8;
pub const IP6_MULTICAST_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MULTICAST_SCOPE_RESERVEDF: u32 = 15;
pub const IP6_ADDR_INVALID: u32 = 0;
pub const IP6_ADDR_TENTATIVE: u32 = 8;
pub const IP6_ADDR_TENTATIVE_1: u32 = 9;
pub const IP6_ADDR_TENTATIVE_2: u32 = 10;
pub const IP6_ADDR_TENTATIVE_3: u32 = 11;
pub const IP6_ADDR_TENTATIVE_4: u32 = 12;
pub const IP6_ADDR_TENTATIVE_5: u32 = 13;
pub const IP6_ADDR_TENTATIVE_6: u32 = 14;
pub const IP6_ADDR_TENTATIVE_7: u32 = 15;
pub const IP6_ADDR_VALID: u32 = 16;
pub const IP6_ADDR_PREFERRED: u32 = 48;
pub const IP6_ADDR_DEPRECATED: u32 = 16;
pub const IP6_ADDR_DUPLICATED: u32 = 64;
pub const IP6_ADDR_TENTATIVE_COUNT_MASK: u32 = 7;
pub const IP6_ADDR_LIFE_STATIC: u32 = 0;
pub const IP6_ADDR_LIFE_INFINITE: u32 = 4294967295;
pub const IP6ADDR_STRLEN_MAX: u32 = 46;
pub const IPADDR_STRLEN_MAX: u32 = 46;
pub const MESH_ROOT_LAYER: u32 = 1;
pub const MESH_MTU: u32 = 1500;
pub const MESH_MPS: u32 = 1472;
pub const ESP_ERR_MESH_WIFI_NOT_START: i32 = 16385;
pub const ESP_ERR_MESH_NOT_INIT: i32 = 16386;
pub const ESP_ERR_MESH_NOT_CONFIG: i32 = 16387;
pub const ESP_ERR_MESH_NOT_START: i32 = 16388;
pub const ESP_ERR_MESH_NOT_SUPPORT: i32 = 16389;
pub const ESP_ERR_MESH_NOT_ALLOWED: i32 = 16390;
pub const ESP_ERR_MESH_NO_MEMORY: i32 = 16391;
pub const ESP_ERR_MESH_ARGUMENT: i32 = 16392;
pub const ESP_ERR_MESH_EXCEED_MTU: i32 = 16393;
pub const ESP_ERR_MESH_TIMEOUT: i32 = 16394;
pub const ESP_ERR_MESH_DISCONNECTED: i32 = 16395;
pub const ESP_ERR_MESH_QUEUE_FAIL: i32 = 16396;
pub const ESP_ERR_MESH_QUEUE_FULL: i32 = 16397;
pub const ESP_ERR_MESH_NO_PARENT_FOUND: i32 = 16398;
pub const ESP_ERR_MESH_NO_ROUTE_FOUND: i32 = 16399;
pub const ESP_ERR_MESH_OPTION_NULL: i32 = 16400;
pub const ESP_ERR_MESH_OPTION_UNKNOWN: i32 = 16401;
pub const ESP_ERR_MESH_XON_NO_WINDOW: i32 = 16402;
pub const ESP_ERR_MESH_INTERFACE: i32 = 16403;
pub const ESP_ERR_MESH_DISCARD_DUPLICATE: i32 = 16404;
pub const ESP_ERR_MESH_DISCARD: i32 = 16405;
pub const ESP_ERR_MESH_VOTING: i32 = 16406;
pub const ESP_ERR_MESH_XMIT: i32 = 16407;
pub const ESP_ERR_MESH_QUEUE_READ: i32 = 16408;
pub const ESP_ERR_MESH_PS: i32 = 16409;
pub const ESP_ERR_MESH_RECV_RELEASE: i32 = 16410;
pub const MESH_DATA_ENC: u32 = 1;
pub const MESH_DATA_P2P: u32 = 2;
pub const MESH_DATA_FROMDS: u32 = 4;
pub const MESH_DATA_TODS: u32 = 8;
pub const MESH_DATA_NONBLOCK: u32 = 16;
pub const MESH_DATA_DROP: u32 = 32;
pub const MESH_DATA_GROUP: u32 = 64;
pub const MESH_OPT_SEND_GROUP: u32 = 7;
pub const MESH_OPT_RECV_DS_ADDR: u32 = 8;
pub const MESH_ASSOC_FLAG_VOTE_IN_PROGRESS: u32 = 2;
pub const MESH_ASSOC_FLAG_NETWORK_FREE: u32 = 8;
pub const MESH_ASSOC_FLAG_ROOTS_FOUND: u32 = 32;
pub const MESH_ASSOC_FLAG_ROOT_FIXED: u32 = 64;
pub const MESH_PS_DEVICE_DUTY_REQUEST: u32 = 1;
pub const MESH_PS_DEVICE_DUTY_DEMAND: u32 = 4;
pub const MESH_PS_NETWORK_DUTY_MASTER: u32 = 128;
pub const MESH_PS_NETWORK_DUTY_APPLIED_ENTIRE: u32 = 0;
pub const MESH_PS_NETWORK_DUTY_APPLIED_UPLINK: u32 = 1;
pub const ESP_ERR_WIFI_REGISTRAR: i32 = 12339;
pub const ESP_ERR_WIFI_WPS_TYPE: i32 = 12340;
pub const ESP_ERR_WIFI_WPS_SM: i32 = 12341;
pub const WPS_MAX_MANUFACTURER_LEN: u32 = 65;
pub const WPS_MAX_MODEL_NUMBER_LEN: u32 = 33;
pub const WPS_MAX_MODEL_NAME_LEN: u32 = 33;
pub const WPS_MAX_DEVICE_NAME_LEN: u32 = 33;
pub const PIN_LEN: u32 = 9;
pub const ETH_ADDR_LEN: u32 = 6;
pub const ETH_HEADER_LEN: u32 = 14;
pub const ETH_VLAN_TAG_LEN: u32 = 4;
pub const ETH_CRC_LEN: u32 = 4;
pub const ETH_MAX_PAYLOAD_LEN: u32 = 1500;
pub const ETH_MIN_PAYLOAD_LEN: u32 = 46;
pub const ETH_JUMBO_FRAME_PAYLOAD_LEN: u32 = 9000;
pub const ETH_MAX_PACKET_SIZE: u32 = 1522;
pub const ETH_MIN_PACKET_SIZE: u32 = 64;
pub const ETH_IEEE802_3_MAX_LEN: u32 = 1500;
pub const ETH_T_8021Q: u32 = 33024;
pub const ETH_T_8021AD: u32 = 34984;
pub const SPI_MAX_DMA_LEN: u32 = 4092;
pub const SPICOMMON_BUSFLAG_SLAVE: u32 = 0;
pub const SPICOMMON_BUSFLAG_MASTER: u32 = 1;
pub const SPICOMMON_BUSFLAG_IOMUX_PINS: u32 = 2;
pub const SPICOMMON_BUSFLAG_GPIO_PINS: u32 = 4;
pub const SPICOMMON_BUSFLAG_SCLK: u32 = 8;
pub const SPICOMMON_BUSFLAG_MISO: u32 = 16;
pub const SPICOMMON_BUSFLAG_MOSI: u32 = 32;
pub const SPICOMMON_BUSFLAG_DUAL: u32 = 64;
pub const SPICOMMON_BUSFLAG_WPHD: u32 = 128;
pub const SPICOMMON_BUSFLAG_QUAD: u32 = 192;
pub const SPICOMMON_BUSFLAG_IO4_IO7: u32 = 256;
pub const SPICOMMON_BUSFLAG_OCTAL: u32 = 448;
pub const SPICOMMON_BUSFLAG_NATIVE_PINS: u32 = 2;
pub const SPI_MASTER_FREQ_8M: u32 = 8000000;
pub const SPI_MASTER_FREQ_9M: u32 = 8888888;
pub const SPI_MASTER_FREQ_10M: u32 = 10000000;
pub const SPI_MASTER_FREQ_11M: u32 = 11428571;
pub const SPI_MASTER_FREQ_13M: u32 = 13333333;
pub const SPI_MASTER_FREQ_16M: u32 = 16000000;
pub const SPI_MASTER_FREQ_20M: u32 = 20000000;
pub const SPI_MASTER_FREQ_26M: u32 = 26666666;
pub const SPI_MASTER_FREQ_40M: u32 = 40000000;
pub const SPI_MASTER_FREQ_80M: u32 = 80000000;
pub const SPI_DEVICE_TXBIT_LSBFIRST: u32 = 1;
pub const SPI_DEVICE_RXBIT_LSBFIRST: u32 = 2;
pub const SPI_DEVICE_BIT_LSBFIRST: u32 = 3;
pub const SPI_DEVICE_3WIRE: u32 = 4;
pub const SPI_DEVICE_POSITIVE_CS: u32 = 8;
pub const SPI_DEVICE_HALFDUPLEX: u32 = 16;
pub const SPI_DEVICE_CLK_AS_CS: u32 = 32;
pub const SPI_DEVICE_NO_DUMMY: u32 = 64;
pub const SPI_DEVICE_DDRCLK: u32 = 128;
pub const SPI_TRANS_MODE_DIO: u32 = 1;
pub const SPI_TRANS_MODE_QIO: u32 = 2;
pub const SPI_TRANS_USE_RXDATA: u32 = 4;
pub const SPI_TRANS_USE_TXDATA: u32 = 8;
pub const SPI_TRANS_MODE_DIOQIO_ADDR: u32 = 16;
pub const SPI_TRANS_VARIABLE_CMD: u32 = 32;
pub const SPI_TRANS_VARIABLE_ADDR: u32 = 64;
pub const SPI_TRANS_VARIABLE_DUMMY: u32 = 128;
pub const SPI_TRANS_CS_KEEP_ACTIVE: u32 = 256;
pub const SPI_TRANS_MULTILINE_CMD: u32 = 512;
pub const SPI_TRANS_MODE_OCT: u32 = 1024;
pub const SPI_TRANS_MULTILINE_ADDR: u32 = 16;
pub const ETH_MAC_FLAG_WORK_WITH_CACHE_DISABLE: u32 = 1;
pub const ETH_MAC_FLAG_PIN_TO_CORE: u32 = 2;
pub const ESP_ETH_PHY_ADDR_AUTO: i32 = -1;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const VEOF: u32 = 0;
pub const VEOL: u32 = 1;
pub const VERASE: u32 = 2;
pub const VINTR: u32 = 3;
pub const VKILL: u32 = 4;
pub const VMIN: u32 = 5;
pub const VQUIT: u32 = 6;
pub const VSTART: u32 = 7;
pub const VSTOP: u32 = 8;
pub const VSUSP: u32 = 9;
pub const VTIME: u32 = 10;
pub const NCCS: u32 = 11;
pub const BRKINT: u32 = 1;
pub const ICRNL: u32 = 2;
pub const IGNBRK: u32 = 4;
pub const IGNCR: u32 = 8;
pub const IGNPAR: u32 = 16;
pub const INLCR: u32 = 32;
pub const INPCK: u32 = 64;
pub const ISTRIP: u32 = 128;
pub const IUCLC: u32 = 256;
pub const IXANY: u32 = 512;
pub const IXOFF: u32 = 1024;
pub const IXON: u32 = 2048;
pub const PARMRK: u32 = 4096;
pub const OPOST: u32 = 1;
pub const OLCUC: u32 = 2;
pub const ONLCR: u32 = 4;
pub const OCRNL: u32 = 8;
pub const ONOCR: u32 = 16;
pub const ONLRET: u32 = 32;
pub const OFILL: u32 = 64;
pub const NLDLY: u32 = 128;
pub const NL0: u32 = 0;
pub const NL1: u32 = 128;
pub const CRDLY: u32 = 768;
pub const CR0: u32 = 0;
pub const CR1: u32 = 256;
pub const CR2: u32 = 512;
pub const CR3: u32 = 768;
pub const TABDLY: u32 = 3072;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 1024;
pub const TAB2: u32 = 2048;
pub const TAB3: u32 = 3072;
pub const BSDLY: u32 = 4096;
pub const BS0: u32 = 0;
pub const BS1: u32 = 4096;
pub const VTDLY: u32 = 8192;
pub const VT0: u32 = 0;
pub const VT1: u32 = 8192;
pub const FFDLY: u32 = 16384;
pub const FF0: u32 = 0;
pub const FF1: u32 = 16384;
pub const B0: u32 = 0;
pub const B50: u32 = 1;
pub const B75: u32 = 2;
pub const B110: u32 = 3;
pub const B134: u32 = 4;
pub const B150: u32 = 5;
pub const B200: u32 = 6;
pub const B300: u32 = 7;
pub const B600: u32 = 8;
pub const B1200: u32 = 9;
pub const B1800: u32 = 10;
pub const B2400: u32 = 11;
pub const B4800: u32 = 12;
pub const B9600: u32 = 13;
pub const B19200: u32 = 14;
pub const B38400: u32 = 15;
pub const B57600: u32 = 16;
pub const B115200: u32 = 17;
pub const B230400: u32 = 18;
pub const B460800: u32 = 19;
pub const B500000: u32 = 20;
pub const B576000: u32 = 21;
pub const B921600: u32 = 22;
pub const B1000000: u32 = 23;
pub const B1152000: u32 = 24;
pub const B1500000: u32 = 25;
pub const B2000000: u32 = 26;
pub const B2500000: u32 = 27;
pub const B3000000: u32 = 28;
pub const B3500000: u32 = 29;
pub const B4000000: u32 = 30;
pub const CSIZE: u32 = 3;
pub const CS5: u32 = 0;
pub const CS6: u32 = 1;
pub const CS7: u32 = 2;
pub const CS8: u32 = 3;
pub const CSTOPB: u32 = 4;
pub const CREAD: u32 = 8;
pub const PARENB: u32 = 16;
pub const PARODD: u32 = 32;
pub const HUPCL: u32 = 64;
pub const CLOCAL: u32 = 128;
pub const CBAUD: u32 = 256;
pub const CBAUDEX: u32 = 512;
pub const BOTHER: u32 = 1024;
pub const ECHO: u32 = 1;
pub const ECHOE: u32 = 2;
pub const ECHOK: u32 = 4;
pub const ECHONL: u32 = 8;
pub const ICANON: u32 = 16;
pub const IEXTEN: u32 = 32;
pub const ISIG: u32 = 64;
pub const NOFLSH: u32 = 128;
pub const TOSTOP: u32 = 256;
pub const XCASE: u32 = 512;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TCIFLUSH: u32 = 0;
pub const TCIOFLUSH: u32 = 1;
pub const TCOFLUSH: u32 = 2;
pub const TCIOFF: u32 = 0;
pub const TCION: u32 = 1;
pub const TCOOFF: u32 = 2;
pub const TCOON: u32 = 3;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_REG: u32 = 1;
pub const DT_DIR: u32 = 2;
pub const MAXNAMLEN: u32 = 255;
pub const MAX_FDS: u32 = 64;
pub const ESP_VFS_PATH_MAX: u32 = 15;
pub const ESP_VFS_FLAG_DEFAULT: u32 = 0;
pub const ESP_VFS_FLAG_CONTEXT_PTR: u32 = 1;
pub const EFD_SUPPORT_ISR: u32 = 16;
pub const GPIO_MATRIX_CONST_ONE_INPUT: u32 = 30;
pub const GPIO_MATRIX_CONST_ZERO_INPUT: u32 = 31;
pub const GPIO_PIN_COUNT: u32 = 22;
pub const SCF_ITSDONE: u32 = 1;
pub const SCF_CMD_AC: u32 = 0;
pub const SCF_CMD_ADTC: u32 = 16;
pub const SCF_CMD_BC: u32 = 32;
pub const SCF_CMD_BCR: u32 = 48;
pub const SCF_CMD_READ: u32 = 64;
pub const SCF_RSP_BSY: u32 = 256;
pub const SCF_RSP_136: u32 = 512;
pub const SCF_RSP_CRC: u32 = 1024;
pub const SCF_RSP_IDX: u32 = 2048;
pub const SCF_RSP_PRESENT: u32 = 4096;
pub const SCF_RSP_R0: u32 = 0;
pub const SCF_RSP_R1: u32 = 7168;
pub const SCF_RSP_R1B: u32 = 7424;
pub const SCF_RSP_R2: u32 = 5632;
pub const SCF_RSP_R3: u32 = 4096;
pub const SCF_RSP_R4: u32 = 4096;
pub const SCF_RSP_R5: u32 = 7168;
pub const SCF_RSP_R5B: u32 = 7424;
pub const SCF_RSP_R6: u32 = 7168;
pub const SCF_RSP_R7: u32 = 7168;
pub const SCF_WAIT_BUSY: u32 = 8192;
pub const SDMMC_FREQ_DEFAULT: u32 = 20000;
pub const SDMMC_FREQ_HIGHSPEED: u32 = 40000;
pub const SDMMC_FREQ_PROBING: u32 = 400;
pub const SDMMC_FREQ_52M: u32 = 52000;
pub const SDMMC_FREQ_26M: u32 = 26000;
pub const FF_DEFINED: u32 = 86631;
pub const FFCONF_DEF: u32 = 86631;
pub const FF_FS_READONLY: u32 = 0;
pub const FF_FS_MINIMIZE: u32 = 0;
pub const FF_USE_FIND: u32 = 0;
pub const FF_USE_MKFS: u32 = 1;
pub const FF_USE_EXPAND: u32 = 0;
pub const FF_USE_CHMOD: u32 = 1;
pub const FF_USE_LABEL: u32 = 0;
pub const FF_USE_FORWARD: u32 = 0;
pub const FF_USE_STRFUNC: u32 = 0;
pub const FF_PRINT_LLI: u32 = 0;
pub const FF_PRINT_FLOAT: u32 = 0;
pub const FF_STRF_ENCODE: u32 = 3;
pub const FF_CODE_PAGE: u32 = 437;
pub const FF_USE_LFN: u32 = 0;
pub const FF_LFN_UNICODE: u32 = 0;
pub const FF_LFN_BUF: u32 = 255;
pub const FF_SFN_BUF: u32 = 12;
pub const FF_FS_RPATH: u32 = 0;
pub const FF_VOLUMES: u32 = 2;
pub const FF_STR_VOLUME_ID: u32 = 0;
pub const FF_MULTI_PARTITION: u32 = 1;
pub const FF_SS_SDCARD: u32 = 512;
pub const FF_SS_WL: u32 = 4096;
pub const FF_LBA64: u32 = 0;
pub const FF_MIN_GPT: u32 = 268435456;
pub const FF_USE_TRIM: u32 = 1;
pub const FF_FS_EXFAT: u32 = 0;
pub const FF_FS_NORTC: u32 = 0;
pub const FF_NORTC_MON: u32 = 1;
pub const FF_NORTC_MDAY: u32 = 1;
pub const FF_NORTC_YEAR: u32 = 2020;
pub const FF_FS_NOFSINFO: u32 = 0;
pub const FF_FS_LOCK: u32 = 0;
pub const FF_FS_REENTRANT: u32 = 1;
pub const FF_INTDEF: u32 = 2;
pub const FA_READ: u32 = 1;
pub const FA_WRITE: u32 = 2;
pub const FA_OPEN_EXISTING: u32 = 0;
pub const FA_CREATE_NEW: u32 = 4;
pub const FA_CREATE_ALWAYS: u32 = 8;
pub const FA_OPEN_ALWAYS: u32 = 16;
pub const FA_OPEN_APPEND: u32 = 48;
pub const FM_FAT: u32 = 1;
pub const FM_FAT32: u32 = 2;
pub const FM_EXFAT: u32 = 4;
pub const FM_ANY: u32 = 7;
pub const FM_SFD: u32 = 8;
pub const FS_FAT12: u32 = 1;
pub const FS_FAT16: u32 = 2;
pub const FS_FAT32: u32 = 3;
pub const FS_EXFAT: u32 = 4;
pub const AM_RDO: u32 = 1;
pub const AM_HID: u32 = 2;
pub const AM_SYS: u32 = 4;
pub const AM_DIR: u32 = 16;
pub const AM_ARC: u32 = 32;
pub const WL_INVALID_HANDLE: i32 = -1;
pub const FF_DRV_NOT_USED: u32 = 255;
pub const STA_NOINIT: u32 = 1;
pub const STA_NODISK: u32 = 2;
pub const STA_PROTECT: u32 = 4;
pub const CTRL_SYNC: u32 = 0;
pub const GET_SECTOR_COUNT: u32 = 1;
pub const GET_SECTOR_SIZE: u32 = 2;
pub const GET_BLOCK_SIZE: u32 = 3;
pub const CTRL_TRIM: u32 = 4;
pub const CTRL_POWER: u32 = 5;
pub const CTRL_LOCK: u32 = 6;
pub const CTRL_EJECT: u32 = 7;
pub const CTRL_FORMAT: u32 = 8;
pub const MMC_GET_TYPE: u32 = 10;
pub const MMC_GET_CSD: u32 = 11;
pub const MMC_GET_CID: u32 = 12;
pub const MMC_GET_OCR: u32 = 13;
pub const MMC_GET_SDSTAT: u32 = 14;
pub const ISDIO_READ: u32 = 55;
pub const ISDIO_WRITE: u32 = 56;
pub const ISDIO_MRITE: u32 = 57;
pub const ATA_GET_REV: u32 = 20;
pub const ATA_GET_MODEL: u32 = 21;
pub const ATA_GET_SN: u32 = 22;
pub const MMC_GO_IDLE_STATE: u32 = 0;
pub const MMC_SEND_OP_COND: u32 = 1;
pub const MMC_ALL_SEND_CID: u32 = 2;
pub const MMC_SET_RELATIVE_ADDR: u32 = 3;
pub const MMC_SWITCH: u32 = 6;
pub const MMC_SELECT_CARD: u32 = 7;
pub const MMC_SEND_EXT_CSD: u32 = 8;
pub const MMC_SEND_CSD: u32 = 9;
pub const MMC_SEND_CID: u32 = 10;
pub const MMC_READ_DAT_UNTIL_STOP: u32 = 11;
pub const MMC_STOP_TRANSMISSION: u32 = 12;
pub const MMC_SEND_STATUS: u32 = 13;
pub const MMC_SET_BLOCKLEN: u32 = 16;
pub const MMC_READ_BLOCK_SINGLE: u32 = 17;
pub const MMC_READ_BLOCK_MULTIPLE: u32 = 18;
pub const MMC_WRITE_DAT_UNTIL_STOP: u32 = 20;
pub const MMC_SET_BLOCK_COUNT: u32 = 23;
pub const MMC_WRITE_BLOCK_SINGLE: u32 = 24;
pub const MMC_WRITE_BLOCK_MULTIPLE: u32 = 25;
pub const MMC_ERASE_GROUP_START: u32 = 35;
pub const MMC_ERASE_GROUP_END: u32 = 36;
pub const MMC_ERASE: u32 = 38;
pub const MMC_APP_CMD: u32 = 55;
pub const SD_SEND_RELATIVE_ADDR: u32 = 3;
pub const SD_SEND_SWITCH_FUNC: u32 = 6;
pub const SD_SEND_IF_COND: u32 = 8;
pub const SD_ERASE_GROUP_START: u32 = 32;
pub const SD_ERASE_GROUP_END: u32 = 33;
pub const SD_READ_OCR: u32 = 58;
pub const SD_CRC_ON_OFF: u32 = 59;
pub const SD_APP_SET_BUS_WIDTH: u32 = 6;
pub const SD_APP_SD_STATUS: u32 = 13;
pub const SD_APP_OP_COND: u32 = 41;
pub const SD_APP_SEND_SCR: u32 = 51;
pub const SD_IO_SEND_OP_COND: u32 = 5;
pub const SD_IO_RW_DIRECT: u32 = 52;
pub const SD_IO_RW_EXTENDED: u32 = 53;
pub const MMC_OCR_MEM_READY: u32 = 2147483648;
pub const MMC_OCR_ACCESS_MODE_MASK: u32 = 1610612736;
pub const MMC_OCR_SECTOR_MODE: u32 = 1073741824;
pub const MMC_OCR_BYTE_MODE: u32 = 536870912;
pub const MMC_OCR_3_5V_3_6V: u32 = 8388608;
pub const MMC_OCR_3_4V_3_5V: u32 = 4194304;
pub const MMC_OCR_3_3V_3_4V: u32 = 2097152;
pub const MMC_OCR_3_2V_3_3V: u32 = 1048576;
pub const MMC_OCR_3_1V_3_2V: u32 = 524288;
pub const MMC_OCR_3_0V_3_1V: u32 = 262144;
pub const MMC_OCR_2_9V_3_0V: u32 = 131072;
pub const MMC_OCR_2_8V_2_9V: u32 = 65536;
pub const MMC_OCR_2_7V_2_8V: u32 = 32768;
pub const MMC_OCR_2_6V_2_7V: u32 = 16384;
pub const MMC_OCR_2_5V_2_6V: u32 = 8192;
pub const MMC_OCR_2_4V_2_5V: u32 = 4096;
pub const MMC_OCR_2_3V_2_4V: u32 = 2048;
pub const MMC_OCR_2_2V_2_3V: u32 = 1024;
pub const MMC_OCR_2_1V_2_2V: u32 = 512;
pub const MMC_OCR_2_0V_2_1V: u32 = 256;
pub const MMC_OCR_1_65V_1_95V: u32 = 128;
pub const SD_OCR_SDHC_CAP: u32 = 1073741824;
pub const SD_OCR_VOL_MASK: u32 = 16744448;
pub const MMC_R1_READY_FOR_DATA: u32 = 256;
pub const MMC_R1_APP_CMD: u32 = 32;
pub const MMC_R1_SWITCH_ERROR: u32 = 128;
pub const MMC_R1_CURRENT_STATE_POS: u32 = 9;
pub const MMC_R1_CURRENT_STATE_MASK: u32 = 7680;
pub const MMC_R1_CURRENT_STATE_TRAN: u32 = 4;
pub const SD_SPI_R1_IDLE_STATE: u32 = 1;
pub const SD_SPI_R1_ERASE_RST: u32 = 2;
pub const SD_SPI_R1_ILLEGAL_CMD: u32 = 4;
pub const SD_SPI_R1_CMD_CRC_ERR: u32 = 8;
pub const SD_SPI_R1_ERASE_SEQ_ERR: u32 = 16;
pub const SD_SPI_R1_ADDR_ERR: u32 = 32;
pub const SD_SPI_R1_PARAM_ERR: u32 = 64;
pub const SD_SPI_R1_NO_RESPONSE: u32 = 128;
pub const SDIO_R1_FUNC_NUM_ERR: u32 = 16;
pub const SD_SPI_R2_CARD_LOCKED: u32 = 256;
pub const SD_SPI_R2_UNLOCK_FAILED: u32 = 512;
pub const SD_SPI_R2_ERROR: u32 = 1024;
pub const SD_SPI_R2_CC_ERROR: u32 = 2048;
pub const SD_SPI_R2_ECC_FAILED: u32 = 4096;
pub const SD_SPI_R2_WP_VIOLATION: u32 = 8192;
pub const SD_SPI_R2_ERASE_PARAM: u32 = 16384;
pub const SD_SPI_R2_OUT_OF_RANGE: u32 = 32768;
pub const SD_SPI_DATA_ACCEPTED: u32 = 2;
pub const SD_SPI_DATA_CRC_ERROR: u32 = 5;
pub const SD_SPI_DATA_WR_ERROR: u32 = 6;
pub const SD_ARG_BUS_WIDTH_1: u32 = 0;
pub const SD_ARG_BUS_WIDTH_4: u32 = 2;
pub const EXT_CSD_SANITIZE_START: u32 = 165;
pub const EXT_CSD_ERASED_MEM_CONT: u32 = 181;
pub const EXT_CSD_BUS_WIDTH: u32 = 183;
pub const EXT_CSD_HS_TIMING: u32 = 185;
pub const EXT_CSD_POWER_CLASS: u32 = 187;
pub const EXT_CSD_CMD_SET: u32 = 191;
pub const EXT_CSD_REV: u32 = 192;
pub const EXT_CSD_STRUCTURE: u32 = 194;
pub const EXT_CSD_CARD_TYPE: u32 = 196;
pub const EXT_CSD_PWR_CL_52_195: u32 = 200;
pub const EXT_CSD_PWR_CL_26_195: u32 = 201;
pub const EXT_CSD_PWR_CL_52_360: u32 = 202;
pub const EXT_CSD_PWR_CL_26_360: u32 = 203;
pub const EXT_CSD_SEC_COUNT: u32 = 212;
pub const EXT_CSD_SEC_FEATURE_SUPPORT: u32 = 231;
pub const EXT_CSD_S_CMD_SET: u32 = 504;
pub const EXT_CSD_REV_1_6: u32 = 6;
pub const EXT_CSD_CMD_SET_NORMAL: u32 = 1;
pub const EXT_CSD_CMD_SET_SECURE: u32 = 2;
pub const EXT_CSD_CMD_SET_CPSECURE: u32 = 4;
pub const EXT_CSD_HS_TIMING_BC: u32 = 0;
pub const EXT_CSD_HS_TIMING_HS: u32 = 1;
pub const EXT_CSD_HS_TIMING_HS200: u32 = 2;
pub const EXT_CSD_HS_TIMING_HS400: u32 = 3;
pub const EXT_CSD_BUS_WIDTH_1: u32 = 0;
pub const EXT_CSD_BUS_WIDTH_4: u32 = 1;
pub const EXT_CSD_BUS_WIDTH_8: u32 = 2;
pub const EXT_CSD_BUS_WIDTH_4_DDR: u32 = 5;
pub const EXT_CSD_BUS_WIDTH_8_DDR: u32 = 6;
pub const EXT_CSD_CARD_TYPE_F_26M: u32 = 1;
pub const EXT_CSD_CARD_TYPE_F_52M: u32 = 2;
pub const EXT_CSD_CARD_TYPE_F_52M_1_8V: u32 = 4;
pub const EXT_CSD_CARD_TYPE_F_52M_1_2V: u32 = 8;
pub const EXT_CSD_CARD_TYPE_26M: u32 = 1;
pub const EXT_CSD_CARD_TYPE_52M: u32 = 3;
pub const EXT_CSD_CARD_TYPE_52M_V18: u32 = 7;
pub const EXT_CSD_CARD_TYPE_52M_V12: u32 = 11;
pub const EXT_CSD_CARD_TYPE_52M_V12_18: u32 = 15;
pub const EXT_CSD_MMC_SIZE: u32 = 512;
pub const MMC_SWITCH_MODE_CMD_SET: u32 = 0;
pub const MMC_SWITCH_MODE_SET_BITS: u32 = 1;
pub const MMC_SWITCH_MODE_CLEAR_BITS: u32 = 2;
pub const MMC_SWITCH_MODE_WRITE_BYTE: u32 = 3;
pub const MMC_CSD_CSDVER_1_0: u32 = 1;
pub const MMC_CSD_CSDVER_2_0: u32 = 2;
pub const MMC_CSD_CSDVER_EXT_CSD: u32 = 3;
pub const MMC_CSD_MMCVER_1_0: u32 = 0;
pub const MMC_CSD_MMCVER_1_4: u32 = 1;
pub const MMC_CSD_MMCVER_2_0: u32 = 2;
pub const MMC_CSD_MMCVER_3_1: u32 = 3;
pub const MMC_CSD_MMCVER_4_0: u32 = 4;
pub const SD_CSD_CSDVER_1_0: u32 = 0;
pub const SD_CSD_CSDVER_2_0: u32 = 1;
pub const SD_CSD_TAAC_1_5_MSEC: u32 = 38;
pub const SD_CSD_SPEED_25_MHZ: u32 = 50;
pub const SD_CSD_SPEED_50_MHZ: u32 = 90;
pub const SD_CSD_CCC_BASIC: u32 = 1;
pub const SD_CSD_CCC_BR: u32 = 4;
pub const SD_CSD_CCC_BW: u32 = 16;
pub const SD_CSD_CCC_ERASE: u32 = 32;
pub const SD_CSD_CCC_WP: u32 = 64;
pub const SD_CSD_CCC_LC: u32 = 128;
pub const SD_CSD_CCC_AS: u32 = 256;
pub const SD_CSD_CCC_IOM: u32 = 512;
pub const SD_CSD_CCC_SWITCH: u32 = 1024;
pub const SD_CSD_V2_BL_LEN: u32 = 9;
pub const SD_CSD_VDD_RW_CURR_100mA: u32 = 7;
pub const SD_CSD_VDD_RW_CURR_80mA: u32 = 6;
pub const SD_CSD_RW_BL_LEN_2G: u32 = 10;
pub const SD_CSD_RW_BL_LEN_1G: u32 = 9;
pub const SCR_STRUCTURE_VER_1_0: u32 = 0;
pub const SCR_SD_SPEC_VER_1_0: u32 = 0;
pub const SCR_SD_SPEC_VER_1_10: u32 = 1;
pub const SCR_SD_SPEC_VER_2: u32 = 2;
pub const SCR_SD_SECURITY_NONE: u32 = 0;
pub const SCR_SD_SECURITY_1_0: u32 = 1;
pub const SCR_SD_SECURITY_1_0_2: u32 = 2;
pub const SCR_SD_BUS_WIDTHS_1BIT: u32 = 1;
pub const SCR_SD_BUS_WIDTHS_4BIT: u32 = 4;
pub const SD_SFUNC_GROUP_MAX: u32 = 6;
pub const SD_SFUNC_FUNC_MAX: u32 = 15;
pub const SD_ACCESS_MODE: u32 = 1;
pub const SD_ACCESS_MODE_SDR12: u32 = 0;
pub const SD_ACCESS_MODE_SDR25: u32 = 1;
pub const SD_ACCESS_MODE_SDR50: u32 = 2;
pub const SD_ACCESS_MODE_SDR104: u32 = 3;
pub const SD_ACCESS_MODE_DDR50: u32 = 4;
pub const SD_SSR_SIZE: u32 = 64;
pub const SD_IO_OCR_MEM_READY: u32 = 2147483648;
pub const SD_IO_OCR_MEM_PRESENT: u32 = 134217728;
pub const SD_IO_OCR_MASK: u32 = 16777200;
pub const SD_ARG_CMD52_READ: u32 = 0;
pub const SD_ARG_CMD52_WRITE: u32 = 2147483648;
pub const SD_ARG_CMD52_FUNC_SHIFT: u32 = 28;
pub const SD_ARG_CMD52_FUNC_MASK: u32 = 7;
pub const SD_ARG_CMD52_EXCHANGE: u32 = 134217728;
pub const SD_ARG_CMD52_REG_SHIFT: u32 = 9;
pub const SD_ARG_CMD52_REG_MASK: u32 = 131071;
pub const SD_ARG_CMD52_DATA_SHIFT: u32 = 0;
pub const SD_ARG_CMD52_DATA_MASK: u32 = 255;
pub const SD_ARG_CMD53_READ: u32 = 0;
pub const SD_ARG_CMD53_WRITE: u32 = 2147483648;
pub const SD_ARG_CMD53_FUNC_SHIFT: u32 = 28;
pub const SD_ARG_CMD53_FUNC_MASK: u32 = 7;
pub const SD_ARG_CMD53_BLOCK_MODE: u32 = 134217728;
pub const SD_ARG_CMD53_INCREMENT: u32 = 67108864;
pub const SD_ARG_CMD53_REG_SHIFT: u32 = 9;
pub const SD_ARG_CMD53_REG_MASK: u32 = 131071;
pub const SD_ARG_CMD53_LENGTH_SHIFT: u32 = 0;
pub const SD_ARG_CMD53_LENGTH_MASK: u32 = 511;
pub const SD_ARG_CMD53_LENGTH_MAX: u32 = 512;
pub const SD_IO_CCCR_START: u32 = 0;
pub const SD_IO_CCCR_SIZE: u32 = 256;
pub const SD_IO_CCCR_FN_ENABLE: u32 = 2;
pub const SD_IO_CCCR_FN_READY: u32 = 3;
pub const SD_IO_CCCR_INT_ENABLE: u32 = 4;
pub const SD_IO_CCCR_INT_PENDING: u32 = 5;
pub const SD_IO_CCCR_CTL: u32 = 6;
pub const CCCR_CTL_RES: u32 = 8;
pub const SD_IO_CCCR_BUS_WIDTH: u32 = 7;
pub const CCCR_BUS_WIDTH_1: u32 = 0;
pub const CCCR_BUS_WIDTH_4: u32 = 2;
pub const CCCR_BUS_WIDTH_8: u32 = 3;
pub const CCCR_BUS_WIDTH_ECSI: u32 = 32;
pub const SD_IO_CCCR_CARD_CAP: u32 = 8;
pub const SD_IO_CCCR_CISPTR: u32 = 9;
pub const SD_IO_CCCR_BLKSIZEL: u32 = 16;
pub const SD_IO_CCCR_BLKSIZEH: u32 = 17;
pub const SD_IO_CCCR_HIGHSPEED: u32 = 19;
pub const SD_IO_FBR_START: u32 = 256;
pub const SD_IO_FBR_SIZE: u32 = 1792;
pub const SD_IO_CIS_START: u32 = 4096;
pub const SD_IO_CIS_SIZE: u32 = 94208;
pub const CISTPL_CODE_NULL: u32 = 0;
pub const CISTPL_CODE_DEVICE: u32 = 1;
pub const CISTPL_CODE_CHKSUM: u32 = 16;
pub const CISTPL_CODE_VERS1: u32 = 21;
pub const CISTPL_CODE_ALTSTR: u32 = 22;
pub const CISTPL_CODE_CONFIG: u32 = 26;
pub const CISTPL_CODE_CFTABLE_ENTRY: u32 = 27;
pub const CISTPL_CODE_MANFID: u32 = 32;
pub const CISTPL_CODE_FUNCID: u32 = 33;
pub const TPLFID_FUNCTION_SDIO: u32 = 12;
pub const CISTPL_CODE_FUNCE: u32 = 34;
pub const CISTPL_CODE_VENDER_BEGIN: u32 = 128;
pub const CISTPL_CODE_VENDER_END: u32 = 143;
pub const CISTPL_CODE_SDIO_STD: u32 = 145;
pub const CISTPL_CODE_SDIO_EXT: u32 = 146;
pub const CISTPL_CODE_END: u32 = 255;
pub const SDMMC_TIMING_LEGACY: u32 = 0;
pub const SDMMC_TIMING_HIGHSPEED: u32 = 1;
pub const SDMMC_TIMING_MMC_DDR52: u32 = 2;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 40;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const MEMP_SIZE: u32 = 0;
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_NAMESIZE: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_LINK_UP: u32 = 4;
pub const NETIF_FLAG_ETHARP: u32 = 8;
pub const NETIF_FLAG_ETHERNET: u32 = 16;
pub const NETIF_FLAG_IGMP: u32 = 32;
pub const NETIF_FLAG_MLD6: u32 = 64;
pub const NETIF_ADDR_IDX_MAX: u32 = 127;
pub const LWIP_NETIF_USE_HINTS: u32 = 0;
pub const NETIF_NO_INDEX: u32 = 0;
pub const LWIP_NSC_NONE: u32 = 0;
pub const LWIP_NSC_NETIF_ADDED: u32 = 1;
pub const LWIP_NSC_NETIF_REMOVED: u32 = 2;
pub const LWIP_NSC_LINK_CHANGED: u32 = 4;
pub const LWIP_NSC_STATUS_CHANGED: u32 = 8;
pub const LWIP_NSC_IPV4_ADDRESS_CHANGED: u32 = 16;
pub const LWIP_NSC_IPV4_GATEWAY_CHANGED: u32 = 32;
pub const LWIP_NSC_IPV4_NETMASK_CHANGED: u32 = 64;
pub const LWIP_NSC_IPV4_SETTINGS_CHANGED: u32 = 128;
pub const LWIP_NSC_IPV6_SET: u32 = 256;
pub const LWIP_NSC_IPV6_ADDR_STATE_CHANGED: u32 = 512;
pub const SIN_ZERO_LEN: u32 = 8;
pub const MSG_TRUNC: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const IFNAMSIZ: u32 = 6;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_BROADCAST: u32 = 32;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_CONTIMEO: u32 = 4105;
pub const SO_NO_CHECK: u32 = 4106;
pub const SO_BINDTODEVICE: u32 = 4107;
pub const SOL_SOCKET: u32 = 4095;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 10;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 10;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_UDPLITE: u32 = 136;
pub const IPPROTO_RAW: u32 = 255;
pub const MSG_PEEK: u32 = 1;
pub const MSG_WAITALL: u32 = 2;
pub const MSG_OOB: u32 = 4;
pub const MSG_DONTWAIT: u32 = 8;
pub const MSG_MORE: u32 = 16;
pub const MSG_NOSIGNAL: u32 = 32;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_PKTINFO: u32 = 8;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const TCP_KEEPIDLE: u32 = 3;
pub const TCP_KEEPINTVL: u32 = 4;
pub const TCP_KEEPCNT: u32 = 5;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_V6ONLY: u32 = 27;
pub const IP_MULTICAST_TTL: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 6;
pub const IP_MULTICAST_LOOP: u32 = 7;
pub const IP_ADD_MEMBERSHIP: u32 = 3;
pub const IP_DROP_MEMBERSHIP: u32 = 4;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_ADD_MEMBERSHIP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_DROP_MEMBERSHIP: u32 = 13;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const O_NDELAY: u32 = 16384;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const LWIP_SELECT_MAXNFDS: u32 = 64;
pub const LWIP_DNS_API_DECLARE_H_ERRNO: u32 = 1;
pub const LWIP_DNS_API_DEFINE_ERRORS: u32 = 1;
pub const LWIP_DNS_API_DEFINE_FLAGS: u32 = 1;
pub const LWIP_DNS_API_DECLARE_STRUCTS: u32 = 1;
pub const EAI_NONAME: u32 = 200;
pub const EAI_SERVICE: u32 = 201;
pub const EAI_FAIL: u32 = 202;
pub const EAI_MEMORY: u32 = 203;
pub const EAI_FAMILY: u32 = 204;
pub const HOST_NOT_FOUND: u32 = 210;
pub const NO_DATA: u32 = 211;
pub const NO_RECOVERY: u32 = 212;
pub const TRY_AGAIN: u32 = 213;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 8;
pub const AI_V4MAPPED: u32 = 16;
pub const AI_ALL: u32 = 32;
pub const AI_ADDRCONFIG: u32 = 64;
pub const SNTP_GET_SERVERS_FROM_DHCP: u32 = 0;
pub const SNTP_GET_SERVERS_FROM_DHCPV6: u32 = 0;
pub const SNTP_CHECK_RESPONSE: u32 = 0;
pub const SNTP_COMP_ROUNDTRIP: u32 = 0;
pub const SNTP_STARTUP_DELAY: u32 = 1;
pub const SNTP_RECV_TIMEOUT: u32 = 15000;
pub const SNTP_RETRY_TIMEOUT: u32 = 15000;
pub const SNTP_RETRY_TIMEOUT_MAX: u32 = 150000;
pub const SNTP_RETRY_TIMEOUT_EXP: u32 = 1;
pub const SNTP_MONITOR_SERVER_REACHABILITY: u32 = 1;
pub const SNTP_OPMODE_POLL: u32 = 0;
pub const SNTP_OPMODE_LISTENONLY: u32 = 1;
pub const ESP_PING_COUNT_INFINITE: u32 = 0;
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 3;
pub const MBEDTLS_VERSION_PATCH: u32 = 0;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50528256;
pub const MBEDTLS_VERSION_STRING: &[u8; 6usize] = b"3.3.0\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15usize] = b"mbed TLS 3.3.0\0";
pub const MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_TICKET_AGE_TOLERANCE: u32 = 6000;
pub const MBEDTLS_SSL_TLS1_3_TICKET_NONCE_LENGTH: u32 = 32;
pub const MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS: u32 = 1;
pub const MBEDTLS_SSL_MAX_EARLY_DATA_SIZE: u32 = 1024;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const PSA_WANT_ALG_CCM: u32 = 1;
pub const PSA_WANT_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 6;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 128;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_BUFFER_TOO_SMALL: i32 = -14464;
pub const MBEDTLS_PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const MBEDTLS_TLS1_3_AES_128_GCM_SHA256: u32 = 4865;
pub const MBEDTLS_TLS1_3_AES_256_GCM_SHA384: u32 = 4866;
pub const MBEDTLS_TLS1_3_CHACHA20_POLY1305_SHA256: u32 = 4867;
pub const MBEDTLS_TLS1_3_AES_128_CCM_SHA256: u32 = 4868;
pub const MBEDTLS_TLS1_3_AES_128_CCM_8_SHA256: u32 = 4869;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 128;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const ESP_AES_ENCRYPT: u32 = 1;
pub const ESP_AES_DECRYPT: u32 = 0;
pub const AES_BLOCK_BYTES: u32 = 16;
pub const AES_BLOCK_WORDS: u32 = 4;
pub const IV_BYTES: u32 = 16;
pub const IV_WORDS: u32 = 4;
pub const TAG_BYTES: u32 = 16;
pub const TAG_WORDS: u32 = 4;
pub const AES_128_KEY_BYTES: u32 = 16;
pub const AES_192_KEY_BYTES: u32 = 24;
pub const AES_256_KEY_BYTES: u32 = 32;
pub const ERR_ESP_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const ERR_ESP_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const LLDESC_MAX_NUM_PER_DESC: u32 = 4092;
pub const LLDESC_MAX_NUM_PER_DESC_16B_ALIGNED: u32 = 4080;
pub const LLDESC_MAX_NUM_PER_DESC_32B_ALIGNED: u32 = 4064;
pub const MBEDTLS_CCM_DECRYPT: u32 = 0;
pub const MBEDTLS_CCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_CCM_STAR_DECRYPT: u32 = 2;
pub const MBEDTLS_CCM_STAR_ENCRYPT: u32 = 3;
pub const MBEDTLS_ERR_CCM_BAD_INPUT: i32 = -13;
pub const MBEDTLS_ERR_CCM_AUTH_FAILED: i32 = -15;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const ESP_ROM_MD5_DIGEST_LEN: u32 = 16;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const MBEDTLS_PSA_KA_MASK_DUAL_USE: u32 = 0;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_ENUMERATED: u32 = 10;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_SAN_OTHER_NAME: u32 = 0;
pub const MBEDTLS_X509_SAN_RFC822_NAME: u32 = 1;
pub const MBEDTLS_X509_SAN_DNS_NAME: u32 = 2;
pub const MBEDTLS_X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const MBEDTLS_X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const MBEDTLS_X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const MBEDTLS_X509_SAN_IP_ADDRESS: u32 = 7;
pub const MBEDTLS_X509_SAN_REGISTERED_ID: u32 = 8;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 32;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_DECODE_ERROR: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION: i32 = -29952;
pub const MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET: i32 = -31488;
pub const MBEDTLS_ERR_SSL_CANNOT_READ_EARLY_DATA: i32 = -31616;
pub const MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA: i32 = -31744;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER: i32 = -26112;
pub const MBEDTLS_ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const MBEDTLS_ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_CID: i32 = -24576;
pub const MBEDTLS_ERR_SSL_VERSION_MISMATCH: i32 = -24320;
pub const MBEDTLS_ERR_SSL_BAD_CONFIG: i32 = -24192;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE: u32 = 1;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_NONE: u32 = 0;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192K1: u32 = 18;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192R1: u32 = 19;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224K1: u32 = 20;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224R1: u32 = 21;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256K1: u32 = 22;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1: u32 = 23;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1: u32 = 24;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1: u32 = 25;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1: u32 = 26;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1: u32 = 27;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1: u32 = 28;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X25519: u32 = 29;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X448: u32 = 30;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048: u32 = 256;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE3072: u32 = 257;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE4096: u32 = 258;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE6144: u32 = 259;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192: u32 = 260;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL: u32 = 2;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL: u32 = 7;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL: u32 = 5;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL: u32 = 6;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_NONE: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_LIST_LEN: u32 = 65535;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CID_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CID_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_UNSUPPORTED: u32 = 0;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER: u32 = 0;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const MBEDTLS_SSL_CID_IN_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_OUT_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY: u32 = 16;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256: u32 = 1025;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA384: u32 = 1281;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA512: u32 = 1537;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256: u32 = 1027;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384: u32 = 1283;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP521R1_SHA512: u32 = 1539;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256: u32 = 2052;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384: u32 = 2053;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512: u32 = 2054;
pub const MBEDTLS_TLS1_3_SIG_ED25519: u32 = 2055;
pub const MBEDTLS_TLS1_3_SIG_ED448: u32 = 2056;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA256: u32 = 2057;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA384: u32 = 2058;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA512: u32 = 2059;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA1: u32 = 513;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SHA1: u32 = 515;
pub const MBEDTLS_TLS1_3_SIG_NONE: u32 = 0;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_MSG_CID: u32 = 25;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_MISSING_EXTENSION: u32 = 109;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REQUIRED: u32 = 116;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_SSL_HS_MESSAGE_HASH: u32 = 254;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_STATUS_REQUEST: u32 = 5;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_GROUPS: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_USE_SRTP: u32 = 14;
pub const MBEDTLS_TLS_EXT_HEARTBEAT: u32 = 15;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_SCT: u32 = 18;
pub const MBEDTLS_TLS_EXT_CLI_CERT_TYPE: u32 = 19;
pub const MBEDTLS_TLS_EXT_SERV_CERT_TYPE: u32 = 20;
pub const MBEDTLS_TLS_EXT_PADDING: u32 = 21;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_PRE_SHARED_KEY: u32 = 41;
pub const MBEDTLS_TLS_EXT_EARLY_DATA: u32 = 42;
pub const MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS: u32 = 43;
pub const MBEDTLS_TLS_EXT_COOKIE: u32 = 44;
pub const MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES: u32 = 45;
pub const MBEDTLS_TLS_EXT_CERT_AUTH: u32 = 47;
pub const MBEDTLS_TLS_EXT_OID_FILTERS: u32 = 48;
pub const MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH: u32 = 49;
pub const MBEDTLS_TLS_EXT_SIG_ALG_CERT: u32 = 50;
pub const MBEDTLS_TLS_EXT_KEY_SHARE: u32 = 51;
pub const MBEDTLS_TLS_EXT_CID: u32 = 54;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 32;
pub const MBEDTLS_TLS1_3_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_SSL_SEQUENCE_NUMBER_LEN: u32 = 8;
pub const MBEDTLS_ERR_ERROR_GENERIC_ERROR: i32 = -1;
pub const MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED: i32 = -110;
pub const MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED: i32 = -112;
pub const MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED: i32 = -114;
pub const ESP_ERR_ESP_TLS_BASE: i32 = 32768;
pub const ESP_ERR_ESP_TLS_CANNOT_RESOLVE_HOSTNAME: i32 = 32769;
pub const ESP_ERR_ESP_TLS_CANNOT_CREATE_SOCKET: i32 = 32770;
pub const ESP_ERR_ESP_TLS_UNSUPPORTED_PROTOCOL_FAMILY: i32 = 32771;
pub const ESP_ERR_ESP_TLS_FAILED_CONNECT_TO_HOST: i32 = 32772;
pub const ESP_ERR_ESP_TLS_SOCKET_SETOPT_FAILED: i32 = 32773;
pub const ESP_ERR_ESP_TLS_CONNECTION_TIMEOUT: i32 = 32774;
pub const ESP_ERR_ESP_TLS_SE_FAILED: i32 = 32775;
pub const ESP_ERR_ESP_TLS_TCP_CLOSED_FIN: i32 = 32776;
pub const ESP_ERR_MBEDTLS_CERT_PARTLY_OK: i32 = 32784;
pub const ESP_ERR_MBEDTLS_CTR_DRBG_SEED_FAILED: i32 = 32785;
pub const ESP_ERR_MBEDTLS_SSL_SET_HOSTNAME_FAILED: i32 = 32786;
pub const ESP_ERR_MBEDTLS_SSL_CONFIG_DEFAULTS_FAILED: i32 = 32787;
pub const ESP_ERR_MBEDTLS_SSL_CONF_ALPN_PROTOCOLS_FAILED: i32 = 32788;
pub const ESP_ERR_MBEDTLS_X509_CRT_PARSE_FAILED: i32 = 32789;
pub const ESP_ERR_MBEDTLS_SSL_CONF_OWN_CERT_FAILED: i32 = 32790;
pub const ESP_ERR_MBEDTLS_SSL_SETUP_FAILED: i32 = 32791;
pub const ESP_ERR_MBEDTLS_SSL_WRITE_FAILED: i32 = 32792;
pub const ESP_ERR_MBEDTLS_PK_PARSE_KEY_FAILED: i32 = 32793;
pub const ESP_ERR_MBEDTLS_SSL_HANDSHAKE_FAILED: i32 = 32794;
pub const ESP_ERR_MBEDTLS_SSL_CONF_PSK_FAILED: i32 = 32795;
pub const ESP_ERR_MBEDTLS_SSL_TICKET_SETUP_FAILED: i32 = 32796;
pub const ESP_ERR_WOLFSSL_SSL_SET_HOSTNAME_FAILED: i32 = 32817;
pub const ESP_ERR_WOLFSSL_SSL_CONF_ALPN_PROTOCOLS_FAILED: i32 = 32818;
pub const ESP_ERR_WOLFSSL_CERT_VERIFY_SETUP_FAILED: i32 = 32819;
pub const ESP_ERR_WOLFSSL_KEY_VERIFY_SETUP_FAILED: i32 = 32820;
pub const ESP_ERR_WOLFSSL_SSL_HANDSHAKE_FAILED: i32 = 32821;
pub const ESP_ERR_WOLFSSL_CTX_SETUP_FAILED: i32 = 32822;
pub const ESP_ERR_WOLFSSL_SSL_SETUP_FAILED: i32 = 32823;
pub const ESP_ERR_WOLFSSL_SSL_WRITE_FAILED: i32 = 32824;
pub const ESP_TLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const ESP_TLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const ESP_TLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const ESP_PARTITION_MAGIC: u32 = 20650;
pub const ESP_PARTITION_MAGIC_MD5: u32 = 60395;
pub const PART_TYPE_APP: u32 = 0;
pub const PART_SUBTYPE_FACTORY: u32 = 0;
pub const PART_SUBTYPE_OTA_FLAG: u32 = 16;
pub const PART_SUBTYPE_OTA_MASK: u32 = 15;
pub const PART_SUBTYPE_TEST: u32 = 32;
pub const PART_TYPE_DATA: u32 = 1;
pub const PART_SUBTYPE_DATA_OTA: u32 = 0;
pub const PART_SUBTYPE_DATA_RF: u32 = 1;
pub const PART_SUBTYPE_DATA_WIFI: u32 = 2;
pub const PART_SUBTYPE_DATA_NVS_KEYS: u32 = 4;
pub const PART_SUBTYPE_DATA_EFUSE_EM: u32 = 5;
pub const PART_TYPE_END: u32 = 255;
pub const PART_SUBTYPE_END: u32 = 255;
pub const PART_FLAG_ENCRYPTED: u32 = 1;
pub const ESP_PARTITION_MD5_OFFSET: u32 = 16;
pub const ESP_BOOTLOADER_DIGEST_OFFSET: u32 = 0;
pub const ESP_BOOTLOADER_OFFSET: u32 = 0;
pub const ESP_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const ESP_PARTITION_TABLE_MAX_LEN: u32 = 3072;
pub const ESP_IMAGE_HEADER_MAGIC: u32 = 233;
pub const ESP_IMAGE_MAX_SEGMENTS: u32 = 16;
pub const ESP_ERR_IMAGE_BASE: i32 = 8192;
pub const ESP_ERR_IMAGE_FLASH_FAIL: i32 = 8193;
pub const ESP_ERR_IMAGE_INVALID: i32 = 8194;
pub const ESP_IMAGE_HASH_LEN: u32 = 32;
pub const ESP_APP_DESC_MAGIC_WORD: u32 = 2882360370;
pub const OTA_SIZE_UNKNOWN: u32 = 4294967295;
pub const OTA_WITH_SEQUENTIAL_WRITES: u32 = 4294967294;
pub const ESP_ERR_OTA_BASE: i32 = 5376;
pub const ESP_ERR_OTA_PARTITION_CONFLICT: i32 = 5377;
pub const ESP_ERR_OTA_SELECT_INFO_INVALID: i32 = 5378;
pub const ESP_ERR_OTA_VALIDATE_FAILED: i32 = 5379;
pub const ESP_ERR_OTA_SMALL_SEC_VER: i32 = 5380;
pub const ESP_ERR_OTA_ROLLBACK_FAILED: i32 = 5381;
pub const ESP_ERR_OTA_ROLLBACK_INVALID_STATE: i32 = 5382;
pub const IF_NAMESIZE: u32 = 6;
pub const MSG_DONTROUTE: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const MSG_EOR: u32 = 8;
pub const SOMAXCONN: u32 = 128;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const DEFAULT_HTTP_BUF_SIZE: u32 = 512;
pub const ESP_ERR_HTTP_BASE: i32 = 28672;
pub const ESP_ERR_HTTP_MAX_REDIRECT: i32 = 28673;
pub const ESP_ERR_HTTP_CONNECT: i32 = 28674;
pub const ESP_ERR_HTTP_WRITE_DATA: i32 = 28675;
pub const ESP_ERR_HTTP_FETCH_HEADER: i32 = 28676;
pub const ESP_ERR_HTTP_INVALID_TRANSPORT: i32 = 28677;
pub const ESP_ERR_HTTP_CONNECTING: i32 = 28678;
pub const ESP_ERR_HTTP_EAGAIN: i32 = 28679;
pub const ESP_ERR_HTTP_CONNECTION_CLOSED: i32 = 28680;
pub const ESP_ERR_TCP_TRANSPORT_BASE: i32 = 57344;
pub const ESP_ERR_TCP_TRANSPORT_CONNECTION_TIMEOUT: i32 = 57345;
pub const ESP_ERR_TCP_TRANSPORT_CONNECTION_CLOSED_BY_FIN: i32 = 57346;
pub const ESP_ERR_TCP_TRANSPORT_CONNECTION_FAILED: i32 = 57347;
pub const ESP_ERR_TCP_TRANSPORT_NO_MEM: i32 = 57348;
pub const HTTP_PARSER_VERSION_MAJOR: u32 = 2;
pub const HTTP_PARSER_VERSION_MINOR: u32 = 7;
pub const HTTP_PARSER_VERSION_PATCH: u32 = 0;
pub const HTTP_PARSER_STRICT: u32 = 1;
pub const HTTP_MAX_HEADER_SIZE: u32 = 81920;
pub const ESP_HTTPD_DEF_CTRL_PORT: u32 = 32768;
pub const ESP_ERR_HTTPD_BASE: i32 = 45056;
pub const ESP_ERR_HTTPD_HANDLERS_FULL: i32 = 45057;
pub const ESP_ERR_HTTPD_HANDLER_EXISTS: i32 = 45058;
pub const ESP_ERR_HTTPD_INVALID_REQ: i32 = 45059;
pub const ESP_ERR_HTTPD_RESULT_TRUNC: i32 = 45060;
pub const ESP_ERR_HTTPD_RESP_HDR: i32 = 45061;
pub const ESP_ERR_HTTPD_RESP_SEND: i32 = 45062;
pub const ESP_ERR_HTTPD_ALLOC_MEM: i32 = 45063;
pub const ESP_ERR_HTTPD_TASK: i32 = 45064;
pub const HTTPD_RESP_USE_STRLEN: i32 = -1;
pub const HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const HTTPD_MAX_URI_LEN: u32 = 512;
pub const HTTPD_SOCK_ERR_FAIL: i32 = -1;
pub const HTTPD_SOCK_ERR_INVALID: i32 = -2;
pub const HTTPD_SOCK_ERR_TIMEOUT: i32 = -3;
pub const HTTPD_200: &[u8; 7usize] = b"200 OK\0";
pub const HTTPD_204: &[u8; 15usize] = b"204 No Content\0";
pub const HTTPD_207: &[u8; 17usize] = b"207 Multi-Status\0";
pub const HTTPD_400: &[u8; 16usize] = b"400 Bad Request\0";
pub const HTTPD_404: &[u8; 14usize] = b"404 Not Found\0";
pub const HTTPD_408: &[u8; 20usize] = b"408 Request Timeout\0";
pub const HTTPD_500: &[u8; 26usize] = b"500 Internal Server Error\0";
pub const HTTPD_TYPE_JSON: &[u8; 17usize] = b"application/json\0";
pub const HTTPD_TYPE_TEXT: &[u8; 10usize] = b"text/html\0";
pub const HTTPD_TYPE_OCTET: &[u8; 25usize] = b"application/octet-stream\0";
pub const ESP_ERR_NVS_BASE: i32 = 4352;
pub const ESP_ERR_NVS_NOT_INITIALIZED: i32 = 4353;
pub const ESP_ERR_NVS_NOT_FOUND: i32 = 4354;
pub const ESP_ERR_NVS_TYPE_MISMATCH: i32 = 4355;
pub const ESP_ERR_NVS_READ_ONLY: i32 = 4356;
pub const ESP_ERR_NVS_NOT_ENOUGH_SPACE: i32 = 4357;
pub const ESP_ERR_NVS_INVALID_NAME: i32 = 4358;
pub const ESP_ERR_NVS_INVALID_HANDLE: i32 = 4359;
pub const ESP_ERR_NVS_REMOVE_FAILED: i32 = 4360;
pub const ESP_ERR_NVS_KEY_TOO_LONG: i32 = 4361;
pub const ESP_ERR_NVS_PAGE_FULL: i32 = 4362;
pub const ESP_ERR_NVS_INVALID_STATE: i32 = 4363;
pub const ESP_ERR_NVS_INVALID_LENGTH: i32 = 4364;
pub const ESP_ERR_NVS_NO_FREE_PAGES: i32 = 4365;
pub const ESP_ERR_NVS_VALUE_TOO_LONG: i32 = 4366;
pub const ESP_ERR_NVS_PART_NOT_FOUND: i32 = 4367;
pub const ESP_ERR_NVS_NEW_VERSION_FOUND: i32 = 4368;
pub const ESP_ERR_NVS_XTS_ENCR_FAILED: i32 = 4369;
pub const ESP_ERR_NVS_XTS_DECR_FAILED: i32 = 4370;
pub const ESP_ERR_NVS_XTS_CFG_FAILED: i32 = 4371;
pub const ESP_ERR_NVS_XTS_CFG_NOT_FOUND: i32 = 4372;
pub const ESP_ERR_NVS_ENCR_NOT_SUPPORTED: i32 = 4373;
pub const ESP_ERR_NVS_KEYS_NOT_INITIALIZED: i32 = 4374;
pub const ESP_ERR_NVS_CORRUPT_KEY_PART: i32 = 4375;
pub const ESP_ERR_NVS_WRONG_ENCRYPTION: i32 = 4377;
pub const ESP_ERR_NVS_CONTENT_DIFFERS: i32 = 4376;
pub const NVS_DEFAULT_PART_NAME: &[u8; 4usize] = b"nvs\0";
pub const NVS_PART_NAME_MAX_SIZE: u32 = 16;
pub const NVS_KEY_NAME_MAX_SIZE: u32 = 16;
pub const NVS_KEY_SIZE: u32 = 32;
pub const MAX_BLE_DEVNAME_LEN: u32 = 29;
pub const BLE_UUID128_VAL_LENGTH: u32 = 16;
pub const MAX_BLE_MANUFACTURER_DATA_LEN: u32 = 29;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 1;
pub const SPI_HD_GPIO_NUM: u32 = 12;
pub const SPI_WP_GPIO_NUM: u32 = 13;
pub const SPI_CS0_GPIO_NUM: u32 = 14;
pub const SPI_CLK_GPIO_NUM: u32 = 15;
pub const SPI_D_GPIO_NUM: u32 = 16;
pub const SPI_Q_GPIO_NUM: u32 = 17;
pub const SD_CLK_GPIO_NUM: u32 = 12;
pub const SD_CMD_GPIO_NUM: u32 = 11;
pub const SD_DATA0_GPIO_NUM: u32 = 13;
pub const SD_DATA1_GPIO_NUM: u32 = 14;
pub const SD_DATA2_GPIO_NUM: u32 = 9;
pub const SD_DATA3_GPIO_NUM: u32 = 10;
pub const USB_DM_GPIO_NUM: u32 = 18;
pub const USB_DP_GPIO_NUM: u32 = 19;
pub const MAX_RTC_GPIO_NUM: u32 = 5;
pub const MAX_PAD_GPIO_NUM: u32 = 21;
pub const MAX_GPIO_NUM: u32 = 25;
pub const REG_IO_MUX_BASE: u32 = 1610649600;
pub const PIN_CTRL: u32 = 1610649600;
pub const PAD_POWER_SEL_V: u32 = 1;
pub const PAD_POWER_SEL_S: u32 = 15;
pub const PAD_POWER_SWITCH_DELAY: u32 = 7;
pub const PAD_POWER_SWITCH_DELAY_V: u32 = 7;
pub const PAD_POWER_SWITCH_DELAY_S: u32 = 12;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_XTAL_32K_P_U: u32 = 1610649604;
pub const FUNC_XTAL_32K_P_GPIO0: u32 = 1;
pub const FUNC_XTAL_32K_P_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_XTAL_32K_N_U: u32 = 1610649608;
pub const FUNC_XTAL_32K_N_GPIO1: u32 = 1;
pub const FUNC_XTAL_32K_N_GPIO1_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610649612;
pub const FUNC_GPIO2_FSPIQ: u32 = 2;
pub const FUNC_GPIO2_GPIO2: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO3_U: u32 = 1610649616;
pub const FUNC_GPIO3_GPIO3: u32 = 1;
pub const FUNC_GPIO3_GPIO3_0: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610649620;
pub const FUNC_MTMS_FSPIHD: u32 = 2;
pub const FUNC_MTMS_GPIO4: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610649624;
pub const FUNC_MTDI_FSPIWP: u32 = 2;
pub const FUNC_MTDI_GPIO5: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610649628;
pub const FUNC_MTCK_FSPICLK: u32 = 2;
pub const FUNC_MTCK_GPIO6: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610649632;
pub const FUNC_MTDO_FSPID: u32 = 2;
pub const FUNC_MTDO_GPIO7: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO8_U: u32 = 1610649636;
pub const FUNC_GPIO8_GPIO8: u32 = 1;
pub const FUNC_GPIO8_GPIO8_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO9_U: u32 = 1610649640;
pub const FUNC_GPIO9_GPIO9: u32 = 1;
pub const FUNC_GPIO9_GPIO9_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO10_U: u32 = 1610649644;
pub const FUNC_GPIO10_FSPICS0: u32 = 2;
pub const FUNC_GPIO10_GPIO10: u32 = 1;
pub const FUNC_GPIO10_GPIO10_0: u32 = 0;
pub const PERIPHS_IO_MUX_VDD_SPI_U: u32 = 1610649648;
pub const FUNC_VDD_SPI_GPIO11: u32 = 1;
pub const FUNC_VDD_SPI_GPIO11_0: u32 = 0;
pub const PERIPHS_IO_MUX_SPIHD_U: u32 = 1610649652;
pub const FUNC_SPIHD_GPIO12: u32 = 1;
pub const FUNC_SPIHD_SPIHD: u32 = 0;
pub const PERIPHS_IO_MUX_SPIWP_U: u32 = 1610649656;
pub const FUNC_SPIWP_GPIO13: u32 = 1;
pub const FUNC_SPIWP_SPIWP: u32 = 0;
pub const PERIPHS_IO_MUX_SPICS0_U: u32 = 1610649660;
pub const FUNC_SPICS0_GPIO14: u32 = 1;
pub const FUNC_SPICS0_SPICS0: u32 = 0;
pub const PERIPHS_IO_MUX_SPICLK_U: u32 = 1610649664;
pub const FUNC_SPICLK_GPIO15: u32 = 1;
pub const FUNC_SPICLK_SPICLK: u32 = 0;
pub const PERIPHS_IO_MUX_SPID_U: u32 = 1610649668;
pub const FUNC_SPID_GPIO16: u32 = 1;
pub const FUNC_SPID_SPID: u32 = 0;
pub const PERIPHS_IO_MUX_SPIQ_U: u32 = 1610649672;
pub const FUNC_SPIQ_GPIO17: u32 = 1;
pub const FUNC_SPIQ_SPIQ: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1610649676;
pub const FUNC_GPIO18_GPIO18: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1610649680;
pub const FUNC_GPIO19_GPIO19: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610649684;
pub const FUNC_U0RXD_GPIO20: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610649688;
pub const FUNC_U0TXD_GPIO21: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const IO_MUX_DATE_REG: u32 = 1610649852;
pub const IO_MUX_DATE: u32 = 4294967295;
pub const IO_MUX_DATE_S: u32 = 0;
pub const IO_MUX_DATE_VERSION: u32 = 33579088;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_PAD_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_PAD_DRIVER_MASK: u32 = 4;
pub const GPIO_BT_SELECT_REG: u32 = 1610629120;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1610629124;
pub const GPIO_OUT_DATA: u32 = 67108863;
pub const GPIO_OUT_DATA_V: u32 = 67108863;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1610629128;
pub const GPIO_OUT_W1TS: u32 = 67108863;
pub const GPIO_OUT_W1TS_V: u32 = 67108863;
pub const GPIO_OUT_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1610629132;
pub const GPIO_OUT_W1TC: u32 = 67108863;
pub const GPIO_OUT_W1TC_V: u32 = 67108863;
pub const GPIO_OUT_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1610629148;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1610629152;
pub const GPIO_ENABLE_DATA: u32 = 67108863;
pub const GPIO_ENABLE_DATA_V: u32 = 67108863;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1610629156;
pub const GPIO_ENABLE_W1TS: u32 = 67108863;
pub const GPIO_ENABLE_W1TS_V: u32 = 67108863;
pub const GPIO_ENABLE_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1610629160;
pub const GPIO_ENABLE_W1TC: u32 = 67108863;
pub const GPIO_ENABLE_W1TC_V: u32 = 67108863;
pub const GPIO_ENABLE_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1610629176;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1610629180;
pub const GPIO_IN_DATA: u32 = 67108863;
pub const GPIO_IN_DATA_V: u32 = 67108863;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1610629188;
pub const GPIO_STATUS_INT: u32 = 67108863;
pub const GPIO_STATUS_INT_V: u32 = 67108863;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1610629192;
pub const GPIO_STATUS_W1TS: u32 = 67108863;
pub const GPIO_STATUS_W1TS_V: u32 = 67108863;
pub const GPIO_STATUS_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1610629196;
pub const GPIO_STATUS_W1TC: u32 = 67108863;
pub const GPIO_STATUS_W1TC_V: u32 = 67108863;
pub const GPIO_STATUS_W1TC_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1610629212;
pub const GPIO_PROCPU_INT: u32 = 67108863;
pub const GPIO_PROCPU_INT_V: u32 = 67108863;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1610629216;
pub const GPIO_PROCPU_NMI_INT: u32 = 67108863;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 67108863;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1610629220;
pub const GPIO_SDIO_INT: u32 = 67108863;
pub const GPIO_SDIO_INT_V: u32 = 67108863;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_PIN0_REG: u32 = 1610629236;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN0_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN0_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN0_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN0_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN1_REG: u32 = 1610629240;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN1_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN1_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN1_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN1_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN2_REG: u32 = 1610629244;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN2_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN2_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN2_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN2_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN3_REG: u32 = 1610629248;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN3_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN3_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN3_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN3_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN4_REG: u32 = 1610629252;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN4_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN4_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN4_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN4_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN5_REG: u32 = 1610629256;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN5_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN5_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN5_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN5_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN6_REG: u32 = 1610629260;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN6_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN6_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN6_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN6_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN7_REG: u32 = 1610629264;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN7_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN7_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN7_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN7_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN8_REG: u32 = 1610629268;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN8_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN8_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN8_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN8_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN9_REG: u32 = 1610629272;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN9_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN9_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN9_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN9_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN10_REG: u32 = 1610629276;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN10_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN10_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN10_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN10_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN11_REG: u32 = 1610629280;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN11_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN11_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN11_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN11_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN12_REG: u32 = 1610629284;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN12_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN12_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN12_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN12_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN13_REG: u32 = 1610629288;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN13_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN13_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN13_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN13_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN14_REG: u32 = 1610629292;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN14_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN14_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN14_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN14_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN15_REG: u32 = 1610629296;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN15_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN15_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN15_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN15_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN16_REG: u32 = 1610629300;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN16_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN16_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN16_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN16_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN17_REG: u32 = 1610629304;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN17_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN17_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN17_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN17_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN18_REG: u32 = 1610629308;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN18_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN18_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN18_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN18_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN19_REG: u32 = 1610629312;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN19_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN19_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN19_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN19_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN20_REG: u32 = 1610629316;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN20_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN20_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN20_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN20_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN21_REG: u32 = 1610629320;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN21_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN21_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN21_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN21_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN22_REG: u32 = 1610629324;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN22_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN22_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN22_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN22_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN23_REG: u32 = 1610629328;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN23_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN23_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN23_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN23_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN24_REG: u32 = 1610629332;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN24_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN24_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN24_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN24_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_PIN25_REG: u32 = 1610629336;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_SYNC1_BYPASS: u32 = 3;
pub const GPIO_PIN25_SYNC1_BYPASS_V: u32 = 3;
pub const GPIO_PIN25_SYNC1_BYPASS_S: u32 = 3;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_SYNC2_BYPASS: u32 = 3;
pub const GPIO_PIN25_SYNC2_BYPASS_V: u32 = 3;
pub const GPIO_PIN25_SYNC2_BYPASS_S: u32 = 0;
pub const GPIO_STATUS_NEXT_REG: u32 = 1610629452;
pub const GPIO_STATUS_INTERRUPT_NEXT: u32 = 67108863;
pub const GPIO_STATUS_INTERRUPT_NEXT_V: u32 = 67108863;
pub const GPIO_STATUS_INTERRUPT_NEXT_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1610629460;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC0_IN_SEL: u32 = 31;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1610629464;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC1_IN_SEL: u32 = 31;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1610629468;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC2_IN_SEL: u32 = 31;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1610629472;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC3_IN_SEL: u32 = 31;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1610629476;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC4_IN_SEL: u32 = 31;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1610629480;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC5_IN_SEL: u32 = 31;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1610629484;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC6_IN_SEL: u32 = 31;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1610629488;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC7_IN_SEL: u32 = 31;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1610629492;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC8_IN_SEL: u32 = 31;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1610629496;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC9_IN_SEL: u32 = 31;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1610629500;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC10_IN_SEL: u32 = 31;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1610629504;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC11_IN_SEL: u32 = 31;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1610629508;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC12_IN_SEL: u32 = 31;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1610629512;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC13_IN_SEL: u32 = 31;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1610629516;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC14_IN_SEL: u32 = 31;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1610629520;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC15_IN_SEL: u32 = 31;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1610629524;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC16_IN_SEL: u32 = 31;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1610629528;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC17_IN_SEL: u32 = 31;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1610629532;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC18_IN_SEL: u32 = 31;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1610629536;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC19_IN_SEL: u32 = 31;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1610629540;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC20_IN_SEL: u32 = 31;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1610629544;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC21_IN_SEL: u32 = 31;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1610629548;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC22_IN_SEL: u32 = 31;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1610629552;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC23_IN_SEL: u32 = 31;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1610629556;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC24_IN_SEL: u32 = 31;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1610629560;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC25_IN_SEL: u32 = 31;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1610629564;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC26_IN_SEL: u32 = 31;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1610629568;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC27_IN_SEL: u32 = 31;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1610629572;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC28_IN_SEL: u32 = 31;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1610629576;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC29_IN_SEL: u32 = 31;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1610629580;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC30_IN_SEL: u32 = 31;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1610629584;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC31_IN_SEL: u32 = 31;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1610629588;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC32_IN_SEL: u32 = 31;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1610629592;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC33_IN_SEL: u32 = 31;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1610629596;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC34_IN_SEL: u32 = 31;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1610629600;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC35_IN_SEL: u32 = 31;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1610629604;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC36_IN_SEL: u32 = 31;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1610629608;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC37_IN_SEL: u32 = 31;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1610629612;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC38_IN_SEL: u32 = 31;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1610629616;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC39_IN_SEL: u32 = 31;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1610629620;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC40_IN_SEL: u32 = 31;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1610629624;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC41_IN_SEL: u32 = 31;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1610629628;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC42_IN_SEL: u32 = 31;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1610629632;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC43_IN_SEL: u32 = 31;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1610629636;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC44_IN_SEL: u32 = 31;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1610629640;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC45_IN_SEL: u32 = 31;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1610629644;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC46_IN_SEL: u32 = 31;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1610629648;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC47_IN_SEL: u32 = 31;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1610629652;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC48_IN_SEL: u32 = 31;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1610629656;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC49_IN_SEL: u32 = 31;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1610629660;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC50_IN_SEL: u32 = 31;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1610629664;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC51_IN_SEL: u32 = 31;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1610629668;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC52_IN_SEL: u32 = 31;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1610629672;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC53_IN_SEL: u32 = 31;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1610629676;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC54_IN_SEL: u32 = 31;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1610629680;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC55_IN_SEL: u32 = 31;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1610629684;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC56_IN_SEL: u32 = 31;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1610629688;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC57_IN_SEL: u32 = 31;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1610629692;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC58_IN_SEL: u32 = 31;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1610629696;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC59_IN_SEL: u32 = 31;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1610629700;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC60_IN_SEL: u32 = 31;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1610629704;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC61_IN_SEL: u32 = 31;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1610629708;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC62_IN_SEL: u32 = 31;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1610629712;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC63_IN_SEL: u32 = 31;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1610629716;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC64_IN_SEL: u32 = 31;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1610629720;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC65_IN_SEL: u32 = 31;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1610629724;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC66_IN_SEL: u32 = 31;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1610629728;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC67_IN_SEL: u32 = 31;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1610629732;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC68_IN_SEL: u32 = 31;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1610629736;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC69_IN_SEL: u32 = 31;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1610629740;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC70_IN_SEL: u32 = 31;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1610629744;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC71_IN_SEL: u32 = 31;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1610629748;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC72_IN_SEL: u32 = 31;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1610629752;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC73_IN_SEL: u32 = 31;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1610629756;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC74_IN_SEL: u32 = 31;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1610629760;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC75_IN_SEL: u32 = 31;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1610629764;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC76_IN_SEL: u32 = 31;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1610629768;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC77_IN_SEL: u32 = 31;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1610629772;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC78_IN_SEL: u32 = 31;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1610629776;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC79_IN_SEL: u32 = 31;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1610629780;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC80_IN_SEL: u32 = 31;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1610629784;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC81_IN_SEL: u32 = 31;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1610629788;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC82_IN_SEL: u32 = 31;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1610629792;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC83_IN_SEL: u32 = 31;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1610629796;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC84_IN_SEL: u32 = 31;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1610629800;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC85_IN_SEL: u32 = 31;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1610629804;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC86_IN_SEL: u32 = 31;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1610629808;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC87_IN_SEL: u32 = 31;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1610629812;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC88_IN_SEL: u32 = 31;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1610629816;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC89_IN_SEL: u32 = 31;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1610629820;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC90_IN_SEL: u32 = 31;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1610629824;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC91_IN_SEL: u32 = 31;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1610629828;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC92_IN_SEL: u32 = 31;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1610629832;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC93_IN_SEL: u32 = 31;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1610629836;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC94_IN_SEL: u32 = 31;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1610629840;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC95_IN_SEL: u32 = 31;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1610629844;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC96_IN_SEL: u32 = 31;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1610629848;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC97_IN_SEL: u32 = 31;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1610629852;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC98_IN_SEL: u32 = 31;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1610629856;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC99_IN_SEL: u32 = 31;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1610629860;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC100_IN_SEL: u32 = 31;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1610629864;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC101_IN_SEL: u32 = 31;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1610629868;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC102_IN_SEL: u32 = 31;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1610629872;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC103_IN_SEL: u32 = 31;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1610629876;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC104_IN_SEL: u32 = 31;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1610629880;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC105_IN_SEL: u32 = 31;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1610629884;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC106_IN_SEL: u32 = 31;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1610629888;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC107_IN_SEL: u32 = 31;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1610629892;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC108_IN_SEL: u32 = 31;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1610629896;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC109_IN_SEL: u32 = 31;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1610629900;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC110_IN_SEL: u32 = 31;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1610629904;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC111_IN_SEL: u32 = 31;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1610629908;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC112_IN_SEL: u32 = 31;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1610629912;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC113_IN_SEL: u32 = 31;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1610629916;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC114_IN_SEL: u32 = 31;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1610629920;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC115_IN_SEL: u32 = 31;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1610629924;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC116_IN_SEL: u32 = 31;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1610629928;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC117_IN_SEL: u32 = 31;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1610629932;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC118_IN_SEL: u32 = 31;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1610629936;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC119_IN_SEL: u32 = 31;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1610629940;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC120_IN_SEL: u32 = 31;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1610629944;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC121_IN_SEL: u32 = 31;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1610629948;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC122_IN_SEL: u32 = 31;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1610629952;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC123_IN_SEL: u32 = 31;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1610629956;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC124_IN_SEL: u32 = 31;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1610629960;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC125_IN_SEL: u32 = 31;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1610629964;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC126_IN_SEL: u32 = 31;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1610629968;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 5;
pub const GPIO_FUNC127_IN_SEL: u32 = 31;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 31;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1610630484;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC0_OUT_SEL: u32 = 255;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1610630488;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC1_OUT_SEL: u32 = 255;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1610630492;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC2_OUT_SEL: u32 = 255;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1610630496;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC3_OUT_SEL: u32 = 255;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1610630500;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC4_OUT_SEL: u32 = 255;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1610630504;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC5_OUT_SEL: u32 = 255;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1610630508;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC6_OUT_SEL: u32 = 255;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1610630512;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC7_OUT_SEL: u32 = 255;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1610630516;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC8_OUT_SEL: u32 = 255;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1610630520;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC9_OUT_SEL: u32 = 255;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1610630524;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC10_OUT_SEL: u32 = 255;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1610630528;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC11_OUT_SEL: u32 = 255;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1610630532;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC12_OUT_SEL: u32 = 255;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1610630536;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC13_OUT_SEL: u32 = 255;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1610630540;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC14_OUT_SEL: u32 = 255;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1610630544;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC15_OUT_SEL: u32 = 255;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1610630548;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC16_OUT_SEL: u32 = 255;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1610630552;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC17_OUT_SEL: u32 = 255;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1610630556;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC18_OUT_SEL: u32 = 255;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1610630560;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC19_OUT_SEL: u32 = 255;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1610630564;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC20_OUT_SEL: u32 = 255;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1610630568;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC21_OUT_SEL: u32 = 255;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1610630572;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC22_OUT_SEL: u32 = 255;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1610630576;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC23_OUT_SEL: u32 = 255;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1610630580;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC24_OUT_SEL: u32 = 255;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1610630584;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 8;
pub const GPIO_FUNC25_OUT_SEL: u32 = 255;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 255;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_CLOCK_GATE_REG: u32 = 1610630700;
pub const GPIO_CLK_EN_V: u32 = 1;
pub const GPIO_CLK_EN_S: u32 = 0;
pub const GPIO_DATE_REG: u32 = 1610630908;
pub const GPIO_DATE: u32 = 268435455;
pub const GPIO_DATE_V: u32 = 268435455;
pub const GPIO_DATE_S: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 0;
pub const SPIQ_OUT_IDX: u32 = 0;
pub const SPID_IN_IDX: u32 = 1;
pub const SPID_OUT_IDX: u32 = 1;
pub const SPIHD_IN_IDX: u32 = 2;
pub const SPIHD_OUT_IDX: u32 = 2;
pub const SPIWP_IN_IDX: u32 = 3;
pub const SPIWP_OUT_IDX: u32 = 3;
pub const SPICLK_OUT_IDX: u32 = 4;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const U0RXD_IN_IDX: u32 = 6;
pub const U0TXD_OUT_IDX: u32 = 6;
pub const U0CTS_IN_IDX: u32 = 7;
pub const U0RTS_OUT_IDX: u32 = 7;
pub const U0DSR_IN_IDX: u32 = 8;
pub const U0DTR_OUT_IDX: u32 = 8;
pub const U1RXD_IN_IDX: u32 = 9;
pub const U1TXD_OUT_IDX: u32 = 9;
pub const U1CTS_IN_IDX: u32 = 10;
pub const U1RTS_OUT_IDX: u32 = 10;
pub const U1DSR_IN_IDX: u32 = 11;
pub const U1DTR_OUT_IDX: u32 = 11;
pub const I2S_MCLK_IN_IDX: u32 = 12;
pub const I2S_MCLK_OUT_IDX: u32 = 12;
pub const I2SO_BCK_IN_IDX: u32 = 13;
pub const I2SO_BCK_OUT_IDX: u32 = 13;
pub const I2SO_WS_IN_IDX: u32 = 14;
pub const I2SO_WS_OUT_IDX: u32 = 14;
pub const I2SI_SD_IN_IDX: u32 = 15;
pub const I2SO_SD_OUT_IDX: u32 = 15;
pub const I2SI_BCK_IN_IDX: u32 = 16;
pub const I2SI_BCK_OUT_IDX: u32 = 16;
pub const I2SI_WS_IN_IDX: u32 = 17;
pub const I2SI_WS_OUT_IDX: u32 = 17;
pub const GPIO_BT_PRIORITY_IDX: u32 = 18;
pub const GPIO_WLAN_PRIO_IDX: u32 = 18;
pub const GPIO_BT_ACTIVE_IDX: u32 = 19;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 19;
pub const CPU_GPIO_IN0_IDX: u32 = 28;
pub const CPU_GPIO_OUT0_IDX: u32 = 28;
pub const CPU_GPIO_IN1_IDX: u32 = 29;
pub const CPU_GPIO_OUT1_IDX: u32 = 29;
pub const CPU_GPIO_IN2_IDX: u32 = 30;
pub const CPU_GPIO_OUT2_IDX: u32 = 30;
pub const CPU_GPIO_IN3_IDX: u32 = 31;
pub const CPU_GPIO_OUT3_IDX: u32 = 31;
pub const CPU_GPIO_IN4_IDX: u32 = 32;
pub const CPU_GPIO_OUT4_IDX: u32 = 32;
pub const CPU_GPIO_IN5_IDX: u32 = 33;
pub const CPU_GPIO_OUT5_IDX: u32 = 33;
pub const CPU_GPIO_IN6_IDX: u32 = 34;
pub const CPU_GPIO_OUT6_IDX: u32 = 34;
pub const CPU_GPIO_IN7_IDX: u32 = 35;
pub const CPU_GPIO_OUT7_IDX: u32 = 35;
pub const USB_JTAG_TCK_OUT_IDX: u32 = 36;
pub const USB_JTAG_TMS_OUT_IDX: u32 = 37;
pub const USB_JTAG_TDI_OUT_IDX: u32 = 38;
pub const USB_JTAG_TDO_OUT_IDX: u32 = 39;
pub const USB_EXTPHY_VP_IDX: u32 = 40;
pub const USB_EXTPHY_OEN_IDX: u32 = 40;
pub const USB_EXTPHY_VM_IDX: u32 = 41;
pub const USB_EXTPHY_SPEED_IDX: u32 = 41;
pub const USB_EXTPHY_RCV_IDX: u32 = 42;
pub const USB_EXTPHY_VPO_IDX: u32 = 42;
pub const USB_EXTPHY_VMO_IDX: u32 = 43;
pub const USB_EXTPHY_SUSPND_IDX: u32 = 44;
pub const EXT_ADC_START_IDX: u32 = 45;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 45;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 46;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 47;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 48;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 49;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 50;
pub const RMT_SIG_IN0_IDX: u32 = 51;
pub const RMT_SIG_OUT0_IDX: u32 = 51;
pub const RMT_SIG_IN1_IDX: u32 = 52;
pub const RMT_SIG_OUT1_IDX: u32 = 52;
pub const I2CEXT0_SCL_IN_IDX: u32 = 53;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 53;
pub const I2CEXT0_SDA_IN_IDX: u32 = 54;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 54;
pub const GPIO_SD0_OUT_IDX: u32 = 55;
pub const GPIO_SD1_OUT_IDX: u32 = 56;
pub const GPIO_SD2_OUT_IDX: u32 = 57;
pub const GPIO_SD3_OUT_IDX: u32 = 58;
pub const I2SO_SD1_OUT_IDX: u32 = 59;
pub const FSPICLK_IN_IDX: u32 = 63;
pub const FSPICLK_OUT_IDX: u32 = 63;
pub const FSPIQ_IN_IDX: u32 = 64;
pub const FSPIQ_OUT_IDX: u32 = 64;
pub const FSPID_IN_IDX: u32 = 65;
pub const FSPID_OUT_IDX: u32 = 65;
pub const FSPIHD_IN_IDX: u32 = 66;
pub const FSPIHD_OUT_IDX: u32 = 66;
pub const FSPIWP_IN_IDX: u32 = 67;
pub const FSPIWP_OUT_IDX: u32 = 67;
pub const FSPICS0_IN_IDX: u32 = 68;
pub const FSPICS0_OUT_IDX: u32 = 68;
pub const FSPICS1_OUT_IDX: u32 = 69;
pub const FSPICS2_OUT_IDX: u32 = 70;
pub const FSPICS3_OUT_IDX: u32 = 71;
pub const FSPICS4_OUT_IDX: u32 = 72;
pub const FSPICS5_OUT_IDX: u32 = 73;
pub const TWAI_RX_IDX: u32 = 74;
pub const TWAI_TX_IDX: u32 = 74;
pub const TWAI_BUS_OFF_ON_IDX: u32 = 75;
pub const TWAI_CLKOUT_IDX: u32 = 76;
pub const PCMFSYNC_IN_IDX: u32 = 77;
pub const BT_AUDIO0_IRQ_IDX: u32 = 77;
pub const PCMCLK_IN_IDX: u32 = 78;
pub const BT_AUDIO1_IRQ_IDX: u32 = 78;
pub const PCMDIN_IDX: u32 = 79;
pub const BT_AUDIO2_IRQ_IDX: u32 = 79;
pub const RW_WAKEUP_REQ_IDX: u32 = 80;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 80;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 81;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 82;
pub const PCMFSYNC_OUT_IDX: u32 = 83;
pub const PCMCLK_OUT_IDX: u32 = 84;
pub const PCMDOUT_IDX: u32 = 85;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 86;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 87;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 88;
pub const ANT_SEL0_IDX: u32 = 89;
pub const ANT_SEL1_IDX: u32 = 90;
pub const ANT_SEL2_IDX: u32 = 91;
pub const ANT_SEL3_IDX: u32 = 92;
pub const ANT_SEL4_IDX: u32 = 93;
pub const ANT_SEL5_IDX: u32 = 94;
pub const ANT_SEL6_IDX: u32 = 95;
pub const ANT_SEL7_IDX: u32 = 96;
pub const SIG_IN_FUNC_97_IDX: u32 = 97;
pub const SIG_IN_FUNC97_IDX: u32 = 97;
pub const SIG_IN_FUNC_98_IDX: u32 = 98;
pub const SIG_IN_FUNC98_IDX: u32 = 98;
pub const SIG_IN_FUNC_99_IDX: u32 = 99;
pub const SIG_IN_FUNC99_IDX: u32 = 99;
pub const SIG_IN_FUNC_100_IDX: u32 = 100;
pub const SIG_IN_FUNC100_IDX: u32 = 100;
pub const SYNCERR_IDX: u32 = 101;
pub const SYNCFOUND_FLAG_IDX: u32 = 102;
pub const EVT_CNTL_IMMEDIATE_ABORT_IDX: u32 = 103;
pub const LINKLBL_IDX: u32 = 104;
pub const DATA_EN_IDX: u32 = 105;
pub const DATA_IDX: u32 = 106;
pub const PKT_TX_ON_IDX: u32 = 107;
pub const PKT_RX_ON_IDX: u32 = 108;
pub const RW_TX_ON_IDX: u32 = 109;
pub const RW_RX_ON_IDX: u32 = 110;
pub const EVT_REQ_P_IDX: u32 = 111;
pub const EVT_STOP_P_IDX: u32 = 112;
pub const BT_MODE_ON_IDX: u32 = 113;
pub const GPIO_LC_DIAG0_IDX: u32 = 114;
pub const GPIO_LC_DIAG1_IDX: u32 = 115;
pub const GPIO_LC_DIAG2_IDX: u32 = 116;
pub const CH_IDX_IDX: u32 = 117;
pub const RX_WINDOW_IDX: u32 = 118;
pub const UPDATE_RX_IDX: u32 = 119;
pub const RX_STATUS_IDX: u32 = 120;
pub const CLK_GPIO_IDX: u32 = 121;
pub const NBT_BLE_IDX: u32 = 122;
pub const CLK_OUT_OUT1_IDX: u32 = 123;
pub const CLK_OUT_OUT2_IDX: u32 = 124;
pub const CLK_OUT_OUT3_IDX: u32 = 125;
pub const SPICS1_OUT_IDX: u32 = 126;
pub const USB_JTAG_TRST_OUT_IDX: u32 = 127;
pub const SIG_GPIO_OUT_IDX: u32 = 128;
pub const GPIO_MAP_DATE_IDX: u32 = 33579312;
pub const RTC_CNTL_WDT_WKEY_VALUE: u32 = 1356348065;
pub const RTC_CNTL_SWD_WKEY_VALUE: u32 = 2401055018;
pub const RTC_WDT_RESET_LENGTH_100_NS: u32 = 0;
pub const RTC_WDT_RESET_LENGTH_200_NS: u32 = 1;
pub const RTC_WDT_RESET_LENGTH_300_NS: u32 = 2;
pub const RTC_WDT_RESET_LENGTH_400_NS: u32 = 3;
pub const RTC_WDT_RESET_LENGTH_500_NS: u32 = 4;
pub const RTC_WDT_RESET_LENGTH_800_NS: u32 = 5;
pub const RTC_WDT_RESET_LENGTH_1600_NS: u32 = 6;
pub const RTC_WDT_RESET_LENGTH_3200_NS: u32 = 7;
pub const RTC_CNTL_OPTIONS0_REG: u32 = 1610645504;
pub const RTC_CNTL_SW_SYS_RST_V: u32 = 1;
pub const RTC_CNTL_SW_SYS_RST_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_S: u32 = 30;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_S: u32 = 29;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_S: u32 = 28;
pub const RTC_CNTL_PLL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_XTL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_NOISO_S: u32 = 26;
pub const RTC_CNTL_ANALOG_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_ISO_S: u32 = 25;
pub const RTC_CNTL_PLL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_XTL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_ISO_S: u32 = 23;
pub const RTC_CNTL_XTL_EXT_CTR_SEL: u32 = 7;
pub const RTC_CNTL_XTL_EXT_CTR_SEL_V: u32 = 7;
pub const RTC_CNTL_XTL_EXT_CTR_SEL_S: u32 = 20;
pub const RTC_CNTL_XTL_EN_WAIT: u32 = 15;
pub const RTC_CNTL_XTL_EN_WAIT_V: u32 = 15;
pub const RTC_CNTL_XTL_EN_WAIT_S: u32 = 14;
pub const RTC_CNTL_XTL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PU_S: u32 = 13;
pub const RTC_CNTL_XTL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PD_S: u32 = 12;
pub const RTC_CNTL_BBPLL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PU_S: u32 = 11;
pub const RTC_CNTL_BBPLL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PD_S: u32 = 10;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_S: u32 = 9;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_S: u32 = 8;
pub const RTC_CNTL_BB_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PU_S: u32 = 7;
pub const RTC_CNTL_BB_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PD_S: u32 = 6;
pub const RTC_CNTL_SW_PROCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_PROCPU_RST_S: u32 = 5;
pub const RTC_CNTL_SW_APPCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_APPCPU_RST_S: u32 = 4;
pub const RTC_CNTL_SW_STALL_PROCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_S: u32 = 2;
pub const RTC_CNTL_SW_STALL_APPCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER0_REG: u32 = 1610645508;
pub const RTC_CNTL_SLP_VAL_LO: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_V: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER1_REG: u32 = 1610645512;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_S: u32 = 16;
pub const RTC_CNTL_SLP_VAL_HI: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_V: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_S: u32 = 0;
pub const RTC_CNTL_TIME_UPDATE_REG: u32 = 1610645516;
pub const RTC_CNTL_TIME_UPDATE_V: u32 = 1;
pub const RTC_CNTL_TIME_UPDATE_S: u32 = 31;
pub const RTC_CNTL_TIMER_SYS_RST_V: u32 = 1;
pub const RTC_CNTL_TIMER_SYS_RST_S: u32 = 29;
pub const RTC_CNTL_TIMER_XTL_OFF_V: u32 = 1;
pub const RTC_CNTL_TIMER_XTL_OFF_S: u32 = 28;
pub const RTC_CNTL_TIMER_SYS_STALL_V: u32 = 1;
pub const RTC_CNTL_TIMER_SYS_STALL_S: u32 = 27;
pub const RTC_CNTL_TIME_LOW0_REG: u32 = 1610645520;
pub const RTC_CNTL_TIMER_VALUE0_LOW: u32 = 4294967295;
pub const RTC_CNTL_TIMER_VALUE0_LOW_V: u32 = 4294967295;
pub const RTC_CNTL_TIMER_VALUE0_LOW_S: u32 = 0;
pub const RTC_CNTL_TIME_HIGH0_REG: u32 = 1610645524;
pub const RTC_CNTL_TIMER_VALUE0_HIGH: u32 = 65535;
pub const RTC_CNTL_TIMER_VALUE0_HIGH_V: u32 = 65535;
pub const RTC_CNTL_TIMER_VALUE0_HIGH_S: u32 = 0;
pub const RTC_CNTL_STATE0_REG: u32 = 1610645528;
pub const RTC_CNTL_SLEEP_EN_V: u32 = 1;
pub const RTC_CNTL_SLEEP_EN_S: u32 = 31;
pub const RTC_CNTL_SLP_REJECT_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_S: u32 = 30;
pub const RTC_CNTL_SLP_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_S: u32 = 29;
pub const RTC_CNTL_SDIO_ACTIVE_IND_V: u32 = 1;
pub const RTC_CNTL_SDIO_ACTIVE_IND_S: u32 = 28;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_V: u32 = 1;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_S: u32 = 22;
pub const RTC_CNTL_SLP_REJECT_CAUSE_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_CAUSE_CLR_S: u32 = 1;
pub const RTC_CNTL_SW_CPU_INT_V: u32 = 1;
pub const RTC_CNTL_SW_CPU_INT_S: u32 = 0;
pub const RTC_CNTL_TIMER1_REG: u32 = 1610645532;
pub const RTC_CNTL_PLL_BUF_WAIT: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_V: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_S: u32 = 24;
pub const RTC_CNTL_PLL_BUF_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_XTL_BUF_WAIT: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_V: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_S: u32 = 14;
pub const RTC_CNTL_XTL_BUF_WAIT_DEFAULT: u32 = 100;
pub const RTC_CNTL_CK8M_WAIT: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_V: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_S: u32 = 6;
pub const RTC_CNTL_CPU_STALL_WAIT: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_V: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_S: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_V: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_S: u32 = 0;
pub const RTC_CNTL_TIMER2_REG: u32 = 1610645536;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_V: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_S: u32 = 24;
pub const RTC_CNTL_TIMER3_REG: u32 = 1610645540;
pub const RTC_CNTL_BT_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_BT_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_BT_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_BT_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_BT_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_BT_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_WIFI_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_WIFI_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER4_REG: u32 = 1610645544;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_CPU_TOP_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_CPU_TOP_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_CPU_TOP_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_CPU_TOP_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_CPU_TOP_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_CPU_TOP_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER5_REG: u32 = 1610645548;
pub const RTC_CNTL_MIN_SLP_VAL: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_V: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_S: u32 = 8;
pub const RTC_CNTL_TIMER6_REG: u32 = 1610645552;
pub const RTC_CNTL_DG_PERI_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_DG_PERI_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_DG_PERI_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_DG_PERI_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_DG_PERI_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_DG_PERI_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_ANA_CONF_REG: u32 = 1610645556;
pub const RTC_CNTL_PLL_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_PLL_I2C_PU_S: u32 = 31;
pub const RTC_CNTL_CKGEN_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_CKGEN_I2C_PU_S: u32 = 30;
pub const RTC_CNTL_RFRX_PBUS_PU_V: u32 = 1;
pub const RTC_CNTL_RFRX_PBUS_PU_S: u32 = 28;
pub const RTC_CNTL_TXRF_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_TXRF_I2C_PU_S: u32 = 27;
pub const RTC_CNTL_PVTMON_PU_V: u32 = 1;
pub const RTC_CNTL_PVTMON_PU_S: u32 = 26;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_S: u32 = 25;
pub const RTC_CNTL_PLLA_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PU_S: u32 = 24;
pub const RTC_CNTL_PLLA_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PD_S: u32 = 23;
pub const RTC_CNTL_SAR_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_SAR_I2C_PU_S: u32 = 22;
pub const RTC_CNTL_GLITCH_RST_EN_V: u32 = 1;
pub const RTC_CNTL_GLITCH_RST_EN_S: u32 = 20;
pub const RTC_CNTL_I2C_RESET_POR_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_I2C_RESET_POR_FORCE_PU_S: u32 = 19;
pub const RTC_CNTL_I2C_RESET_POR_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_I2C_RESET_POR_FORCE_PD_S: u32 = 18;
pub const RTC_CNTL_RESET_STATE_REG: u32 = 1610645560;
pub const RTC_CNTL_DRESET_MASK_PROCPU_V: u32 = 1;
pub const RTC_CNTL_DRESET_MASK_PROCPU_S: u32 = 25;
pub const RTC_CNTL_DRESET_MASK_APPCPU_V: u32 = 1;
pub const RTC_CNTL_DRESET_MASK_APPCPU_S: u32 = 24;
pub const RTC_CNTL_JTAG_RESET_FLAG_CLR_APPCPU_V: u32 = 1;
pub const RTC_CNTL_JTAG_RESET_FLAG_CLR_APPCPU_S: u32 = 23;
pub const RTC_CNTL_JTAG_RESET_FLAG_CLR_PROCPU_V: u32 = 1;
pub const RTC_CNTL_JTAG_RESET_FLAG_CLR_PROCPU_S: u32 = 22;
pub const RTC_CNTL_JTAG_RESET_FLAG_APPCPU_V: u32 = 1;
pub const RTC_CNTL_JTAG_RESET_FLAG_APPCPU_S: u32 = 21;
pub const RTC_CNTL_JTAG_RESET_FLAG_PROCPU_V: u32 = 1;
pub const RTC_CNTL_JTAG_RESET_FLAG_PROCPU_S: u32 = 20;
pub const RTC_CNTL_OCD_HALT_ON_RESET_PROCPU_V: u32 = 1;
pub const RTC_CNTL_OCD_HALT_ON_RESET_PROCPU_S: u32 = 19;
pub const RTC_CNTL_OCD_HALT_ON_RESET_APPCPU_V: u32 = 1;
pub const RTC_CNTL_OCD_HALT_ON_RESET_APPCPU_S: u32 = 18;
pub const RTC_CNTL_ALL_RESET_FLAG_CLR_APPCPU_V: u32 = 1;
pub const RTC_CNTL_ALL_RESET_FLAG_CLR_APPCPU_S: u32 = 17;
pub const RTC_CNTL_ALL_RESET_FLAG_CLR_PROCPU_V: u32 = 1;
pub const RTC_CNTL_ALL_RESET_FLAG_CLR_PROCPU_S: u32 = 16;
pub const RTC_CNTL_ALL_RESET_FLAG_APPCPU_V: u32 = 1;
pub const RTC_CNTL_ALL_RESET_FLAG_APPCPU_S: u32 = 15;
pub const RTC_CNTL_ALL_RESET_FLAG_PROCPU_V: u32 = 1;
pub const RTC_CNTL_ALL_RESET_FLAG_PROCPU_S: u32 = 14;
pub const RTC_CNTL_STAT_VECTOR_SEL_PROCPU_V: u32 = 1;
pub const RTC_CNTL_STAT_VECTOR_SEL_PROCPU_S: u32 = 13;
pub const RTC_CNTL_STAT_VECTOR_SEL_APPCPU_V: u32 = 1;
pub const RTC_CNTL_STAT_VECTOR_SEL_APPCPU_S: u32 = 12;
pub const RTC_CNTL_RESET_CAUSE_APPCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_S: u32 = 6;
pub const RTC_CNTL_RESET_CAUSE_PROCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_S: u32 = 0;
pub const RTC_CNTL_WAKEUP_STATE_REG: u32 = 1610645564;
pub const RTC_CNTL_WAKEUP_ENA: u32 = 131071;
pub const RTC_CNTL_WAKEUP_ENA_V: u32 = 131071;
pub const RTC_CNTL_WAKEUP_ENA_S: u32 = 15;
pub const RTC_CNTL_INT_ENA_REG: u32 = 1610645568;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_ENA_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ENA_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_S: u32 = 0;
pub const RTC_CNTL_INT_RAW_REG: u32 = 1610645572;
pub const RTC_CNTL_BBPLL_CAL_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_RAW_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_RAW_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_RAW_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_RAW_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_RAW_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_S: u32 = 0;
pub const RTC_CNTL_INT_ST_REG: u32 = 1610645576;
pub const RTC_CNTL_BBPLL_CAL_INT_ST_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_ST_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_ST_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_ST_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ST_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ST_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_ST_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ST_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ST_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ST_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_S: u32 = 0;
pub const RTC_CNTL_INT_CLR_REG: u32 = 1610645580;
pub const RTC_CNTL_BBPLL_CAL_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_CLR_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_CLR_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_CLR_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_CLR_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_CLR_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_S: u32 = 0;
pub const RTC_CNTL_STORE0_REG: u32 = 1610645584;
pub const RTC_CNTL_SCRATCH0: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_S: u32 = 0;
pub const RTC_CNTL_STORE1_REG: u32 = 1610645588;
pub const RTC_CNTL_SCRATCH1: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_S: u32 = 0;
pub const RTC_CNTL_STORE2_REG: u32 = 1610645592;
pub const RTC_CNTL_SCRATCH2: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_S: u32 = 0;
pub const RTC_CNTL_STORE3_REG: u32 = 1610645596;
pub const RTC_CNTL_SCRATCH3: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_S: u32 = 0;
pub const RTC_CNTL_EXT_XTL_CONF_REG: u32 = 1610645600;
pub const RTC_CNTL_XTL_EXT_CTR_EN_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_EN_S: u32 = 31;
pub const RTC_CNTL_XTL_EXT_CTR_LV_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_LV_S: u32 = 30;
pub const RTC_CNTL_XTAL32K_GPIO_SEL_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_GPIO_SEL_S: u32 = 23;
pub const RTC_CNTL_WDT_STATE: u32 = 7;
pub const RTC_CNTL_WDT_STATE_V: u32 = 7;
pub const RTC_CNTL_WDT_STATE_S: u32 = 20;
pub const RTC_CNTL_DAC_XTAL_32K: u32 = 7;
pub const RTC_CNTL_DAC_XTAL_32K_V: u32 = 7;
pub const RTC_CNTL_DAC_XTAL_32K_S: u32 = 17;
pub const RTC_CNTL_XPD_XTAL_32K_V: u32 = 1;
pub const RTC_CNTL_XPD_XTAL_32K_S: u32 = 16;
pub const RTC_CNTL_DRES_XTAL_32K: u32 = 7;
pub const RTC_CNTL_DRES_XTAL_32K_V: u32 = 7;
pub const RTC_CNTL_DRES_XTAL_32K_S: u32 = 13;
pub const RTC_CNTL_DGM_XTAL_32K: u32 = 7;
pub const RTC_CNTL_DGM_XTAL_32K_V: u32 = 7;
pub const RTC_CNTL_DGM_XTAL_32K_S: u32 = 10;
pub const RTC_CNTL_DBUF_XTAL_32K_V: u32 = 1;
pub const RTC_CNTL_DBUF_XTAL_32K_S: u32 = 9;
pub const RTC_CNTL_ENCKINIT_XTAL_32K_V: u32 = 1;
pub const RTC_CNTL_ENCKINIT_XTAL_32K_S: u32 = 8;
pub const RTC_CNTL_XTAL32K_XPD_FORCE_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_XPD_FORCE_S: u32 = 7;
pub const RTC_CNTL_XTAL32K_AUTO_RETURN_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_AUTO_RETURN_S: u32 = 6;
pub const RTC_CNTL_XTAL32K_AUTO_RESTART_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_AUTO_RESTART_S: u32 = 5;
pub const RTC_CNTL_XTAL32K_AUTO_BACKUP_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_AUTO_BACKUP_S: u32 = 4;
pub const RTC_CNTL_XTAL32K_EXT_CLK_FO_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_EXT_CLK_FO_S: u32 = 3;
pub const RTC_CNTL_XTAL32K_WDT_RESET_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_WDT_RESET_S: u32 = 2;
pub const RTC_CNTL_XTAL32K_WDT_CLK_FO_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_WDT_CLK_FO_S: u32 = 1;
pub const RTC_CNTL_XTAL32K_WDT_EN_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_WDT_EN_S: u32 = 0;
pub const RTC_CNTL_EXT_WAKEUP_CONF_REG: u32 = 1610645604;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_V: u32 = 1;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_S: u32 = 31;
pub const RTC_CNTL_SLP_REJECT_CONF_REG: u32 = 1610645608;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_S: u32 = 31;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_S: u32 = 30;
pub const RTC_CNTL_SLEEP_REJECT_ENA: u32 = 262143;
pub const RTC_CNTL_SLEEP_REJECT_ENA_V: u32 = 262143;
pub const RTC_CNTL_SLEEP_REJECT_ENA_S: u32 = 12;
pub const RTC_CNTL_CPU_PERIOD_CONF_REG: u32 = 1610645612;
pub const RTC_CNTL_CPUPERIOD_SEL: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_V: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_S: u32 = 30;
pub const RTC_CNTL_CPUSEL_CONF_V: u32 = 1;
pub const RTC_CNTL_CPUSEL_CONF_S: u32 = 29;
pub const RTC_CNTL_CLK_CONF_REG: u32 = 1610645616;
pub const RTC_CNTL_ANA_CLK_RTC_SEL: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_V: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_S: u32 = 30;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_V: u32 = 1;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_S: u32 = 29;
pub const RTC_CNTL_XTAL_GLOBAL_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_XTAL_GLOBAL_FORCE_NOGATING_S: u32 = 28;
pub const RTC_CNTL_XTAL_GLOBAL_FORCE_GATING_V: u32 = 1;
pub const RTC_CNTL_XTAL_GLOBAL_FORCE_GATING_S: u32 = 27;
pub const RTC_CNTL_CK8M_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PU_S: u32 = 26;
pub const RTC_CNTL_CK8M_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PD_S: u32 = 25;
pub const RTC_CNTL_CK8M_DFREQ: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_V: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_S: u32 = 17;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_S: u32 = 16;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_S: u32 = 15;
pub const RTC_CNTL_CK8M_DIV_SEL: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_V: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_S: u32 = 12;
pub const RTC_CNTL_DIG_CLK8M_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_EN_S: u32 = 10;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_S: u32 = 9;
pub const RTC_CNTL_DIG_XTAL32K_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_XTAL32K_EN_S: u32 = 8;
pub const RTC_CNTL_ENB_CK8M_DIV_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_DIV_S: u32 = 7;
pub const RTC_CNTL_ENB_CK8M_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_S: u32 = 6;
pub const RTC_CNTL_CK8M_DIV: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_V: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_S: u32 = 4;
pub const RTC_CNTL_CK8M_DIV_SEL_VLD_V: u32 = 1;
pub const RTC_CNTL_CK8M_DIV_SEL_VLD_S: u32 = 3;
pub const RTC_CNTL_EFUSE_CLK_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_EFUSE_CLK_FORCE_NOGATING_S: u32 = 2;
pub const RTC_CNTL_EFUSE_CLK_FORCE_GATING_V: u32 = 1;
pub const RTC_CNTL_EFUSE_CLK_FORCE_GATING_S: u32 = 1;
pub const RTC_CNTL_SLOW_CLK_CONF_REG: u32 = 1610645620;
pub const RTC_CNTL_SLOW_CLK_NEXT_EDGE_V: u32 = 1;
pub const RTC_CNTL_SLOW_CLK_NEXT_EDGE_S: u32 = 31;
pub const RTC_CNTL_ANA_CLK_DIV: u32 = 255;
pub const RTC_CNTL_ANA_CLK_DIV_V: u32 = 255;
pub const RTC_CNTL_ANA_CLK_DIV_S: u32 = 23;
pub const RTC_CNTL_ANA_CLK_DIV_VLD_V: u32 = 1;
pub const RTC_CNTL_ANA_CLK_DIV_VLD_S: u32 = 22;
pub const RTC_CNTL_SDIO_CONF_REG: u32 = 1610645624;
pub const RTC_CNTL_XPD_SDIO_REG_V: u32 = 1;
pub const RTC_CNTL_XPD_SDIO_REG_S: u32 = 31;
pub const RTC_CNTL_DREFH_SDIO: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_S: u32 = 29;
pub const RTC_CNTL_DREFM_SDIO: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_S: u32 = 27;
pub const RTC_CNTL_DREFL_SDIO: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_S: u32 = 25;
pub const RTC_CNTL_REG1P8_READY_V: u32 = 1;
pub const RTC_CNTL_REG1P8_READY_S: u32 = 24;
pub const RTC_CNTL_SDIO_TIEH_V: u32 = 1;
pub const RTC_CNTL_SDIO_TIEH_S: u32 = 23;
pub const RTC_CNTL_SDIO_FORCE_V: u32 = 1;
pub const RTC_CNTL_SDIO_FORCE_S: u32 = 22;
pub const RTC_CNTL_SDIO_PD_EN_V: u32 = 1;
pub const RTC_CNTL_SDIO_PD_EN_S: u32 = 21;
pub const RTC_CNTL_SDIO_ENCURLIM_V: u32 = 1;
pub const RTC_CNTL_SDIO_ENCURLIM_S: u32 = 20;
pub const RTC_CNTL_SDIO_MODECURLIM_V: u32 = 1;
pub const RTC_CNTL_SDIO_MODECURLIM_S: u32 = 19;
pub const RTC_CNTL_SDIO_DCURLIM: u32 = 7;
pub const RTC_CNTL_SDIO_DCURLIM_V: u32 = 7;
pub const RTC_CNTL_SDIO_DCURLIM_S: u32 = 16;
pub const RTC_CNTL_SDIO_EN_INITI_V: u32 = 1;
pub const RTC_CNTL_SDIO_EN_INITI_S: u32 = 15;
pub const RTC_CNTL_SDIO_INITI: u32 = 3;
pub const RTC_CNTL_SDIO_INITI_V: u32 = 3;
pub const RTC_CNTL_SDIO_INITI_S: u32 = 13;
pub const RTC_CNTL_SDIO_DCAP: u32 = 3;
pub const RTC_CNTL_SDIO_DCAP_V: u32 = 3;
pub const RTC_CNTL_SDIO_DCAP_S: u32 = 11;
pub const RTC_CNTL_SDIO_DTHDRV: u32 = 3;
pub const RTC_CNTL_SDIO_DTHDRV_V: u32 = 3;
pub const RTC_CNTL_SDIO_DTHDRV_S: u32 = 9;
pub const RTC_CNTL_SDIO_TIMER_TARGET: u32 = 255;
pub const RTC_CNTL_SDIO_TIMER_TARGET_V: u32 = 255;
pub const RTC_CNTL_SDIO_TIMER_TARGET_S: u32 = 0;
pub const RTC_CNTL_BIAS_CONF_REG: u32 = 1610645628;
pub const RTC_CNTL_DBG_ATTEN_MONITOR: u32 = 15;
pub const RTC_CNTL_DBG_ATTEN_MONITOR_V: u32 = 15;
pub const RTC_CNTL_DBG_ATTEN_MONITOR_S: u32 = 22;
pub const RTC_CNTL_DBG_ATTEN_DEEP_SLP: u32 = 15;
pub const RTC_CNTL_DBG_ATTEN_DEEP_SLP_V: u32 = 15;
pub const RTC_CNTL_DBG_ATTEN_DEEP_SLP_S: u32 = 18;
pub const RTC_CNTL_BIAS_SLEEP_MONITOR_V: u32 = 1;
pub const RTC_CNTL_BIAS_SLEEP_MONITOR_S: u32 = 17;
pub const RTC_CNTL_BIAS_SLEEP_DEEP_SLP_V: u32 = 1;
pub const RTC_CNTL_BIAS_SLEEP_DEEP_SLP_S: u32 = 16;
pub const RTC_CNTL_PD_CUR_MONITOR_V: u32 = 1;
pub const RTC_CNTL_PD_CUR_MONITOR_S: u32 = 15;
pub const RTC_CNTL_PD_CUR_DEEP_SLP_V: u32 = 1;
pub const RTC_CNTL_PD_CUR_DEEP_SLP_S: u32 = 14;
pub const RTC_CNTL_BIAS_BUF_MONITOR_V: u32 = 1;
pub const RTC_CNTL_BIAS_BUF_MONITOR_S: u32 = 13;
pub const RTC_CNTL_BIAS_BUF_DEEP_SLP_V: u32 = 1;
pub const RTC_CNTL_BIAS_BUF_DEEP_SLP_S: u32 = 12;
pub const RTC_CNTL_BIAS_BUF_WAKE_V: u32 = 1;
pub const RTC_CNTL_BIAS_BUF_WAKE_S: u32 = 11;
pub const RTC_CNTL_BIAS_BUF_IDLE_V: u32 = 1;
pub const RTC_CNTL_BIAS_BUF_IDLE_S: u32 = 10;
pub const RTC_CNTL_DG_VDD_DRV_B_SLP_EN_V: u32 = 1;
pub const RTC_CNTL_DG_VDD_DRV_B_SLP_EN_S: u32 = 8;
pub const RTC_CNTL_DG_VDD_DRV_B_SLP: u32 = 255;
pub const RTC_CNTL_DG_VDD_DRV_B_SLP_V: u32 = 255;
pub const RTC_CNTL_DG_VDD_DRV_B_SLP_S: u32 = 0;
pub const RTC_CNTL_REG: u32 = 1610645632;
pub const RTC_CNTL_REGULATOR_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_REGULATOR_FORCE_PU_S: u32 = 31;
pub const RTC_CNTL_REGULATOR_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_REGULATOR_FORCE_PD_S: u32 = 30;
pub const RTC_CNTL_DBOOST_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PU_S: u32 = 29;
pub const RTC_CNTL_DBOOST_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PD_S: u32 = 28;
pub const RTC_CNTL_SCK_DCAP: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_V: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_S: u32 = 14;
pub const RTC_CNTL_SCK_DCAP_DEFAULT: u32 = 255;
pub const RTC_CNTL_DIG_CAL_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CAL_EN_S: u32 = 7;
pub const RTC_CNTL_PWC_REG: u32 = 1610645636;
pub const RTC_CNTL_PAD_FORCE_HOLD_V: u32 = 1;
pub const RTC_CNTL_PAD_FORCE_HOLD_S: u32 = 21;
pub const RTC_CNTL_DIG_PWC_REG: u32 = 1610645640;
pub const RTC_CNTL_DG_WRAP_PD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_PD_EN_S: u32 = 31;
pub const RTC_CNTL_WIFI_PD_EN_V: u32 = 1;
pub const RTC_CNTL_WIFI_PD_EN_S: u32 = 30;
pub const RTC_CNTL_CPU_TOP_PD_EN_V: u32 = 1;
pub const RTC_CNTL_CPU_TOP_PD_EN_S: u32 = 29;
pub const RTC_CNTL_DG_PERI_PD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_PERI_PD_EN_S: u32 = 28;
pub const RTC_CNTL_BT_PD_EN_V: u32 = 1;
pub const RTC_CNTL_BT_PD_EN_S: u32 = 27;
pub const RTC_CNTL_CPU_TOP_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_CPU_TOP_FORCE_PU_S: u32 = 22;
pub const RTC_CNTL_CPU_TOP_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_CPU_TOP_FORCE_PD_S: u32 = 21;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_S: u32 = 20;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_S: u32 = 19;
pub const RTC_CNTL_WIFI_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PU_S: u32 = 18;
pub const RTC_CNTL_WIFI_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PD_S: u32 = 17;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_S: u32 = 16;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_S: u32 = 15;
pub const RTC_CNTL_DG_PERI_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DG_PERI_FORCE_PU_S: u32 = 14;
pub const RTC_CNTL_DG_PERI_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DG_PERI_FORCE_PD_S: u32 = 13;
pub const RTC_CNTL_BT_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BT_FORCE_PU_S: u32 = 12;
pub const RTC_CNTL_BT_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BT_FORCE_PD_S: u32 = 11;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_S: u32 = 4;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_S: u32 = 3;
pub const RTC_CNTL_VDD_SPI_PWR_FORCE_V: u32 = 1;
pub const RTC_CNTL_VDD_SPI_PWR_FORCE_S: u32 = 2;
pub const RTC_CNTL_VDD_SPI_PWR_DRV: u32 = 3;
pub const RTC_CNTL_VDD_SPI_PWR_DRV_V: u32 = 3;
pub const RTC_CNTL_VDD_SPI_PWR_DRV_S: u32 = 0;
pub const RTC_CNTL_DIG_ISO_REG: u32 = 1610645644;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_S: u32 = 30;
pub const RTC_CNTL_WIFI_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_NOISO_S: u32 = 29;
pub const RTC_CNTL_WIFI_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_ISO_S: u32 = 28;
pub const RTC_CNTL_CPU_TOP_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_CPU_TOP_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_CPU_TOP_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_CPU_TOP_FORCE_ISO_S: u32 = 26;
pub const RTC_CNTL_DG_PERI_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_PERI_FORCE_NOISO_S: u32 = 25;
pub const RTC_CNTL_DG_PERI_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_PERI_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_BT_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_BT_FORCE_NOISO_S: u32 = 23;
pub const RTC_CNTL_BT_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_BT_FORCE_ISO_S: u32 = 22;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_S: u32 = 15;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_S: u32 = 14;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_S: u32 = 13;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_S: u32 = 12;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_S: u32 = 11;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_S: u32 = 10;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_S: u32 = 9;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_S: u32 = 8;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_S: u32 = 7;
pub const RTC_CNTL_WDTCONFIG0_REG: u32 = 1610645648;
pub const RTC_CNTL_WDT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_EN_S: u32 = 31;
pub const RTC_CNTL_WDT_STG0: u32 = 7;
pub const RTC_CNTL_WDT_STG0_V: u32 = 7;
pub const RTC_CNTL_WDT_STG0_S: u32 = 28;
pub const RTC_CNTL_WDT_STG1: u32 = 7;
pub const RTC_CNTL_WDT_STG1_V: u32 = 7;
pub const RTC_CNTL_WDT_STG1_S: u32 = 25;
pub const RTC_CNTL_WDT_STG2: u32 = 7;
pub const RTC_CNTL_WDT_STG2_V: u32 = 7;
pub const RTC_CNTL_WDT_STG2_S: u32 = 22;
pub const RTC_CNTL_WDT_STG3: u32 = 7;
pub const RTC_CNTL_WDT_STG3_V: u32 = 7;
pub const RTC_CNTL_WDT_STG3_S: u32 = 19;
pub const RTC_WDT_STG_SEL_OFF: u32 = 0;
pub const RTC_WDT_STG_SEL_INT: u32 = 1;
pub const RTC_WDT_STG_SEL_RESET_CPU: u32 = 2;
pub const RTC_WDT_STG_SEL_RESET_SYSTEM: u32 = 3;
pub const RTC_WDT_STG_SEL_RESET_RTC: u32 = 4;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_S: u32 = 16;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_S: u32 = 13;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_S: u32 = 12;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_S: u32 = 11;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_S: u32 = 10;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_V: u32 = 1;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_S: u32 = 9;
pub const RTC_CNTL_WDT_CHIP_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_CHIP_RESET_EN_S: u32 = 8;
pub const RTC_CNTL_WDT_CHIP_RESET_WIDTH: u32 = 255;
pub const RTC_CNTL_WDT_CHIP_RESET_WIDTH_V: u32 = 255;
pub const RTC_CNTL_WDT_CHIP_RESET_WIDTH_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG1_REG: u32 = 1610645652;
pub const RTC_CNTL_WDT_STG0_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG2_REG: u32 = 1610645656;
pub const RTC_CNTL_WDT_STG1_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG3_REG: u32 = 1610645660;
pub const RTC_CNTL_WDT_STG2_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG4_REG: u32 = 1610645664;
pub const RTC_CNTL_WDT_STG3_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTFEED_REG: u32 = 1610645668;
pub const RTC_CNTL_WDT_FEED_V: u32 = 1;
pub const RTC_CNTL_WDT_FEED_S: u32 = 31;
pub const RTC_CNTL_WDTWPROTECT_REG: u32 = 1610645672;
pub const RTC_CNTL_WDT_WKEY: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_S: u32 = 0;
pub const RTC_CNTL_SWD_CONF_REG: u32 = 1610645676;
pub const RTC_CNTL_SWD_AUTO_FEED_EN_V: u32 = 1;
pub const RTC_CNTL_SWD_AUTO_FEED_EN_S: u32 = 31;
pub const RTC_CNTL_SWD_DISABLE_V: u32 = 1;
pub const RTC_CNTL_SWD_DISABLE_S: u32 = 30;
pub const RTC_CNTL_SWD_FEED_V: u32 = 1;
pub const RTC_CNTL_SWD_FEED_S: u32 = 29;
pub const RTC_CNTL_SWD_RST_FLAG_CLR_V: u32 = 1;
pub const RTC_CNTL_SWD_RST_FLAG_CLR_S: u32 = 28;
pub const RTC_CNTL_SWD_SIGNAL_WIDTH: u32 = 1023;
pub const RTC_CNTL_SWD_SIGNAL_WIDTH_V: u32 = 1023;
pub const RTC_CNTL_SWD_SIGNAL_WIDTH_S: u32 = 18;
pub const RTC_CNTL_SWD_BYPASS_RST_V: u32 = 1;
pub const RTC_CNTL_SWD_BYPASS_RST_S: u32 = 17;
pub const RTC_CNTL_SWD_FEED_INT_V: u32 = 1;
pub const RTC_CNTL_SWD_FEED_INT_S: u32 = 1;
pub const RTC_CNTL_SWD_RESET_FLAG_V: u32 = 1;
pub const RTC_CNTL_SWD_RESET_FLAG_S: u32 = 0;
pub const RTC_CNTL_SWD_WPROTECT_REG: u32 = 1610645680;
pub const RTC_CNTL_SWD_WKEY: u32 = 4294967295;
pub const RTC_CNTL_SWD_WKEY_V: u32 = 4294967295;
pub const RTC_CNTL_SWD_WKEY_S: u32 = 0;
pub const RTC_CNTL_SW_CPU_STALL_REG: u32 = 1610645684;
pub const RTC_CNTL_SW_STALL_PROCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_S: u32 = 26;
pub const RTC_CNTL_SW_STALL_APPCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_S: u32 = 20;
pub const RTC_CNTL_STORE4_REG: u32 = 1610645688;
pub const RTC_CNTL_SCRATCH4: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_S: u32 = 0;
pub const RTC_CNTL_STORE5_REG: u32 = 1610645692;
pub const RTC_CNTL_SCRATCH5: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_S: u32 = 0;
pub const RTC_CNTL_STORE6_REG: u32 = 1610645696;
pub const RTC_CNTL_SCRATCH6: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_S: u32 = 0;
pub const RTC_CNTL_STORE7_REG: u32 = 1610645700;
pub const RTC_CNTL_SCRATCH7: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_S: u32 = 0;
pub const RTC_CNTL_LOW_POWER_ST_REG: u32 = 1610645704;
pub const RTC_CNTL_MAIN_STATE: u32 = 15;
pub const RTC_CNTL_MAIN_STATE_V: u32 = 15;
pub const RTC_CNTL_MAIN_STATE_S: u32 = 28;
pub const RTC_CNTL_MAIN_STATE_IN_IDLE_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_IN_IDLE_S: u32 = 27;
pub const RTC_CNTL_MAIN_STATE_IN_SLP_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_IN_SLP_S: u32 = 26;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_XTL_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_XTL_S: u32 = 25;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_PLL_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_PLL_S: u32 = 24;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_8M_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_IN_WAIT_8M_S: u32 = 23;
pub const RTC_CNTL_IN_LOW_POWER_STATE_V: u32 = 1;
pub const RTC_CNTL_IN_LOW_POWER_STATE_S: u32 = 22;
pub const RTC_CNTL_IN_WAKEUP_STATE_V: u32 = 1;
pub const RTC_CNTL_IN_WAKEUP_STATE_S: u32 = 21;
pub const RTC_CNTL_MAIN_STATE_WAIT_END_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_WAIT_END_S: u32 = 20;
pub const RTC_CNTL_RDY_FOR_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_RDY_FOR_WAKEUP_S: u32 = 19;
pub const RTC_CNTL_MAIN_STATE_PLL_ON_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_PLL_ON_S: u32 = 18;
pub const RTC_CNTL_MAIN_STATE_XTAL_ISO_V: u32 = 1;
pub const RTC_CNTL_MAIN_STATE_XTAL_ISO_S: u32 = 17;
pub const RTC_CNTL_COCPU_STATE_DONE_V: u32 = 1;
pub const RTC_CNTL_COCPU_STATE_DONE_S: u32 = 16;
pub const RTC_CNTL_COCPU_STATE_SLP_V: u32 = 1;
pub const RTC_CNTL_COCPU_STATE_SLP_S: u32 = 15;
pub const RTC_CNTL_COCPU_STATE_SWITCH_V: u32 = 1;
pub const RTC_CNTL_COCPU_STATE_SWITCH_S: u32 = 14;
pub const RTC_CNTL_COCPU_STATE_START_V: u32 = 1;
pub const RTC_CNTL_COCPU_STATE_START_S: u32 = 13;
pub const RTC_CNTL_TOUCH_STATE_DONE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_STATE_DONE_S: u32 = 12;
pub const RTC_CNTL_TOUCH_STATE_SLP_V: u32 = 1;
pub const RTC_CNTL_TOUCH_STATE_SLP_S: u32 = 11;
pub const RTC_CNTL_TOUCH_STATE_SWITCH_V: u32 = 1;
pub const RTC_CNTL_TOUCH_STATE_SWITCH_S: u32 = 10;
pub const RTC_CNTL_TOUCH_STATE_START_V: u32 = 1;
pub const RTC_CNTL_TOUCH_STATE_START_S: u32 = 9;
pub const RTC_CNTL_XPD_DIG_V: u32 = 1;
pub const RTC_CNTL_XPD_DIG_S: u32 = 8;
pub const RTC_CNTL_DIG_ISO_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_S: u32 = 7;
pub const RTC_CNTL_XPD_WIFI_V: u32 = 1;
pub const RTC_CNTL_XPD_WIFI_S: u32 = 6;
pub const RTC_CNTL_WIFI_ISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_ISO_S: u32 = 5;
pub const RTC_CNTL_XPD_RTC_PERI_V: u32 = 1;
pub const RTC_CNTL_XPD_RTC_PERI_S: u32 = 4;
pub const RTC_CNTL_PERI_ISO_V: u32 = 1;
pub const RTC_CNTL_PERI_ISO_S: u32 = 3;
pub const RTC_CNTL_XPD_DIG_DCDC_V: u32 = 1;
pub const RTC_CNTL_XPD_DIG_DCDC_S: u32 = 2;
pub const RTC_CNTL_XPD_ROM0_V: u32 = 1;
pub const RTC_CNTL_XPD_ROM0_S: u32 = 0;
pub const RTC_CNTL_DIAG0_REG: u32 = 1610645708;
pub const RTC_CNTL_LOW_POWER_DIAG1: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_V: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_S: u32 = 0;
pub const RTC_CNTL_PAD_HOLD_REG: u32 = 1610645712;
pub const RTC_CNTL_GPIO_PIN5_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN5_HOLD_S: u32 = 5;
pub const RTC_CNTL_GPIO_PIN4_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN4_HOLD_S: u32 = 4;
pub const RTC_CNTL_GPIO_PIN3_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN3_HOLD_S: u32 = 3;
pub const RTC_CNTL_GPIO_PIN2_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN2_HOLD_S: u32 = 2;
pub const RTC_CNTL_GPIO_PIN1_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN1_HOLD_S: u32 = 1;
pub const RTC_CNTL_GPIO_PIN0_HOLD_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN0_HOLD_S: u32 = 0;
pub const RTC_CNTL_DIG_PAD_HOLD_REG: u32 = 1610645716;
pub const RTC_CNTL_DIG_PAD_HOLD: u32 = 4294967295;
pub const RTC_CNTL_DIG_PAD_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_DIG_PAD_HOLD_S: u32 = 0;
pub const RTC_CNTL_BROWN_OUT_REG: u32 = 1610645720;
pub const RTC_CNTL_BROWN_OUT_DET_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_DET_S: u32 = 31;
pub const RTC_CNTL_BROWN_OUT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_ENA_S: u32 = 30;
pub const RTC_CNTL_BROWN_OUT_CNT_CLR_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_CNT_CLR_S: u32 = 29;
pub const RTC_CNTL_BROWN_OUT_ANA_RST_EN_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_ANA_RST_EN_S: u32 = 28;
pub const RTC_CNTL_BROWN_OUT_RST_SEL_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_RST_SEL_S: u32 = 27;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_S: u32 = 26;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_V: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_S: u32 = 16;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_S: u32 = 15;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_S: u32 = 14;
pub const RTC_CNTL_BROWN_OUT_INT_WAIT: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_INT_WAIT_V: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_INT_WAIT_S: u32 = 4;
pub const RTC_CNTL_TIME_LOW1_REG: u32 = 1610645724;
pub const RTC_CNTL_TIMER_VALUE1_LOW: u32 = 4294967295;
pub const RTC_CNTL_TIMER_VALUE1_LOW_V: u32 = 4294967295;
pub const RTC_CNTL_TIMER_VALUE1_LOW_S: u32 = 0;
pub const RTC_CNTL_TIME_HIGH1_REG: u32 = 1610645728;
pub const RTC_CNTL_TIMER_VALUE1_HIGH: u32 = 65535;
pub const RTC_CNTL_TIMER_VALUE1_HIGH_V: u32 = 65535;
pub const RTC_CNTL_TIMER_VALUE1_HIGH_S: u32 = 0;
pub const RTC_CNTL_XTAL32K_CLK_FACTOR_REG: u32 = 1610645732;
pub const RTC_CNTL_XTAL32K_CLK_FACTOR: u32 = 4294967295;
pub const RTC_CNTL_XTAL32K_CLK_FACTOR_V: u32 = 4294967295;
pub const RTC_CNTL_XTAL32K_CLK_FACTOR_S: u32 = 0;
pub const RTC_CNTL_XTAL32K_CONF_REG: u32 = 1610645736;
pub const RTC_CNTL_XTAL32K_STABLE_THRES: u32 = 15;
pub const RTC_CNTL_XTAL32K_STABLE_THRES_V: u32 = 15;
pub const RTC_CNTL_XTAL32K_STABLE_THRES_S: u32 = 28;
pub const RTC_CNTL_XTAL32K_WDT_TIMEOUT: u32 = 255;
pub const RTC_CNTL_XTAL32K_WDT_TIMEOUT_V: u32 = 255;
pub const RTC_CNTL_XTAL32K_WDT_TIMEOUT_S: u32 = 20;
pub const RTC_CNTL_XTAL32K_RESTART_WAIT: u32 = 65535;
pub const RTC_CNTL_XTAL32K_RESTART_WAIT_V: u32 = 65535;
pub const RTC_CNTL_XTAL32K_RESTART_WAIT_S: u32 = 4;
pub const RTC_CNTL_XTAL32K_RETURN_WAIT: u32 = 15;
pub const RTC_CNTL_XTAL32K_RETURN_WAIT_V: u32 = 15;
pub const RTC_CNTL_XTAL32K_RETURN_WAIT_S: u32 = 0;
pub const RTC_CNTL_USB_CONF_REG: u32 = 1610645740;
pub const RTC_CNTL_IO_MUX_RESET_DISABLE_V: u32 = 1;
pub const RTC_CNTL_IO_MUX_RESET_DISABLE_S: u32 = 18;
pub const RTC_CNTL_SLP_REJECT_CAUSE_REG: u32 = 1610645744;
pub const RTC_CNTL_REJECT_CAUSE: u32 = 262143;
pub const RTC_CNTL_REJECT_CAUSE_V: u32 = 262143;
pub const RTC_CNTL_REJECT_CAUSE_S: u32 = 0;
pub const RTC_CNTL_OPTION1_REG: u32 = 1610645748;
pub const RTC_CNTL_FORCE_DOWNLOAD_BOOT_V: u32 = 1;
pub const RTC_CNTL_FORCE_DOWNLOAD_BOOT_S: u32 = 0;
pub const RTC_CNTL_SLP_WAKEUP_CAUSE_REG: u32 = 1610645752;
pub const RTC_CNTL_WAKEUP_CAUSE: u32 = 131071;
pub const RTC_CNTL_WAKEUP_CAUSE_V: u32 = 131071;
pub const RTC_CNTL_WAKEUP_CAUSE_S: u32 = 0;
pub const RTC_CNTL_ULP_CP_TIMER_1_REG: u32 = 1610645756;
pub const RTC_CNTL_ULP_CP_TIMER_SLP_CYCLE: u32 = 16777215;
pub const RTC_CNTL_ULP_CP_TIMER_SLP_CYCLE_V: u32 = 16777215;
pub const RTC_CNTL_ULP_CP_TIMER_SLP_CYCLE_S: u32 = 8;
pub const RTC_CNTL_INT_ENA_W1TS_REG: u32 = 1610645760;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_W1TS_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_W1TS_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_W1TS_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_ENA_W1TS_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_W1TS_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_W1TS_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ENA_W1TS_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_W1TS_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_W1TS_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_W1TS_S: u32 = 0;
pub const RTC_CNTL_INT_ENA_W1TC_REG: u32 = 1610645764;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_INT_ENA_W1TC_S: u32 = 20;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_GLITCH_DET_INT_ENA_W1TC_S: u32 = 19;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_XTAL32K_DEAD_INT_ENA_W1TC_S: u32 = 16;
pub const RTC_CNTL_SWD_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_SWD_INT_ENA_W1TC_S: u32 = 15;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_W1TC_S: u32 = 10;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_W1TC_S: u32 = 9;
pub const RTC_CNTL_WDT_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ENA_W1TC_S: u32 = 3;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_W1TC_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_W1TC_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_W1TC_S: u32 = 0;
pub const RTC_CNTL_RETENTION_CTRL_REG: u32 = 1610645768;
pub const RTC_CNTL_RETENTION_WAIT: u32 = 31;
pub const RTC_CNTL_RETENTION_WAIT_V: u32 = 31;
pub const RTC_CNTL_RETENTION_WAIT_S: u32 = 27;
pub const RTC_CNTL_RETENTION_EN_V: u32 = 1;
pub const RTC_CNTL_RETENTION_EN_S: u32 = 26;
pub const RTC_CNTL_RETENTION_CLKOFF_WAIT: u32 = 15;
pub const RTC_CNTL_RETENTION_CLKOFF_WAIT_V: u32 = 15;
pub const RTC_CNTL_RETENTION_CLKOFF_WAIT_S: u32 = 22;
pub const RTC_CNTL_RETENTION_DONE_WAIT: u32 = 7;
pub const RTC_CNTL_RETENTION_DONE_WAIT_V: u32 = 7;
pub const RTC_CNTL_RETENTION_DONE_WAIT_S: u32 = 19;
pub const RTC_CNTL_RETENTION_CLK_SEL_V: u32 = 1;
pub const RTC_CNTL_RETENTION_CLK_SEL_S: u32 = 18;
pub const RTC_CNTL_FIB_SEL_REG: u32 = 1610645772;
pub const RTC_CNTL_FIB_SEL: u32 = 7;
pub const RTC_CNTL_FIB_SEL_V: u32 = 7;
pub const RTC_CNTL_FIB_SEL_S: u32 = 0;
pub const RTC_CNTL_GPIO_WAKEUP_REG: u32 = 1610645776;
pub const RTC_CNTL_GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 31;
pub const RTC_CNTL_GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 30;
pub const RTC_CNTL_GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 29;
pub const RTC_CNTL_GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 28;
pub const RTC_CNTL_GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 27;
pub const RTC_CNTL_GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 26;
pub const RTC_CNTL_GPIO_PIN0_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN0_INT_TYPE_S: u32 = 23;
pub const RTC_CNTL_GPIO_PIN1_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN1_INT_TYPE_S: u32 = 20;
pub const RTC_CNTL_GPIO_PIN2_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN2_INT_TYPE_S: u32 = 17;
pub const RTC_CNTL_GPIO_PIN3_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN3_INT_TYPE_S: u32 = 14;
pub const RTC_CNTL_GPIO_PIN4_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN4_INT_TYPE_S: u32 = 11;
pub const RTC_CNTL_GPIO_PIN5_INT_TYPE: u32 = 7;
pub const RTC_CNTL_GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const RTC_CNTL_GPIO_PIN5_INT_TYPE_S: u32 = 8;
pub const RTC_CNTL_GPIO_PIN_CLK_GATE_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN_CLK_GATE_S: u32 = 7;
pub const RTC_CNTL_GPIO_WAKEUP_STATUS_CLR_V: u32 = 1;
pub const RTC_CNTL_GPIO_WAKEUP_STATUS_CLR_S: u32 = 6;
pub const RTC_CNTL_GPIO_WAKEUP_STATUS: u32 = 63;
pub const RTC_CNTL_GPIO_WAKEUP_STATUS_V: u32 = 63;
pub const RTC_CNTL_GPIO_WAKEUP_STATUS_S: u32 = 0;
pub const RTC_CNTL_DBG_SEL_REG: u32 = 1610645780;
pub const RTC_CNTL_DEBUG_SEL4: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL4_V: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL4_S: u32 = 27;
pub const RTC_CNTL_DEBUG_SEL3: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL3_V: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL3_S: u32 = 22;
pub const RTC_CNTL_DEBUG_SEL2: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL2_V: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL2_S: u32 = 17;
pub const RTC_CNTL_DEBUG_SEL1: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL1_V: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL1_S: u32 = 12;
pub const RTC_CNTL_DEBUG_SEL0: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL0_V: u32 = 31;
pub const RTC_CNTL_DEBUG_SEL0_S: u32 = 7;
pub const RTC_CNTL_DEBUG_BIT_SEL: u32 = 31;
pub const RTC_CNTL_DEBUG_BIT_SEL_V: u32 = 31;
pub const RTC_CNTL_DEBUG_BIT_SEL_S: u32 = 2;
pub const RTC_CNTL_DEBUG_12M_NO_GATING_V: u32 = 1;
pub const RTC_CNTL_DEBUG_12M_NO_GATING_S: u32 = 1;
pub const RTC_CNTL_DBG_MAP_REG: u32 = 1610645784;
pub const RTC_CNTL_GPIO_PIN0_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN0_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN0_FUN_SEL_S: u32 = 28;
pub const RTC_CNTL_GPIO_PIN1_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN1_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN1_FUN_SEL_S: u32 = 24;
pub const RTC_CNTL_GPIO_PIN2_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN2_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN2_FUN_SEL_S: u32 = 20;
pub const RTC_CNTL_GPIO_PIN3_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN3_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN3_FUN_SEL_S: u32 = 16;
pub const RTC_CNTL_GPIO_PIN4_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN4_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN4_FUN_SEL_S: u32 = 12;
pub const RTC_CNTL_GPIO_PIN5_FUN_SEL: u32 = 15;
pub const RTC_CNTL_GPIO_PIN5_FUN_SEL_V: u32 = 15;
pub const RTC_CNTL_GPIO_PIN5_FUN_SEL_S: u32 = 8;
pub const RTC_CNTL_GPIO_PIN0_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN0_MUX_SEL_S: u32 = 7;
pub const RTC_CNTL_GPIO_PIN1_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN1_MUX_SEL_S: u32 = 6;
pub const RTC_CNTL_GPIO_PIN2_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN2_MUX_SEL_S: u32 = 5;
pub const RTC_CNTL_GPIO_PIN3_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN3_MUX_SEL_S: u32 = 4;
pub const RTC_CNTL_GPIO_PIN4_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN4_MUX_SEL_S: u32 = 3;
pub const RTC_CNTL_GPIO_PIN5_MUX_SEL_V: u32 = 1;
pub const RTC_CNTL_GPIO_PIN5_MUX_SEL_S: u32 = 2;
pub const RTC_CNTL_SENSOR_CTRL_REG: u32 = 1610645788;
pub const RTC_CNTL_FORCE_XPD_SAR: u32 = 3;
pub const RTC_CNTL_FORCE_XPD_SAR_V: u32 = 3;
pub const RTC_CNTL_FORCE_XPD_SAR_S: u32 = 30;
pub const RTC_CNTL_SAR2_PWDET_CCT: u32 = 7;
pub const RTC_CNTL_SAR2_PWDET_CCT_V: u32 = 7;
pub const RTC_CNTL_SAR2_PWDET_CCT_S: u32 = 27;
pub const RTC_CNTL_DBG_SAR_SEL_REG: u32 = 1610645792;
pub const RTC_CNTL_SAR_DEBUG_SEL: u32 = 31;
pub const RTC_CNTL_SAR_DEBUG_SEL_V: u32 = 31;
pub const RTC_CNTL_SAR_DEBUG_SEL_S: u32 = 27;
pub const RTC_CNTL_PG_CTRL_REG: u32 = 1610645796;
pub const RTC_CNTL_POWER_GLITCH_EN_V: u32 = 1;
pub const RTC_CNTL_POWER_GLITCH_EN_S: u32 = 31;
pub const RTC_CNTL_POWER_GLITCH_EFUSE_SEL_V: u32 = 1;
pub const RTC_CNTL_POWER_GLITCH_EFUSE_SEL_S: u32 = 30;
pub const RTC_CNTL_POWER_GLITCH_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_POWER_GLITCH_FORCE_PU_S: u32 = 29;
pub const RTC_CNTL_POWER_GLITCH_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_POWER_GLITCH_FORCE_PD_S: u32 = 28;
pub const RTC_CNTL_POWER_GLITCH_DSENSE: u32 = 3;
pub const RTC_CNTL_POWER_GLITCH_DSENSE_V: u32 = 3;
pub const RTC_CNTL_POWER_GLITCH_DSENSE_S: u32 = 26;
pub const RTC_CNTL_DATE_REG: u32 = 1610646012;
pub const RTC_CNTL_CNTL_DATE: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_V: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_S: u32 = 0;
pub const TWAI_EXTD_ID_MASK: u32 = 536870911;
pub const TWAI_STD_ID_MASK: u32 = 2047;
pub const TWAI_FRAME_MAX_DLC: u32 = 8;
pub const TWAI_FRAME_EXTD_ID_LEN_BYTES: u32 = 4;
pub const TWAI_FRAME_STD_ID_LEN_BYTES: u32 = 2;
pub const TWAI_ERR_PASS_THRESH: u32 = 128;
pub const TWAI_MSG_FLAG_NONE: u32 = 0;
pub const TWAI_MSG_FLAG_EXTD: u32 = 1;
pub const TWAI_MSG_FLAG_RTR: u32 = 2;
pub const TWAI_MSG_FLAG_SS: u32 = 4;
pub const TWAI_MSG_FLAG_SELF: u32 = 8;
pub const TWAI_MSG_FLAG_DLC_NON_COMP: u32 = 16;
pub const TWAI_BRP_MAX: u32 = 16384;
pub const TWAI_BRP_MIN: u32 = 2;
pub const TWAI_ALERT_TX_IDLE: u32 = 1;
pub const TWAI_ALERT_TX_SUCCESS: u32 = 2;
pub const TWAI_ALERT_RX_DATA: u32 = 4;
pub const TWAI_ALERT_BELOW_ERR_WARN: u32 = 8;
pub const TWAI_ALERT_ERR_ACTIVE: u32 = 16;
pub const TWAI_ALERT_RECOVERY_IN_PROGRESS: u32 = 32;
pub const TWAI_ALERT_BUS_RECOVERED: u32 = 64;
pub const TWAI_ALERT_ARB_LOST: u32 = 128;
pub const TWAI_ALERT_ABOVE_ERR_WARN: u32 = 256;
pub const TWAI_ALERT_BUS_ERROR: u32 = 512;
pub const TWAI_ALERT_TX_FAILED: u32 = 1024;
pub const TWAI_ALERT_RX_QUEUE_FULL: u32 = 2048;
pub const TWAI_ALERT_ERR_PASS: u32 = 4096;
pub const TWAI_ALERT_BUS_OFF: u32 = 8192;
pub const TWAI_ALERT_RX_FIFO_OVERRUN: u32 = 16384;
pub const TWAI_ALERT_TX_RETRIED: u32 = 32768;
pub const TWAI_ALERT_PERIPH_RESET: u32 = 65536;
pub const TWAI_ALERT_ALL: u32 = 131071;
pub const TWAI_ALERT_NONE: u32 = 0;
pub const TWAI_ALERT_AND_LOG: u32 = 131072;
pub const SOC_CLK_RC_FAST_FREQ_APPROX: u32 = 17500000;
pub const SOC_CLK_RC_SLOW_FREQ_APPROX: u32 = 136000;
pub const SOC_CLK_RC_FAST_D256_FREQ_APPROX: u32 = 68359;
pub const SOC_CLK_XTAL32K_FREQ_APPROX: u32 = 32768;
pub const I2C_APB_CLK_FREQ: u32 = 80000000;
pub const I2C_NUM_MAX: u32 = 1;
pub const I2C_NUM_0: u32 = 0;
pub const I2C_SCLK_SRC_FLAG_FOR_NOMAL: u32 = 0;
pub const I2C_SCLK_SRC_FLAG_AWARE_DFS: u32 = 1;
pub const I2C_SCLK_SRC_FLAG_LIGHT_SLEEP: u32 = 2;
pub const I2C_INTERNAL_STRUCT_SIZE: u32 = 24;
pub const I2S_PIN_NO_CHANGE: i32 = -1;
pub const LEDC_ERR_DUTY: u32 = 4294967295;
pub const LEDC_ERR_VAL: i32 = -1;
pub const I2S_TDM_AUTO_SLOT_NUM: u32 = 0;
pub const I2S_TDM_AUTO_WS_WIDTH: u32 = 0;
pub const RMT_CHANNEL_FLAGS_AWARE_DFS: u32 = 1;
pub const RMT_CHANNEL_FLAGS_INVERT_SIG: u32 = 2;
pub const RMT_MEM_ITEM_NUM: u32 = 48;
pub const SPI_SLAVE_TXBIT_LSBFIRST: u32 = 1;
pub const SPI_SLAVE_RXBIT_LSBFIRST: u32 = 2;
pub const SPI_SLAVE_BIT_LSBFIRST: u32 = 3;
pub const UART_NUM_0: u32 = 0;
pub const UART_NUM_1: u32 = 1;
pub const UART_NUM_MAX: u32 = 2;
pub const UART_PIN_NO_CHANGE: i32 = -1;
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_BITRATE_MAX: u32 = 5000000;
pub const APP_ELF_SHA256_SZ: u32 = 17;
pub const PTHREAD_CANCEL_ENABLE: u32 = 0;
pub const PTHREAD_CANCEL_DISABLE: u32 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 768;
pub const LCD_CMD_NOP: u32 = 0;
pub const LCD_CMD_SWRESET: u32 = 1;
pub const LCD_CMD_RDDID: u32 = 4;
pub const LCD_CMD_RDDST: u32 = 9;
pub const LCD_CMD_RDDPM: u32 = 10;
pub const LCD_CMD_RDD_MADCTL: u32 = 11;
pub const LCD_CMD_RDD_COLMOD: u32 = 12;
pub const LCD_CMD_RDDIM: u32 = 13;
pub const LCD_CMD_RDDSM: u32 = 14;
pub const LCD_CMD_RDDSR: u32 = 15;
pub const LCD_CMD_SLPIN: u32 = 16;
pub const LCD_CMD_SLPOUT: u32 = 17;
pub const LCD_CMD_PTLON: u32 = 18;
pub const LCD_CMD_NORON: u32 = 19;
pub const LCD_CMD_INVOFF: u32 = 32;
pub const LCD_CMD_INVON: u32 = 33;
pub const LCD_CMD_GAMSET: u32 = 38;
pub const LCD_CMD_DISPOFF: u32 = 40;
pub const LCD_CMD_DISPON: u32 = 41;
pub const LCD_CMD_CASET: u32 = 42;
pub const LCD_CMD_RASET: u32 = 43;
pub const LCD_CMD_RAMWR: u32 = 44;
pub const LCD_CMD_RAMRD: u32 = 46;
pub const LCD_CMD_PTLAR: u32 = 48;
pub const LCD_CMD_VSCRDEF: u32 = 51;
pub const LCD_CMD_TEOFF: u32 = 52;
pub const LCD_CMD_TEON: u32 = 53;
pub const LCD_CMD_MADCTL: u32 = 54;
pub const LCD_CMD_MH_BIT: u32 = 4;
pub const LCD_CMD_BGR_BIT: u32 = 8;
pub const LCD_CMD_ML_BIT: u32 = 16;
pub const LCD_CMD_MV_BIT: u32 = 32;
pub const LCD_CMD_MX_BIT: u32 = 64;
pub const LCD_CMD_MY_BIT: u32 = 128;
pub const LCD_CMD_VSCSAD: u32 = 55;
pub const LCD_CMD_IDMOFF: u32 = 56;
pub const LCD_CMD_IDMON: u32 = 57;
pub const LCD_CMD_COLMOD: u32 = 58;
pub const LCD_CMD_RAMWRC: u32 = 60;
pub const LCD_CMD_RAMRDC: u32 = 62;
pub const LCD_CMD_STE: u32 = 68;
pub const LCD_CMD_GDCAN: u32 = 69;
pub const LCD_CMD_WRDISBV: u32 = 81;
pub const LCD_CMD_RDDISBV: u32 = 82;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::core::ffi::c_ulong;
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock {
    pub reserved: [::core::ffi::c_int; 23usize],
}
pub type _lock_t = _LOCK_T;
extern "C" {
    pub fn _lock_init(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(plock: *mut _lock_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(plock: *mut _lock_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _lock_release(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(plock: *mut _lock_t);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _data: *mut _reent,
}
impl Default for __sFILE_fake {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> _ssize_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> _ssize_t,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
    pub _rand_next: ::core::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
impl Default for _mprec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
impl Default for _misc_reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: *mut ::core::ffi::c_char,
    pub __sdidinit: ::core::ffi::c_int,
    pub _unspecified_locale_info: ::core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::core::ffi::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::core::ffi::c_char,
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[must_use]
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    #[must_use]
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::core::ffi::c_char, arg2: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    #[must_use]
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[must_use]
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[must_use]
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::core::ffi::c_char,
        resolved_path: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn l64a(__input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::core::ffi::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[must_use]
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
        arg4: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
extern "C" {
    #[must_use]
    pub fn aligned_alloc(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub fn _cleanup_r(r: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ulong = ::core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type daddr_t = ::core::ffi::c_long;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
extern "C" {
    pub fn sched_yield() -> ::core::ffi::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::core::ffi::c_int,
    pub contentionscope: ::core::ffi::c_int,
    pub inheritsched: ::core::ffi::c_int,
    pub schedpolicy: ::core::ffi::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::core::ffi::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub type_: ::core::ffi::c_int,
    pub recursive: ::core::ffi::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::core::ffi::c_int,
    pub init_executed: ::core::ffi::c_int,
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[must_use]
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::core::ffi::c_long,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::core::ffi::c_char,
        _new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
pub type esp_err_t = ::core::ffi::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes\n\n This function finds the error code in a pre-generated lookup-table and\n returns its string representation.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes\n\n This function finds the error code in a pre-generated lookup-table of\n esp_err_t errors and returns its string representation. If the error code\n is not found then it is attempted to be found among system errors.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @param[out] buf buffer where the error message should be written\n @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).\n @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut ::core::ffi::c_char,
        buflen: usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
        function: *const ::core::ffi::c_char,
        expression: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
        function: *const ::core::ffi::c_char,
        expression: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Return full IDF version string, same as 'git describe' output.\n\n @note If you are printing the ESP-IDF version in a log file or other information,\n this function provides more information than using the numerical version macros.\n For example, numerical version macros don't differentiate between development,\n pre-release and release versions, but the output of this function does.\n\n @return constant string from IDF_VER"]
    pub fn esp_get_idf_version() -> *const ::core::ffi::c_char;
}
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP32)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = ::core::ffi::c_uint;
#[doc = " Shutdown handler type"]
pub type shutdown_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief  Register shutdown handler\n\n This function allows you to register a handler that gets invoked before\n the application is restarted using esp_restart function.\n @param handle function to execute on restart\n @return\n   - ESP_OK on success\n   - ESP_ERR_INVALID_STATE if the handler has already been registered\n   - ESP_ERR_NO_MEM if no more shutdown handler slots are available"]
    pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Unregister shutdown handler\n\n This function allows you to unregister a handler which was previously\n registered using esp_register_shutdown_handler function.\n   - ESP_OK on success\n   - ESP_ERR_INVALID_STATE if the given handler hasn't been registered before"]
    pub fn esp_unregister_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restart PRO and APP CPUs.\n\n This function can be called both from PRO and APP CPUs.\n After successful restart, CPU reset reason will be SW_CPU_RESET.\n Peripherals (except for Wi-Fi, BT, UART0, SPI1, and legacy timers) are not reset.\n This function does not return."]
    pub fn esp_restart() -> !;
}
extern "C" {
    #[doc = " @brief  Get reason of last reset\n @return See description of esp_reset_reason_t for explanation of each value."]
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
    #[doc = " @brief  Get the size of available heap.\n\n @note Note that the returned value may be larger than the maximum contiguous block\n which can be allocated.\n\n @return Available heap size, in bytes."]
    pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief  Get the size of available internal heap.\n\n @note Note that the returned value may be larger than the maximum contiguous block\n which can be allocated.\n\n @return Available internal heap size, in bytes."]
    pub fn esp_get_free_internal_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief Get the minimum heap that has ever been available\n\n @return Minimum free heap ever available"]
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief Trigger a software abort\n\n @param details Details that will be displayed during panic handling."]
    pub fn esp_system_abort(details: *const ::core::ffi::c_char) -> !;
}
extern "C" {
    #[doc = " @brief CRC32 value in little endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC32 value"]
    pub fn esp_rom_crc32_le(crc: u32, buf: *const u8, len: u32) -> u32;
}
extern "C" {
    #[doc = " @brief CRC32 value in big endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC32 value"]
    pub fn esp_rom_crc32_be(crc: u32, buf: *const u8, len: u32) -> u32;
}
extern "C" {
    #[doc = " @brief CRC16 value in little endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC16 value"]
    pub fn esp_rom_crc16_le(crc: u16, buf: *const u8, len: u32) -> u16;
}
extern "C" {
    #[doc = " @brief CRC16 value in big endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC16 value"]
    pub fn esp_rom_crc16_be(crc: u16, buf: *const u8, len: u32) -> u16;
}
extern "C" {
    #[doc = " @brief CRC8 value in little endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC8 value"]
    pub fn esp_rom_crc8_le(crc: u8, buf: *const u8, len: u32) -> u8;
}
extern "C" {
    #[doc = " @brief CRC8 value in big endian.\n\n @param crc: Initial CRC value (result of last calculation or 0 for the first time)\n @param buf: Data buffer that used to calculate the CRC value\n @param len: Length of the data buffer\n @return CRC8 value"]
    pub fn esp_rom_crc8_be(crc: u8, buf: *const u8, len: u32) -> u8;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
pub const soc_reset_reason_t_RESET_REASON_CHIP_POWER_ON: soc_reset_reason_t = 1;
pub const soc_reset_reason_t_RESET_REASON_CHIP_BROWN_OUT: soc_reset_reason_t = 1;
pub const soc_reset_reason_t_RESET_REASON_CHIP_SUPER_WDT: soc_reset_reason_t = 1;
pub const soc_reset_reason_t_RESET_REASON_CORE_SW: soc_reset_reason_t = 3;
pub const soc_reset_reason_t_RESET_REASON_CORE_DEEP_SLEEP: soc_reset_reason_t = 5;
pub const soc_reset_reason_t_RESET_REASON_CORE_MWDT0: soc_reset_reason_t = 7;
pub const soc_reset_reason_t_RESET_REASON_CORE_MWDT1: soc_reset_reason_t = 8;
pub const soc_reset_reason_t_RESET_REASON_CORE_RTC_WDT: soc_reset_reason_t = 9;
pub const soc_reset_reason_t_RESET_REASON_CPU0_MWDT0: soc_reset_reason_t = 11;
pub const soc_reset_reason_t_RESET_REASON_CPU0_SW: soc_reset_reason_t = 12;
pub const soc_reset_reason_t_RESET_REASON_CPU0_RTC_WDT: soc_reset_reason_t = 13;
pub const soc_reset_reason_t_RESET_REASON_SYS_BROWN_OUT: soc_reset_reason_t = 15;
pub const soc_reset_reason_t_RESET_REASON_SYS_RTC_WDT: soc_reset_reason_t = 16;
pub const soc_reset_reason_t_RESET_REASON_CPU0_MWDT1: soc_reset_reason_t = 17;
pub const soc_reset_reason_t_RESET_REASON_SYS_SUPER_WDT: soc_reset_reason_t = 18;
pub const soc_reset_reason_t_RESET_REASON_SYS_CLK_GLITCH: soc_reset_reason_t = 19;
pub const soc_reset_reason_t_RESET_REASON_CORE_EFUSE_CRC: soc_reset_reason_t = 20;
pub const soc_reset_reason_t_RESET_REASON_CORE_USB_UART: soc_reset_reason_t = 21;
pub const soc_reset_reason_t_RESET_REASON_CORE_USB_JTAG: soc_reset_reason_t = 22;
pub const soc_reset_reason_t_RESET_REASON_CORE_PWR_GLITCH: soc_reset_reason_t = 23;
#[doc = " @brief Naming conventions: RESET_REASON_{reset level}_{reset reason}\n @note refer to TRM: <Reset and Clock> chapter"]
pub type soc_reset_reason_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Print formated string to console device\n @note float and long long data are not supported!\n\n @param fmt Format string\n @param ... Additional arguments, depending on the format string\n @return int: Total number of characters written on success; A negative number on failure."]
    pub fn esp_rom_printf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Pauses execution for us microseconds\n\n @param us Number of microseconds to pause"]
    pub fn esp_rom_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief esp_rom_printf can print message to different channels simultaneously.\n        This function can help install the low level putc function for esp_rom_printf.\n\n @param channel Channel number (startting from 1)\n @param putc Function pointer to the putc implementation. Set NULL can disconnect esp_rom_printf with putc."]
    pub fn esp_rom_install_channel_putc(
        channel: ::core::ffi::c_int,
        putc: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief Install UART1 as the default console channel, equivalent to `esp_rom_install_channel_putc(1, esp_rom_uart_putc)`"]
    pub fn esp_rom_install_uart_printf();
}
extern "C" {
    #[doc = " @brief Get reset reason of CPU\n\n @param cpu_no CPU number\n @return Reset reason code (see in soc/reset_reasons.h)"]
    pub fn esp_rom_get_reset_reason(cpu_no: ::core::ffi::c_int) -> soc_reset_reason_t;
}
extern "C" {
    #[doc = " @brief Route peripheral interrupt sources to CPU's interrupt port by matrix\n\n Usually there're 4 steps to use an interrupt:\n 1. Route peripheral interrupt source to CPU. e.g.  esp_rom_route_intr_matrix(0, ETS_WIFI_MAC_INTR_SOURCE, ETS_WMAC_INUM)\n 2. Set interrupt handler for CPU\n 3. Enable CPU interupt\n 4. Enable peripheral interrupt\n\n @param cpu_core The CPU number, which the peripheral interupt will inform to\n @param periph_intr_id The peripheral interrupt source number\n @param cpu_intr_num The CPU interrupt number"]
    pub fn esp_rom_route_intr_matrix(
        cpu_core: ::core::ffi::c_int,
        periph_intr_id: u32,
        cpu_intr_num: u32,
    );
}
extern "C" {
    #[doc = " @brief Get the real CPU ticks per us\n\n @return CPU ticks per us"]
    pub fn esp_rom_get_cpu_ticks_per_us() -> u32;
}
#[doc = "< No log output"]
pub const esp_log_level_t_ESP_LOG_NONE: esp_log_level_t = 0;
#[doc = "< Critical errors, software module can not recover on its own"]
pub const esp_log_level_t_ESP_LOG_ERROR: esp_log_level_t = 1;
#[doc = "< Error conditions from which recovery measures have been taken"]
pub const esp_log_level_t_ESP_LOG_WARN: esp_log_level_t = 2;
#[doc = "< Information messages which describe normal flow of events"]
pub const esp_log_level_t_ESP_LOG_INFO: esp_log_level_t = 3;
#[doc = "< Extra information which is not necessary for normal use (values, pointers, sizes, etc)."]
pub const esp_log_level_t_ESP_LOG_DEBUG: esp_log_level_t = 4;
#[doc = "< Bigger chunks of debugging information, or frequent messages which can potentially flood the output."]
pub const esp_log_level_t_ESP_LOG_VERBOSE: esp_log_level_t = 5;
#[doc = " @brief Log level\n"]
pub type esp_log_level_t = ::core::ffi::c_uint;
pub type vprintf_like_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, arg2: va_list) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " @brief Default log level\n\n This is used by the definition of ESP_EARLY_LOGx macros. It is not\n recommended to set this directly, call esp_log_level_set(\"*\", level)\n instead."]
    pub static mut esp_log_default_level: esp_log_level_t;
}
extern "C" {
    #[doc = " @brief Set log level for given tag\n\n If logging for given component has already been enabled, changes previous setting.\n\n @note Note that this function can not raise log level above the level set using\n CONFIG_LOG_MAXIMUM_LEVEL setting in menuconfig.\n To raise log level above the default one for a given file, define\n LOG_LOCAL_LEVEL to one of the ESP_LOG_* values, before including\n esp_log.h in this file.\n\n @param tag Tag of the log entries to enable. Must be a non-NULL zero terminated string.\n            Value \"*\" resets log level for all tags to the given value.\n\n @param level  Selects log level to enable. Only logs at this and lower verbosity\n levels will be shown."]
    pub fn esp_log_level_set(tag: *const ::core::ffi::c_char, level: esp_log_level_t);
}
extern "C" {
    #[doc = " @brief Get log level for a given tag, can be used to avoid expensive log statements\n\n @param tag Tag of the log to query current level. Must be a non-NULL zero terminated\n            string.\n\n @return The current log level for the given tag"]
    pub fn esp_log_level_get(tag: *const ::core::ffi::c_char) -> esp_log_level_t;
}
extern "C" {
    #[doc = " @brief Set function used to output log entries\n\n By default, log output goes to UART0. This function can be used to redirect log\n output to some other destination, such as file or network. Returns the original\n log handler, which may be necessary to return output to the previous destination.\n\n @note Please note that function callback here must be re-entrant as it can be\n invoked in parallel from multiple thread context.\n\n @param func new Function used for output. Must have same signature as vprintf.\n\n @return func old Function used for output."]
    pub fn esp_log_set_vprintf(func: vprintf_like_t) -> vprintf_like_t;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output\n\n This function is used in expansion of ESP_LOGx macros.\n In the 2nd stage bootloader, and at early application startup stage\n this function uses CPU cycle counter as time source. Later when\n FreeRTOS scheduler start running, it switches to FreeRTOS tick count.\n\n For now, we ignore millisecond counter overflow.\n\n @return timestamp, in milliseconds"]
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Function which returns system timestamp to be used in log output\n\n This function is used in expansion of ESP_LOGx macros to print\n the system time as \"HH:MM:SS.sss\". The system time is initialized to\n 0 on startup, this can be set to the correct time with an SNTP sync,\n or manually with standard POSIX time functions.\n\n Currently, this will not get used in logging from binary blobs\n (i.e. Wi-Fi & Bluetooth libraries), these will still print the RTOS tick time.\n\n @return timestamp, in \"HH:MM:SS.sss\""]
    pub fn esp_log_system_timestamp() -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output\n\n This function uses HW cycle counter and does not depend on OS,\n so it can be safely used after application crash.\n\n @return timestamp, in milliseconds"]
    pub fn esp_log_early_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Write message into the log\n\n This function is not intended to be used directly. Instead, use one of\n ESP_LOGE, ESP_LOGW, ESP_LOGI, ESP_LOGD, ESP_LOGV macros.\n\n This function or these macros should not be used from an interrupt."]
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn esp_log_buffer_hex_internal(
        tag: *const ::core::ffi::c_char,
        buffer: *const ::core::ffi::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_char_internal(
        tag: *const ::core::ffi::c_char,
        buffer: *const ::core::ffi::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_hexdump_internal(
        tag: *const ::core::ffi::c_char,
        buffer: *const ::core::ffi::c_void,
        buff_len: u16,
        log_level: esp_log_level_t,
    );
}
pub const intr_type_INTR_TYPE_LEVEL: intr_type = 0;
pub const intr_type_INTR_TYPE_EDGE: intr_type = 1;
pub type intr_type = ::core::ffi::c_uint;
#[doc = " Callback type of the interrupt handler"]
pub type intr_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " Set the interrupt handler function for the given CPU interrupt\n @param rv_int_num  CPU interrupt number\n @param fn  Handler function\n @param arg  Handler argument"]
    pub fn intr_handler_set(
        rv_int_num: ::core::ffi::c_int,
        fn_: intr_handler_t,
        arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get the interrupt handler function for the given CPU interrupt\n\n@return interrupt handler registered for a particular interrupt number, or NULL otherwise"]
    pub fn intr_handler_get(rv_int_num: ::core::ffi::c_int) -> intr_handler_t;
}
extern "C" {
    #[doc = " Get the interrupt handler argument associated with the given CPU interrupt\n\n@return interrupt handler argument for a particular interrupt number, or NULL otherwise"]
    pub fn intr_handler_get_arg(rv_int_num: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " this function will be removed in later, please use `intr_matrix_set` instead\n Route the peripheral interrupt signal to the CPU\n @param periph_intr_source  Peripheral interrupt number, one of ETS_XXX_SOURCE\n @param rv_int_num  CPU interrupt number"]
    pub fn intr_matrix_route(
        periph_intr_source: ::core::ffi::c_int,
        rv_int_num: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Enable interrupts from interrupt controller.\n\n @param uint32_t unmask, unmask bits for interrupts, each bit for an interrupt\n\n return none"]
    pub fn esprv_intc_int_enable(unmask: u32);
}
extern "C" {
    #[doc = " @brief Disable interrupts from interrupt controller.\n\n @param uint32_t mask, mask bits for interrupts, each bit for an interrupt\n\n return none"]
    pub fn esprv_intc_int_disable(mask: u32);
}
extern "C" {
    #[doc = " @brief Set interrupt type\n\n Set the type of a particular interrupt (level or edge).\n - Level interrupts are cleared automatically once their interrupt source has\n   been cleared\n - Edge interrupts must be cleared by software when they are handled.\n\n @param intr_num Interrupt number\n @param type Interrupt type"]
    pub fn esprv_intc_int_set_type(intr_num: ::core::ffi::c_int, type_: intr_type);
}
extern "C" {
    #[doc = " @brief Get the current type of an interrupt\n\n Get the current type of a particular interrupt (level or edge). An interrupt's\n type can be set by calling esprv_intc_int_set_type().\n\n @param intr_num Interrupt number\n @return Interrupt type"]
    pub fn esprv_intc_int_get_type(intr_num: ::core::ffi::c_int) -> intr_type;
}
extern "C" {
    #[doc = " Set interrupt priority in the interrupt controller\n @param rv_int_num CPU interrupt number\n @param priority Interrupt priority level, 1 to 7"]
    pub fn esprv_intc_int_set_priority(
        rv_int_num: ::core::ffi::c_int,
        priority: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get the current priority of an interrupt\n\n Get the current priority of an interrupt.\n\n @param rv_int_num CPU interrupt number\n @return Interrupt priority level, 1 to 7"]
    pub fn esprv_intc_int_get_priority(rv_int_num: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Set interrupt priority threshold.\n Interrupts with priority levels lower than the threshold are masked.\n\n @param priority_threshold  Interrupt priority threshold, 0 to 7"]
    pub fn esprv_intc_int_set_threshold(priority_threshold: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Get interrupt unmask\n @param none\n @return uint32_t interrupt unmask"]
    pub fn esprv_intc_get_interrupt_unmask() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
#[doc = " Handle to an interrupt handler"]
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt\n\n This will mark a certain interrupt on the specified CPU as\n an interrupt that can be used to hook shared interrupt handlers\n to.\n\n @param intno The number of the interrupt (0-31)\n @param cpu CPU on which the interrupt should be marked as shared (0 or 1)\n @param is_in_iram Shared interrupt is for handlers that reside in IRAM and\n                   the int can be left enabled while the flash cache is disabled.\n\n @return ESP_ERR_INVALID_ARG if cpu or intno is invalid\n         ESP_OK otherwise"]
    pub fn esp_intr_mark_shared(
        intno: ::core::ffi::c_int,
        cpu: ::core::ffi::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework\n\n This will mark a certain interrupt on the specified CPU as\n reserved, not to be allocated for any reason.\n\n @param intno The number of the interrupt (0-31)\n @param cpu CPU on which the interrupt should be marked as shared (0 or 1)\n\n @return ESP_ERR_INVALID_ARG if cpu or intno is invalid\n         ESP_OK otherwise"]
    pub fn esp_intr_reserve(intno: ::core::ffi::c_int, cpu: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters.\n\n This finds an interrupt that matches the restrictions as given in the flags\n parameter, maps the given interrupt source to it and hooks up the given\n interrupt handler (with optional argument) as well. If needed, it can return\n a handle for the interrupt as well.\n\n The interrupt will always be allocated on the core that runs this function.\n\n If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or\n RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned.\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared\n               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return\n               from this function with the interrupt disabled.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags\n         ESP_OK otherwise"]
    pub fn esp_intr_alloc(
        source: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        handler: intr_handler_t,
        arg: *mut ::core::ffi::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters.\n\n\n This essentially does the same as esp_intr_alloc, but allows specifying a register and mask\n combo. For shared interrupts, the handler is only called if a read from the specified\n register, ANDed with the mask, returns non-zero. By passing an interrupt status register\n address and a fitting mask, this can be used to accelerate interrupt handling in the case\n a shared interrupt is triggered; by checking the interrupt statuses first, the code can\n decide which ISRs can be skipped\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared\n               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return\n               from this function with the interrupt disabled.\n @param intrstatusreg The address of an interrupt status register\n @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits\n               that are 1 in the mask set, the ISR will be called. If not, it will be\n               skipped.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags\n         ESP_OK otherwise"]
    pub fn esp_intr_alloc_intrstatus(
        source: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut ::core::ffi::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable and free an interrupt.\n\n Use an interrupt handle to disable the interrupt and release the resources associated with it.\n If the current core is not the core that registered this interrupt, this routine will be assigned to\n the core that allocated this interrupt, blocking and waiting until the resource is successfully released.\n\n @note\n When the handler shares its source with other handlers, the interrupt status\n bits it's responsible for should be managed properly before freeing it. see\n ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG the handle is NULL\n         ESP_FAIL failed to release this handle\n         ESP_OK otherwise"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle\n\n @note\n 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the\n CPU the interrupt is allocated on. Other interrupts have no such restriction.\n 2. When several handlers sharing a same interrupt source, interrupt status bits, which are\n handled in the handler to be disabled, should be masked before the disabling, or handled\n in other enabled interrupts properly. Miss of interrupt status handling will cause infinite\n interrupt calls and finally system crash.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK otherwise"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle\n\n @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the\n       CPU the interrupt is allocated on. Other interrupts have no such restriction.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK otherwise"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler.\n\n @note Does not work on shared interrupts.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n @param is_in_iram Whether the handler associated with this handle resides in IRAM.\n                   Handlers residing in IRAM can be called when cache is disabled.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK otherwise"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
extern "C" {
    #[doc = " @brief enable the interrupt source based on its number\n @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_enable_source(inum: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief disable the interrupt source based on its number\n @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_disable_source(inum: ::core::ffi::c_int);
}
#[doc = " @brief CPU cycle count type\n\n This data type represents the CPU's clock cycle count"]
pub type esp_cpu_cycle_count_t = u32;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_LEVEL: esp_cpu_intr_type_t = 0;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_EDGE: esp_cpu_intr_type_t = 1;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_NA: esp_cpu_intr_type_t = 2;
#[doc = " @brief CPU interrupt type"]
pub type esp_cpu_intr_type_t = ::core::ffi::c_uint;
#[doc = " @brief CPU interrupt descriptor\n\n Each particular CPU interrupt has an associated descriptor describing that\n particular interrupt's characteristics. Call esp_cpu_intr_get_desc() to get\n the descriptors of a particular interrupt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_cpu_intr_desc_t {
    #[doc = "< Priority of the interrupt if it has a fixed priority, (-1) if the priority is configurable."]
    pub priority: ::core::ffi::c_int,
    #[doc = "< Whether the interrupt is an edge or level type interrupt, ESP_CPU_INTR_TYPE_NA if the type is configurable."]
    pub type_: esp_cpu_intr_type_t,
    #[doc = "< Flags indicating extra details."]
    pub flags: u32,
}
impl Default for esp_cpu_intr_desc_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief CPU interrupt handler type"]
pub type esp_cpu_intr_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_LOAD: esp_cpu_watchpoint_trigger_t = 0;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_STORE: esp_cpu_watchpoint_trigger_t = 1;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_ACCESS: esp_cpu_watchpoint_trigger_t = 2;
#[doc = " @brief CPU watchpoint trigger type"]
pub type esp_cpu_watchpoint_trigger_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Stall a CPU core\n\n @param core_id  The core's ID"]
    pub fn esp_cpu_stall(core_id: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Resume a previously stalled CPU core\n\n @param core_id The core's ID"]
    pub fn esp_cpu_unstall(core_id: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Reset a CPU core\n\n @param core_id The core's ID"]
    pub fn esp_cpu_reset(core_id: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Wait for Interrupt\n\n This function causes the current CPU core to execute its Wait For Interrupt\n (WFI or equivalent) instruction. After executing this function, the CPU core\n will stop execution until an interrupt occurs."]
    pub fn esp_cpu_wait_for_intr();
}
extern "C" {
    #[doc = " @brief Get a CPU interrupt's descriptor\n\n Each CPU interrupt has a descriptor describing the interrupt's capabilities\n and restrictions. This function gets the descriptor of a particular interrupt\n on a particular CPU.\n\n @param[in] core_id The core's ID\n @param[in] intr_num Interrupt number\n @param[out] intr_desc_ret The interrupt's descriptor"]
    pub fn esp_cpu_intr_get_desc(
        core_id: ::core::ffi::c_int,
        intr_num: ::core::ffi::c_int,
        intr_desc_ret: *mut esp_cpu_intr_desc_t,
    );
}
extern "C" {
    #[doc = " @brief Configure the CPU to disable access to invalid memory regions"]
    pub fn esp_cpu_configure_region_protection();
}
extern "C" {
    #[doc = " @brief Set and enable a hardware breakpoint on the current CPU\n\n @note This function is meant to be called by the panic handler to set a\n breakpoint for an attached debugger during a panic.\n @note Overwrites previously set breakpoint with same breakpoint number.\n @param bp_num Hardware breakpoint number [0..SOC_CPU_BREAKPOINTS_NUM - 1]\n @param bp_addr Address to set a breakpoint on\n @return ESP_OK if breakpoint is set. Failure otherwise"]
    pub fn esp_cpu_set_breakpoint(
        bp_num: ::core::ffi::c_int,
        bp_addr: *const ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear a hardware breakpoint on the current CPU\n\n @note Clears a breakpoint regardless of whether it was previously set\n @param bp_num Hardware breakpoint number [0..SOC_CPU_BREAKPOINTS_NUM - 1]\n @return ESP_OK if breakpoint is cleared. Failure otherwise"]
    pub fn esp_cpu_clear_breakpoint(bp_num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set and enable a hardware watchpoint on the current CPU\n\n Set and enable a hardware watchpoint on the current CPU, specifying the\n memory range and trigger operation. Watchpoints will break/panic the CPU when\n the CPU accesses (according to the trigger type) on a certain memory range.\n\n @note Overwrites previously set watchpoint with same watchpoint number.\n @param wp_num Hardware watchpoint number [0..SOC_CPU_WATCHPOINTS_NUM - 1]\n @param wp_addr Watchpoint's base address\n @param size Size of the region to watch. Must be one of 2^n, with n in [0..6].\n @param trigger Trigger type\n @return ESP_ERR_INVALID_ARG on invalid arg, ESP_OK otherwise"]
    pub fn esp_cpu_set_watchpoint(
        wp_num: ::core::ffi::c_int,
        wp_addr: *const ::core::ffi::c_void,
        size: usize,
        trigger: esp_cpu_watchpoint_trigger_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear a hardware watchpoint on the current CPU\n\n @note Clears a watchpoint regardless of whether it was previously set\n @param wp_num Hardware watchpoint number [0..SOC_CPU_WATCHPOINTS_NUM - 1]\n @return ESP_OK if watchpoint was cleared. Failure otherwise."]
    pub fn esp_cpu_clear_watchpoint(wp_num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Atomic compare-and-set operation\n\n @param addr Address of atomic variable\n @param compare_value Value to compare the atomic variable to\n @param new_value New value to set the atomic variable to\n @return Whether the atomic variable was set or not"]
    pub fn esp_cpu_compare_and_set(addr: *mut u32, compare_value: u32, new_value: u32) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_backtrace_frame_t {
    pub pc: u32,
    pub sp: u32,
    pub next_pc: u32,
    pub exc_frame: *const ::core::ffi::c_void,
}
impl Default for esp_backtrace_frame_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief If an OCD is connected over JTAG. set breakpoint 0 to the given function\n        address. Do nothing otherwise.\n @param fn  Pointer to the target breakpoint position"]
    pub fn esp_set_breakpoint_if_jtag(fn_: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " Get the first frame of the current stack's backtrace\n\n Given the following function call flow (B -> A -> X -> esp_backtrace_get_start),\n this function will do the following.\n - Flush CPU registers and window frames onto the current stack\n - Return PC and SP of function A (i.e. start of the stack's backtrace)\n - Return PC of function B (i.e. next_pc)\n\n @note This function is implemented in assembly\n\n @param[out] pc       PC of the first frame in the backtrace\n @param[out] sp       SP of the first frame in the backtrace\n @param[out] next_pc  PC of the first frame's caller"]
    pub fn esp_backtrace_get_start(pc: *mut u32, sp: *mut u32, next_pc: *mut u32);
}
extern "C" {
    #[doc = " Get the next frame on a stack for backtracing\n\n Given a stack frame(i), this function will obtain the next stack frame(i-1)\n on the same call stack (i.e. the caller of frame(i)). This function is meant to be\n called iteratively when doing a backtrace.\n\n Entry Conditions: Frame structure containing valid SP and next_pc\n Exit Conditions:\n  - Frame structure updated with SP and PC of frame(i-1). next_pc now points to frame(i-2).\n  - If a next_pc of 0 is returned, it indicates that frame(i-1) is last frame on the stack\n\n @param[inout] frame  Pointer to frame structure\n\n @return\n  - True if the SP and PC of the next frame(i-1) are sane\n  - False otherwise"]
    pub fn esp_backtrace_get_next_frame(frame: *mut esp_backtrace_frame_t) -> bool;
}
extern "C" {
    #[doc = " @brief Print the backtrace from specified frame.\n\n @param depth The maximum number of stack frames to print (should be > 0)\n @param frame Starting frame to print from\n @param panic Indicator if backtrace print is during a system panic\n\n @note On the ESP32, users must call esp_backtrace_get_start() first to flush the stack.\n @note If a esp_backtrace_frame_t* frame is obtained though a call to esp_backtrace_get_start()\n from some example function func_a(), then frame is only valid within the frame/scope of func_a().\n Users should not attempt to pass/use frame other frames within the same stack of different stacks.\n\n @return\n      - ESP_OK    Backtrace successfully printed to completion or to depth limit\n      - ESP_FAIL  Backtrace is corrupted"]
    pub fn esp_backtrace_print_from_frame(
        depth: ::core::ffi::c_int,
        frame: *const esp_backtrace_frame_t,
        panic: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Print the backtrace of the current stack\n\n @param depth The maximum number of stack frames to print (should be > 0)\n\n @return\n      - ESP_OK    Backtrace successfully printed to completion or to depth limit\n      - ESP_FAIL  Backtrace is corrupted"]
    pub fn esp_backtrace_print(depth: ::core::ffi::c_int) -> esp_err_t;
}
#[doc = "< Touch pad channel 0 is GPIO4(ESP32)"]
pub const touch_pad_t_TOUCH_PAD_NUM0: touch_pad_t = 0;
#[doc = "< Touch pad channel 1 is GPIO0(ESP32) / GPIO1(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM1: touch_pad_t = 1;
#[doc = "< Touch pad channel 2 is GPIO2(ESP32) / GPIO2(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM2: touch_pad_t = 2;
#[doc = "< Touch pad channel 3 is GPIO15(ESP32) / GPIO3(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM3: touch_pad_t = 3;
#[doc = "< Touch pad channel 4 is GPIO13(ESP32) / GPIO4(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM4: touch_pad_t = 4;
#[doc = "< Touch pad channel 5 is GPIO12(ESP32) / GPIO5(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM5: touch_pad_t = 5;
#[doc = "< Touch pad channel 6 is GPIO14(ESP32) / GPIO6(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM6: touch_pad_t = 6;
#[doc = "< Touch pad channel 7 is GPIO27(ESP32) / GPIO7(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM7: touch_pad_t = 7;
#[doc = "< Touch pad channel 8 is GPIO33(ESP32) / GPIO8(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM8: touch_pad_t = 8;
#[doc = "< Touch pad channel 9 is GPIO32(ESP32) / GPIO9(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM9: touch_pad_t = 9;
pub const touch_pad_t_TOUCH_PAD_MAX: touch_pad_t = 10;
#[doc = " Touch pad channel"]
pub type touch_pad_t = ::core::ffi::c_uint;
#[doc = "<Touch sensor high reference voltage, no change"]
pub const touch_high_volt_t_TOUCH_HVOLT_KEEP: touch_high_volt_t = -1;
#[doc = "<Touch sensor high reference voltage, 2.4V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V4: touch_high_volt_t = 0;
#[doc = "<Touch sensor high reference voltage, 2.5V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V5: touch_high_volt_t = 1;
#[doc = "<Touch sensor high reference voltage, 2.6V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V6: touch_high_volt_t = 2;
#[doc = "<Touch sensor high reference voltage, 2.7V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V7: touch_high_volt_t = 3;
pub const touch_high_volt_t_TOUCH_HVOLT_MAX: touch_high_volt_t = 4;
#[doc = " Touch sensor high reference voltage"]
pub type touch_high_volt_t = ::core::ffi::c_int;
#[doc = "<Touch sensor low reference voltage, no change"]
pub const touch_low_volt_t_TOUCH_LVOLT_KEEP: touch_low_volt_t = -1;
#[doc = "<Touch sensor low reference voltage, 0.5V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V5: touch_low_volt_t = 0;
#[doc = "<Touch sensor low reference voltage, 0.6V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V6: touch_low_volt_t = 1;
#[doc = "<Touch sensor low reference voltage, 0.7V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V7: touch_low_volt_t = 2;
#[doc = "<Touch sensor low reference voltage, 0.8V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V8: touch_low_volt_t = 3;
pub const touch_low_volt_t_TOUCH_LVOLT_MAX: touch_low_volt_t = 4;
#[doc = " Touch sensor low reference voltage"]
pub type touch_low_volt_t = ::core::ffi::c_int;
#[doc = "<Touch sensor high reference voltage attenuation, no change"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_KEEP: touch_volt_atten_t = -1;
#[doc = "<Touch sensor high reference voltage attenuation, 1.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V5: touch_volt_atten_t = 0;
#[doc = "<Touch sensor high reference voltage attenuation, 1.0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V: touch_volt_atten_t = 1;
#[doc = "<Touch sensor high reference voltage attenuation, 0.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V5: touch_volt_atten_t = 2;
#[doc = "<Touch sensor high reference voltage attenuation,   0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V: touch_volt_atten_t = 3;
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_MAX: touch_volt_atten_t = 4;
#[doc = " Touch sensor high reference voltage attenuation"]
pub type touch_volt_atten_t = ::core::ffi::c_int;
#[doc = "<Touch sensor charge / discharge speed, always zero"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_0: touch_cnt_slope_t = 0;
#[doc = "<Touch sensor charge / discharge speed, slowest"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_1: touch_cnt_slope_t = 1;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_2: touch_cnt_slope_t = 2;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_3: touch_cnt_slope_t = 3;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_4: touch_cnt_slope_t = 4;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_5: touch_cnt_slope_t = 5;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_6: touch_cnt_slope_t = 6;
#[doc = "<Touch sensor charge / discharge speed, fast"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_7: touch_cnt_slope_t = 7;
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_MAX: touch_cnt_slope_t = 8;
#[doc = " Touch sensor charge/discharge speed"]
pub type touch_cnt_slope_t = ::core::ffi::c_uint;
#[doc = "<Initial level of charging voltage, low level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_LOW: touch_tie_opt_t = 0;
#[doc = "<Initial level of charging voltage, high level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_HIGH: touch_tie_opt_t = 1;
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_MAX: touch_tie_opt_t = 2;
#[doc = " Touch sensor initial charge level"]
pub type touch_tie_opt_t = ::core::ffi::c_uint;
#[doc = "<To start touch FSM by timer"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_TIMER: touch_fsm_mode_t = 0;
#[doc = "<To start touch FSM by software trigger"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_SW: touch_fsm_mode_t = 1;
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_MAX: touch_fsm_mode_t = 2;
#[doc = " Touch sensor FSM mode"]
pub type touch_fsm_mode_t = ::core::ffi::c_uint;
#[doc = "<Touch interrupt will happen if counter value is less than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_BELOW: touch_trigger_mode_t = 0;
#[doc = "<Touch interrupt will happen if counter value is larger than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_ABOVE: touch_trigger_mode_t = 1;
pub const touch_trigger_mode_t_TOUCH_TRIGGER_MAX: touch_trigger_mode_t = 2;
#[doc = " ESP32 Only"]
pub type touch_trigger_mode_t = ::core::ffi::c_uint;
#[doc = "< wakeup interrupt is generated if both SET1 and SET2 are \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_BOTH: touch_trigger_src_t = 0;
#[doc = "< wakeup interrupt is generated if SET1 is \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_SET1: touch_trigger_src_t = 1;
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_MAX: touch_trigger_src_t = 2;
pub type touch_trigger_src_t = ::core::ffi::c_uint;
#[doc = "<Measurement done for one of the enabled channels."]
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_DONE: touch_pad_intr_mask_t = 1;
#[doc = "<Active for one of the enabled channels."]
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_ACTIVE: touch_pad_intr_mask_t = 2;
#[doc = "<Inactive for one of the enabled channels."]
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_INACTIVE: touch_pad_intr_mask_t = 4;
#[doc = "<Measurement done for all the enabled channels."]
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_SCAN_DONE: touch_pad_intr_mask_t = 8;
#[doc = "<Timeout for one of the enabled channels."]
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_TIMEOUT: touch_pad_intr_mask_t = 16;
pub const touch_pad_intr_mask_t_TOUCH_PAD_INTR_MASK_MAX: touch_pad_intr_mask_t = 17;
pub type touch_pad_intr_mask_t = ::core::ffi::c_uint;
#[doc = "<Denoise range is 12bit"]
pub const touch_pad_denoise_grade_t_TOUCH_PAD_DENOISE_BIT12: touch_pad_denoise_grade_t = 0;
#[doc = "<Denoise range is 10bit"]
pub const touch_pad_denoise_grade_t_TOUCH_PAD_DENOISE_BIT10: touch_pad_denoise_grade_t = 1;
#[doc = "<Denoise range is 8bit"]
pub const touch_pad_denoise_grade_t_TOUCH_PAD_DENOISE_BIT8: touch_pad_denoise_grade_t = 2;
#[doc = "<Denoise range is 4bit"]
pub const touch_pad_denoise_grade_t_TOUCH_PAD_DENOISE_BIT4: touch_pad_denoise_grade_t = 3;
pub const touch_pad_denoise_grade_t_TOUCH_PAD_DENOISE_MAX: touch_pad_denoise_grade_t = 4;
pub type touch_pad_denoise_grade_t = ::core::ffi::c_uint;
#[doc = "<Denoise channel internal reference capacitance is 5pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L0: touch_pad_denoise_cap_t = 0;
#[doc = "<Denoise channel internal reference capacitance is 6.4pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L1: touch_pad_denoise_cap_t = 1;
#[doc = "<Denoise channel internal reference capacitance is 7.8pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L2: touch_pad_denoise_cap_t = 2;
#[doc = "<Denoise channel internal reference capacitance is 9.2pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L3: touch_pad_denoise_cap_t = 3;
#[doc = "<Denoise channel internal reference capacitance is 10.6pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L4: touch_pad_denoise_cap_t = 4;
#[doc = "<Denoise channel internal reference capacitance is 12.0pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L5: touch_pad_denoise_cap_t = 5;
#[doc = "<Denoise channel internal reference capacitance is 13.4pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L6: touch_pad_denoise_cap_t = 6;
#[doc = "<Denoise channel internal reference capacitance is 14.8pf"]
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_L7: touch_pad_denoise_cap_t = 7;
pub const touch_pad_denoise_cap_t_TOUCH_PAD_DENOISE_CAP_MAX: touch_pad_denoise_cap_t = 8;
pub type touch_pad_denoise_cap_t = ::core::ffi::c_uint;
#[doc = " Touch sensor denoise configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct touch_pad_denoise {
    #[doc = "<Select denoise range of denoise channel.\nDetermined by measuring the noise amplitude of the denoise channel."]
    pub grade: touch_pad_denoise_grade_t,
    #[doc = "<Select internal reference capacitance of denoise channel.\nEnsure that the denoise readings are closest to the readings of the channel being measured.\nUse `touch_pad_denoise_read_data` to get the reading of denoise channel.\nThe equivalent capacitance of the shielded channel can be calculated\nfrom the reading of denoise channel."]
    pub cap_level: touch_pad_denoise_cap_t,
}
impl Default for touch_pad_denoise {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Touch sensor denoise configuration"]
pub type touch_pad_denoise_t = touch_pad_denoise;
#[doc = "<The max equivalent capacitance in shield channel is 40pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L0: touch_pad_shield_driver_t = 0;
#[doc = "<The max equivalent capacitance in shield channel is 80pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L1: touch_pad_shield_driver_t = 1;
#[doc = "<The max equivalent capacitance in shield channel is 120pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L2: touch_pad_shield_driver_t = 2;
#[doc = "<The max equivalent capacitance in shield channel is 160pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L3: touch_pad_shield_driver_t = 3;
#[doc = "<The max equivalent capacitance in shield channel is 200pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L4: touch_pad_shield_driver_t = 4;
#[doc = "<The max equivalent capacitance in shield channel is 240pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L5: touch_pad_shield_driver_t = 5;
#[doc = "<The max equivalent capacitance in shield channel is 280pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L6: touch_pad_shield_driver_t = 6;
#[doc = "<The max equivalent capacitance in shield channel is 320pf"]
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_L7: touch_pad_shield_driver_t = 7;
pub const touch_pad_shield_driver_t_TOUCH_PAD_SHIELD_DRV_MAX: touch_pad_shield_driver_t = 8;
#[doc = " Touch sensor shield channel drive capability level"]
pub type touch_pad_shield_driver_t = ::core::ffi::c_uint;
#[doc = " Touch sensor waterproof configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct touch_pad_waterproof {
    #[doc = "<Waterproof. Select touch channel use for guard pad.\nGuard pad is used to detect the large area of water covering the touch panel."]
    pub guard_ring_pad: touch_pad_t,
    #[doc = "<Waterproof. Shield channel drive capability configuration.\nShield pad is used to shield the influence of water droplets covering the touch panel.\nWhen the waterproof function is enabled, Touch14 is set as shield channel by default.\nThe larger the parasitic capacitance on the shielding channel, the higher the drive capability needs to be set.\nThe equivalent capacitance of the shield channel can be estimated through the reading value of the denoise channel(Touch0)."]
    pub shield_driver: touch_pad_shield_driver_t,
}
impl Default for touch_pad_waterproof {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Touch sensor waterproof configuration"]
pub type touch_pad_waterproof_t = touch_pad_waterproof;
#[doc = "<Idle status of touch channel is high resistance state"]
pub const touch_pad_conn_type_t_TOUCH_PAD_CONN_HIGHZ: touch_pad_conn_type_t = 0;
#[doc = "<Idle status of touch channel is ground connection"]
pub const touch_pad_conn_type_t_TOUCH_PAD_CONN_GND: touch_pad_conn_type_t = 1;
pub const touch_pad_conn_type_t_TOUCH_PAD_CONN_MAX: touch_pad_conn_type_t = 2;
#[doc = " Touch channel idle state configuration"]
pub type touch_pad_conn_type_t = ::core::ffi::c_uint;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 4."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_4: touch_filter_mode_t = 0;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 8."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_8: touch_filter_mode_t = 1;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 16 (Typical value)."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_16: touch_filter_mode_t = 2;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 32."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_32: touch_filter_mode_t = 3;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 64."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_64: touch_filter_mode_t = 4;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 128."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_128: touch_filter_mode_t = 5;
#[doc = "<The filter mode is first-order IIR filter. The coefficient is 256."]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_IIR_256: touch_filter_mode_t = 6;
#[doc = "<The filter mode is jitter filter"]
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_JITTER: touch_filter_mode_t = 7;
pub const touch_filter_mode_t_TOUCH_PAD_FILTER_MAX: touch_filter_mode_t = 8;
#[doc = " @brief Touch channel IIR filter coefficient configuration.\n @note On ESP32S2. There is an error in the IIR calculation. The magnitude of the error is twice the filter coefficient.\n       So please select a smaller filter coefficient on the basis of meeting the filtering requirements.\n       Recommended filter coefficient selection `IIR_16`."]
pub type touch_filter_mode_t = ::core::ffi::c_uint;
#[doc = "<No filtering of raw data."]
pub const touch_smooth_mode_t_TOUCH_PAD_SMOOTH_OFF: touch_smooth_mode_t = 0;
#[doc = "<Filter the raw data. The coefficient is 2 (Typical value)."]
pub const touch_smooth_mode_t_TOUCH_PAD_SMOOTH_IIR_2: touch_smooth_mode_t = 1;
#[doc = "<Filter the raw data. The coefficient is 4."]
pub const touch_smooth_mode_t_TOUCH_PAD_SMOOTH_IIR_4: touch_smooth_mode_t = 2;
#[doc = "<Filter the raw data. The coefficient is 8."]
pub const touch_smooth_mode_t_TOUCH_PAD_SMOOTH_IIR_8: touch_smooth_mode_t = 3;
pub const touch_smooth_mode_t_TOUCH_PAD_SMOOTH_MAX: touch_smooth_mode_t = 4;
#[doc = " @brief Level of filter applied on the original data against large noise interference.\n @note On ESP32S2. There is an error in the IIR calculation. The magnitude of the error is twice the filter coefficient.\n       So please select a smaller filter coefficient on the basis of meeting the filtering requirements.\n       Recommended filter coefficient selection `IIR_2`."]
pub type touch_smooth_mode_t = ::core::ffi::c_uint;
#[doc = " Touch sensor filter configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct touch_filter_config {
    #[doc = "<Set filter mode. The input of the filter is the raw value of touch reading,\nand the output of the filter is involved in the judgment of the touch state."]
    pub mode: touch_filter_mode_t,
    #[doc = "<Set debounce count, such as `n`. If the measured values continue to exceed\nthe threshold for `n+1` times, the touch sensor state changes.\nRange: 0 ~ 7"]
    pub debounce_cnt: u32,
    #[doc = "<Noise threshold coefficient. Higher = More noise resistance.\nThe actual noise should be less than (noise coefficient * touch threshold).\nRange: 0 ~ 3. The coefficient is 0: 4/8;  1: 3/8;   2: 2/8;   3: 1;"]
    pub noise_thr: u32,
    #[doc = "<Set jitter filter step size. Range: 0 ~ 15"]
    pub jitter_step: u32,
    #[doc = "<Level of filter applied on the original data against large noise interference."]
    pub smh_lvl: touch_smooth_mode_t,
}
impl Default for touch_filter_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Touch sensor filter configuration"]
pub type touch_filter_config_t = touch_filter_config;
#[doc = " Touch sensor channel sleep configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct touch_pad_sleep_channel_t {
    #[doc = "<Set touch channel number for sleep pad.\nOnly one touch sensor channel is supported in deep sleep mode.\nIf clear the sleep channel, point this pad to `TOUCH_PAD_NUM0`"]
    pub touch_num: touch_pad_t,
    #[doc = "<enable proximity function for sleep pad"]
    pub en_proximity: bool,
}
impl Default for touch_pad_sleep_channel_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const gpio_port_t_GPIO_PORT_0: gpio_port_t = 0;
pub const gpio_port_t_GPIO_PORT_MAX: gpio_port_t = 1;
pub type gpio_port_t = ::core::ffi::c_uint;
#[doc = "< Use to signal not connected to S/W"]
pub const gpio_num_t_GPIO_NUM_NC: gpio_num_t = -1;
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
#[doc = "< GPIO17, input and output"]
pub const gpio_num_t_GPIO_NUM_17: gpio_num_t = 17;
#[doc = "< GPIO18, input and output"]
pub const gpio_num_t_GPIO_NUM_18: gpio_num_t = 18;
#[doc = "< GPIO19, input and output"]
pub const gpio_num_t_GPIO_NUM_19: gpio_num_t = 19;
#[doc = "< GPIO20, input and output"]
pub const gpio_num_t_GPIO_NUM_20: gpio_num_t = 20;
#[doc = "< GPIO21, input and output"]
pub const gpio_num_t_GPIO_NUM_21: gpio_num_t = 21;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 22;
pub type gpio_num_t = ::core::ffi::c_int;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = ::core::ffi::c_uint;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
#[doc = "< GPIO mode : output and input with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD: gpio_mode_t = 7;
#[doc = "< GPIO mode : output and input mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT: gpio_mode_t = 3;
#[doc = " @endcond"]
pub type gpio_mode_t = ::core::ffi::c_uint;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = ::core::ffi::c_uint;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = ::core::ffi::c_uint;
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad pull up + pull down"]
pub const gpio_pull_mode_t_GPIO_PULLUP_PULLDOWN: gpio_pull_mode_t = 2;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 3;
pub type gpio_pull_mode_t = ::core::ffi::c_uint;
#[doc = "< Pad drive capability: weak"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_0: gpio_drive_cap_t = 0;
#[doc = "< Pad drive capability: stronger"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_1: gpio_drive_cap_t = 1;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_2: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: strongest"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_3: gpio_drive_cap_t = 3;
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_MAX: gpio_drive_cap_t = 4;
pub type gpio_drive_cap_t = ::core::ffi::c_uint;
#[doc = "!< Wake the chip when all selected GPIOs go low"]
pub const esp_sleep_ext1_wakeup_mode_t_ESP_EXT1_WAKEUP_ALL_LOW: esp_sleep_ext1_wakeup_mode_t = 0;
#[doc = "!< Wake the chip when any of the selected GPIOs go high"]
pub const esp_sleep_ext1_wakeup_mode_t_ESP_EXT1_WAKEUP_ANY_HIGH: esp_sleep_ext1_wakeup_mode_t = 1;
#[doc = " @brief Logic function used for EXT1 wakeup mode."]
pub type esp_sleep_ext1_wakeup_mode_t = ::core::ffi::c_uint;
pub const esp_deepsleep_gpio_wake_up_mode_t_ESP_GPIO_WAKEUP_GPIO_LOW:
    esp_deepsleep_gpio_wake_up_mode_t = 0;
pub const esp_deepsleep_gpio_wake_up_mode_t_ESP_GPIO_WAKEUP_GPIO_HIGH:
    esp_deepsleep_gpio_wake_up_mode_t = 1;
pub type esp_deepsleep_gpio_wake_up_mode_t = ::core::ffi::c_uint;
#[doc = "!< XTAL oscillator"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_XTAL: esp_sleep_pd_domain_t = 0;
#[doc = "!< CPU core"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_CPU: esp_sleep_pd_domain_t = 1;
#[doc = "!< Internal 8M oscillator"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_RTC8M: esp_sleep_pd_domain_t = 2;
#[doc = "!< VDD_SDIO"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_VDDSDIO: esp_sleep_pd_domain_t = 3;
#[doc = "!< Number of domains"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_MAX: esp_sleep_pd_domain_t = 4;
#[doc = " @brief Power domains which can be powered down in sleep mode"]
pub type esp_sleep_pd_domain_t = ::core::ffi::c_uint;
#[doc = "!< Power down the power domain in sleep mode"]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_OFF: esp_sleep_pd_option_t = 0;
#[doc = "!< Keep power domain enabled during sleep mode"]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_ON: esp_sleep_pd_option_t = 1;
#[doc = "!< Keep power domain enabled in sleep mode, if it is needed by one of the wakeup options. Otherwise power it down."]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_AUTO: esp_sleep_pd_option_t = 2;
#[doc = " @brief Power down options"]
pub type esp_sleep_pd_option_t = ::core::ffi::c_uint;
#[doc = "!< In case of deep sleep, reset was not caused by exit from deep sleep"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_UNDEFINED: esp_sleep_source_t = 0;
#[doc = "!< Not a wakeup cause, used to disable all wakeup sources with esp_sleep_disable_wakeup_source"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_ALL: esp_sleep_source_t = 1;
#[doc = "!< Wakeup caused by external signal using RTC_IO"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_EXT0: esp_sleep_source_t = 2;
#[doc = "!< Wakeup caused by external signal using RTC_CNTL"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_EXT1: esp_sleep_source_t = 3;
#[doc = "!< Wakeup caused by timer"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_TIMER: esp_sleep_source_t = 4;
#[doc = "!< Wakeup caused by touchpad"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_TOUCHPAD: esp_sleep_source_t = 5;
#[doc = "!< Wakeup caused by ULP program"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_ULP: esp_sleep_source_t = 6;
#[doc = "!< Wakeup caused by GPIO (light sleep only on ESP32, S2 and S3)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_GPIO: esp_sleep_source_t = 7;
#[doc = "!< Wakeup caused by UART (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_UART: esp_sleep_source_t = 8;
#[doc = "!< Wakeup caused by WIFI (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_WIFI: esp_sleep_source_t = 9;
#[doc = "!< Wakeup caused by COCPU int"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_COCPU: esp_sleep_source_t = 10;
#[doc = "!< Wakeup caused by COCPU crash"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_COCPU_TRAP_TRIG: esp_sleep_source_t = 11;
#[doc = "!< Wakeup caused by BT (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_BT: esp_sleep_source_t = 12;
#[doc = " @brief Sleep wakeup cause"]
pub type esp_sleep_source_t = ::core::ffi::c_uint;
#[doc = " @brief Sleep wakeup cause"]
pub use self::esp_sleep_source_t as esp_sleep_wakeup_cause_t;
pub const ESP_ERR_SLEEP_REJECT: _bindgen_ty_1 = 259;
pub const ESP_ERR_SLEEP_TOO_SHORT_SLEEP_DURATION: _bindgen_ty_1 = 258;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Disable wakeup source\n\n This function is used to deactivate wake up trigger for source\n defined as parameter of the function.\n\n @note This function does not modify wake up configuration in RTC.\n       It will be performed in esp_deep_sleep_start/esp_light_sleep_start function.\n\n See docs/sleep-modes.rst for details.\n\n @param source - number of source to disable of type esp_sleep_source_t\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if trigger was not active"]
    pub fn esp_sleep_disable_wakeup_source(source: esp_sleep_source_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by timer\n @param time_in_us  time before wakeup, in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if value is out of range (TBD)"]
    pub fn esp_sleep_enable_timer_wakeup(time_in_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns true if a GPIO number is valid for use as wakeup source.\n\n @note For SoCs with RTC IO capability, this can be any valid RTC IO input pin.\n\n @param gpio_num Number of the GPIO to test for wakeup source capability\n\n @return True if this GPIO number will be accepted as a sleep wakeup source."]
    pub fn esp_sleep_is_valid_wakeup_gpio(gpio_num: gpio_num_t) -> bool;
}
extern "C" {
    #[doc = " @brief Enable wakeup using specific gpio pins\n\n This function enables an IO pin to wake up the chip from deep sleep.\n\n @note This function does not modify pin configuration. The pins are\n       configured inside esp_deep_sleep_start, immediately before entering sleep mode.\n\n @note You don't need to care to pull-up or pull-down before using this\n       function, because this will be set internally in esp_deep_sleep_start\n       based on the wakeup mode. BTW, when you use low level to wake up the\n       chip, we strongly recommend you to add external resistors (pull-up).\n\n @param gpio_pin_mask  Bit mask of GPIO numbers which will cause wakeup. Only GPIOs\n              which have RTC functionality (pads that powered by VDD3P3_RTC) can be used in this bit map.\n @param mode Select logic function used to determine wakeup condition:\n            - ESP_GPIO_WAKEUP_GPIO_LOW: wake up when the gpio turn to low.\n            - ESP_GPIO_WAKEUP_GPIO_HIGH: wake up when the gpio turn to high.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the mask contains any invalid deep sleep wakeup pin or wakeup mode is invalid"]
    pub fn esp_deep_sleep_enable_gpio_wakeup(
        gpio_pin_mask: u64,
        mode: esp_deepsleep_gpio_wake_up_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup from light sleep using GPIOs\n\n Each GPIO supports wakeup function, which can be triggered on either low level\n or high level. Unlike EXT0 and EXT1 wakeup sources, this method can be used\n both for all IOs: RTC IOs and digital IOs. It can only be used to wakeup from\n light sleep though.\n\n To enable wakeup, first call gpio_wakeup_enable, specifying gpio number and\n wakeup level, for each GPIO which is used for wakeup.\n Then call this function to enable wakeup feature.\n\n @note On ESP32, GPIO wakeup source can not be used together with touch or ULP wakeup sources.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if wakeup triggers conflict"]
    pub fn esp_sleep_enable_gpio_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup from light sleep using UART\n\n Use uart_set_wakeup_threshold function to configure UART wakeup threshold.\n\n Wakeup from light sleep takes some time, so not every character sent\n to the UART can be received by the application.\n\n @note ESP32 does not support wakeup from UART2.\n\n @param uart_num  UART port to wake up from\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if wakeup from given UART is not supported"]
    pub fn esp_sleep_enable_uart_wakeup(uart_num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by bluetooth\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_SUPPORTED if wakeup from bluetooth is not supported"]
    pub fn esp_sleep_enable_bt_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable wakeup by bluetooth\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_SUPPORTED if wakeup from bluetooth is not supported"]
    pub fn esp_sleep_disable_bt_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by WiFi MAC\n @return\n      - ESP_OK on success"]
    pub fn esp_sleep_enable_wifi_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable wakeup by WiFi MAC\n @return\n      - ESP_OK on success"]
    pub fn esp_sleep_disable_wifi_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the bit mask of GPIOs which caused wakeup (ext1)\n\n If wakeup was caused by another source, this function will return 0.\n\n @return bit mask, if GPIOn caused wakeup, BIT(n) will be set"]
    pub fn esp_sleep_get_ext1_wakeup_status() -> u64;
}
extern "C" {
    #[doc = " @brief Get the bit mask of GPIOs which caused wakeup (gpio)\n\n If wakeup was caused by another source, this function will return 0.\n\n @return bit mask, if GPIOn caused wakeup, BIT(n) will be set"]
    pub fn esp_sleep_get_gpio_wakeup_status() -> u64;
}
extern "C" {
    #[doc = " @brief Set power down mode for an RTC power domain in sleep mode\n\n If not set set using this API, all power domains default to ESP_PD_OPTION_AUTO.\n\n @param domain  power domain to configure\n @param option  power down option (ESP_PD_OPTION_OFF, ESP_PD_OPTION_ON, or ESP_PD_OPTION_AUTO)\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if either of the arguments is out of range"]
    pub fn esp_sleep_pd_config(
        domain: esp_sleep_pd_domain_t,
        option: esp_sleep_pd_option_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enter deep sleep with the configured wakeup options\n\n This function does not return."]
    pub fn esp_deep_sleep_start() -> !;
}
extern "C" {
    #[doc = " @brief Enter light sleep with the configured wakeup options\n\n @return\n  - ESP_OK on success (returned after wakeup)\n  - ESP_ERR_SLEEP_REJECT sleep request is rejected(wakeup source set before the sleep request)\n  - ESP_ERR_SLEEP_TOO_SHORT_SLEEP_DURATION after deducting the sleep flow overhead, the final sleep duration\n                                           is too short to cover the minimum sleep duration of the chip, when\n                                           rtc timer wakeup source enabled"]
    pub fn esp_light_sleep_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enter deep-sleep mode\n\n The device will automatically wake up after the deep-sleep time\n Upon waking up, the device calls deep sleep wake stub, and then proceeds\n to load application.\n\n Call to this function is equivalent to a call to esp_deep_sleep_enable_timer_wakeup\n followed by a call to esp_deep_sleep_start.\n\n esp_deep_sleep does not shut down WiFi, BT, and higher level protocol\n connections gracefully.\n Make sure relevant WiFi and BT stack functions are called to close any\n connections and deinitialize the peripherals. These include:\n     - esp_bluedroid_disable\n     - esp_bt_controller_disable\n     - esp_wifi_stop\n\n This function does not return.\n\n @note The device will wake up immediately if the deep-sleep time is set to 0\n\n @param time_in_us  deep-sleep time, unit: microsecond"]
    pub fn esp_deep_sleep(time_in_us: u64) -> !;
}
extern "C" {
    #[doc = " @brief Get the wakeup source which caused wakeup from sleep\n\n @return cause of wake up from last sleep (deep sleep or light sleep)"]
    pub fn esp_sleep_get_wakeup_cause() -> esp_sleep_wakeup_cause_t;
}
extern "C" {
    #[doc = " @brief Default stub to run on wake from deep sleep.\n\n Allows for executing code immediately on wake from sleep, before\n the software bootloader or ESP-IDF app has started up.\n\n This function is weak-linked, so you can implement your own version\n to run code immediately when the chip wakes from\n sleep.\n\n See docs/deep-sleep-stub.rst for details."]
    pub fn esp_wake_deep_sleep();
}
#[doc = " @brief Function type for stub to run on wake from sleep.\n"]
pub type esp_deep_sleep_wake_stub_fn_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief Install a new stub at runtime to run on wake from deep sleep\n\n If implementing esp_wake_deep_sleep() then it is not necessary to\n call this function.\n\n However, it is possible to call this function to substitute a\n different deep sleep stub. Any function used as a deep sleep stub\n must be marked RTC_IRAM_ATTR, and must obey the same rules given\n for esp_wake_deep_sleep()."]
    pub fn esp_set_deep_sleep_wake_stub(new_stub: esp_deep_sleep_wake_stub_fn_t);
}
extern "C" {
    #[doc = " @brief Get current wake from deep sleep stub\n @return Return current wake from deep sleep stub, or NULL if\n         no stub is installed."]
    pub fn esp_get_deep_sleep_wake_stub() -> esp_deep_sleep_wake_stub_fn_t;
}
extern "C" {
    #[doc = "  @brief The default esp-idf-provided esp_wake_deep_sleep() stub.\n\n  See docs/deep-sleep-stub.rst for details."]
    pub fn esp_default_wake_deep_sleep();
}
extern "C" {
    #[doc = " @brief Disable logging from the ROM code after deep sleep.\n\n Using LSB of RTC_STORE4."]
    pub fn esp_deep_sleep_disable_rom_logging();
}
extern "C" {
    #[doc = " @brief CPU Power down low-level initialize\n\n @param enable  enable or disable CPU power down during light sleep\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM not enough retention memory"]
    pub fn esp_sleep_cpu_pd_low_init(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure to isolate all GPIO pins in sleep state"]
    pub fn esp_sleep_config_gpio_isolate();
}
extern "C" {
    #[doc = " @brief Enable or disable GPIO pins status switching between slept status and waked status.\n @param enable decide whether to switch status or not"]
    pub fn esp_sleep_enable_gpio_switch(enable: bool);
}
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spinlock_t {
    pub owner: u32,
    pub count: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to a registered heap"]
pub type multi_heap_handle_t = *mut multi_heap_info;
extern "C" {
    #[doc = " @brief allocate a chunk of memory with specific alignment\n\n @param heap  Handle to a registered heap.\n @param size  size in bytes of memory chunk\n @param alignment  how the memory must be aligned\n\n @return pointer to the memory allocated, NULL on failure"]
    pub fn multi_heap_aligned_alloc(
        heap: multi_heap_handle_t,
        size: usize,
        alignment: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief malloc() a buffer in a given heap\n\n Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param size Size of desired buffer.\n\n @return Pointer to new memory, or NULL if allocation fails."]
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief free() a buffer aligned in a given heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_aligned_alloc() for the same heap.\n @note This function is deprecated, consider using multi_heap_free() instead"]
    pub fn multi_heap_aligned_free(heap: multi_heap_handle_t, p: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief free() a buffer in a given heap.\n\n Semantics are the same as standard free(), only the argument 'p' must be NULL or have been allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief realloc() a buffer in a given heap.\n\n Semantics are the same as standard realloc(), only the argument 'p' must be NULL or have been allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap.\n @param size Desired new size for buffer.\n\n @return New buffer of 'size' containing contents of 'p', or NULL if reallocation failed."]
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut ::core::ffi::c_void,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with.\n\n @param heap Handle to a registered heap.\n @param p Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap.\n\n @return Size of the memory allocated at this block. May be more than the original size argument, due\n to padding and minimum block sizes."]
    pub fn multi_heap_get_allocated_size(
        heap: multi_heap_handle_t,
        p: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Register a new heap for use\n\n This function initialises a heap at the specified address, and returns a handle for future heap operations.\n\n There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes.\n\n @param start Start address of the memory to use for a new heap.\n @param size Size (in bytes) of the new heap.\n\n @return Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised."]
    pub fn multi_heap_register(start: *mut ::core::ffi::c_void, size: usize)
        -> multi_heap_handle_t;
}
extern "C" {
    #[doc = " @brief Associate a private lock pointer with a heap\n\n The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h.\n\n The lock in question must be recursive.\n\n When the heap is first registered, the associated lock is NULL.\n\n @param heap Handle to a registered heap.\n @param lock Optional pointer to a locking structure to associate with this heap."]
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Dump heap information to stdout\n\n For debugging purposes, this function dumps information about every block in the heap to stdout.\n\n @param heap Handle to a registered heap."]
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
extern "C" {
    #[doc = " @brief Check heap integrity\n\n Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message\n can be optionally printed to stderr. Print behaviour can be overridden at compile time by defining\n MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h.\n\n @note This function is not thread-safe as it sets a global variable with the value of print_errors.\n\n @param heap Handle to a registered heap.\n @param print_errors If true, errors will be printed to stderr.\n @return true if heap is valid, false otherwise."]
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Return free heap size\n\n Returns the number of bytes available in the heap.\n\n Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info().\n\n Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this\n size, see the largest_free_block member returned by multi_heap_get_heap_info().\n\n @param heap Handle to a registered heap.\n @return Number of free bytes."]
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> usize;
}
extern "C" {
    #[doc = " @brief Return the lifetime minimum free heap size\n\n Equivalent to the minimum_free_bytes member returned by multi_heap_get_info().\n\n Returns the lifetime \"low watermark\" of possible values returned from multi_free_heap_size(), for the specified\n heap.\n\n @param heap Handle to a registered heap.\n @return Number of free bytes."]
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> usize;
}
#[doc = " @brief Structure to access heap metadata via multi_heap_get_info"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct multi_heap_info_t {
    #[doc = "<  Total free bytes in the heap. Equivalent to multi_free_heap_size()."]
    pub total_free_bytes: usize,
    #[doc = "<  Total bytes allocated to data in the heap."]
    pub total_allocated_bytes: usize,
    #[doc = "<  Size of the largest free block in the heap. This is the largest malloc-able size."]
    pub largest_free_block: usize,
    #[doc = "<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size()."]
    pub minimum_free_bytes: usize,
    #[doc = "<  Number of (variable size) blocks allocated in the heap."]
    pub allocated_blocks: usize,
    #[doc = "<  Number of (variable size) free blocks in the heap."]
    pub free_blocks: usize,
    #[doc = "<  Total number of (variable size) blocks in the heap."]
    pub total_blocks: usize,
}
extern "C" {
    #[doc = " @brief Return metadata about a given heap\n\n Fills a multi_heap_info_t structure with information about the specified heap.\n\n @param heap Handle to a registered heap.\n @param info Pointer to a structure to fill with heap metadata."]
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
#[doc = " @brief callback called when an allocation operation fails, if registered\n @param size in bytes of failed allocation\n @param caps capabilities requested of failed allocation\n @param function_name function which generated the failure"]
pub type esp_alloc_failed_hook_t = ::core::option::Option<
    unsafe extern "C" fn(size: usize, caps: u32, function_name: *const ::core::ffi::c_char),
>;
extern "C" {
    #[doc = " @brief registers a callback function to be invoked if a memory allocation operation fails\n @param callback caller defined callback to be invoked\n @return ESP_OK if callback was registered."]
    pub fn heap_caps_register_failed_alloc_callback(callback: esp_alloc_failed_hook_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities\n\n Equivalent semantics to libc malloc(), for capability-aware memory.\n\n @param size Size, in bytes, of the amount of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc(size: usize, caps: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc().\n\n Equivalent semantics to libc free(), for capability-aware memory.\n\n  In IDF, ``free(p)`` is equivalent to ``heap_caps_free(p)``.\n\n @param ptr Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL."]
    pub fn heap_caps_free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc().\n\n Equivalent semantics to libc realloc(), for capability-aware memory.\n\n In IDF, ``realloc(p, s)`` is equivalent to ``heap_caps_realloc(p, s, MALLOC_CAP_8BIT)``.\n\n 'caps' parameter can be different to the capabilities that any original 'ptr' was allocated with. In this way,\n realloc can be used to \"move\" a buffer if necessary to ensure it meets a new set of capabilities.\n\n @param ptr Pointer to previously allocated memory, or NULL for a new allocation.\n @param size Size of the new buffer requested, or 0 to free the buffer.\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory desired for the new allocation.\n\n @return Pointer to a new buffer of size 'size' with capabilities 'caps', or NULL if allocation failed."]
    pub fn heap_caps_realloc(
        ptr: *mut ::core::ffi::c_void,
        size: usize,
        caps: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate an aligned chunk of memory which has the given capabilities\n\n Equivalent semantics to libc aligned_alloc(), for capability-aware memory.\n @param alignment  How the pointer received needs to be aligned\n                   must be a power of two\n @param size Size, in bytes, of the amount of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure\n\n"]
    pub fn heap_caps_aligned_alloc(
        alignment: usize,
        size: usize,
        caps: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Used to deallocate memory previously allocated with heap_caps_aligned_alloc\n\n @param ptr Pointer to the memory allocated\n @note This function is deprecated, please consider using heap_caps_free() instead"]
    pub fn heap_caps_aligned_free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Allocate an aligned chunk of memory which has the given capabilities. The initialized value in the memory is set to zero.\n\n @param alignment  How the pointer received needs to be aligned\n                   must be a power of two\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure\n"]
    pub fn heap_caps_aligned_calloc(
        alignment: usize,
        n: usize,
        size: usize,
        caps: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero.\n\n Equivalent semantics to libc calloc(), for capability-aware memory.\n\n In IDF, ``calloc(p)`` is equivalent to ``heap_caps_calloc(p, MALLOC_CAP_8BIT)``.\n\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc(n: usize, size: usize, caps: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Get the total size of all the regions that have the given capabilities\n\n This function takes all regions capable of having the given capabilities allocated in them\n and adds up the total space they have.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return total size in bytes"]
    pub fn heap_caps_get_total_size(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities\n\n This function takes all regions capable of having the given capabilities allocated in them\n and adds up the free space they have.\n\n @note Note that because of heap fragmentation it is probably not possible to allocate a single block of memory\n of this size. Use heap_caps_get_largest_free_block() for this purpose.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities\n\n This adds all the low watermarks of the regions capable of delivering the memory\n with the given capabilities.\n\n @note Note the result may be less than the global all-time minimum available heap of this kind, as \"low watermarks\" are\n tracked per-region. Individual regions' heaps may have reached their \"low watermarks\" at different points in time. However,\n this result still gives a \"worst case\" indication for all-time minimum free heap.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get the largest free block of memory able to be allocated with the given capabilities.\n\n Returns the largest value of ``s`` for which ``heap_caps_malloc(s, caps)`` will succeed.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Size of the largest free block in bytes."]
    pub fn heap_caps_get_largest_free_block(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get heap info for all regions with the given capabilities.\n\n Calls multi_heap_info() on all heaps which share the given capabilities. The information returned is an aggregate\n across all matching heaps. The meanings of fields are the same as defined for multi_heap_info_t, except that\n ``minimum_free_bytes`` has the same caveats described in heap_caps_get_minimum_free_size().\n\n @param info        Pointer to a structure which will be filled with relevant\n                    heap metadata.\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n"]
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
extern "C" {
    #[doc = " @brief Print a summary of all memory with the given capabilities.\n\n Calls multi_heap_info on all heaps which share the given capabilities, and\n prints a two-line summary for each, then a total summary.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n"]
    pub fn heap_caps_print_heap_info(caps: u32);
}
extern "C" {
    #[doc = " @brief Check integrity of all heap memory in the system.\n\n Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt.\n\n Calling this function is equivalent to calling heap_caps_check_integrity\n with the caps argument set to MALLOC_CAP_INVALID.\n\n @param print_errors Print specific errors if heap corruption is found.\n\n @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of all heaps with the given capabilities.\n\n Calls multi_heap_check on all heaps which share the given capabilities. Optionally\n print errors if the heaps are corrupt.\n\n See also heap_caps_check_integrity_all to check all heap memory\n in the system and heap_caps_check_integrity_addr to check memory\n around a single address.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n @param print_errors Print specific errors if heap corruption is found.\n\n @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of heap memory around a given address.\n\n This function can be used to check the integrity of a single region of heap memory,\n which contains the given address.\n\n This can be useful if debugging heap integrity for corruption at a known address,\n as it has a lower overhead than checking all heap regions. Note that if the corrupt\n address moves around between runs (due to timing or other factors) then this approach\n won't work, and you should call heap_caps_check_integrity or\n heap_caps_check_integrity_all instead.\n\n @note The entire heap region around the address is checked, not only the adjacent\n heap blocks.\n\n @param addr Address in memory. Check for corruption in region containing this address.\n @param print_errors Print specific errors if heap corruption is found.\n\n @return True if the heap containing the specified address is valid,\n False if at least one heap is corrupt or the address doesn't belong to a heap region."]
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Enable malloc() in external memory and set limit below which\n        malloc() attempts are placed in internal memory.\n\n When external memory is in use, the allocation strategy is to initially try to\n satisfy smaller allocation requests with internal memory and larger requests\n with external memory. This sets the limit between the two, as well as generally\n enabling allocation in external memory.\n\n @param limit       Limit, in bytes."]
    pub fn heap_caps_malloc_extmem_enable(limit: usize);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order.\n\n @attention The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory.\n            This API prefers to allocate memory with the first parameter. If failed, allocate memory with\n            the next parameter. It will try in this order until allocating a chunk of memory successfully\n            or fail to allocate memories with any of the parameters.\n\n @param size Size, in bytes, of the amount of memory to allocate\n @param num Number of variable parameters\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc_prefer(size: usize, num: usize, ...) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Reallocate a chunk of memory as preference in decreasing order.\n\n @param ptr Pointer to previously allocated memory, or NULL for a new allocation.\n @param size Size of the new buffer requested, or 0 to free the buffer.\n @param num Number of variable paramters\n\n @return Pointer to a new buffer of size 'size', or NULL if allocation failed."]
    pub fn heap_caps_realloc_prefer(
        ptr: *mut ::core::ffi::c_void,
        size: usize,
        num: usize,
        ...
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order.\n\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param num  Number of variable paramters\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc_prefer(
        n: usize,
        size: usize,
        num: usize,
        ...
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps with matching capabilities.\n\n Prints a large amount of output to serial (because of locking limitations,\n the output bypasses stdout/stderr). For each (variable sized) block\n in each matching heap, the following output is printed on a single line:\n\n - Block address (the data buffer returned by malloc is 4 bytes after this\n   if heap debugging is set to Basic, or 8 bytes otherwise).\n - Data size (the data size may be larger than the size requested by malloc,\n   either due to heap fragmentation or because of heap debugging level).\n - Address of next block in the heap.\n - If the block is free, the address of the next free block is also printed.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory"]
    pub fn heap_caps_dump(caps: u32);
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps.\n\n Covers all registered heaps. Prints a large amount of output to serial.\n\n Output is the same as for heap_caps_dump.\n"]
    pub fn heap_caps_dump_all();
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with.\n\n @param ptr Pointer to currently allocated heap memory. Must be a pointer value previously\n returned by heap_caps_malloc, malloc, calloc, etc. and not yet freed.\n\n @note The app will crash with an assertion failure if the pointer is not valid.\n\n @return Size of the memory allocated at this block.\n"]
    pub fn heap_caps_get_allocated_size(ptr: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn esp_newlib_time_init();
}
extern "C" {
    #[doc = " Replacement for newlib's _REENT_INIT_PTR and __sinit.\n\n Called from startup code and FreeRTOS, not intended to be called from\n application code."]
    pub fn esp_reent_init(r: *mut _reent);
}
extern "C" {
    #[doc = " Clean up some of lazily allocated buffers in REENT structures."]
    pub fn esp_reent_cleanup();
}
extern "C" {
    #[doc = " Function which sets up newlib in ROM for use with ESP-IDF\n\n Includes defining the syscall table, setting up any common locks, etc.\n\n Called from the startup code, not intended to be called from application\n code."]
    pub fn esp_newlib_init();
}
extern "C" {
    pub fn esp_setup_syscall_table();
}
extern "C" {
    #[doc = " Update current microsecond time from RTC"]
    pub fn esp_set_time_from_rtc();
}
extern "C" {
    pub fn esp_sync_timekeeping_timers();
}
extern "C" {
    #[doc = " Initialize newlib static locks"]
    pub fn esp_newlib_locks_init();
}
pub type StackType_t = u8;
pub type BaseType_t = ::core::ffi::c_int;
pub type UBaseType_t = ::core::ffi::c_uint;
pub type TickType_t = u32;
extern "C" {
    #[doc = " @brief Checks if the current core is in an ISR context\n\n - ISR context consist of Low/Mid priority ISR, or time tick ISR\n - High priority ISRs aren't detected here, but they normally cannot call C code, so that should not be an issue anyway.\n\n @note [refactor-todo] Check if this should be inlined\n @return\n  - pdTRUE if in ISR\n  - pdFALSE otherwise"]
    pub fn xPortInIsrContext() -> BaseType_t;
}
extern "C" {
    #[doc = " @brief Check if in ISR context from High priority ISRs\n\n - Called from High priority ISR\n - Checks if the previous context (before high priority interrupt) was in ISR context (meaning low/med priority)\n\n @note [refactor-todo] Check if this should be inlined\n @return\n  - pdTRUE if in previous in ISR context\n  - pdFALSE otherwise"]
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
#[doc = " @brief Spinlock object\n Owner:\n  - Set to 0 if uninitialized\n  - Set to portMUX_FREE_VAL when free\n  - Set to CORE_ID_REGVAL_PRO or CORE_ID_REGVAL_AP when locked\n  - Any other value indicates corruption\n Count:\n  - 0 if unlocked\n  - Recursive count if locked\n\n @note Not a true spinlock as single core RISC-V does not have atomic compare and set instruction\n @note Keep portMUX_INITIALIZER_UNLOCKED in sync with this struct"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct portMUX_TYPE {
    pub owner: u32,
    pub count: u32,
}
extern "C" {
    #[doc = " @brief Enter a critical section\n\n - Simply disable interrupts\n - Can be nested"]
    pub fn vPortEnterCritical();
}
extern "C" {
    #[doc = " @brief Exit a critical section\n\n - Reenables interrupts\n - Can be nested"]
    pub fn vPortExitCritical();
}
extern "C" {
    #[doc = " @brief Set interrupt mask and return current interrupt enable register\n\n @note [refactor-todo] Check if this function should be renamed (due to int return type)\n @return int Current interrupt enable register before set"]
    pub fn vPortSetInterruptMask() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Clear current interrupt mask and set given mask\n\n @param mask Interrupt mask"]
    pub fn vPortClearInterruptMask(mask: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Perform a context switch from a task\n\n @note [refactor-todo] The rest of ESP-IDF should call taskYield() instead"]
    pub fn vPortYield();
}
extern "C" {
    #[doc = " @brief Perform a context switch from an ISR"]
    pub fn vPortYieldFromISR();
}
extern "C" {
    #[doc = " @brief Yields the other core\n\n @note Added to be compatible with SMP API\n @note [refactor-todo] Put this into private macros as its only called from task.c and is not public API\n @param coreid ID of core to yield"]
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
extern "C" {
    #[doc = " @brief Hook function called on entry to tickless idle\n\n - Implemented in pm_impl.c\n\n @param xExpectedIdleTime Expected idle time"]
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
    #[doc = " @brief Get the tick rate per second\n\n @note [refactor-todo] make this inline\n @note [refactor-todo] Check if this function should be renamed (due to uint return type)\n @return uint32_t Tick rate in Hz"]
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    #[doc = " @brief Set a watchpoint to watch the last 32 bytes of the stack\n\n Callback to set a watchpoint on the end of the stack. Called every context switch to change the stack watchpoint\n around.\n\n @param pxStackStart Pointer to the start of the stack"]
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Checks if a given piece of memory can be used to store a task's TCB\n\n - Defined in port_common.c\n\n @param ptr Pointer to memory\n @return true Memory can be used to store a TCB\n @return false Otherwise"]
    pub fn xPortCheckValidTCBMem(ptr: *const ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[doc = " @brief Checks if a given piece of memory can be used to store a task's stack\n\n - Defined in port_common.c\n\n @param ptr Pointer to memory\n @return true Memory can be used to store a task stack\n @return false Otherwise"]
    pub fn xPortcheckValidStackMem(ptr: *const ::core::ffi::c_void) -> bool;
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::core::ffi::c_void,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tms {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _close_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _execve_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const *mut ::core::ffi::c_char,
        arg4: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcntl_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fork_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fstat_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut stat,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getpid_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _isatty_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _kill_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _link_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _lseek_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> _off_t;
}
extern "C" {
    pub fn _mkdir_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _read_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: usize,
    ) -> _ssize_t;
}
extern "C" {
    pub fn _sbrk_r(arg1: *mut _reent, arg2: isize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _stat_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut stat,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _times_r(arg1: *mut _reent, arg2: *mut tms) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn _unlink_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _wait_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _write_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_void,
        arg4: usize,
    ) -> _ssize_t;
}
extern "C" {
    pub fn _gettimeofday_r(
        arg1: *mut _reent,
        __tp: *mut timeval,
        __tzp: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::core::ffi::c_void; 4usize],
}
impl Default for xSTATIC_LIST_ITEM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::core::ffi::c_void; 2usize],
}
impl Default for xSTATIC_MINI_LIST_ITEM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut ::core::ffi::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
impl Default for xSTATIC_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::core::ffi::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::core::ffi::c_void,
    pub ucDummy7: [u8; 16usize],
    pub xDummyCore: BaseType_t,
    pub pxDummy8: *mut ::core::ffi::c_void,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut ::core::ffi::c_void; 1usize],
    pub pvDummyLocalStorageCallBack: [*mut ::core::ffi::c_void; 1usize],
    pub xDummy17: _reent,
    pub ulDummy18: [u32; 1usize],
    pub ucDummy19: [u8; 1usize],
    pub uxDummy20: u8,
    pub ucDummy21: u8,
}
impl Default for xSTATIC_TCB {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::core::ffi::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub ucDummy6: u8,
    pub pvDummy7: *mut ::core::ffi::c_void,
    pub xDummy10: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub uxDummy2: UBaseType_t,
}
impl Default for xSTATIC_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for xSTATIC_QUEUE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub ucDummy4: u8,
    pub xDummy5: portMUX_TYPE,
}
impl Default for xSTATIC_EVENT_GROUP {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::core::ffi::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut ::core::ffi::c_void,
    pub pvDummy6: TaskFunction_t,
    pub ucDummy8: u8,
}
impl Default for xSTATIC_TIMER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [usize; 4usize],
    pub pvDummy2: [*mut ::core::ffi::c_void; 3usize],
    pub ucDummy3: u8,
    pub xDummy5: portMUX_TYPE,
}
impl Default for xSTATIC_STREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut ::core::ffi::c_void,
    pub pxContainer: *mut xLIST,
}
impl Default for xLIST_ITEM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
impl Default for xMINI_LIST_ITEM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
impl Default for xLIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h\n\n Type by which tasks are referenced.  For example, a call to xTaskCreate\n returns (via a pointer parameter) an TaskHandle_t variable that can then\n be used as a parameter to vTaskDelete to delete the task.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup TaskHandle_t TaskHandle_t\n @endcond\n \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
#[doc = " Task states returned by eTaskGetState."]
pub type eTaskState = ::core::ffi::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = ::core::ffi::c_uint;
#[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION */\n/**\n Used internally only."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
#[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION */\n/**\n Used internally only."]
pub type TimeOut_t = xTIME_OUT;
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::core::ffi::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
impl Default for xMEMORY_REGION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::core::ffi::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut ::core::ffi::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
impl Default for xTASK_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const ::core::ffi::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u32,
}
impl Default for xTASK_STATUS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
#[doc = " Possible return values for eTaskConfirmSleepModeStatus()."]
pub type eSleepModeStatus = ::core::ffi::c_uint;
extern "C" {
    pub fn xTaskCreatePinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const ::core::ffi::c_char,
        usStackDepth: u32,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pvCreatedTask: *mut TaskHandle_t,
        xCoreID: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCreateStaticPinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const ::core::ffi::c_char,
        ulStackDepth: u32,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pxStackBuffer: *mut StackType_t,
        pxTaskBuffer: *mut StaticTask_t,
        xCoreID: BaseType_t,
    ) -> TaskHandle_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );\n @endcode\n @endcond\n\n Memory regions are assigned to a restricted task when the task is created by\n a call to xTaskCreateRestricted().  These regions can be redefined using\n vTaskAllocateMPURegions().\n\n @param xTask The handle of the task being updated.\n\n @param pxRegions A pointer to an MemoryRegion_t structure that contains the\n new memory region definitions.\n\n Example usage:\n @code{c}\n // Define an array of MemoryRegion_t structures that configures an MPU region\n // allowing read/write access for 1024 bytes starting at the beginning of the\n // ucOneKByte array.  The other two of the maximum 3 definable regions are\n // unused so set to zero.\n static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n {\n  // Base address     Length      Parameters\n  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },\n  { 0,                0,          0 },\n  { 0,                0,          0 }\n };\n\n void vATask( void *pvParameters )\n {\n  // This task was created such that it has access to certain regions of\n  // memory as defined by the MPU configuration.  At some point it is\n  // desired that these MPU regions are replaced with that defined in the\n  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n  // for this purpose.  NULL is used as the task handle to indicate that this\n  // function should modify the MPU regions of the calling task.\n  vTaskAllocateMPURegions( NULL, xAltRegions );\n\n  // Now the task can continue its function, but from this point on can only\n  // access its stack and the ucOneKByte array (unless any other statically\n  // defined or shared regions have been declared elsewhere).\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskCreateRestricted xTaskCreateRestricted\n @endcond\n \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskDelete( TaskHandle_t xTask );\n @endcode\n @endcond\n\n INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Remove a task from the RTOS real time kernel's management.  The task being\n deleted will be removed from all ready, blocked, suspended and event lists.\n\n NOTE:  The idle task is responsible for freeing the kernel allocated\n memory from tasks that have been deleted.  It is therefore important that\n the idle task is not starved of microcontroller processing time if your\n application makes any calls to vTaskDelete ().  Memory allocated by the\n task code is not automatically freed, and should be freed before the task\n is deleted.\n\n See the demo application file death.c for sample code that utilises\n vTaskDelete ().\n\n @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n cause the calling task to be deleted.\n\n Example usage:\n @code{c}\n void vOtherFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create the task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // Use the handle to delete the task.\n   vTaskDelete( xHandle );\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskDelete vTaskDelete\n @endcond\n \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskDelay( const TickType_t xTicksToDelay );\n @endcode\n @endcond\n\n Delay a task for a given number of ticks.  The actual time that the\n task remains blocked depends on the tick rate.  The constant\n portTICK_PERIOD_MS can be used to calculate real time from the tick\n rate - with the resolution of one tick period.\n\n INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n\n vTaskDelay() specifies a time at which the task wishes to unblock relative to\n the time at which vTaskDelay() is called.  For example, specifying a block\n period of 100 ticks will cause the task to unblock 100 ticks after\n vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n of controlling the frequency of a periodic task as the path taken through the\n code, as well as other task and interrupt activity, will effect the frequency\n at which vTaskDelay() gets called and therefore the time at which the task\n next executes.  See xTaskDelayUntil() for an alternative API function designed\n to facilitate fixed frequency execution.  It does this by specifying an\n absolute time (rather than a relative time) at which the calling task should\n unblock.\n\n @param xTicksToDelay The amount of time, in tick periods, that\n the calling task should block.\n\n Example usage:\n @code{c}\n void vTaskFunction( void * pvParameters )\n {\n // Block for 500ms.\n const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n\n   for( ;; )\n   {\n       // Simply toggle the LED every 500ms, blocking between each toggle.\n       vToggleLED();\n       vTaskDelay( xDelay );\n   }\n }\n @endcode\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskDelay vTaskDelay\n @endcond\n \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );\n @endcode\n @endcond\n\n INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Delay a task until a specified time.  This function can be used by periodic\n tasks to ensure a constant execution frequency.\n\n This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n cause a task to block for the specified number of ticks from the time vTaskDelay () is\n called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n execution frequency as the time between a task starting to execute and that task\n calling vTaskDelay () may not be fixed [the task may take a different path though the\n code between calls, or may get interrupted or preempted a different number of times\n each time it executes].\n\n Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n unblock.\n\n The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a\n time specified in milliseconds with a resolution of one tick period.\n\n @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n task was last unblocked.  The variable must be initialised with the current time\n prior to its first use (see the example below).  Following this the variable is\n automatically updated within xTaskDelayUntil ().\n\n @param xTimeIncrement The cycle time period.  The task will be unblocked at\n time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the\n same xTimeIncrement parameter value will cause the task to execute with\n a fixed interface period.\n\n @return Value which can be used to check whether the task was actually delayed.\n Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not\n be delayed if the next expected wake time is in the past.\n\n Example usage:\n @code{c}\n // Perform an action every 10 ticks.\n void vTaskFunction( void * pvParameters )\n {\n TickType_t xLastWakeTime;\n const TickType_t xFrequency = 10;\n BaseType_t xWasDelayed;\n\n     // Initialise the xLastWakeTime variable with the current time.\n     xLastWakeTime = xTaskGetTickCount ();\n     for( ;; )\n     {\n         // Wait for the next cycle.\n         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );\n\n         // Perform action here. xWasDelayed value can be used to determine\n         // whether a deadline was missed if the code here took too long.\n     }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskDelayUntil xTaskDelayUntil\n @endcond\n \\ingroup TaskCtrl"]
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskAbortDelay( TaskHandle_t xTask );\n @endcode\n @endcond\n\n INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this\n function to be available.\n\n A task will enter the Blocked state when it is waiting for an event.  The\n event it is waiting for can be a temporal event (waiting for a time), such\n as when vTaskDelay() is called, or an event on an object, such as when\n xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task\n that is in the Blocked state is used in a call to xTaskAbortDelay() then the\n task will leave the Blocked state, and return from whichever function call\n placed the task into the Blocked state.\n\n There is no 'FromISR' version of this function as an interrupt would need to\n know which object a task was blocked on in order to know which actions to\n take.  For example, if the task was blocked on a queue the interrupt handler\n would then need to know if the queue was locked.\n\n @param xTask The handle of the task to remove from the Blocked state.\n\n @return If the task referenced by xTask was not in the Blocked state then\n pdFAIL is returned.  Otherwise pdPASS is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskAbortDelay xTaskAbortDelay\n @endcond\n \\ingroup TaskCtrl"]
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );\n @endcode\n @endcond\n\n INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Obtain the priority of any task.\n\n @param xTask Handle of the task to be queried.  Passing a NULL\n handle results in the priority of the calling task being returned.\n\n @return The priority of xTask.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to obtain the priority of the created task.\n   // It was created with tskIDLE_PRIORITY, but may have changed\n   // it itself.\n   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n   {\n       // The task has changed it's priority.\n   }\n\n   // ...\n\n   // Is our priority higher than the created task?\n   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n   {\n       // Our priority (obtained using NULL handle) is higher.\n   }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup uxTaskPriorityGet uxTaskPriorityGet\n @endcond\n \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );\n @endcode\n @endcond\n\n A version of uxTaskPriorityGet() that can be used from an ISR."]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n eTaskState eTaskGetState( TaskHandle_t xTask );\n @endcode\n @endcond\n\n INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Obtain the state of any task.  States are encoded by the eTaskState\n enumerated type.\n\n @param xTask Handle of the task to be queried.\n\n @return The state of xTask at the time the function was called.  Note the\n state of the task might change between the function being called, and the\n functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );\n @endcode\n @endcond\n\n configUSE_TRACE_FACILITY must be defined as 1 for this function to be\n available.  See the configuration section for more information.\n\n Populates a TaskStatus_t structure with information about a task.\n\n @param xTask Handle of the task being queried.  If xTask is NULL then\n information will be returned about the calling task.\n\n @param pxTaskStatus A pointer to the TaskStatus_t structure that will be\n filled with information about the task referenced by the handle passed using\n the xTask parameter.\n\n @param xGetFreeStackSpace The TaskStatus_t structure contains a member to report\n the stack high water mark of the task being queried.  Calculating the stack\n high water mark takes a relatively long time, and can make the system\n temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to\n allow the high water mark checking to be skipped.  The high watermark value\n will only be written to the TaskStatus_t structure if xGetFreeStackSpace is\n not set to pdFALSE;\n\n @param eState The TaskStatus_t structure contains a member to report the\n state of the task being queried.  Obtaining the task state is not as fast as\n a simple assignment - so the eState parameter is provided to allow the state\n information to be omitted from the TaskStatus_t structure.  To obtain state\n information then set eState to eInvalid - otherwise the value passed in\n eState will be reported as the task state in the TaskStatus_t structure.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n TaskStatus_t xTaskDetails;\n\n  // Obtain the handle of a task from its name.\n  xHandle = xTaskGetHandle( \"Task_Name\" );\n\n  // Check the handle is not NULL.\n  configASSERT( xHandle );\n\n  // Use the handle to obtain further information about the task.\n  vTaskGetInfo( xHandle,\n                &xTaskDetails,\n                pdTRUE, // Include the high water mark in xTaskDetails.\n                eInvalid ); // Include the task state in xTaskDetails.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskGetInfo vTaskGetInfo\n @endcond\n \\ingroup TaskCtrl"]
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );\n @endcode\n @endcond\n\n INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Set the priority of any task.\n\n A context switch will occur before the function returns if the priority\n being set is higher than the currently executing task.\n\n @param xTask Handle to the task for which the priority is being set.\n Passing a NULL handle results in the priority of the calling task being set.\n\n @param uxNewPriority The priority to which the task will be set.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to raise the priority of the created task.\n   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n\n   // ...\n\n   // Use a NULL handle to raise our priority to the same value.\n   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskPrioritySet vTaskPrioritySet\n @endcond\n \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskSuspend( TaskHandle_t xTaskToSuspend );\n @endcode\n @endcond\n\n INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Suspend any task.  When suspended a task will never get any microcontroller\n processing time, no matter what its priority.\n\n Calls to vTaskSuspend are not accumulative -\n i.e. calling vTaskSuspend () twice on the same task still only requires one\n call to vTaskResume () to ready the suspended task.\n\n @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n handle will cause the calling task to be suspended.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Suspend ourselves.\n   vTaskSuspend( NULL );\n\n   // We cannot get here unless another task calls vTaskResume\n   // with our handle as the parameter.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskSuspend vTaskSuspend\n @endcond\n \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskResume( TaskHandle_t xTaskToResume );\n @endcode\n @endcond\n\n INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Resumes a suspended task.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n vTaskResume ().\n\n @param xTaskToResume Handle to the task being readied.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Resume the suspended task ourselves.\n   vTaskResume( xHandle );\n\n   // The created task will once again get microcontroller processing\n   // time in accordance with its priority within the system.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskResume vTaskResume\n @endcond\n \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void xTaskResumeFromISR( TaskHandle_t xTaskToResume );\n @endcode\n @endcond\n\n INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n available.  See the configuration section for more information.\n\n An implementation of vTaskResume() that can be called from within an ISR.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n xTaskResumeFromISR ().\n\n xTaskResumeFromISR() should not be used to synchronise a task with an\n interrupt if there is a chance that the interrupt could arrive prior to the\n task being suspended - as this can lead to interrupts being missed. Use of a\n semaphore as a synchronisation mechanism would avoid this eventuality.\n\n @param xTaskToResume Handle to the task being readied.\n\n @return pdTRUE if resuming the task should result in a context switch,\n otherwise pdFALSE. This is used by the ISR to determine if a context switch\n may be required following the ISR.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskResumeFromISR vTaskResumeFromISR\n @endcond\n \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION */\n/**\n @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskStartScheduler( void );\n @endcode\n @endcond\n\n Starts the real time kernel tick processing.  After calling the kernel\n has control over which tasks are executed and when.\n\n NOTE: In ESP-IDF the scheduler is started automatically during\n application startup, vTaskStartScheduler() should not be called from\n ESP-IDF applications.\n\n See the demo application file main.c for an example of creating\n tasks and starting the kernel.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will not get here unless a task calls vTaskEndScheduler ()\n }\n @endcode\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskStartScheduler vTaskStartScheduler\n @endcond\n \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskEndScheduler( void );\n @endcode\n @endcond\n\n NOTE:  At the time of writing only the x86 real mode port, which runs on a PC\n in place of DOS, implements this function.\n\n Stops the real time kernel tick.  All created tasks will be automatically\n deleted and multitasking (either preemptive or cooperative) will\n stop.  Execution then resumes from the point where vTaskStartScheduler ()\n was called, as if vTaskStartScheduler () had just returned.\n\n See the demo application file main. c in the demo/PC directory for an\n example that uses vTaskEndScheduler ().\n\n vTaskEndScheduler () requires an exit function to be defined within the\n portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n performs hardware specific operations such as stopping the kernel tick.\n\n vTaskEndScheduler () will cause all of the resources allocated by the\n kernel to be freed - but will not free resources allocated by application\n tasks.\n\n Example usage:\n @code{c}\n void vTaskCode( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // At some point we want to end the real time kernel processing\n       // so call ...\n       vTaskEndScheduler ();\n   }\n }\n\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will only get here when the vTaskCode () task has called\n   // vTaskEndScheduler ().  When we get here we are back to single task\n   // execution.\n }\n @endcode\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskEndScheduler vTaskEndScheduler\n @endcond\n \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskSuspendAll( void );\n @endcode\n @endcond\n\n Suspends the scheduler without disabling interrupts.  Context switches will\n not occur while the scheduler is suspended.\n\n After calling vTaskSuspendAll () the calling task will continue to execute\n without risk of being swapped out until a call to xTaskResumeAll () has been\n made.\n\n API functions that have the potential to cause a context switch (for example,\n vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n is suspended.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the kernel\n       // tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.\n       xTaskResumeAll ();\n   }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskSuspendAll vTaskSuspendAll\n @endcond\n \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskResumeAll( void );\n @endcode\n @endcond\n\n Resumes scheduler activity after it was suspended by a call to\n vTaskSuspendAll().\n\n xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n that were previously suspended by a call to vTaskSuspend().\n\n @return If resuming the scheduler caused a context switch then pdTRUE is\n         returned, otherwise pdFALSE is returned.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the real\n       // time kernel tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.  We want to force\n       // a context switch - but there is no point if resuming the scheduler\n       // caused a context switch already.\n       if( !xTaskResumeAll () )\n       {\n            taskYIELD ();\n       }\n   }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskResumeAll xTaskResumeAll\n @endcond\n \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n TickType_t xTaskGetTickCount( void );\n @endcode\n @endcond\n\n @return The count of ticks since vTaskStartScheduler was called.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskGetTickCount xTaskGetTickCount\n @endcond\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n TickType_t xTaskGetTickCountFromISR( void );\n @endcode\n @endcond\n\n @return The count of ticks since vTaskStartScheduler was called.\n\n This is a version of xTaskGetTickCount() that is safe to be called from an\n ISR - provided that TickType_t is the natural word size of the\n microcontroller being used or interrupt nesting is either not supported or\n not being used.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR\n @endcond\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n uint16_t uxTaskGetNumberOfTasks( void );\n @endcode\n @endcond\n\n @return The number of tasks that the real time kernel is currently managing.\n This includes all ready, blocked and suspended tasks.  A task that\n has been deleted but not yet freed by the idle task will also be\n included in the count.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks\n @endcond\n \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n char *pcTaskGetName( TaskHandle_t xTaskToQuery );\n @endcode\n @endcond\n\n @return The text (human readable) name of the task referenced by the handle\n xTaskToQuery.  A task can query its own name by either passing in its own\n handle, or by setting xTaskToQuery to NULL.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup pcTaskGetName pcTaskGetName\n @endcond\n \\ingroup TaskUtils"]
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );\n @endcode\n @endcond\n\n NOTE:  This function takes a relatively long time to complete and should be\n used sparingly.\n\n @return The handle of the task that has the human readable name pcNameToQuery.\n NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle\n must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup pcTaskGetHandle pcTaskGetHandle\n @endcond\n \\ingroup TaskUtils"]
    pub fn xTaskGetHandle(pcNameToQuery: *const ::core::ffi::c_char) -> TaskHandle_t;
}
extern "C" {
    #[doc = " Returns the high water mark of the stack associated with xTask.\n\n INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n this function to be available.\n\n Returns the high water mark of the stack associated with xTask.  That is,\n the minimum free stack space there has been (in bytes not words, unlike vanilla\n FreeRTOS) since the task started.  The smaller the returned\n number the closer the task has come to overflowing its stack.\n\n uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the\n same except for their return type.  Using configSTACK_DEPTH_TYPE allows the\n user to determine the return type.  It gets around the problem of the value\n overflowing on 8-bit types without breaking backward compatibility for\n applications that expect an 8-bit return type.\n\n @param xTask Handle of the task associated with the stack to be checked.\n Set xTask to NULL to check the stack of the calling task.\n\n @return The smallest amount of free stack space there has been (in bytes not words,\n unlike vanilla FreeRTOS) since the task referenced by\n xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Returns the start of the stack associated with xTask.\n\n INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for\n this function to be available.\n\n Returns the high water mark of the stack associated with xTask.  That is,\n the minimum free stack space there has been (in words, so on a 32 bit machine\n a value of 1 means 4 bytes) since the task started.  The smaller the returned\n number the closer the task has come to overflowing its stack.\n\n uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the\n same except for their return type.  Using configSTACK_DEPTH_TYPE allows the\n user to determine the return type.  It gets around the problem of the value\n overflowing on 8-bit types without breaking backward compatibility for\n applications that expect an 8-bit return type.\n\n @param xTask Handle of the task associated with the stack to be checked.\n Set xTask to NULL to check the stack of the calling task.\n\n @return The smallest amount of free stack space there has been (in words, so\n actual spaces on the stack rather than bytes) since the task referenced by\n xTask was created."]
    pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u32;
}
extern "C" {
    #[doc = " Returns the start of the stack associated with xTask.\n\n INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n this function to be available.\n\n Returns the lowest stack memory address, regardless of whether the stack grows up or down.\n\n @param xTask Handle of the task associated with the stack returned.\n Set xTask to NULL to return the stack of the calling task.\n\n @return A pointer to the start of the stack."]
    pub fn pxTaskGetStackStart(xTask: TaskHandle_t) -> *mut u8;
}
extern "C" {
    #[doc = " Set local storage pointer specific to the given task.\n\n Each task contains an array of pointers that is dimensioned by the\n configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n The kernel does not use the pointers itself, so the application writer\n can use the pointers for any purpose they wish.\n\n @param xTaskToSet  Task to set thread local storage pointer for\n @param xIndex The index of the pointer to set, from 0 to\n               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n @param pvValue  Pointer value to set."]
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get local storage pointer specific to the given task.\n\n Each task contains an array of pointers that is dimensioned by the\n configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n The kernel does not use the pointers itself, so the application writer\n can use the pointers for any purpose they wish.\n\n @param xTaskToQuery  Task to get thread local storage pointer for\n @param xIndex The index of the pointer to get, from 0 to\n               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n @return  Pointer value"]
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut ::core::ffi::c_void;
}
#[doc = " Prototype of local storage pointer deletion callback."]
pub type TlsDeleteCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = " Set local storage pointer and deletion callback.\n\n Each task contains an array of pointers that is dimensioned by the\n configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n The kernel does not use the pointers itself, so the application writer\n can use the pointers for any purpose they wish.\n\n Local storage pointers set for a task can reference dynamically\n allocated resources. This function is similar to\n vTaskSetThreadLocalStoragePointer, but provides a way to release\n these resources when the task gets deleted. For each pointer,\n a callback function can be set. This function will be called\n when task is deleted, with the local storage pointer index\n and value as arguments.\n\n @param xTaskToSet  Task to set thread local storage pointer for\n @param xIndex The index of the pointer to set, from 0 to\n               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n @param pvValue  Pointer value to set.\n @param pvDelCallback  Function to call to dispose of the local\n                       storage pointer when the task is deleted."]
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n void vApplicationStackOverflowHook( TaskHandle_t xTask char *pcTaskName);\n @endcode\n @endcond\n The application stack overflow hook is called when a stack overflow is detected for a task.\n\n Details on stack overflow detection can be found here: https://www.FreeRTOS.org/Stacks-and-stack-overflow-checking.html\n\n @param xTask the task that just exceeded its stack boundaries.\n @param pcTaskName A character string containing the name of the offending task."]
    pub fn vApplicationStackOverflowHook(xTask: TaskHandle_t, pcTaskName: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )\n @endcode\n @endcond\n This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer\n @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for thie idle task\n @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetIdleTaskMemory(
        ppxIdleTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxIdleTaskStackBuffer: *mut *mut StackType_t,
        pulIdleTaskStackSize: *mut u32,
    );
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );\n @endcode\n @endcond\n\n Calls the hook function associated with xTask.  Passing xTask as NULL has\n the effect of calling the Running tasks (the calling task) hook function.\n\n @param xTask  Handle of the task to call the hook for.\n @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n wants.  The return value is the value returned by the task hook function\n registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xTaskGetIdleTaskHandle() is only available if\n INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n\n Simply returns the handle of the idle task.  It is not valid to call\n xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n uxTaskGetSystemState() to be available.\n\n uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n the system.  TaskStatus_t structures contain, among other things, members\n for the task handle, task name, task priority, task state, and total amount\n of run time consumed by the task.  See the TaskStatus_t structure\n definition in this file for the full member list.\n\n NOTE: This function is intended for debugging use only as its use results in\n the scheduler remaining suspended for an extended period.\n\n @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n The array must contain at least one TaskStatus_t structure for each task\n that is under the control of the RTOS.  The number of tasks under the control\n of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n\n @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n parameter.  The size is specified as the number of indexes in the array, or\n the number of TaskStatus_t structures contained in the array, not by the\n number of bytes in the array.\n\n @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n total run time (as defined by the run time stats clock, see\n https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted.\n pulTotalRunTime can be set to NULL to omit the total run time information.\n\n @return The number of TaskStatus_t structures that were populated by\n uxTaskGetSystemState().  This should equal the number returned by the\n uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n in the uxArraySize parameter was too small.\n\n Example usage:\n @code{c}\n  // This example demonstrates how a human readable table of run time stats\n  // information is generated from raw data provided by uxTaskGetSystemState().\n  // The human readable table is written to pcWriteBuffer\n  void vTaskGetRunTimeStats( char *pcWriteBuffer )\n  {\n  TaskStatus_t *pxTaskStatusArray;\n  volatile UBaseType_t uxArraySize, x;\n  uint32_t ulTotalRunTime, ulStatsAsPercentage;\n\n      // Make sure the write buffer does not contain a string.\n *pcWriteBuffer = 0x00;\n\n      // Take a snapshot of the number of tasks in case it changes while this\n      // function is executing.\n      uxArraySize = uxTaskGetNumberOfTasks();\n\n      // Allocate a TaskStatus_t structure for each task.  An array could be\n      // allocated statically at compile time.\n      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n\n      if( pxTaskStatusArray != NULL )\n      {\n          // Generate raw status information about each task.\n          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n\n          // For percentage calculations.\n          ulTotalRunTime /= 100UL;\n\n          // Avoid divide by zero errors.\n          if( ulTotalRunTime > 0 )\n          {\n              // For each populated position in the pxTaskStatusArray array,\n              // format the raw data as human readable ASCII data\n              for( x = 0; x < uxArraySize; x++ )\n              {\n                  // What percentage of the total run time has the task used?\n                  // This will always be rounded down to the nearest integer.\n                  // ulTotalRunTimeDiv100 has already been divided by 100.\n                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n\n                  if( ulStatsAsPercentage > 0UL )\n                  {\n                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n                  }\n                  else\n                  {\n                      // If the percentage is zero here then the task has\n                      // consumed less than 1% of the total run time.\n                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n                  }\n\n                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n              }\n          }\n\n          // The array is no longer needed, free the memory it consumes.\n          vPortFree( pxTaskStatusArray );\n      }\n  }\n  @endcode"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " List all the current tasks.\n\n configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n both be defined as 1 for this function to be available.  See the\n configuration section of the FreeRTOS.org website for more information.\n\n NOTE 1: This function will disable interrupts for its duration.  It is\n not intended for normal application runtime use but as a debug aid.\n\n Lists all the current tasks, along with their current state and stack\n usage high water mark.\n\n Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n suspended ('S').\n\n PLEASE NOTE:\n\n This function is provided for convenience only, and is used by many of the\n demo applications.  Do not consider it to be part of the scheduler.\n\n vTaskList() calls uxTaskGetSystemState(), then formats part of the\n uxTaskGetSystemState() output into a human readable table that displays task\n names, states and stack usage.\n\n vTaskList() has a dependency on the sprintf() C library function that might\n bloat the code size, use a lot of stack, and provide different results on\n different platforms.  An alternative, tiny, third party, and limited\n functionality implementation of sprintf() is provided in many of the\n FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n printf-stdarg.c does not provide a full snprintf() implementation!).\n\n It is recommended that production systems call uxTaskGetSystemState()\n directly to get access to raw stats data, rather than indirectly through a\n call to vTaskList().\n\n @param pcWriteBuffer A buffer into which the above mentioned details\n will be written, in ASCII form.  This buffer is assumed to be large\n enough to contain the generated report.  Approximately 40 bytes per\n task should be sufficient.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskList vTaskList\n @endcond\n \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Get the state of running tasks as a string\n\n configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n must both be defined as 1 for this function to be available.  The application\n must also then provide definitions for\n portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n to configure a peripheral timer/counter and return the timers current count\n value respectively.  The counter should be at least 10 times the frequency of\n the tick count.\n\n NOTE 1: This function will disable interrupts for its duration.  It is\n not intended for normal application runtime use but as a debug aid.\n\n Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n accumulated execution time being stored for each task.  The resolution\n of the accumulated time value depends on the frequency of the timer\n configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n Calling vTaskGetRunTimeStats() writes the total execution time of each\n task into a buffer, both as an absolute count value and as a percentage\n of the total system execution time.\n\n NOTE 2:\n\n This function is provided for convenience only, and is used by many of the\n demo applications.  Do not consider it to be part of the scheduler.\n\n vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n uxTaskGetSystemState() output into a human readable table that displays the\n amount of time each task has spent in the Running state in both absolute and\n percentage terms.\n\n vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n that might bloat the code size, use a lot of stack, and provide different\n results on different platforms.  An alternative, tiny, third party, and\n limited functionality implementation of sprintf() is provided in many of the\n FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n printf-stdarg.c does not provide a full snprintf() implementation!).\n\n It is recommended that production systems call uxTaskGetSystemState() directly\n to get access to raw stats data, rather than indirectly through a call to\n vTaskGetRunTimeStats().\n\n @param pcWriteBuffer A buffer into which the execution times will be\n written, in ASCII form.  This buffer is assumed to be large enough to\n contain the generated report.  Approximately 40 bytes per task should\n be sufficient.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats\n @endcond\n \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code\n uint32_t ulTaskGetIdleRunTimeCounter( void );\n @endcode\n @endcond\n\n configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n must both be defined as 1 for this function to be available.  The application\n must also then provide definitions for\n portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n to configure a peripheral timer/counter and return the timers current count\n value respectively.  The counter should be at least 10 times the frequency of\n the tick count.\n\n Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n accumulated execution time being stored for each task.  The resolution\n of the accumulated time value depends on the frequency of the timer\n configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total\n execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()\n returns the total execution time of just the idle task.\n\n @return The total run time of the idle task.  This is the amount of time the\n idle task has actually been executing.  The unit of time is dependent on the\n frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and\n portGET_RUN_TIME_COUNTER_VALUE() macros.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter\n @endcond\n \\ingroup TaskUtils"]
    pub fn ulTaskGetIdleRunTimeCounter() -> u32;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );\n BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n @endcode\n @endcond\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Sends a direct to task notification to a task, with an optional value and\n action.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotify() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()\n with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does\n not have this parameter and always sends notifications to index 0.\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The target notification value is bitwise ORed with ulValue.\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eIncrement -\n The target notification value is incremented.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The target notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification at the\n same array index (the task already had a notification pending at that index).\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending at the\n same array index then the target notification value is set to ulValue and\n xTaskNotifyIndexed() will return pdPASS.  If the task being notified already\n had a notification pending at the same array index then no action is\n performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification at the specified array index without the\n notification value at that index being updated.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n @param pulPreviousNotificationValue -\n Can be used to pass out the subject task's notification value before any\n bits are modified by the notify function.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskNotifyIndexed xTaskNotifyIndexed\n @endcond\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n A version of xTaskNotifyIndexed() that can be used from an interrupt service\n routine (ISR).\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyFromISR() is equivalent to calling\n xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()\n does not have this parameter and always sends notifications to index 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The task's notification value is bitwise ORed with ulValue.  xTaskNotify()\n always returns pdPASS in this case.\n\n eIncrement -\n The task's notification value is incremented.  ulValue is not used and\n xTaskNotify() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The task's notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification (the\n task already had a notification pending).  xTaskNotify() always returns\n pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending then\n the task's notification value is set to ulValue and xTaskNotify() will\n return pdPASS.  If the task being notified already had a notification\n pending then no action is performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification without its notification value being\n updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n this case.\n\n @param pulPreviousNotificationValue -\n Can be used to pass out the subject task's notification value before any\n bits are modified by the notify function.\n\n @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR\n @endcond\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n @endcode\n @endcond\n\n Waits for a direct to task notification to be pending at a given index within\n an array of direct to task notifications.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyWait() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotifyWait() is equivalent to calling\n xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be received.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does\n not have this parameter and always waits for notifications on index 0.\n\n @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n will be cleared in the calling task's notification value before the task is\n marked as waiting for a new notification (provided a notification is not\n already pending). Optionally blocks if no notifications are pending. Setting\n ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n (if limits.h is not included) will have the effect of resetting the task's\n notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the\n task's notification value unchanged.\n\n @param ulBitsToClearOnExit If a notification is pending or received before\n the calling task exits the xTaskNotifyWait() function then the task's\n notification value (see the xTaskNotify() API function) is passed out using\n the pulNotificationValue parameter.  Then any bits that are set in\n ulBitsToClearOnExit will be cleared in the task's notification value (note\n *pulNotificationValue is set before any bits are cleared).  Setting\n ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n (if limits.h is not included) will have the effect of resetting the task's\n notification value to 0 before the function exits.  Setting\n ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n when the function exits (in which case the value passed out in\n pulNotificationValue will match the task's notification value).\n\n @param pulNotificationValue Used to pass the task's notification value out\n of the function.  Note the value passed out will not be effected by the\n clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for a notification to be received, should a notification\n not already be pending when xTaskNotifyWait() was called.  The task\n will not consume any processing time while it is in the Blocked state.  This\n is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be\n used to convert a time specified in milliseconds to a time specified in\n ticks.\n\n @return If a notification was received (including notifications that were\n already pending when xTaskNotifyWait was called) then pdPASS is\n returned.  Otherwise pdFAIL is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed\n @endcond\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n A version of xTaskNotifyGiveIndexed() that can be called from an interrupt\n service routine (ISR).\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications\n are used as light weight and faster binary or counting semaphore equivalents.\n Actual FreeRTOS semaphores are given from an ISR using the\n xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n a task notification is vTaskNotifyGiveIndexedFromISR().\n\n When task notifications are being used as a binary or counting semaphore\n equivalent then the task being notified should wait for the notification\n using the ulTaskNotificationTakeIndexed() API function rather than the\n xTaskNotifyWaitIndexed() API function.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling\n xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n xTaskNotifyGiveFromISR() does not have this parameter and always sends\n notifications to index 0.\n\n @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n should be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR\n @endcond\n \\ingroup TaskNotifications"]
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n @endcode\n @endcond\n\n Waits for a direct to task notification on a particular index in the calling\n task's notification array in a manner similar to taking a counting semaphore.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n ulTaskNotifyTakeIndexed() is intended for use when a task notification is\n used as a faster and lighter weight binary or counting semaphore alternative.\n Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,\n the equivalent action that instead uses a task notification is\n ulTaskNotifyTakeIndexed().\n\n When a task is using its notification value as a binary or counting semaphore\n other tasks should send notifications to it using the xTaskNotifyGiveIndexed()\n macro, or xTaskNotifyIndex() function with the eAction parameter set to\n eIncrement.\n\n ulTaskNotifyTakeIndexed() can either clear the task's notification value at\n the array index specified by the uxIndexToWaitOn parameter to zero on exit,\n in which case the notification value acts like a binary semaphore, or\n decrement the notification value on exit, in which case the notification\n value acts like a counting semaphore.\n\n A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for\n the task's notification value to be non-zero.  The task does not consume any\n CPU time while it is in the Blocked state.\n\n Where as xTaskNotifyWaitIndexed() will return when a notification is pending,\n ulTaskNotifyTakeIndexed() will return when the task's notification value is\n not zero.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyTake() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling ulTaskNotifyTake() is equivalent to calling\n ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be non-zero.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does\n not have this parameter and always waits for notifications on index 0.\n\n @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n notification value is decremented when the function exits.  In this way the\n notification value acts like a counting semaphore.  If xClearCountOnExit is\n not pdFALSE then the task's notification value is cleared to zero when the\n function exits.  In this way the notification value acts like a binary\n semaphore.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for the task's notification value to be greater than zero,\n should the count not already be greater than zero when\n ulTaskNotifyTake() was called.  The task will not consume any processing\n time while it is in the Blocked state.  This is specified in kernel ticks,\n the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time\n specified in milliseconds to a time specified in ticks.\n\n @return The task's notification count before it is either cleared to zero or\n decremented (see the xClearCountOnExit parameter).\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed\n @endcond\n \\ingroup TaskNotifications"]
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );\n\n BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );\n @endcode\n @endcond\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n If a notification is sent to an index within the array of notifications then\n the notification at that index is said to be 'pending' until it is read or\n explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()\n is the function that clears a pending notification without reading the\n notification value.  The notification value at the same array index is not\n altered.  Set xTask to NULL to clear the notification state of the calling\n task.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyStateClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyStateClear() is equivalent to calling\n xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have a notification state\n cleared.  Set xTask to NULL to clear a notification state in the calling\n task.  To obtain a task's handle create the task using xTaskCreate() and\n make use of the pxCreatedTask parameter, or create the task using\n xTaskCreateStatic() and store the returned value, or use the task's name in\n a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values to act upon.  For example, setting uxIndexToClear to 1\n will clear the state of the notification at index 1 within the array.\n uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyStateClear() does not have this parameter and always acts on the\n notification at index 0.\n\n @return pdTRUE if the task's notification state was set to\n eNotWaitingNotification, otherwise pdFALSE.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed\n @endcond\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task. h\n @code{c}\n uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );\n\n uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );\n @endcode\n @endcond\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n ulTaskNotifyValueClearIndexed() clears the bits specified by the\n ulBitsToClear bit mask in the notification value at array index uxIndexToClear\n of the task referenced by xTask.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyValueClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling ulTaskNotifyValueClear() is equivalent to calling\n ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have bits in one of its\n notification values cleared. Set xTask to NULL to clear bits in a\n notification value of the calling task.  To obtain a task's handle create the\n task using xTaskCreate() and make use of the pxCreatedTask parameter, or\n create the task using xTaskCreateStatic() and store the returned value, or\n use the task's name in a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values in which to clear the bits.  uxIndexToClear\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyValueClear() does not have this parameter and always clears bits\n in the notification value at index 0.\n\n @param ulBitsToClear Bit mask of the bits to clear in the notification value of\n xTask. Set a bit to 1 to clear the corresponding bits in the task's notification\n value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear\n the notification value to 0.  Set ulBitsToClear to 0 to query the task's\n notification value without clearing any bits.\n\n\n @return The value of the target task's notification value before the bits\n specified by ulBitsToClear were cleared.\n @cond !DOC_SINGLE_GROUP\n \\defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear\n @endcond\n \\ingroup TaskNotifications"]
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );\n @endcode\n @endcond\n\n Capture the current time for future use with xTaskCheckForTimeOut().\n\n @param pxTimeOut Pointer to a timeout object into which the current time\n is to be captured.  The captured time includes the tick count and the number\n of times the tick count has overflowed since the system first booted.\n \\defgroup vTaskSetTimeOutState vTaskSetTimeOutState\n @cond !DOC_SINGLE_GROUP\n \\ingroup TaskCtrl\n @endcond"]
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code\n BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );\n @endcode\n @endcond\n\n Determines if pxTicksToWait ticks has passed since a time was captured\n using a call to vTaskSetTimeOutState().  The captured time includes the tick\n count and the number of times the tick count has overflowed.\n\n @param pxTimeOut The time status as captured previously using\n vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated\n to reflect the current time status.\n @param pxTicksToWait The number of ticks to check for timeout i.e. if\n pxTicksToWait ticks have passed since pxTimeOut was last updated (either by\n vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.\n If the timeout has not occurred, pxTicksToWait is updated to reflect the\n number of remaining ticks.\n\n @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is\n returned and pxTicksToWait is updated to reflect the number of remaining\n ticks.\n\n @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html\n\n Example Usage:\n @code\n  // Driver library function used to receive uxWantedBytes from an Rx buffer\n  // that is filled by a UART interrupt. If there are not enough bytes in the\n  // Rx buffer then the task enters the Blocked state until it is notified that\n  // more data has been placed into the buffer. If there is still not enough\n  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()\n  // is used to re-calculate the Block time to ensure the total amount of time\n  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This\n  // continues until either the buffer contains at least uxWantedBytes bytes,\n  // or the total amount of time spent in the Blocked state reaches\n  // MAX_TIME_TO_WAIT – at which point the task reads however many bytes are\n  // available up to a maximum of uxWantedBytes.\n\n  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )\n  {\n  size_t uxReceived = 0;\n  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;\n  TimeOut_t xTimeOut;\n\n      // Initialize xTimeOut.  This records the time at which this function\n      // was entered.\n      vTaskSetTimeOutState( &xTimeOut );\n\n      // Loop until the buffer contains the wanted number of bytes, or a\n      // timeout occurs.\n      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )\n      {\n          // The buffer didn't contain enough data so this task is going to\n          // enter the Blocked state. Adjusting xTicksToWait to account for\n          // any time that has been spent in the Blocked state within this\n          // function so far to ensure the total amount of time spent in the\n          // Blocked state does not exceed MAX_TIME_TO_WAIT.\n          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )\n          {\n              //Timed out before the wanted number of bytes were available,\n              // exit the loop.\n              break;\n          }\n\n          // Wait for a maximum of xTicksToWait ticks to be notified that the\n          // receive interrupt has placed more data into the buffer.\n          ulTaskNotifyTake( pdTRUE, xTicksToWait );\n      }\n\n      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.\n      // The actual number of bytes read (which might be less than\n      // uxWantedBytes) is returned.\n      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,\n                                                  pucBuffer,\n                                                  uxWantedBytes );\n\n      return uxReceived;\n  }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut\n @endcond\n \\ingroup TaskCtrl"]
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );\n @endcode\n @endcond\n\n This function corrects the tick count value after the application code has held\n interrupts disabled for an extended period resulting in tick interrupts having\n been missed.\n\n This function is similar to vTaskStepTick(), however, unlike\n vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a\n time at which a task should be removed from the blocked state.  That means\n tasks may have to be removed from the blocked state as the tick count is\n moved.\n\n @param xTicksToCatchUp The number of tick interrupts that have been missed due to\n interrupts being disabled.  Its value is not computed automatically, so must be\n computed by the application writer.\n\n @return pdTRUE if moving the tick count forward resulted in a task leaving the\n blocked state and a context switch being performed.  Otherwise pdFALSE.\n\n \\defgroup xTaskCatchUpTicks xTaskCatchUpTicks\n @cond !DOC_SINGLE_GROUP\n \\ingroup TaskCtrl\n @endcond"]
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTaskGetCurrentTaskHandleForCPU(cpuid: BaseType_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the given CPU.\n\n xTaskGetIdleTaskHandleForCPU() is only available if\n INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n\n @param cpuid The CPU to get the handle for\n\n @return Idle task handle of a given cpu. It is not valid to call\n xTaskGetIdleTaskHandleForCPU() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandleForCPU(cpuid: UBaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetAffinity(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTickOtherCores() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn vTaskTakeEventListLock();
}
extern "C" {
    pub fn vTaskReleaseEventListLock();
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[doc = " @brief Task Watchdog Timer (TWDT) configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_task_wdt_config_t {
    #[doc = "< TWDT timeout duration in milliseconds"]
    pub timeout_ms: u32,
    #[doc = "< Mask of the cores who's idle task should be subscribed on initialization"]
    pub idle_core_mask: u32,
    #[doc = "< Trigger panic when timeout occurs"]
    pub trigger_panic: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_task_wdt_user_handle_s {
    _unused: [u8; 0],
}
#[doc = " @brief Task Watchdog Timer (TWDT) user handle"]
pub type esp_task_wdt_user_handle_t = *mut esp_task_wdt_user_handle_s;
extern "C" {
    #[doc = " @brief  Initialize the Task Watchdog Timer (TWDT)\n\n This function configures and initializes the TWDT. This function will subscribe the idle tasks if\n configured to do so. For other tasks, users can subscribe them using esp_task_wdt_add() or esp_task_wdt_add_user().\n This function won't start the timer if no task have been registered yet.\n\n @note esp_task_wdt_init() must only be called after the scheduler is started. Moreover, it must not be called by\n       multiple tasks simultaneously.\n @param[in] config Configuration structure\n @return\n  - ESP_OK: Initialization was successful\n  - ESP_ERR_INVALID_STATE: Already initialized\n  - Other: Failed to initialize TWDT"]
    pub fn esp_task_wdt_init(config: *const esp_task_wdt_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the Task Watchdog Timer (TWDT)\n\n The function reconfigures the running TWDT. It must already be initialized when this function is called.\n\n @note esp_task_wdt_reconfigure() must not be called by multiple tasks simultaneously.\n\n @param[in] config Configuration structure\n\n @return\n  - ESP_OK: Reconfiguring was successful\n  - ESP_ERR_INVALID_STATE: TWDT not initialized yet\n  - Other: Failed to initialize TWDT"]
    pub fn esp_task_wdt_reconfigure(config: *const esp_task_wdt_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Deinitialize the Task Watchdog Timer (TWDT)\n\n This function will deinitialize the TWDT, and unsubscribe any idle tasks. Calling this function whilst other tasks\n are still subscribed to the TWDT, or when the TWDT is already deinitialized, will result in an error code being\n returned.\n\n @note esp_task_wdt_deinit() must not be called by multiple tasks simultaneously.\n @return\n  - ESP_OK: TWDT successfully deinitialized\n  - Other: Failed to deinitialize TWDT"]
    pub fn esp_task_wdt_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Subscribe a task to the Task Watchdog Timer (TWDT)\n\n This function subscribes a task to the TWDT. Each subscribed task must periodically call esp_task_wdt_reset() to\n prevent the TWDT from elapsing its timeout period. Failure to do so will result in a TWDT timeout.\n\n @param task_handle Handle of the task. Input NULL to subscribe the current running task to the TWDT\n @return\n  - ESP_OK: Successfully subscribed the task to the TWDT\n  - Other: Failed to subscribe task"]
    pub fn esp_task_wdt_add(task_handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Subscribe a user to the Task Watchdog Timer (TWDT)\n\n This function subscribes a user to the TWDT. A user of the TWDT is usually a function that needs to run\n periodically. Each subscribed user must periodically call esp_task_wdt_reset_user() to prevent the TWDT from elapsing\n its timeout period. Failure to do so will result in a TWDT timeout.\n\n @param[in] user_name String to identify the user\n @param[out] user_handle_ret Handle of the user\n @return\n  - ESP_OK: Successfully subscribed the user to the TWDT\n  - Other: Failed to subscribe user"]
    pub fn esp_task_wdt_add_user(
        user_name: *const ::core::ffi::c_char,
        user_handle_ret: *mut esp_task_wdt_user_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset the Task Watchdog Timer (TWDT) on behalf of the currently running task\n\n This function will reset the TWDT on behalf of the currently running task. Each subscribed task must periodically\n call this function to prevent the TWDT from timing out. If one or more subscribed tasks fail to reset the TWDT on\n their own behalf, a TWDT timeout will occur.\n\n @return\n  - ESP_OK: Successfully reset the TWDT on behalf of the currently running task\n  - Other: Failed to reset"]
    pub fn esp_task_wdt_reset() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset the Task Watchdog Timer (TWDT) on behalf of a user\n\n This function will reset the TWDT on behalf of a user. Each subscribed user must periodically call this function to\n prevent the TWDT from timing out. If one or more subscribed users fail to reset the TWDT on their own behalf, a TWDT\n timeout will occur.\n\n @param[in] user_handle User handle\n  - ESP_OK: Successfully reset the TWDT on behalf of the user\n  - Other: Failed to reset"]
    pub fn esp_task_wdt_reset_user(user_handle: esp_task_wdt_user_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unsubscribes a task from the Task Watchdog Timer (TWDT)\n\n This function will unsubscribe a task from the TWDT. After being unsubscribed, the task should no longer call\n esp_task_wdt_reset().\n\n @param[in] task_handle Handle of the task. Input NULL to unsubscribe the current running task.\n @return\n  - ESP_OK: Successfully unsubscribed the task from the TWDT\n  - Other: Failed to unsubscribe task"]
    pub fn esp_task_wdt_delete(task_handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unsubscribes a user from the Task Watchdog Timer (TWDT)\n\n This function will unsubscribe a user from the TWDT. After being unsubscribed, the user should no longer call\n esp_task_wdt_reset_user().\n\n @param[in] user_handle User handle\n @return\n  - ESP_OK: Successfully unsubscribed the user from the TWDT\n  - Other: Failed to unsubscribe user"]
    pub fn esp_task_wdt_delete_user(user_handle: esp_task_wdt_user_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Query whether a task is subscribed to the Task Watchdog Timer (TWDT)\n\n This function will query whether a task is currently subscribed to the TWDT, or whether the TWDT is initialized.\n\n @param[in] task_handle Handle of the task. Input NULL to query the current running task.\n @return:\n  - ESP_OK: The task is currently subscribed to the TWDT\n  - ESP_ERR_NOT_FOUND: The task is not subscribed\n  - ESP_ERR_INVALID_STATE: TWDT was never initialized"]
    pub fn esp_task_wdt_status(task_handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief User ISR callback placeholder\n\n This function is called by task_wdt_isr function (ISR for when TWDT times out). It can be defined in user code to\n handle TWDT events.\n\n @note It has the same limitations as the interrupt function. Do not use ESP_LOGx functions inside."]
    pub fn esp_task_wdt_isr_user_handler();
}
#[doc = "< ESP32 station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< ESP32 soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< ESP32 ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 2;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 3;
pub type esp_interface_t = ::core::ffi::c_uint;
pub const esp_mac_type_t_ESP_MAC_WIFI_STA: esp_mac_type_t = 0;
pub const esp_mac_type_t_ESP_MAC_WIFI_SOFTAP: esp_mac_type_t = 1;
pub const esp_mac_type_t_ESP_MAC_BT: esp_mac_type_t = 2;
pub const esp_mac_type_t_ESP_MAC_ETH: esp_mac_type_t = 3;
pub const esp_mac_type_t_ESP_MAC_IEEE802154: esp_mac_type_t = 4;
pub type esp_mac_type_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief  Set base MAC address with the MAC address which is stored in BLK3 of EFUSE or\n         external storage e.g. flash and EEPROM.\n\n Base MAC address is used to generate the MAC addresses used by network interfaces.\n\n If using a custom base MAC address, call this API before initializing any network interfaces.\n Refer to the ESP-IDF Programming Guide for details about how the Base MAC is used.\n\n @note Base MAC must be a unicast MAC (least significant bit of first byte must be zero).\n\n @note If not using a valid OUI, set the \"locally administered\" bit\n       (bit value 0x02 in the first byte) to avoid collisions.\n\n @param  mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG If mac is NULL or is not a unicast MAC"]
    pub fn esp_base_mac_addr_set(mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is set using esp_base_mac_addr_set.\n\n @note If no custom Base MAC has been set, this returns the pre-programmed Espressif base MAC address.\n\n @param  mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG mac is NULL\n         ESP_ERR_INVALID_MAC base MAC address has not been set"]
    pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which was previously written to BLK3 of EFUSE.\n\n Base MAC address is used to generate the MAC addresses used by the networking interfaces.\n This API returns the custom base MAC address which was previously written to EFUSE BLK3 in\n a specified format.\n\n Writing this EFUSE allows setting of a different (non-Espressif) base MAC address. It is also\n possible to store a custom base MAC address elsewhere, see esp_base_mac_addr_set() for details.\n\n @note This function is currently only supported on ESP32.\n\n @param  mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG mac is NULL\n         ESP_ERR_INVALID_MAC CUSTOM_MAC address has not been set, all zeros (for esp32-xx)\n         ESP_ERR_INVALID_VERSION An invalid MAC version field was read from BLK3 of EFUSE (for esp32)\n         ESP_ERR_INVALID_CRC An invalid MAC CRC was read from BLK3 of EFUSE (for esp32)"]
    pub fn esp_efuse_mac_get_custom(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is factory-programmed by Espressif in EFUSE.\n\n @param  mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG mac is NULL"]
    pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read base MAC address and set MAC address of the interface.\n\n This function first get base MAC address using esp_base_mac_addr_get().\n Then calculates the MAC address of the specific interface requested,\n refer to ESP-IDF Programming Guide for the algorithm.\n\n @param  mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n @param  type Type of MAC address to return\n\n @return ESP_OK on success"]
    pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Derive local MAC address from universal MAC address.\n\n This function copies a universal MAC address and then sets the \"locally\n administered\" bit (bit 0x2) in the first octet, creating a locally\n administered MAC address.\n\n If the universal MAC address argument is already a locally administered MAC\n address, then the first octet is XORed with 0x4 in order to create a different\n locally administered MAC address.\n\n @param  local_mac base MAC address, length: 6 bytes/8 bytes.\n         length: 6 bytes for MAC-48\n                 8 bytes for EUI-64(used for IEEE 802.15.4)\n @param  universal_mac  Source universal MAC address, length: 6 bytes.\n\n @return ESP_OK on success"]
    pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
pub type esp_freertos_idle_cb_t = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type esp_freertos_tick_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief  Register a callback to be called from the specified core's idle hook.\n         The callback should return true if it should be called by the idle hook\n         once per interrupt (or FreeRTOS tick), and return false if it should\n         be called repeatedly as fast as possible by the idle hook.\n\n @warning Idle callbacks MUST NOT, UNDER ANY CIRCUMSTANCES, CALL\n          A FUNCTION THAT MIGHT BLOCK.\n\n @param[in]  new_idle_cb     Callback to be called\n @param[in]  cpuid           id of the core\n\n @return\n     - ESP_OK:              Callback registered to the specified core's idle hook\n     - ESP_ERR_NO_MEM:      No more space on the specified core's idle hook to register callback\n     - ESP_ERR_INVALID_ARG: cpuid is invalid"]
    pub fn esp_register_freertos_idle_hook_for_cpu(
        new_idle_cb: esp_freertos_idle_cb_t,
        cpuid: UBaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Register a callback to the idle hook of the core that calls this function.\n         The callback should return true if it should be called by the idle hook\n         once per interrupt (or FreeRTOS tick), and return false if it should\n         be called repeatedly as fast as possible by the idle hook.\n\n @warning Idle callbacks MUST NOT, UNDER ANY CIRCUMSTANCES, CALL\n          A FUNCTION THAT MIGHT BLOCK.\n\n @param[in]  new_idle_cb     Callback to be called\n\n @return\n     - ESP_OK:         Callback registered to the calling core's idle hook\n     - ESP_ERR_NO_MEM: No more space on the calling core's idle hook to register callback"]
    pub fn esp_register_freertos_idle_hook(new_idle_cb: esp_freertos_idle_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Register a callback to be called from the specified core's tick hook.\n\n @param[in]  new_tick_cb     Callback to be called\n @param[in]  cpuid           id of the core\n\n @return\n     - ESP_OK:              Callback registered to specified core's tick hook\n     - ESP_ERR_NO_MEM:      No more space on the specified core's tick hook to register the callback\n     - ESP_ERR_INVALID_ARG: cpuid is invalid"]
    pub fn esp_register_freertos_tick_hook_for_cpu(
        new_tick_cb: esp_freertos_tick_cb_t,
        cpuid: UBaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Register a callback to be called from the calling core's tick hook.\n\n @param[in]  new_tick_cb     Callback to be called\n\n @return\n     - ESP_OK:         Callback registered to the calling core's tick hook\n     - ESP_ERR_NO_MEM: No more space on the calling core's tick hook to register the callback"]
    pub fn esp_register_freertos_tick_hook(new_tick_cb: esp_freertos_tick_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Unregister an idle callback from the idle hook of the specified core\n\n @param[in]  old_idle_cb     Callback to be unregistered\n @param[in]  cpuid           id of the core"]
    pub fn esp_deregister_freertos_idle_hook_for_cpu(
        old_idle_cb: esp_freertos_idle_cb_t,
        cpuid: UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief  Unregister an idle callback. If the idle callback is registered to\n         the idle hooks of both cores, the idle hook will be unregistered from\n         both cores\n\n @param[in]  old_idle_cb     Callback to be unregistered"]
    pub fn esp_deregister_freertos_idle_hook(old_idle_cb: esp_freertos_idle_cb_t);
}
extern "C" {
    #[doc = " @brief  Unregister a tick callback from the tick hook of the specified core\n\n @param[in]  old_tick_cb     Callback to be unregistered\n @param[in]  cpuid           id of the core"]
    pub fn esp_deregister_freertos_tick_hook_for_cpu(
        old_tick_cb: esp_freertos_tick_cb_t,
        cpuid: UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief  Unregister a tick callback. If the tick callback is registered to the\n         tick hooks of both cores, the tick hook will be unregistered from\n         both cores\n\n @param[in]  old_tick_cb     Callback to be unregistered"]
    pub fn esp_deregister_freertos_tick_hook(old_tick_cb: esp_freertos_tick_cb_t);
}
#[doc = " Type by which software timers are referenced.  For example, a call to\n xTimerCreate() returns an TimerHandle_t variable that can then be used to\n reference the subject timer in calls to other software timer API functions\n (for example, xTimerStart(), xTimerReset(), etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32)>;
extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const ::core::ffi::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
extern "C" {
    pub fn xTimerCreateStatic(
        pcTimerName: *const ::core::ffi::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
        pxTimerBuffer: *mut StaticTimer_t,
    ) -> TimerHandle_t;
}
extern "C" {
    #[doc = " void *pvTimerGetTimerID( TimerHandle_t xTimer );\n\n Returns the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer, and by calling the\n vTimerSetTimerID() API function.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being queried.\n\n @return The ID assigned to the timer being queried.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );\n\n Sets the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being updated.\n\n @param pvNewID The ID to assign to the timer.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );\n\n Queries a timer to see if it is active or dormant.\n\n A timer will be dormant if:\n     1) It has been created but not started, or\n     2) It is an expired one-shot timer that has not been restarted.\n\n Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),\n xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and\n xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the\n active state.\n\n @param xTimer The timer being queried.\n\n @return pdFALSE will be returned if the timer is dormant.  A value other than\n pdFALSE will be returned if the timer is active.\n\n Example usage:\n @verbatim\n // This function assumes xTimer has already been created.\n void vAFunction( TimerHandle_t xTimer )\n {\n     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\"\n     {\n         // xTimer is active, do something.\n     }\n     else\n     {\n         // xTimer is not active, do something else.\n     }\n }\n @endverbatim"]
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );\n\n Simply returns the handle of the timer service/daemon task.  It it not valid\n to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,\n                                          void *pvParameter1,\n                                          uint32_t ulParameter2,\n                                          BaseType_t *pxHigherPriorityTaskWoken );\n\n\n Used from application interrupt service routines to defer the execution of a\n function to the RTOS daemon task (the timer service task, hence this function\n is implemented in timers.c and is prefixed with 'Timer').\n\n Ideally an interrupt service routine (ISR) is kept as short as possible, but\n sometimes an ISR either has a lot of processing to do, or needs to perform\n processing that is not deterministic.  In these cases\n xTimerPendFunctionCallFromISR() can be used to defer processing of a function\n to the RTOS daemon task.\n\n A mechanism is provided that allows the interrupt to return directly to the\n task that will subsequently execute the pended callback function.  This\n allows the callback function to execute contiguously in time with the\n interrupt - just as if the callback had executed in the interrupt itself.\n\n @param xFunctionToPend The function to execute from the timer service/\n daemon task.  The function must conform to the PendedFunction_t\n prototype.\n\n @param pvParameter1 The value of the callback function's first parameter.\n The parameter has a void * type to allow it to be used to pass any type.\n For example, unsigned longs can be cast to a void *, or the void * can be\n used to point to a structure.\n\n @param ulParameter2 The value of the callback function's second parameter.\n\n @param pxHigherPriorityTaskWoken As mentioned above, calling this function\n will result in a message being sent to the timer daemon task.  If the\n priority of the timer daemon task (which is set using\n configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of\n the currently running task (the task the interrupt interrupted) then\n *pxHigherPriorityTaskWoken will be set to pdTRUE within\n xTimerPendFunctionCallFromISR(), indicating that a context switch should be\n requested before the interrupt exits.  For that reason\n *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the\n example code below.\n\n @return pdPASS is returned if the message was successfully sent to the\n timer daemon task, otherwise pdFALSE is returned.\n\n Example usage:\n @verbatim\n\n  // The callback function that will execute in the context of the daemon task.\n  // Note callback functions must all use this same prototype.\n  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )\n  {\n      BaseType_t xInterfaceToService;\n\n      // The interface that requires servicing is passed in the second\n      // parameter.  The first parameter is not used in this case.\n      xInterfaceToService = ( BaseType_t ) ulParameter2;\n\n      // ...Perform the processing here...\n  }\n\n  // An ISR that receives data packets from multiple interfaces\n  void vAnISR( void )\n  {\n      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;\n\n      // Query the hardware to determine which interface needs processing.\n      xInterfaceToService = prvCheckInterfaces();\n\n      // The actual processing is to be deferred to a task.  Request the\n      // vProcessInterface() callback function is executed, passing in the\n      // number of the interface that needs processing.  The interface to\n      // service is passed in the second parameter.  The first parameter is\n      // not used in this case.\n      xHigherPriorityTaskWoken = pdFALSE;\n      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );\n\n      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context\n      // switch should be requested.  The macro used is port specific and will\n      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to\n      // the documentation page for the port being used.\n      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n\n  }\n @endverbatim"]
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,\n                                    void *pvParameter1,\n                                    uint32_t ulParameter2,\n                                    TickType_t xTicksToWait );\n\n\n Used to defer the execution of a function to the RTOS daemon task (the timer\n service task, hence this function is implemented in timers.c and is prefixed\n with 'Timer').\n\n @param xFunctionToPend The function to execute from the timer service/\n daemon task.  The function must conform to the PendedFunction_t\n prototype.\n\n @param pvParameter1 The value of the callback function's first parameter.\n The parameter has a void * type to allow it to be used to pass any type.\n For example, unsigned longs can be cast to a void *, or the void * can be\n used to point to a structure.\n\n @param ulParameter2 The value of the callback function's second parameter.\n\n @param xTicksToWait Calling this function will result in a message being\n sent to the timer daemon task on a queue.  xTicksToWait is the amount of\n time the calling task should remain in the Blocked state (so not using any\n processing time) for space to become available on the timer queue if the\n queue is found to be full.\n\n @return pdPASS is returned if the message was successfully sent to the\n timer daemon task, otherwise pdFALSE is returned.\n"]
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " const char * const pcTimerGetName( TimerHandle_t xTimer );\n\n Returns the name that was assigned to a timer when the timer was created.\n\n @param xTimer The handle of the timer being queried.\n\n @return The name assigned to the timer specified by the xTimer parameter."]
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload );\n\n Updates a timer to be either an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being updated.\n\n @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will\n expire repeatedly with a frequency set by the timer's period (see the\n xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If\n uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and\n enter the dormant state after it expires."]
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, uxAutoReload: UBaseType_t);
}
extern "C" {
    #[doc = " UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );\n\n Queries a timer to determine if it is an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise\n pdFALSE is returned."]
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " TickType_t xTimerGetPeriod( TimerHandle_t xTimer );\n\n Returns the period of a timer.\n\n @param xTimer The handle of the timer being queried.\n\n @return The period of the timer in ticks."]
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );\n\n Returns the time in ticks at which the timer will expire.  If this is less\n than the current tick count then the expiry time has overflowed from the\n current time.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is running then the time in ticks at which the timer\n will next expire is returned.  If the timer is not running then the return\n value is undefined."]
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n task.h\n @code{c}\n void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t ** ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )\n @endcode\n @endcond\n\n This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer\n @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for thie idle task\n @param pulTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetTimerTaskMemory(
        ppxTimerTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxTimerTaskStackBuffer: *mut *mut StackType_t,
        pulTimerTaskStackSize: *mut u32,
    );
}
#[doc = " event_groups.h\n\n Type by which event groups are referenced.  For example, a call to\n xEventGroupCreate() returns an EventGroupHandle_t variable that can then\n be used as a parameter to other event group functions.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup EventGroupHandle_t EventGroupHandle_t\n @endcond\n \\ingroup EventGroup"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type EventBits_t = TickType_t;
extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
extern "C" {
    pub fn xEventGroupCreateStatic(
        pxEventGroupBuffer: *mut StaticEventGroup_t,
    ) -> EventGroupHandle_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  EventBits_t xEventGroupWaitBits(    EventGroupHandle_t xEventGroup,\n                                      const EventBits_t uxBitsToWaitFor,\n                                      const BaseType_t xClearOnExit,\n                                      const BaseType_t xWaitForAllBits,\n                                      const TickType_t xTicksToWait );\n @endcode\n @endcond\n\n [Potentially] block to wait for one or more bits to be set within a\n previously created event group.\n\n This function cannot be called from an interrupt.\n\n @param xEventGroup The event group in which the bits are being tested.  The\n event group must have previously been created using a call to\n xEventGroupCreate().\n\n @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test\n inside the event group.  For example, to wait for bit 0 and/or bit 2 set\n uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set\n uxBitsToWaitFor to 0x07.  Etc.\n\n @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within\n uxBitsToWaitFor that are set within the event group will be cleared before\n xEventGroupWaitBits() returns if the wait condition was met (if the function\n returns for a reason other than a timeout).  If xClearOnExit is set to\n pdFALSE then the bits set in the event group are not altered when the call to\n xEventGroupWaitBits() returns.\n\n @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then\n xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor\n are set or the specified block time expires.  If xWaitForAllBits is set to\n pdFALSE then xEventGroupWaitBits() will return when any one of the bits set\n in uxBitsToWaitFor is set or the specified block time expires.  The block\n time is specified by the xTicksToWait parameter.\n\n @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait\n for one/all (depending on the xWaitForAllBits value) of the bits specified by\n uxBitsToWaitFor to become set.\n\n @return The value of the event group at the time either the bits being waited\n for became set, or the block time expired.  Test the return value to know\n which bits were set.  If xEventGroupWaitBits() returned because its timeout\n expired then not all the bits being waited for will be set.  If\n xEventGroupWaitBits() returned because the bits it was waiting for were set\n then the returned value is the event group value before any bits were\n automatically cleared in the case that xClearOnExit parameter was set to\n pdTRUE.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;\n\n      // Wait a maximum of 100ms for either bit 0 or bit 4 to be set within\n      // the event group.  Clear the bits before exiting.\n      uxBits = xEventGroupWaitBits(\n                  xEventGroup,    // The event group being tested.\n                  BIT_0 | BIT_4,  // The bits within the event group to wait for.\n                  pdTRUE,         // BIT_0 and BIT_4 should be cleared before returning.\n                  pdFALSE,        // Don't wait for both bits, either bit will do.\n                  xTicksToWait ); // Wait a maximum of 100ms for either bit to be set.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // xEventGroupWaitBits() returned because both bits were set.\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // xEventGroupWaitBits() returned because just BIT_0 was set.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // xEventGroupWaitBits() returned because just BIT_4 was set.\n      }\n      else\n      {\n          // xEventGroupWaitBits() returned because xTicksToWait ticks passed\n          // without either BIT_0 or BIT_4 becoming set.\n      }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xEventGroupWaitBits xEventGroupWaitBits\n @endcond\n \\ingroup EventGroup"]
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );\n @endcode\n @endcond\n\n Clear bits within an event group.  This function cannot be called from an\n interrupt.\n\n @param xEventGroup The event group in which the bits are to be cleared.\n\n @param uxBitsToClear A bitwise value that indicates the bit or bits to clear\n in the event group.  For example, to clear bit 3 only, set uxBitsToClear to\n 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.\n\n @return The value of the event group before the specified bits were cleared.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n\n      // Clear bit 0 and bit 4 in xEventGroup.\n      uxBits = xEventGroupClearBits(\n                              xEventGroup,    // The event group being updated.\n                              BIT_0 | BIT_4 );// The bits being cleared.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // Both bit 0 and bit 4 were set before xEventGroupClearBits() was\n          // called.  Both will now be clear (not set).\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // Bit 0 was set before xEventGroupClearBits() was called.  It will\n          // now be clear.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // Bit 4 was set before xEventGroupClearBits() was called.  It will\n          // now be clear.\n      }\n      else\n      {\n          // Neither bit 0 nor bit 4 were set in the first place.\n      }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xEventGroupClearBits xEventGroupClearBits\n @endcond\n \\ingroup EventGroup"]
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );\n @endcode\n @endcond\n\n Set bits within an event group.\n This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()\n is a version that can be called from an interrupt.\n\n Setting bits in an event group will automatically unblock tasks that are\n blocked waiting for the bits.\n\n @param xEventGroup The event group in which the bits are to be set.\n\n @param uxBitsToSet A bitwise value that indicates the bit or bits to set.\n For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3\n and bit 0 set uxBitsToSet to 0x09.\n\n @return The value of the event group at the time the call to\n xEventGroupSetBits() returns.  There are two reasons why the returned value\n might have the bits specified by the uxBitsToSet parameter cleared.  First,\n if setting a bit results in a task that was waiting for the bit leaving the\n blocked state then it is possible the bit will be cleared automatically\n (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any\n unblocked (or otherwise Ready state) task that has a priority above that of\n the task that called xEventGroupSetBits() will execute and may change the\n event group value before the call to xEventGroupSetBits() returns.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n\n      // Set bit 0 and bit 4 in xEventGroup.\n      uxBits = xEventGroupSetBits(\n                          xEventGroup,    // The event group being updated.\n                          BIT_0 | BIT_4 );// The bits being set.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // Both bit 0 and bit 4 remained set when the function returned.\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // Bit 0 remained set when the function returned, but bit 4 was\n          // cleared.  It might be that bit 4 was cleared automatically as a\n          // task that was waiting for bit 4 was removed from the Blocked\n          // state.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // Bit 4 remained set when the function returned, but bit 0 was\n          // cleared.  It might be that bit 0 was cleared automatically as a\n          // task that was waiting for bit 0 was removed from the Blocked\n          // state.\n      }\n      else\n      {\n          // Neither bit 0 nor bit 4 remained set.  It might be that a task\n          // was waiting for both of the bits to be set, and the bits were\n          // cleared as the task left the Blocked state.\n      }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xEventGroupSetBits xEventGroupSetBits\n @endcond\n \\ingroup EventGroup"]
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,\n                                  const EventBits_t uxBitsToSet,\n                                  const EventBits_t uxBitsToWaitFor,\n                                  TickType_t xTicksToWait );\n @endcode\n @endcond\n\n Atomically set bits within an event group, then wait for a combination of\n bits to be set within the same event group.  This functionality is typically\n used to synchronise multiple tasks, where each task has to wait for the other\n tasks to reach a synchronisation point before proceeding.\n\n This function cannot be used from an interrupt.\n\n The function will return before its block time expires if the bits specified\n by the uxBitsToWait parameter are set, or become set within that time.  In\n this case all the bits specified by uxBitsToWait will be automatically\n cleared before the function returns.\n\n @param xEventGroup The event group in which the bits are being tested.  The\n event group must have previously been created using a call to\n xEventGroupCreate().\n\n @param uxBitsToSet The bits to set in the event group before determining\n if, and possibly waiting for, all the bits specified by the uxBitsToWait\n parameter are set.\n\n @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test\n inside the event group.  For example, to wait for bit 0 and bit 2 set\n uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set\n uxBitsToWaitFor to 0x07.  Etc.\n\n @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait\n for all of the bits specified by uxBitsToWaitFor to become set.\n\n @return The value of the event group at the time either the bits being waited\n for became set, or the block time expired.  Test the return value to know\n which bits were set.  If xEventGroupSync() returned because its timeout\n expired then not all the bits being waited for will be set.  If\n xEventGroupSync() returned because all the bits it was waiting for were\n set then the returned value is the event group value before any bits were\n automatically cleared.\n\n Example usage:\n @code{c}\n // Bits used by the three tasks.\n #define TASK_0_BIT      ( 1 << 0 )\n #define TASK_1_BIT      ( 1 << 1 )\n #define TASK_2_BIT      ( 1 << 2 )\n\n #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )\n\n // Use an event group to synchronise three tasks.  It is assumed this event\n // group has already been created elsewhere.\n EventGroupHandle_t xEventBits;\n\n void vTask0( void *pvParameters )\n {\n EventBits_t uxReturn;\n TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;\n\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 0 in the event flag to note this task has reached the\n      // sync point.  The other two tasks will set the other two bits defined\n      // by ALL_SYNC_BITS.  All three tasks have reached the synchronisation\n      // point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms\n      // for this to happen.\n      uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );\n\n      if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )\n      {\n          // All three tasks reached the synchronisation point before the call\n          // to xEventGroupSync() timed out.\n      }\n  }\n }\n\n void vTask1( void *pvParameters )\n {\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 1 in the event flag to note this task has reached the\n      // synchronisation point.  The other two tasks will set the other two\n      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the\n      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait\n      // indefinitely for this to happen.\n      xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );\n\n      // xEventGroupSync() was called with an indefinite block time, so\n      // this task will only reach here if the synchronisation was made by all\n      // three tasks, so there is no need to test the return value.\n   }\n }\n\n void vTask2( void *pvParameters )\n {\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 2 in the event flag to note this task has reached the\n      // synchronisation point.  The other two tasks will set the other two\n      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the\n      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait\n      // indefinitely for this to happen.\n      xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );\n\n      // xEventGroupSync() was called with an indefinite block time, so\n      // this task will only reach here if the synchronisation was made by all\n      // three tasks, so there is no need to test the return value.\n  }\n }\n\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xEventGroupSync xEventGroupSync\n @endcond\n \\ingroup EventGroup"]
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );\n @endcode\n @endcond\n\n A version of xEventGroupGetBits() that can be called from an ISR.\n\n @param xEventGroup The event group being queried.\n\n @return The event group bits at the time xEventGroupGetBitsFromISR() was called.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR\n @endcond\n \\ingroup EventGroup"]
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n event_groups.h\n @code{c}\n  void xEventGroupDelete( EventGroupHandle_t xEventGroup );\n @endcode\n @endcond\n\n Delete an event group that was previously created by a call to\n xEventGroupCreate().  Tasks that are blocked on the event group will be\n unblocked and obtain 0 as the event group's value.\n\n @param xEventGroup The event group being deleted."]
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut ::core::ffi::c_void, ulBitsToSet: u32);
}
extern "C" {
    pub fn vEventGroupClearBitsCallback(pvEventGroup: *mut ::core::ffi::c_void, ulBitsToClear: u32);
}
#[doc = " Type by which stream buffers are referenced.  For example, a call to\n xStreamBufferCreate() returns an StreamBufferHandle_t variable that can\n then be used as a parameter to xStreamBufferSend(), xStreamBufferReceive(),\n etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StreamBufferDef_t {
    _unused: [u8; 0],
}
pub type StreamBufferHandle_t = *mut StreamBufferDef_t;
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\n                        const void *pvTxData,\n                        size_t xDataLengthBytes,\n                        TickType_t xTicksToWait );\n @endcode\n @endcond\n\n Sends bytes to a stream buffer.  The bytes are copied into the stream buffer.\n\n ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\n implementation (so also the message buffer implementation, as message buffers\n are built on top of stream buffers) assumes there is only one task or\n interrupt that will write to the buffer (the writer), and only one task or\n interrupt that will read from the buffer (the reader).  It is safe for the\n writer and reader to be different tasks or interrupts, but, unlike other\n FreeRTOS objects, it is not safe to have multiple different writers or\n multiple different readers.  If there are to be multiple different writers\n then the application writer must place each call to a writing API function\n (such as xStreamBufferSend()) inside a critical section and set the send\n block time to 0.  Likewise, if there are to be multiple different readers\n then the application writer must place each call to a reading API function\n (such as xStreamBufferReceive()) inside a critical section and set the receive\n block time to 0.\n\n Use xStreamBufferSend() to write to a stream buffer from a task.  Use\n xStreamBufferSendFromISR() to write to a stream buffer from an interrupt\n service routine (ISR).\n\n @param xStreamBuffer The handle of the stream buffer to which a stream is\n being sent.\n\n @param pvTxData A pointer to the buffer that holds the bytes to be copied\n into the stream buffer.\n\n @param xDataLengthBytes   The maximum number of bytes to copy from pvTxData\n into the stream buffer.\n\n @param xTicksToWait The maximum amount of time the task should remain in the\n Blocked state to wait for enough space to become available in the stream\n buffer, should the stream buffer contain too little space to hold the\n another xDataLengthBytes bytes.  The block time is specified in tick periods,\n so the absolute time it represents is dependent on the tick frequency.  The\n macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds\n into a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will\n cause the task to wait indefinitely (without timing out), provided\n INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out\n before it can write all xDataLengthBytes into the buffer it will still write\n as many bytes as possible.  A task does not use any CPU time when it is in\n the blocked state.\n\n @return The number of bytes written to the stream buffer.  If a task times\n out before it can write all xDataLengthBytes into the buffer it will still\n write as many bytes as possible.\n\n Example use:\n @code{c}\n void vAFunction( StreamBufferHandle_t xStreamBuffer )\n {\n size_t xBytesSent;\n uint8_t ucArrayToSend[] = { 0, 1, 2, 3 };\n char *pcStringToSend = \"String to send\";\n const TickType_t x100ms = pdMS_TO_TICKS( 100 );\n\n  // Send an array to the stream buffer, blocking for a maximum of 100ms to\n  // wait for enough space to be available in the stream buffer.\n  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );\n\n  if( xBytesSent != sizeof( ucArrayToSend ) )\n  {\n      // The call to xStreamBufferSend() times out before there was enough\n      // space in the buffer for the data to be written, but it did\n      // successfully write xBytesSent bytes.\n  }\n\n  // Send the string to the stream buffer.  Return immediately if there is not\n  // enough space in the buffer.\n  xBytesSent = xStreamBufferSend( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );\n\n  if( xBytesSent != strlen( pcStringToSend ) )\n  {\n      // The entire string could not be added to the stream buffer because\n      // there was not enough free space in the buffer, but xBytesSent bytes\n      // were sent.  Could try again to send the remaining bytes.\n  }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferSend xStreamBufferSend\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferSend(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\n                               const void *pvTxData,\n                               size_t xDataLengthBytes,\n                               BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n Interrupt safe version of the API function that sends a stream of bytes to\n the stream buffer.\n\n ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\n implementation (so also the message buffer implementation, as message buffers\n are built on top of stream buffers) assumes there is only one task or\n interrupt that will write to the buffer (the writer), and only one task or\n interrupt that will read from the buffer (the reader).  It is safe for the\n writer and reader to be different tasks or interrupts, but, unlike other\n FreeRTOS objects, it is not safe to have multiple different writers or\n multiple different readers.  If there are to be multiple different writers\n then the application writer must place each call to a writing API function\n (such as xStreamBufferSend()) inside a critical section and set the send\n block time to 0.  Likewise, if there are to be multiple different readers\n then the application writer must place each call to a reading API function\n (such as xStreamBufferReceive()) inside a critical section and set the receive\n block time to 0.\n\n Use xStreamBufferSend() to write to a stream buffer from a task.  Use\n xStreamBufferSendFromISR() to write to a stream buffer from an interrupt\n service routine (ISR).\n\n @param xStreamBuffer The handle of the stream buffer to which a stream is\n being sent.\n\n @param pvTxData A pointer to the data that is to be copied into the stream\n buffer.\n\n @param xDataLengthBytes The maximum number of bytes to copy from pvTxData\n into the stream buffer.\n\n @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will\n have a task blocked on it waiting for data.  Calling\n xStreamBufferSendFromISR() can make data available, and so cause a task that\n was waiting for data to leave the Blocked state.  If calling\n xStreamBufferSendFromISR() causes a task to leave the Blocked state, and the\n unblocked task has a priority higher than the currently executing task (the\n task that was interrupted), then, internally, xStreamBufferSendFromISR()\n will set *pxHigherPriorityTaskWoken to pdTRUE.  If\n xStreamBufferSendFromISR() sets this value to pdTRUE, then normally a\n context switch should be performed before the interrupt is exited.  This will\n ensure that the interrupt returns directly to the highest priority Ready\n state task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it\n is passed into the function.  See the example code below for an example.\n\n @return The number of bytes actually written to the stream buffer, which will\n be less than xDataLengthBytes if the stream buffer didn't have enough free\n space for all the bytes to be written.\n\n Example use:\n @code{c}\n // A stream buffer that has already been created.\n StreamBufferHandle_t xStreamBuffer;\n\n void vAnInterruptServiceRoutine( void )\n {\n size_t xBytesSent;\n char *pcStringToSend = \"String to send\";\n BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.\n\n  // Attempt to send the string to the stream buffer.\n  xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,\n                                         ( void * ) pcStringToSend,\n                                         strlen( pcStringToSend ),\n                                         &xHigherPriorityTaskWoken );\n\n  if( xBytesSent != strlen( pcStringToSend ) )\n  {\n      // There was not enough free space in the stream buffer for the entire\n      // string to be written, ut xBytesSent bytes were written.\n  }\n\n  // If xHigherPriorityTaskWoken was set to pdTRUE inside\n  // xStreamBufferSendFromISR() then a task that has a priority above the\n  // priority of the currently executing task was unblocked and a context\n  // switch should be performed to ensure the ISR returns to the unblocked\n  // task.  In most FreeRTOS ports this is done by simply passing\n  // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the\n  // variables value, and perform the context switch if necessary.  Check the\n  // documentation for the port in use for port specific instructions.\n  taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferSendFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvTxData: *const ::core::ffi::c_void,
        xDataLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\n                           void *pvRxData,\n                           size_t xBufferLengthBytes,\n                           TickType_t xTicksToWait );\n @endcode\n @endcond\n\n Receives bytes from a stream buffer.\n\n ***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\n implementation (so also the message buffer implementation, as message buffers\n are built on top of stream buffers) assumes there is only one task or\n interrupt that will write to the buffer (the writer), and only one task or\n interrupt that will read from the buffer (the reader).  It is safe for the\n writer and reader to be different tasks or interrupts, but, unlike other\n FreeRTOS objects, it is not safe to have multiple different writers or\n multiple different readers.  If there are to be multiple different writers\n then the application writer must place each call to a writing API function\n (such as xStreamBufferSend()) inside a critical section and set the send\n block time to 0.  Likewise, if there are to be multiple different readers\n then the application writer must place each call to a reading API function\n (such as xStreamBufferReceive()) inside a critical section and set the receive\n block time to 0.\n\n Use xStreamBufferReceive() to read from a stream buffer from a task.  Use\n xStreamBufferReceiveFromISR() to read from a stream buffer from an\n interrupt service routine (ISR).\n\n @param xStreamBuffer The handle of the stream buffer from which bytes are to\n be received.\n\n @param pvRxData A pointer to the buffer into which the received bytes will be\n copied.\n\n @param xBufferLengthBytes The length of the buffer pointed to by the\n pvRxData parameter.  This sets the maximum number of bytes to receive in one\n call.  xStreamBufferReceive will return as many bytes as possible up to a\n maximum set by xBufferLengthBytes.\n\n @param xTicksToWait The maximum amount of time the task should remain in the\n Blocked state to wait for data to become available if the stream buffer is\n empty.  xStreamBufferReceive() will return immediately if xTicksToWait is\n zero.  The block time is specified in tick periods, so the absolute time it\n represents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can\n be used to convert a time specified in milliseconds into a time specified in\n ticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait\n indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1\n in FreeRTOSConfig.h.  A task does not use any CPU time when it is in the\n Blocked state.\n\n @return The number of bytes actually read from the stream buffer, which will\n be less than xBufferLengthBytes if the call to xStreamBufferReceive() timed\n out before xBufferLengthBytes were available.\n\n Example use:\n @code{c}\n void vAFunction( StreamBuffer_t xStreamBuffer )\n {\n uint8_t ucRxData[ 20 ];\n size_t xReceivedBytes;\n const TickType_t xBlockTime = pdMS_TO_TICKS( 20 );\n\n  // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.\n  // Wait in the Blocked state (so not using any CPU processing time) for a\n  // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be\n  // available.\n  xReceivedBytes = xStreamBufferReceive( xStreamBuffer,\n                                         ( void * ) ucRxData,\n                                         sizeof( ucRxData ),\n                                         xBlockTime );\n\n  if( xReceivedBytes > 0 )\n  {\n      // A ucRxData contains another xRecievedBytes bytes of data, which can\n      // be processed here....\n  }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferReceive xStreamBufferReceive\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferReceive(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        xTicksToWait: TickType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\n                                  void *pvRxData,\n                                  size_t xBufferLengthBytes,\n                                  BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n An interrupt safe version of the API function that receives bytes from a\n stream buffer.\n\n Use xStreamBufferReceive() to read bytes from a stream buffer from a task.\n Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an\n interrupt service routine (ISR).\n\n @param xStreamBuffer The handle of the stream buffer from which a stream\n is being received.\n\n @param pvRxData A pointer to the buffer into which the received bytes are\n copied.\n\n @param xBufferLengthBytes The length of the buffer pointed to by the\n pvRxData parameter.  This sets the maximum number of bytes to receive in one\n call.  xStreamBufferReceive will return as many bytes as possible up to a\n maximum set by xBufferLengthBytes.\n\n @param pxHigherPriorityTaskWoken  It is possible that a stream buffer will\n have a task blocked on it waiting for space to become available.  Calling\n xStreamBufferReceiveFromISR() can make space available, and so cause a task\n that is waiting for space to leave the Blocked state.  If calling\n xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and\n the unblocked task has a priority higher than the currently executing task\n (the task that was interrupted), then, internally,\n xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.\n If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a\n context switch should be performed before the interrupt is exited.  That will\n ensure the interrupt returns directly to the highest priority Ready state\n task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is\n passed into the function.  See the code example below for an example.\n\n @return The number of bytes read from the stream buffer, if any.\n\n Example use:\n @code{c}\n // A stream buffer that has already been created.\n StreamBuffer_t xStreamBuffer;\n\n void vAnInterruptServiceRoutine( void )\n {\n uint8_t ucRxData[ 20 ];\n size_t xReceivedBytes;\n BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.\n\n  // Receive the next stream from the stream buffer.\n  xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,\n                                                ( void * ) ucRxData,\n                                                sizeof( ucRxData ),\n                                                &xHigherPriorityTaskWoken );\n\n  if( xReceivedBytes > 0 )\n  {\n      // ucRxData contains xReceivedBytes read from the stream buffer.\n      // Process the stream here....\n  }\n\n  // If xHigherPriorityTaskWoken was set to pdTRUE inside\n  // xStreamBufferReceiveFromISR() then a task that has a priority above the\n  // priority of the currently executing task was unblocked and a context\n  // switch should be performed to ensure the ISR returns to the unblocked\n  // task.  In most FreeRTOS ports this is done by simply passing\n  // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the\n  // variables value, and perform the context switch if necessary.  Check the\n  // documentation for the port in use for port specific instructions.\n  taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferReceiveFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pvRxData: *mut ::core::ffi::c_void,
        xBufferLengthBytes: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Deletes a stream buffer that was previously created using a call to\n xStreamBufferCreate() or xStreamBufferCreateStatic().  If the stream\n buffer was created using dynamic memory (that is, by xStreamBufferCreate()),\n then the allocated memory is freed.\n\n A stream buffer handle must not be used after the stream buffer has been\n deleted.\n\n @param xStreamBuffer The handle of the stream buffer to be deleted.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vStreamBufferDelete vStreamBufferDelete\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn vStreamBufferDelete(xStreamBuffer: StreamBufferHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Queries a stream buffer to see if it is full.  A stream buffer is full if it\n does not have any free space, and therefore cannot accept any more data.\n\n @param xStreamBuffer The handle of the stream buffer being queried.\n\n @return If the stream buffer is full then pdTRUE is returned.  Otherwise\n pdFALSE is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferIsFull xStreamBufferIsFull\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferIsFull(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Queries a stream buffer to see if it is empty.  A stream buffer is empty if\n it does not contain any data.\n\n @param xStreamBuffer The handle of the stream buffer being queried.\n\n @return If the stream buffer is empty then pdTRUE is returned.  Otherwise\n pdFALSE is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferIsEmpty xStreamBufferIsEmpty\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferIsEmpty(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Resets a stream buffer to its initial, empty, state.  Any data that was in\n the stream buffer is discarded.  A stream buffer can only be reset if there\n are no tasks blocked waiting to either send to or receive from the stream\n buffer.\n\n @param xStreamBuffer The handle of the stream buffer being reset.\n\n @return If the stream buffer is reset then pdPASS is returned.  If there was\n a task blocked waiting to send to or read from the stream buffer then the\n stream buffer is not reset and pdFAIL is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferReset xStreamBufferReset\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferReset(xStreamBuffer: StreamBufferHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Queries a stream buffer to see how much free space it contains, which is\n equal to the amount of data that can be sent to the stream buffer before it\n is full.\n\n @param xStreamBuffer The handle of the stream buffer being queried.\n\n @return The number of bytes that can be written to the stream buffer before\n the stream buffer would be full.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferSpacesAvailable xStreamBufferSpacesAvailable\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferSpacesAvailable(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer );\n @endcode\n @endcond\n\n Queries a stream buffer to see how much data it contains, which is equal to\n the number of bytes that can be read from the stream buffer before the stream\n buffer would be empty.\n\n @param xStreamBuffer The handle of the stream buffer being queried.\n\n @return The number of bytes that can be read from the stream buffer before\n the stream buffer would be empty.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferBytesAvailable xStreamBufferBytesAvailable\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferBytesAvailable(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel );\n @endcode\n @endcond\n\n A stream buffer's trigger level is the number of bytes that must be in the\n stream buffer before a task that is blocked on the stream buffer to\n wait for data is moved out of the blocked state.  For example, if a task is\n blocked on a read of an empty stream buffer that has a trigger level of 1\n then the task will be unblocked when a single byte is written to the buffer\n or the task's block time expires.  As another example, if a task is blocked\n on a read of an empty stream buffer that has a trigger level of 10 then the\n task will not be unblocked until the stream buffer contains at least 10 bytes\n or the task's block time expires.  If a reading task's block time expires\n before the trigger level is reached then the task will still receive however\n many bytes are actually available.  Setting a trigger level of 0 will result\n in a trigger level of 1 being used.  It is not valid to specify a trigger\n level that is greater than the buffer size.\n\n A trigger level is set when the stream buffer is created, and can be modified\n using xStreamBufferSetTriggerLevel().\n\n @param xStreamBuffer The handle of the stream buffer being updated.\n\n @param xTriggerLevel The new trigger level for the stream buffer.\n\n @return If xTriggerLevel was less than or equal to the stream buffer's length\n then the trigger level will be updated and pdTRUE is returned.  Otherwise\n pdFALSE is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferSetTriggerLevel xStreamBufferSetTriggerLevel\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferSetTriggerLevel(
        xStreamBuffer: StreamBufferHandle_t,
        xTriggerLevel: usize,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n For advanced users only.\n\n The sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when\n data is sent to a message buffer or stream buffer.  If there was a task that\n was blocked on the message or stream buffer waiting for data to arrive then\n the sbSEND_COMPLETED() macro sends a notification to the task to remove it\n from the Blocked state.  xStreamBufferSendCompletedFromISR() does the same\n thing.  It is provided to enable application writers to implement their own\n version of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.\n\n See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for\n additional information.\n\n @param xStreamBuffer The handle of the stream buffer to which data was\n written.\n\n @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be\n initialised to pdFALSE before it is passed into\n xStreamBufferSendCompletedFromISR().  If calling\n xStreamBufferSendCompletedFromISR() removes a task from the Blocked state,\n and the task has a priority above the priority of the currently running task,\n then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a\n context switch should be performed before exiting the ISR.\n\n @return If a task was removed from the Blocked state then pdTRUE is returned.\n Otherwise pdFALSE is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferSendCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n stream_buffer.h\n\n @code{c}\n BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken );\n @endcode\n @endcond\n\n For advanced users only.\n\n The sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when\n data is read out of a message buffer or stream buffer.  If there was a task\n that was blocked on the message or stream buffer waiting for data to arrive\n then the sbRECEIVE_COMPLETED() macro sends a notification to the task to\n remove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()\n does the same thing.  It is provided to enable application writers to\n implement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT\n ANY OTHER TIME.\n\n See the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for\n additional information.\n\n @param xStreamBuffer The handle of the stream buffer from which data was\n read.\n\n @param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be\n initialised to pdFALSE before it is passed into\n xStreamBufferReceiveCompletedFromISR().  If calling\n xStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,\n and the task has a priority above the priority of the currently running task,\n then *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a\n context switch should be performed before exiting the ISR.\n\n @return If a task was removed from the Blocked state then pdTRUE is returned.\n Otherwise pdFALSE is returned.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR\n @endcond\n \\ingroup StreamBufferManagement"]
    pub fn xStreamBufferReceiveCompletedFromISR(
        xStreamBuffer: StreamBufferHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xStreamBufferGenericCreate(
        xBufferSizeBytes: usize,
        xTriggerLevelBytes: usize,
        xIsMessageBuffer: BaseType_t,
    ) -> StreamBufferHandle_t;
}
extern "C" {
    pub fn xStreamBufferGenericCreateStatic(
        xBufferSizeBytes: usize,
        xTriggerLevelBytes: usize,
        xIsMessageBuffer: BaseType_t,
        pucStreamBufferStorageArea: *mut u8,
        pxStaticStreamBuffer: *mut StaticStreamBuffer_t,
    ) -> StreamBufferHandle_t;
}
extern "C" {
    pub fn xStreamBufferNextMessageLengthBytes(xStreamBuffer: StreamBufferHandle_t) -> usize;
}
#[doc = " Type by which message buffers are referenced.  For example, a call to\n xMessageBufferCreate() returns an MessageBufferHandle_t variable that can\n then be used as a parameter to xMessageBufferSend(), xMessageBufferReceive(),\n etc."]
pub type MessageBufferHandle_t = *mut ::core::ffi::c_void;
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()\n returns an QueueHandle_t variable that can then be used as a parameter to\n xQueueSend(), xQueueReceive(), etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
#[doc = " Type by which queue sets are referenced.  For example, a call to\n xQueueCreateSet() returns an xQueueSet variable that can then be used as a\n parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut QueueDefinition;
#[doc = " Queue sets can contain both queues and semaphores, so the\n QueueSetMemberHandle_t is defined as a type to be used where a parameter or\n return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueueGenericSend(\n                                  QueueHandle_t xQueue,\n                                  const void * pvItemToQueue,\n                                  TickType_t xTicksToWait\n                                  BaseType_t xCopyPosition\n                              );\n @endcode\n @endcond\n\n It is preferred that the macros xQueueSend(), xQueueSendToFront() and\n xQueueSendToBack() are used in place of calling this function directly.\n\n Post an item on a queue.  The item is queued by copy, not by reference.\n This function must not be called from an interrupt service routine.\n See xQueueSendFromISR () for an alternative which may be used in an ISR.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for space to become available on the queue, should it already\n be full.  The call will return immediately if this is set to 0 and the\n queue is full.  The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n uint32_t ulVar = 10UL;\n\n void vATask( void *pvParameters )\n {\n QueueHandle_t xQueue1, xQueue2;\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 uint32_t values.\n  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\n\n  // ...\n\n  if( xQueue1 != 0 )\n  {\n      // Send an uint32_t.  Wait for 10 ticks for space to become\n      // available if necessary.\n      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )\n      {\n          // Failed to post the message, even after 10 ticks.\n      }\n  }\n\n  if( xQueue2 != 0 )\n  {\n      // Send a pointer to a struct AMessage object.  Don't block if the\n      // queue is already full.\n      pxMessage = & xMessage;\n      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xQueueSend xQueueSend\n @endcond\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueuePeek(\n                           QueueHandle_t xQueue,\n                           void * const pvBuffer,\n                           TickType_t xTicksToWait\n                       );\n @endcode\n @endcond\n\n Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n This macro must not be used in an interrupt service routine.  See\n xQueuePeekFromISR() for an alternative that can be called from an interrupt\n service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n xQueuePeek() will return immediately if xTicksToWait is 0 and the queue\n is empty.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to peek the data from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Peek a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask, but the item still remains on the queue.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xQueuePeek xQueuePeek\n @endcond\n \\ingroup QueueManagement"]
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueuePeekFromISR(\n                                  QueueHandle_t xQueue,\n                                  void *pvBuffer,\n                              );\n @endcode\n @endcond\n\n A version of xQueuePeek() that can be called from an interrupt service\n routine (ISR).\n\n Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup xQueuePeekFromISR xQueuePeekFromISR\n @endcond\n \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueueReceive(\n                               QueueHandle_t xQueue,\n                               void *pvBuffer,\n                               TickType_t xTicksToWait\n                          );\n @endcode\n @endcond\n\n Receive an item from a queue.  The item is received by copy so a buffer of\n adequate size must be provided.  The number of bytes copied into the buffer\n was defined when the queue was created.\n\n Successfully received items are removed from the queue.\n\n This function must not be used in an interrupt service routine.  See\n xQueueReceiveFromISR for an alternative that can.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. xQueueReceive() will return immediately if xTicksToWait\n is zero and the queue is empty.  The time is defined in tick periods so the\n constant portTICK_PERIOD_MS should be used to convert to real time if this is\n required.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to receive from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Receive a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xQueueReceive xQueueReceive\n @endcond\n \\ingroup QueueManagement"]
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );\n @endcode\n @endcond\n\n Return the number of messages stored in a queue.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of messages available in the queue.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting\n @endcond\n \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );\n @endcode\n @endcond\n\n Return the number of free spaces available in a queue.  This is equal to the\n number of items that can be sent to the queue before the queue becomes full\n if no items are removed.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of spaces available in the queue.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting\n @endcond\n \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n void vQueueDelete( QueueHandle_t xQueue );\n @endcode\n @endcond\n\n Delete a queue - freeing all the memory allocated for storing of items\n placed on the queue.\n\n @param xQueue A handle to the queue to be deleted.\n\n @cond !DOC_SINGLE_GROUP\n \\defgroup vQueueDelete vQueueDelete\n @endcond\n \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION */\n/**@{*/\n/**\n @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueueGenericSendFromISR(\n                                         QueueHandle_t    xQueue,\n                                         const    void    *pvItemToQueue,\n                                         BaseType_t  *pxHigherPriorityTaskWoken,\n                                         BaseType_t  xCopyPosition\n                                     );\n @endcode\n @endcond\n\n It is preferred that the macros xQueueSendFromISR(),\n xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place\n of calling this function directly.  xQueueGiveFromISR() is an\n equivalent for use by semaphores that don't actually copy any data.\n\n Post an item on a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n Items are queued by copy not reference so it is preferable to only\n queue small items, especially when called from an ISR.  In most cases\n it would be preferable to store a pointer to the item being queued.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param[out] pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task\n to unblock, and the unblocked task has a priority higher than the currently\n running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then\n a context switch should be requested before the interrupt is exited.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdTRUE if the data was successfully sent to the queue, otherwise\n errQUEUE_FULL.\n\n Example usage for buffered IO (where the ISR can obtain more than one value\n per call):\n @code{c}\n void vBufferISR( void )\n {\n char cIn;\n BaseType_t xHigherPriorityTaskWokenByPost;\n\n  // We have not woken a task at the start of the ISR.\n  xHigherPriorityTaskWokenByPost = pdFALSE;\n\n  // Loop until the buffer is empty.\n  do\n  {\n      // Obtain a byte from the buffer.\n      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\n\n      // Post each byte.\n      xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );\n\n  } while( portINPUT_BYTE( BUFFER_COUNT ) );\n\n  // Now the buffer is empty we can switch context if necessary.  Note that the\n  // name of the yield function required is port specific.\n  if( xHigherPriorityTaskWokenByPost )\n  {\n      taskYIELD_YIELD_FROM_ISR();\n  }\n }\n @endcode\n\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION\n queue. h\n @code{c}\n BaseType_t xQueueReceiveFromISR(\n                                     QueueHandle_t    xQueue,\n                                     void             *pvBuffer,\n                                     BaseType_t       *pxTaskWoken\n                                 );\n @endcode\n @endcond\n\n Receive an item from a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param[out] pxHigherPriorityTaskWoken A task may be blocked waiting for space to become\n available on the queue.  If xQueueReceiveFromISR causes such a task to\n unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will\n remain unchanged.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n\n QueueHandle_t xQueue;\n\n // Function to create a queue and post some values.\n void vAFunction( void *pvParameters )\n {\n char cValueToPost;\n const TickType_t xTicksToWait = ( TickType_t )0xff;\n\n  // Create a queue capable of containing 10 characters.\n  xQueue = xQueueCreate( 10, sizeof( char ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Post some characters that will be used within an ISR.  If the queue\n  // is full then this task will block for xTicksToWait ticks.\n  cValueToPost = 'a';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n  cValueToPost = 'b';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n\n  // ... keep posting characters ... this task may block when the queue\n  // becomes full.\n\n  cValueToPost = 'c';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n }\n\n // ISR that outputs all the characters received on the queue.\n void vISR_Routine( void )\n {\n BaseType_t xTaskWokenByReceive = pdFALSE;\n char cRxedChar;\n\n  while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )\n  {\n      // A character was received.  Output the character now.\n      vOutputCharacter( cRxedChar );\n\n      // If removing the character from the queue woke the task that was\n      // posting onto the queue cTaskWokenByReceive will have been set to\n      // pdTRUE.  No matter how many times this loop iterates only one\n      // task will be woken.\n  }\n\n  if( cTaskWokenByPost != ( char ) pdFALSE;\n  {\n      taskYIELD ();\n  }\n }\n @endcode\n @cond !DOC_SINGLE_GROUP\n \\defgroup xQueueReceiveFromISR xQueueReceiveFromISR\n @endcond\n \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " For internal use only.  Use xSemaphoreCreateMutex(),\n xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling\n these functions directly."]
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " For internal use only.  Use xSemaphoreTakeMutexRecursive() or\n xSemaphoreGiveMutexRecursive() instead of calling these functions directly."]
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueGenericCreateStatic(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        pucQueueStorage: *mut u8,
        pxStaticQueue: *mut StaticQueue_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    #[doc = " Queue sets provide a mechanism to allow a task to block (pend) on a read\n operation from multiple queues or semaphores simultaneously.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n A queue set must be explicitly created using a call to xQueueCreateSet()\n before it can be used.  Once created, standard FreeRTOS queues and semaphores\n can be added to the set using calls to xQueueAddToSet().\n xQueueSelectFromSet() is then used to determine which, if any, of the queues\n or semaphores contained in the set is in a state where a queue read or\n semaphore take operation would be successful.\n\n Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html\n for reasons why queue sets are very rarely needed in practice as there are\n simpler methods of blocking on multiple objects.\n\n Note 2:  Blocking on a queue set that contains a mutex will not cause the\n mutex holder to inherit the priority of the blocked task.\n\n Note 3:  An additional 4 bytes of RAM is required for each space in a every\n queue added to a queue set.  Therefore counting semaphores that have a high\n maximum count value should not be added to a queue set.\n\n Note 4:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param uxEventQueueLength Queue sets store events that occur on\n the queues and semaphores contained in the set.  uxEventQueueLength specifies\n the maximum number of events that can be queued at once.  To be absolutely\n certain that events are not lost uxEventQueueLength should be set to the\n total sum of the length of the queues added to the set, where binary\n semaphores and mutexes have a length of 1, and counting semaphores have a\n length set by their maximum count value.  Examples:\n  + If a queue set is to hold a queue of length 5, another queue of length 12,\n    and a binary semaphore, then uxEventQueueLength should be set to\n    (5 + 12 + 1), or 18.\n  + If a queue set is to hold three binary semaphores then uxEventQueueLength\n    should be set to (1 + 1 + 1 ), or 3.\n  + If a queue set is to hold a counting semaphore that has a maximum count of\n    5, and a counting semaphore that has a maximum count of 3, then\n    uxEventQueueLength should be set to (5 + 3), or 8.\n\n @return If the queue set is created successfully then a handle to the created\n queue set is returned.  Otherwise NULL is returned."]
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    #[doc = " Adds a queue or semaphore to a queue set that was previously created by a\n call to xQueueCreateSet().\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n Note 1:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param xQueueOrSemaphore The handle of the queue or semaphore being added to\n the queue set (cast to an QueueSetMemberHandle_t type).\n\n @param xQueueSet The handle of the queue set to which the queue or semaphore\n is being added.\n\n @return If the queue or semaphore was successfully added to the queue set\n then pdPASS is returned.  If the queue could not be successfully added to the\n queue set because it is already a member of a different queue set then pdFAIL\n is returned."]
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Removes a queue or semaphore from a queue set.  A queue or semaphore can only\n be removed from a set if the queue or semaphore is empty.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n @param xQueueOrSemaphore The handle of the queue or semaphore being removed\n from the queue set (cast to an QueueSetMemberHandle_t type).\n\n @param xQueueSet The handle of the queue set in which the queue or semaphore\n is included.\n\n @return If the queue or semaphore was successfully removed from the queue set\n then pdPASS is returned.  If the queue was not in the queue set, or the\n queue (or semaphore) was not empty, then pdFAIL is returned."]
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xQueueSelectFromSet() selects from the members of a queue set a queue or\n semaphore that either contains data (in the case of a queue) or is available\n to take (in the case of a semaphore).  xQueueSelectFromSet() effectively\n allows a task to block (pend) on a read operation on all the queues and\n semaphores in a queue set simultaneously.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html\n for reasons why queue sets are very rarely needed in practice as there are\n simpler methods of blocking on multiple objects.\n\n Note 2:  Blocking on a queue set that contains a mutex will not cause the\n mutex holder to inherit the priority of the blocked task.\n\n Note 3:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param xQueueSet The queue set on which the task will (potentially) block.\n\n @param xTicksToWait The maximum time, in ticks, that the calling task will\n remain in the Blocked state (with other tasks executing) to wait for a member\n of the queue set to be ready for a successful queue read or semaphore take\n operation.\n\n @return xQueueSelectFromSet() will return the handle of a queue (cast to\n a QueueSetMemberHandle_t type) contained in the queue set that contains data,\n or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained\n in the queue set that is available, or NULL if no such queue or semaphore\n exists before before the specified block time expires."]
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " A version of xQueueSelectFromSet() that can be used from an ISR."]
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
#[doc = " @brief Task Snapshot structure\n\n - Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n - We need this structure because TCB_t is defined (hidden) in tasks.c."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_SNAPSHOT {
    #[doc = "< Address of the task control block."]
    pub pxTCB: *mut ::core::ffi::c_void,
    #[doc = "< Points to the location of the last item placed on the tasks stack."]
    pub pxTopOfStack: *mut StackType_t,
    #[doc = "< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\npxTopOfStack > pxEndOfStack, stack grows lo2hi"]
    pub pxEndOfStack: *mut StackType_t,
}
impl Default for xTASK_SNAPSHOT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Task Snapshot structure\n\n - Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n - We need this structure because TCB_t is defined (hidden) in tasks.c."]
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
extern "C" {
    #[doc = " @brief Iterate over all tasks in the system\n\n - This function can be used to iterate over every task in the system\n - The first call to this function must set pxTask to NULL\n - When all functions have been iterated, this function will return NULL.\n - This function is only available when CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT is set to 1.\n\n @note This function should only be called when FreeRTOS is no longer running (e.g., during a panic) as this function\n       does not acquire any locks.\n @param pxTask Handle of the previous task (or NULL on the first call of this function)\n @return TaskHandle_t Handle of the next task (or NULL when all tasks have been iterated over)"]
    pub fn pxTaskGetNext(pxTask: TaskHandle_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " @brief Fill a TaskSnapshot_t structure for specified task.\n\n - This function is used by the panic handler to get the snapshot of a particular task.\n - This function is only available when CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT is set to 1.\n\n @note This function should only be called when FreeRTOS is no longer running (e.g., during a panic) as this function\n       does not acquire any locks.\n @param[in] pxTask Task's handle\n @param[out] pxTaskSnapshot Snapshot of the task\n @return pdTRUE if operation was successful else pdFALSE"]
    pub fn vTaskGetSnapshot(
        pxTask: TaskHandle_t,
        pxTaskSnapshot: *mut TaskSnapshot_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief Fill an array of TaskSnapshot_t structures for every task in the system\n\n - This function is used by the panic handler to get a snapshot of all tasks in the system\n - This function is only available when CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT is set to 1.\n\n @note This function should only be called when FreeRTOS is no longer running (e.g., during a panic) as this function\n        does not acquire any locks.\n @param[out] pxTaskSnapshotArray Array of TaskSnapshot_t structures filled by this function\n @param[in] uxArrayLength Length of the provided array\n @param[out] pxTCBSize Size of the a task's TCB structure\n @return UBaseType_t"]
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArrayLength: UBaseType_t,
        pxTCBSize: *mut UBaseType_t,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " @brief Initialize PSRAM interface/hardware.\n\n @return\n        - ESP_OK:                On success\n        - ESP_FAIL:              PSRAM isn't initialized successfully, potential reason would be: wrong VDDSDIO, invalid chip ID, etc.\n        - ESP_ERR_INVALID_STATE: PSRAM is initialized already"]
    pub fn esp_psram_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief If PSRAM has been initialized\n\n @return\n          - true:  PSRAM has been initialized successfully\n          - false: PSRAM hasn't been initialized or initialized failed"]
    pub fn esp_psram_is_initialized() -> bool;
}
extern "C" {
    #[doc = " @brief Get the available size of the attached PSRAM chip\n\n @return Size in bytes, or 0 if PSRAM isn't successfully initialized"]
    pub fn esp_psram_get_size() -> usize;
}
extern "C" {
    #[doc = " @brief  Internal function to restart PRO and APP CPUs.\n\n @note This function should not be called from FreeRTOS applications.\n       Use esp_restart instead.\n\n This is an internal function called by esp_restart. It is called directly\n by the panic handler and brownout detector interrupt."]
    pub fn esp_restart_noos() -> !;
}
extern "C" {
    #[doc = " @brief Similar to esp_restart_noos, but resets all the digital peripherals."]
    pub fn esp_restart_noos_dig() -> !;
}
extern "C" {
    #[doc = " @brief  Internal function to set reset reason hint\n\n The hint is used do distinguish different reset reasons when software reset\n is performed.\n\n The hint is stored in RTC store register, RTC_RESET_CAUSE_REG.\n\n @param hint  Desired esp_reset_reason_t value for the real reset reason"]
    pub fn esp_reset_reason_set_hint(hint: esp_reset_reason_t);
}
extern "C" {
    #[doc = " @brief  Internal function to get the reset hint value\n @return  - Reset hint value previously stored into RTC_RESET_CAUSE_REG using\n          esp_reset_reason_set_hint function\n          - ESP_RST_UNKNOWN if the value in RTC_RESET_CAUSE_REG is invalid"]
    pub fn esp_reset_reason_get_hint() -> esp_reset_reason_t;
}
extern "C" {
    #[doc = " @brief Get the time in microseconds since startup\n\n @returns time since g_startup_time; definition should be fixed by system time provider\n no matter the underlying timer used."]
    pub fn esp_system_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the resolution of the time returned by `esp_system_get_time`.\n\n @returns the resolution in nanoseconds"]
    pub fn esp_system_get_time_resolution() -> u32;
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_USB_DEVICE_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2S1_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_SPI2_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_TWAI_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_WIFI_BT_COMMON_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_BT_BASEBAND_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_BT_LC_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_HMAC_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_DS_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_GDMA_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_SYSTIMER_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_SARADC_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_TEMPSENSOR_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_MODULE_MAX: periph_module_t = 28;
pub type periph_module_t = ::core::ffi::c_uint;
#[doc = "< interrupt of WiFi MAC, level"]
pub const periph_interrput_t_ETS_WIFI_MAC_INTR_SOURCE: periph_interrput_t = 0;
#[doc = "< interrupt of WiFi MAC, NMI, use if MAC have bug to fix in NMI"]
pub const periph_interrput_t_ETS_WIFI_MAC_NMI_SOURCE: periph_interrput_t = 1;
#[doc = "<"]
pub const periph_interrput_t_ETS_WIFI_PWR_INTR_SOURCE: periph_interrput_t = 2;
#[doc = "< interrupt of WiFi BB, level, we can do some calibartion"]
pub const periph_interrput_t_ETS_WIFI_BB_INTR_SOURCE: periph_interrput_t = 3;
#[doc = "< will be cancelled"]
pub const periph_interrput_t_ETS_BT_MAC_INTR_SOURCE: periph_interrput_t = 4;
#[doc = "< interrupt of BT BB, level"]
pub const periph_interrput_t_ETS_BT_BB_INTR_SOURCE: periph_interrput_t = 5;
#[doc = "< interrupt of BT BB, NMI, use if BB have bug to fix in NMI"]
pub const periph_interrput_t_ETS_BT_BB_NMI_SOURCE: periph_interrput_t = 6;
#[doc = "< interrupt of RWBT, level"]
pub const periph_interrput_t_ETS_RWBT_INTR_SOURCE: periph_interrput_t = 7;
#[doc = "< interrupt of RWBLE, level"]
pub const periph_interrput_t_ETS_RWBLE_INTR_SOURCE: periph_interrput_t = 8;
#[doc = "< interrupt of RWBT, NMI, use if RWBT have bug to fix in NMI"]
pub const periph_interrput_t_ETS_RWBT_NMI_SOURCE: periph_interrput_t = 9;
#[doc = "< interrupt of RWBLE, NMI, use if RWBT have bug to fix in NMI"]
pub const periph_interrput_t_ETS_RWBLE_NMI_SOURCE: periph_interrput_t = 10;
#[doc = "< interrupt of I2C Master, level"]
pub const periph_interrput_t_ETS_I2C_MASTER_SOURCE: periph_interrput_t = 11;
#[doc = "< interrupt of SLC0, level"]
pub const periph_interrput_t_ETS_SLC0_INTR_SOURCE: periph_interrput_t = 12;
#[doc = "< interrupt of SLC1, level"]
pub const periph_interrput_t_ETS_SLC1_INTR_SOURCE: periph_interrput_t = 13;
#[doc = "< interrupt of APB ctrl, ?"]
pub const periph_interrput_t_ETS_APB_CTRL_INTR_SOURCE: periph_interrput_t = 14;
#[doc = "< interrupt of UHCI0, level"]
pub const periph_interrput_t_ETS_UHCI0_INTR_SOURCE: periph_interrput_t = 15;
#[doc = "< interrupt of GPIO, level"]
pub const periph_interrput_t_ETS_GPIO_INTR_SOURCE: periph_interrput_t = 16;
#[doc = "< interrupt of GPIO, NMI"]
pub const periph_interrput_t_ETS_GPIO_NMI_SOURCE: periph_interrput_t = 17;
#[doc = "< interrupt of SPI1, level, SPI1 is for flash read/write, do not use this"]
pub const periph_interrput_t_ETS_SPI1_INTR_SOURCE: periph_interrput_t = 18;
#[doc = "< interrupt of SPI2, level"]
pub const periph_interrput_t_ETS_SPI2_INTR_SOURCE: periph_interrput_t = 19;
#[doc = "< interrupt of I2S1, level"]
pub const periph_interrput_t_ETS_I2S1_INTR_SOURCE: periph_interrput_t = 20;
#[doc = "< interrupt of UART0, level"]
pub const periph_interrput_t_ETS_UART0_INTR_SOURCE: periph_interrput_t = 21;
#[doc = "< interrupt of UART1, level"]
pub const periph_interrput_t_ETS_UART1_INTR_SOURCE: periph_interrput_t = 22;
#[doc = "< interrupt of LED PWM, level"]
pub const periph_interrput_t_ETS_LEDC_INTR_SOURCE: periph_interrput_t = 23;
#[doc = "< interrupt of efuse, level, not likely to use"]
pub const periph_interrput_t_ETS_EFUSE_INTR_SOURCE: periph_interrput_t = 24;
#[doc = "< interrupt of can, level"]
pub const periph_interrput_t_ETS_TWAI_INTR_SOURCE: periph_interrput_t = 25;
#[doc = "< interrupt of USJ, level"]
pub const periph_interrput_t_ETS_USB_SERIAL_JTAG_INTR_SOURCE: periph_interrput_t = 26;
#[doc = "< interrupt of rtc core, level, include rtc watchdog"]
pub const periph_interrput_t_ETS_RTC_CORE_INTR_SOURCE: periph_interrput_t = 27;
#[doc = "< interrupt of remote controller, level"]
pub const periph_interrput_t_ETS_RMT_INTR_SOURCE: periph_interrput_t = 28;
#[doc = "< interrupt of I2C controller1, level"]
pub const periph_interrput_t_ETS_I2C_EXT0_INTR_SOURCE: periph_interrput_t = 29;
pub const periph_interrput_t_ETS_TIMER1_INTR_SOURCE: periph_interrput_t = 30;
pub const periph_interrput_t_ETS_TIMER2_INTR_SOURCE: periph_interrput_t = 31;
#[doc = "< interrupt of TIMER_GROUP0, TIMER0, level"]
pub const periph_interrput_t_ETS_TG0_T0_LEVEL_INTR_SOURCE: periph_interrput_t = 32;
#[doc = "< interrupt of TIMER_GROUP0, WATCH DOG, level"]
pub const periph_interrput_t_ETS_TG0_WDT_LEVEL_INTR_SOURCE: periph_interrput_t = 33;
#[doc = "< interrupt of TIMER_GROUP1, TIMER0, level"]
pub const periph_interrput_t_ETS_TG1_T0_LEVEL_INTR_SOURCE: periph_interrput_t = 34;
#[doc = "< interrupt of TIMER_GROUP1, WATCHDOG, level"]
pub const periph_interrput_t_ETS_TG1_WDT_LEVEL_INTR_SOURCE: periph_interrput_t = 35;
#[doc = "< interrupt of Cache Invalied Access, LEVEL"]
pub const periph_interrput_t_ETS_CACHE_IA_INTR_SOURCE: periph_interrput_t = 36;
#[doc = "< interrupt of system timer 0, EDGE"]
pub const periph_interrput_t_ETS_SYSTIMER_TARGET0_EDGE_INTR_SOURCE: periph_interrput_t = 37;
#[doc = "< interrupt of system timer 1, EDGE"]
pub const periph_interrput_t_ETS_SYSTIMER_TARGET1_EDGE_INTR_SOURCE: periph_interrput_t = 38;
#[doc = "< interrupt of system timer 2, EDGE"]
pub const periph_interrput_t_ETS_SYSTIMER_TARGET2_EDGE_INTR_SOURCE: periph_interrput_t = 39;
#[doc = "< interrupt of SPI0 Cache access and SPI1 access rejected, LEVEL"]
pub const periph_interrput_t_ETS_SPI_MEM_REJECT_CACHE_INTR_SOURCE: periph_interrput_t = 40;
#[doc = "< interrupt of ICache perload operation, LEVEL"]
pub const periph_interrput_t_ETS_ICACHE_PRELOAD0_INTR_SOURCE: periph_interrput_t = 41;
#[doc = "< interrupt of instruction cache sync done, LEVEL"]
pub const periph_interrput_t_ETS_ICACHE_SYNC0_INTR_SOURCE: periph_interrput_t = 42;
#[doc = "< interrupt of APB ADC, LEVEL"]
pub const periph_interrput_t_ETS_APB_ADC_INTR_SOURCE: periph_interrput_t = 43;
#[doc = "< interrupt of general DMA channel 0, LEVEL"]
pub const periph_interrput_t_ETS_DMA_CH0_INTR_SOURCE: periph_interrput_t = 44;
#[doc = "< interrupt of general DMA channel 1, LEVEL"]
pub const periph_interrput_t_ETS_DMA_CH1_INTR_SOURCE: periph_interrput_t = 45;
#[doc = "< interrupt of general DMA channel 2, LEVEL"]
pub const periph_interrput_t_ETS_DMA_CH2_INTR_SOURCE: periph_interrput_t = 46;
#[doc = "< interrupt of RSA accelerator, level"]
pub const periph_interrput_t_ETS_RSA_INTR_SOURCE: periph_interrput_t = 47;
#[doc = "< interrupt of AES accelerator, level"]
pub const periph_interrput_t_ETS_AES_INTR_SOURCE: periph_interrput_t = 48;
#[doc = "< interrupt of SHA accelerator, level"]
pub const periph_interrput_t_ETS_SHA_INTR_SOURCE: periph_interrput_t = 49;
#[doc = "< interrupt0 generated from a CPU, level"]
pub const periph_interrput_t_ETS_FROM_CPU_INTR0_SOURCE: periph_interrput_t = 50;
#[doc = "< interrupt1 generated from a CPU, level"]
pub const periph_interrput_t_ETS_FROM_CPU_INTR1_SOURCE: periph_interrput_t = 51;
#[doc = "< interrupt2 generated from a CPU, level"]
pub const periph_interrput_t_ETS_FROM_CPU_INTR2_SOURCE: periph_interrput_t = 52;
#[doc = "< interrupt3 generated from a CPU, level"]
pub const periph_interrput_t_ETS_FROM_CPU_INTR3_SOURCE: periph_interrput_t = 53;
#[doc = "< interrupt of Assist debug module, LEVEL"]
pub const periph_interrput_t_ETS_ASSIST_DEBUG_INTR_SOURCE: periph_interrput_t = 54;
pub const periph_interrput_t_ETS_DMA_APBPERI_PMS_INTR_SOURCE: periph_interrput_t = 55;
pub const periph_interrput_t_ETS_CORE0_IRAM0_PMS_INTR_SOURCE: periph_interrput_t = 56;
pub const periph_interrput_t_ETS_CORE0_DRAM0_PMS_INTR_SOURCE: periph_interrput_t = 57;
pub const periph_interrput_t_ETS_CORE0_PIF_PMS_INTR_SOURCE: periph_interrput_t = 58;
pub const periph_interrput_t_ETS_CORE0_PIF_PMS_SIZE_INTR_SOURCE: periph_interrput_t = 59;
pub const periph_interrput_t_ETS_BAK_PMS_VIOLATE_INTR_SOURCE: periph_interrput_t = 60;
pub const periph_interrput_t_ETS_CACHE_CORE0_ACS_INTR_SOURCE: periph_interrput_t = 61;
pub const periph_interrput_t_ETS_MAX_INTR_SOURCE: periph_interrput_t = 62;
pub type periph_interrput_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Initialize the non-CPU-specific parts of interrupt watchdog.\n\n This function is automatically called during application startup if the\n interrupt watchdog is enabled in menuconfig."]
    pub fn esp_int_wdt_init();
}
extern "C" {
    #[doc = " @brief Enable the interrupt watchdog on the current CPU.\n\n This function is automatically called during application startup for each CPU\n that has enabled the interrupt watchdog in menuconfig.\n\n @note esp_int_wdt_init() must be called first before calling this function"]
    pub fn esp_int_wdt_cpu_init();
}
#[doc = " @brief Parameters for console initialization"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_console_config_t {
    #[doc = "!< length of command line buffer, in bytes"]
    pub max_cmdline_length: usize,
    #[doc = "!< maximum number of command line arguments to parse"]
    pub max_cmdline_args: usize,
    #[doc = "!< ASCII color code of hint text"]
    pub hint_color: ::core::ffi::c_int,
    #[doc = "!< Set to 1 to print hint text in bold"]
    pub hint_bold: ::core::ffi::c_int,
}
#[doc = " @brief Parameters for console REPL (Read Eval Print Loop)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_console_repl_config_t {
    #[doc = "!< maximum length for the history"]
    pub max_history_len: u32,
    #[doc = "!< file path used to save history commands, set to NULL won't save to file system"]
    pub history_save_path: *const ::core::ffi::c_char,
    #[doc = "!< repl task stack size"]
    pub task_stack_size: u32,
    #[doc = "!< repl task priority"]
    pub task_priority: u32,
    #[doc = "!< prompt (NULL represents default: \"esp> \")"]
    pub prompt: *const ::core::ffi::c_char,
    #[doc = "!< maximum length of a command line. If 0, default value will be used"]
    pub max_cmdline_length: usize,
}
impl Default for esp_console_repl_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Parameters for console device: UART\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_console_dev_uart_config_t {
    #[doc = "!< UART channel number (count from zero)"]
    pub channel: ::core::ffi::c_int,
    #[doc = "!< Comunication baud rate"]
    pub baud_rate: ::core::ffi::c_int,
    #[doc = "!< GPIO number for TX path, -1 means using default one"]
    pub tx_gpio_num: ::core::ffi::c_int,
    #[doc = "!< GPIO number for RX path, -1 means using default one"]
    pub rx_gpio_num: ::core::ffi::c_int,
}
#[doc = " @brief Parameters for console device: USB CDC\n\n @note It's an empty structure for now, reserved for future\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_console_dev_usb_cdc_config_t {}
extern "C" {
    #[doc = " @brief initialize console module\n @param config console configuration\n @note  Call this once before using other console module features\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if out of memory\n      - ESP_ERR_INVALID_STATE if already initialized\n      - ESP_ERR_INVALID_ARG if the configuration is invalid"]
    pub fn esp_console_init(config: *const esp_console_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief de-initialize console module\n @note  Call this once when done using console module functions\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if not initialized yet"]
    pub fn esp_console_deinit() -> esp_err_t;
}
#[doc = " @brief Console command main function\n @param argc number of arguments\n @param argv array with argc entries, each pointing to a zero-terminated string argument\n @return console command return code, 0 indicates \"success\""]
pub type esp_console_cmd_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief Console command description"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_console_cmd_t {
    #[doc = " Command name. Must not be NULL, must not contain spaces.\n The pointer must be valid until the call to esp_console_deinit."]
    pub command: *const ::core::ffi::c_char,
    #[doc = " Help text for the command, shown by help command.\n If set, the pointer must be valid until the call to esp_console_deinit.\n If not set, the command will not be listed in 'help' output."]
    pub help: *const ::core::ffi::c_char,
    #[doc = " Hint text, usually lists possible arguments.\n If set to NULL, and 'argtable' field is non-NULL, hint will be generated\n automatically"]
    pub hint: *const ::core::ffi::c_char,
    #[doc = " Pointer to a function which implements the command."]
    pub func: esp_console_cmd_func_t,
    #[doc = " Array or structure of pointers to arg_xxx structures, may be NULL.\n Used to generate hint text if 'hint' is set to NULL.\n Array/structure which this field points to must end with an arg_end.\n Only used for the duration of esp_console_cmd_register call."]
    pub argtable: *mut ::core::ffi::c_void,
}
impl Default for esp_console_cmd_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Register console command\n @param cmd pointer to the command description; can point to a temporary value\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if out of memory\n      - ESP_ERR_INVALID_ARG if command description includes invalid arguments"]
    pub fn esp_console_cmd_register(cmd: *const esp_console_cmd_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Run command line\n @param cmdline command line (command name followed by a number of arguments)\n @param[out] cmd_ret return code from the command (set if command was run)\n @return\n      - ESP_OK, if command was run\n      - ESP_ERR_INVALID_ARG, if the command line is empty, or only contained\n        whitespace\n      - ESP_ERR_NOT_FOUND, if command with given name wasn't registered\n      - ESP_ERR_INVALID_STATE, if esp_console_init wasn't called"]
    pub fn esp_console_run(
        cmdline: *const ::core::ffi::c_char,
        cmd_ret: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Split command line into arguments in place\n @verbatim\n - This function finds whitespace-separated arguments in the given input line.\n\n     'abc def 1 20 .3' -> [ 'abc', 'def', '1', '20', '.3' ]\n\n - Argument which include spaces may be surrounded with quotes. In this case\n   spaces are preserved and quotes are stripped.\n\n     'abc \"123 456\" def' -> [ 'abc', '123 456', 'def' ]\n\n - Escape sequences may be used to produce backslash, double quote, and space:\n\n     'a\\ b\\\\c\\\"' -> [ 'a b\\c\"' ]\n @endverbatim\n @note Pointers to at most argv_size - 1 arguments are returned in argv array.\n       The pointer after the last one (i.e. argv[argc]) is set to NULL.\n\n @param line pointer to buffer to parse; it is modified in place\n @param argv array where the pointers to arguments are written\n @param argv_size number of elements in argv_array (max. number of arguments)\n @return number of arguments found (argc)"]
    pub fn esp_console_split_argv(
        line: *mut ::core::ffi::c_char,
        argv: *mut *mut ::core::ffi::c_char,
        argv_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Callback which provides command completion for linenoise library\n\n When using linenoise for line editing, command completion support\n can be enabled like this:\n\n   linenoiseSetCompletionCallback(&esp_console_get_completion);\n\n @param buf the string typed by the user\n @param lc linenoiseCompletions to be filled in"]
    pub fn esp_console_get_completion(
        buf: *const ::core::ffi::c_char,
        lc: *mut linenoiseCompletions,
    );
}
extern "C" {
    #[doc = " @brief Callback which provides command hints for linenoise library\n\n When using linenoise for line editing, hints support can be enabled as\n follows:\n\n   linenoiseSetHintsCallback((linenoiseHintsCallback*) &esp_console_get_hint);\n\n The extra cast is needed because linenoiseHintsCallback is defined as\n returning a char* instead of const char*.\n\n @param buf line typed by the user\n @param[out] color ANSI color code to be used when displaying the hint\n @param[out] bold set to 1 if hint has to be displayed in bold\n @return string containing the hint text. This string is persistent and should\n         not be freed (i.e. linenoiseSetFreeHintsCallback should not be used)."]
    pub fn esp_console_get_hint(
        buf: *const ::core::ffi::c_char,
        color: *mut ::core::ffi::c_int,
        bold: *mut ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Register a 'help' command\n\n Default 'help' command prints the list of registered commands along with\n hints and help strings.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE, if esp_console_init wasn't called"]
    pub fn esp_console_register_help_command() -> esp_err_t;
}
#[doc = " @brief Console REPL base structure\n"]
pub type esp_console_repl_t = esp_console_repl_s;
#[doc = " @brief Console REPL base structure\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_console_repl_s {
    #[doc = " @brief Delete console REPL environment\n @param[in] repl REPL handle returned from esp_console_new_repl_xxx\n @return\n      - ESP_OK on success\n      - ESP_FAIL on errors"]
    pub del:
        ::core::option::Option<unsafe extern "C" fn(repl: *mut esp_console_repl_t) -> esp_err_t>,
}
extern "C" {
    #[doc = " @brief Establish a console REPL environment over UART driver\n\n @param[in] dev_config UART device configuration\n @param[in] repl_config REPL configuration\n @param[out] ret_repl return REPL handle after initialization succeed, return NULL otherwise\n\n @note This is an all-in-one function to establish the environment needed for REPL, includes:\n       - Install the UART driver on the console UART (8n1, 115200, REF_TICK clock source)\n       - Configures the stdin/stdout to go through the UART driver\n       - Initializes linenoise\n       - Spawn new thread to run REPL in the background\n\n @attention This function is meant to be used in the examples to make the code more compact.\n            Applications which use console functionality should be based on\n            the underlying linenoise and esp_console functions.\n\n @return\n      - ESP_OK on success\n      - ESP_FAIL Parameter error"]
    pub fn esp_console_new_repl_uart(
        dev_config: *const esp_console_dev_uart_config_t,
        repl_config: *const esp_console_repl_config_t,
        ret_repl: *mut *mut esp_console_repl_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Establish a console REPL environment over USB CDC\n\n @param[in] dev_config USB CDC configuration\n @param[in] repl_config REPL configuration\n @param[out] ret_repl return REPL handle after initialization succeed, return NULL otherwise\n\n @note This is a all-in-one function to establish the environment needed for REPL, includes:\n       - Initializes linenoise\n       - Spawn new thread to run REPL in the background\n\n @attention This function is meant to be used in the examples to make the code more compact.\n            Applications which use console functionality should be based on\n            the underlying linenoise and esp_console functions.\n\n @return\n      - ESP_OK on success\n      - ESP_FAIL Parameter error"]
    pub fn esp_console_new_repl_usb_cdc(
        dev_config: *const esp_console_dev_usb_cdc_config_t,
        repl_config: *const esp_console_repl_config_t,
        ret_repl: *mut *mut esp_console_repl_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start REPL environment\n @param[in] repl REPL handle returned from esp_console_new_repl_xxx\n @note Once the REPL gets started, it won't be stopped until the user calls repl->del(repl) to destroy the REPL environment.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE, if repl has started already"]
    pub fn esp_console_start_repl(repl: *mut esp_console_repl_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linenoiseCompletions {
    pub len: usize,
    pub cvec: *mut *mut ::core::ffi::c_char,
}
impl Default for linenoiseCompletions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type linenoiseCompletionCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, arg2: *mut linenoiseCompletions),
>;
pub type linenoiseHintsCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_char,
        color: *mut ::core::ffi::c_int,
        bold: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char,
>;
pub type linenoiseFreeHintsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
extern "C" {
    pub fn linenoiseSetCompletionCallback(arg1: linenoiseCompletionCallback);
}
extern "C" {
    pub fn linenoiseSetHintsCallback(arg1: linenoiseHintsCallback);
}
extern "C" {
    pub fn linenoiseSetFreeHintsCallback(arg1: linenoiseFreeHintsCallback);
}
extern "C" {
    pub fn linenoiseAddCompletion(
        arg1: *mut linenoiseCompletions,
        arg2: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn linenoiseProbe() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linenoise(prompt: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn linenoiseFree(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn linenoiseHistoryAdd(line: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linenoiseHistorySetMaxLen(len: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linenoiseHistorySave(filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linenoiseHistoryLoad(filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linenoiseHistoryFree();
}
extern "C" {
    pub fn linenoiseClearScreen();
}
extern "C" {
    pub fn linenoiseSetMultiLine(ml: ::core::ffi::c_int);
}
extern "C" {
    pub fn linenoiseSetDumbMode(set: ::core::ffi::c_int);
}
extern "C" {
    pub fn linenoiseIsDumbMode() -> bool;
}
extern "C" {
    pub fn linenoisePrintKeyCodes();
}
extern "C" {
    pub fn linenoiseAllowEmpty(arg1: bool);
}
extern "C" {
    pub fn linenoiseSetMaxLineLen(len: usize) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::core::ffi::c_long;
}
extern "C" {
    pub static mut _daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::core::ffi::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_value: sigval,
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_flags: ::core::ffi::c_int,
    pub ss_size: usize,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::core::ffi::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::core::ffi::c_int, arg3: sigval) -> ::core::ffi::c_int;
}
pub type sig_atomic_t = ::core::ffi::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: _sig_func_ptr,
    ) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn signal(arg1: ::core::ffi::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::core::ffi::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        clock_id: clockid_t,
        flags: ::core::ffi::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::core::ffi::c_int;
}
pub const ARG_TERMINATOR: _bindgen_ty_2 = 1;
pub const ARG_HASVALUE: _bindgen_ty_2 = 2;
pub const ARG_HASOPTVALUE: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _internal_arg_dstr {
    _unused: [u8; 0],
}
pub type arg_dstr_t = *mut _internal_arg_dstr;
pub type arg_cmd_itr_t = *mut ::core::ffi::c_void;
pub type arg_resetfn =
    ::core::option::Option<unsafe extern "C" fn(parent: *mut ::core::ffi::c_void)>;
pub type arg_scanfn = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::core::ffi::c_void,
        argval: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
pub type arg_checkfn = ::core::option::Option<
    unsafe extern "C" fn(parent: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type arg_errorfn = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::core::ffi::c_void,
        ds: arg_dstr_t,
        error: ::core::ffi::c_int,
        argval: *const ::core::ffi::c_char,
        progname: *const ::core::ffi::c_char,
    ),
>;
pub type arg_dstr_freefn =
    ::core::option::Option<unsafe extern "C" fn(buf: *mut ::core::ffi::c_char)>;
pub type arg_cmdfn = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        res: arg_dstr_t,
    ) -> ::core::ffi::c_int,
>;
pub type arg_comparefn = ::core::option::Option<
    unsafe extern "C" fn(
        k1: *const ::core::ffi::c_void,
        k2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_hdr {
    pub flag: ::core::ffi::c_char,
    pub shortopts: *const ::core::ffi::c_char,
    pub longopts: *const ::core::ffi::c_char,
    pub datatype: *const ::core::ffi::c_char,
    pub glossary: *const ::core::ffi::c_char,
    pub mincount: ::core::ffi::c_int,
    pub maxcount: ::core::ffi::c_int,
    pub parent: *mut ::core::ffi::c_void,
    pub resetfn: arg_resetfn,
    pub scanfn: arg_scanfn,
    pub checkfn: arg_checkfn,
    pub errorfn: arg_errorfn,
    pub priv_: *mut ::core::ffi::c_void,
}
impl Default for arg_hdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_hdr_t = arg_hdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_rem {
    pub hdr: arg_hdr,
}
impl Default for arg_rem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_rem_t = arg_rem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_lit {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
}
impl Default for arg_lit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_lit_t = arg_lit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_int {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub ival: *mut ::core::ffi::c_int,
}
impl Default for arg_int {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_int_t = arg_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_dbl {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub dval: *mut f64,
}
impl Default for arg_dbl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_dbl_t = arg_dbl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_str {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub sval: *mut *const ::core::ffi::c_char,
}
impl Default for arg_str {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_str_t = arg_str;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_rex {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub sval: *mut *const ::core::ffi::c_char,
}
impl Default for arg_rex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_rex_t = arg_rex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_file {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub filename: *mut *const ::core::ffi::c_char,
    pub basename: *mut *const ::core::ffi::c_char,
    pub extension: *mut *const ::core::ffi::c_char,
}
impl Default for arg_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_file_t = arg_file;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_date {
    pub hdr: arg_hdr,
    pub format: *const ::core::ffi::c_char,
    pub count: ::core::ffi::c_int,
    pub tmval: *mut tm,
}
impl Default for arg_date {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_date_t = arg_date;
pub const ARG_ELIMIT: _bindgen_ty_3 = 1;
pub const ARG_EMALLOC: _bindgen_ty_3 = 2;
pub const ARG_ENOMATCH: _bindgen_ty_3 = 3;
pub const ARG_ELONGOPT: _bindgen_ty_3 = 4;
pub const ARG_EMISSARG: _bindgen_ty_3 = 5;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_end {
    pub hdr: arg_hdr,
    pub count: ::core::ffi::c_int,
    pub error: *mut ::core::ffi::c_int,
    pub parent: *mut *mut ::core::ffi::c_void,
    pub argval: *mut *const ::core::ffi::c_char,
}
impl Default for arg_end {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_end_t = arg_end;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arg_cmd_info {
    pub name: [::core::ffi::c_char; 100usize],
    pub description: [::core::ffi::c_char; 256usize],
    pub proc_: arg_cmdfn,
}
impl Default for arg_cmd_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arg_cmd_info_t = arg_cmd_info;
extern "C" {
    #[doc = " arg_xxx constructor functions"]
    pub fn arg_rem(
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_rem;
}
extern "C" {
    pub fn arg_lit0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_lit;
}
extern "C" {
    pub fn arg_lit1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_lit;
}
extern "C" {
    pub fn arg_litn(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_lit;
}
extern "C" {
    pub fn arg_int0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_int;
}
extern "C" {
    pub fn arg_int1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_int;
}
extern "C" {
    pub fn arg_intn(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_int;
}
extern "C" {
    pub fn arg_dbl0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_dbl;
}
extern "C" {
    pub fn arg_dbl1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_dbl;
}
extern "C" {
    pub fn arg_dbln(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_dbl;
}
extern "C" {
    pub fn arg_str0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_str;
}
extern "C" {
    pub fn arg_str1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_str;
}
extern "C" {
    pub fn arg_strn(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_str;
}
extern "C" {
    pub fn arg_rex0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        pattern: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_rex;
}
extern "C" {
    pub fn arg_rex1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        pattern: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_rex;
}
extern "C" {
    pub fn arg_rexn(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        pattern: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_rex;
}
extern "C" {
    pub fn arg_file0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_file;
}
extern "C" {
    pub fn arg_file1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_file;
}
extern "C" {
    pub fn arg_filen(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_file;
}
extern "C" {
    pub fn arg_date0(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_date;
}
extern "C" {
    pub fn arg_date1(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_date;
}
extern "C" {
    pub fn arg_daten(
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        mincount: ::core::ffi::c_int,
        maxcount: ::core::ffi::c_int,
        glossary: *const ::core::ffi::c_char,
    ) -> *mut arg_date;
}
extern "C" {
    pub fn arg_end(maxcount: ::core::ffi::c_int) -> *mut arg_end;
}
extern "C" {
    #[doc = " other functions"]
    pub fn arg_nullcheck(argtable: *mut *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_parse(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        argtable: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_print_option(
        fp: *mut FILE,
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_syntax(
        fp: *mut FILE,
        argtable: *mut *mut ::core::ffi::c_void,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_syntaxv(
        fp: *mut FILE,
        argtable: *mut *mut ::core::ffi::c_void,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_glossary(
        fp: *mut FILE,
        argtable: *mut *mut ::core::ffi::c_void,
        format: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_glossary_gnu(fp: *mut FILE, argtable: *mut *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn arg_print_formatted(
        fp: *mut FILE,
        lmargin: ::core::ffi::c_uint,
        rmargin: ::core::ffi::c_uint,
        text: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_errors(fp: *mut FILE, end: *mut arg_end, progname: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn arg_print_option_ds(
        ds: arg_dstr_t,
        shortopts: *const ::core::ffi::c_char,
        longopts: *const ::core::ffi::c_char,
        datatype: *const ::core::ffi::c_char,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_syntax_ds(
        ds: arg_dstr_t,
        argtable: *mut *mut ::core::ffi::c_void,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_syntaxv_ds(
        ds: arg_dstr_t,
        argtable: *mut *mut ::core::ffi::c_void,
        suffix: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_glossary_ds(
        ds: arg_dstr_t,
        argtable: *mut *mut ::core::ffi::c_void,
        format: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_print_glossary_gnu_ds(ds: arg_dstr_t, argtable: *mut *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn arg_print_errors_ds(
        ds: arg_dstr_t,
        end: *mut arg_end,
        progname: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_freetable(argtable: *mut *mut ::core::ffi::c_void, n: usize);
}
extern "C" {
    pub fn arg_dstr_create() -> arg_dstr_t;
}
extern "C" {
    pub fn arg_dstr_destroy(ds: arg_dstr_t);
}
extern "C" {
    pub fn arg_dstr_reset(ds: arg_dstr_t);
}
extern "C" {
    pub fn arg_dstr_free(ds: arg_dstr_t);
}
extern "C" {
    pub fn arg_dstr_set(ds: arg_dstr_t, str_: *mut ::core::ffi::c_char, free_proc: arg_dstr_freefn);
}
extern "C" {
    pub fn arg_dstr_cat(ds: arg_dstr_t, str_: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn arg_dstr_catc(ds: arg_dstr_t, c: ::core::ffi::c_char);
}
extern "C" {
    pub fn arg_dstr_catf(ds: arg_dstr_t, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn arg_dstr_cstr(ds: arg_dstr_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn arg_cmd_init();
}
extern "C" {
    pub fn arg_cmd_uninit();
}
extern "C" {
    pub fn arg_cmd_register(
        name: *const ::core::ffi::c_char,
        proc_: arg_cmdfn,
        description: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn arg_cmd_unregister(name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn arg_cmd_dispatch(
        name: *const ::core::ffi::c_char,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
        res: arg_dstr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_cmd_count() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn arg_cmd_info(name: *const ::core::ffi::c_char) -> *mut arg_cmd_info_t;
}
extern "C" {
    pub fn arg_cmd_itr_create() -> arg_cmd_itr_t;
}
extern "C" {
    pub fn arg_cmd_itr_destroy(itr: arg_cmd_itr_t);
}
extern "C" {
    pub fn arg_cmd_itr_advance(itr: arg_cmd_itr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_cmd_itr_key(itr: arg_cmd_itr_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn arg_cmd_itr_value(itr: arg_cmd_itr_t) -> *mut arg_cmd_info_t;
}
extern "C" {
    pub fn arg_cmd_itr_search(
        itr: arg_cmd_itr_t,
        k: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_mgsort(
        data: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        esize: ::core::ffi::c_int,
        i: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        comparefn: arg_comparefn,
    );
}
extern "C" {
    pub fn arg_make_get_help_msg(res: arg_dstr_t);
}
extern "C" {
    pub fn arg_make_help_msg(
        ds: arg_dstr_t,
        cmd_name: *mut ::core::ffi::c_char,
        argtable: *mut *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn arg_make_syntax_err_msg(
        ds: arg_dstr_t,
        argtable: *mut *mut ::core::ffi::c_void,
        end: *mut arg_end,
    );
}
extern "C" {
    pub fn arg_make_syntax_err_help_msg(
        ds: arg_dstr_t,
        name: *mut ::core::ffi::c_char,
        help: ::core::ffi::c_int,
        nerrors: ::core::ffi::c_int,
        argtable: *mut *mut ::core::ffi::c_void,
        end: *mut arg_end,
        exitcode: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arg_set_module_name(name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn arg_set_module_version(
        major: ::core::ffi::c_int,
        minor: ::core::ffi::c_int,
        patch: ::core::ffi::c_int,
        tag: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " deprecated functions, for back-compatibility only"]
    pub fn arg_free(argtable: *mut *mut ::core::ffi::c_void);
}
#[doc = "< Number of eFuse BLOCK0. REPEAT_DATA"]
pub const esp_efuse_block_t_EFUSE_BLK0: esp_efuse_block_t = 0;
#[doc = "< Number of eFuse BLOCK1. MAC_SPI_8M_SYS"]
pub const esp_efuse_block_t_EFUSE_BLK1: esp_efuse_block_t = 1;
#[doc = "< Number of eFuse BLOCK2. SYS_DATA_PART1"]
pub const esp_efuse_block_t_EFUSE_BLK2: esp_efuse_block_t = 2;
#[doc = "< Number of eFuse BLOCK2. SYS_DATA_PART1"]
pub const esp_efuse_block_t_EFUSE_BLK_SYS_DATA_PART1: esp_efuse_block_t = 2;
#[doc = "< Number of eFuse BLOCK3. USER_DATA"]
pub const esp_efuse_block_t_EFUSE_BLK3: esp_efuse_block_t = 3;
#[doc = "< Number of eFuse BLOCK3. USER_DATA"]
pub const esp_efuse_block_t_EFUSE_BLK_USER_DATA: esp_efuse_block_t = 3;
#[doc = "< Number of eFuse BLOCK4. KEY0"]
pub const esp_efuse_block_t_EFUSE_BLK4: esp_efuse_block_t = 4;
#[doc = "< Number of eFuse BLOCK4. KEY0"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY0: esp_efuse_block_t = 4;
#[doc = "< Number of eFuse BLOCK5. KEY1"]
pub const esp_efuse_block_t_EFUSE_BLK5: esp_efuse_block_t = 5;
#[doc = "< Number of eFuse BLOCK5. KEY1"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY1: esp_efuse_block_t = 5;
#[doc = "< Number of eFuse BLOCK6. KEY2"]
pub const esp_efuse_block_t_EFUSE_BLK6: esp_efuse_block_t = 6;
#[doc = "< Number of eFuse BLOCK6. KEY2"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY2: esp_efuse_block_t = 6;
#[doc = "< Number of eFuse BLOCK7. KEY3"]
pub const esp_efuse_block_t_EFUSE_BLK7: esp_efuse_block_t = 7;
#[doc = "< Number of eFuse BLOCK7. KEY3"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY3: esp_efuse_block_t = 7;
#[doc = "< Number of eFuse BLOCK8. KEY4"]
pub const esp_efuse_block_t_EFUSE_BLK8: esp_efuse_block_t = 8;
#[doc = "< Number of eFuse BLOCK8. KEY4"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY4: esp_efuse_block_t = 8;
#[doc = "< Number of eFuse BLOCK9. KEY5"]
pub const esp_efuse_block_t_EFUSE_BLK9: esp_efuse_block_t = 9;
#[doc = "< Number of eFuse BLOCK9. KEY5"]
pub const esp_efuse_block_t_EFUSE_BLK_KEY5: esp_efuse_block_t = 9;
pub const esp_efuse_block_t_EFUSE_BLK_KEY_MAX: esp_efuse_block_t = 10;
#[doc = "< Number of eFuse BLOCK10. SYS_DATA_PART2"]
pub const esp_efuse_block_t_EFUSE_BLK10: esp_efuse_block_t = 10;
#[doc = "< Number of eFuse BLOCK10. SYS_DATA_PART2"]
pub const esp_efuse_block_t_EFUSE_BLK_SYS_DATA_PART2: esp_efuse_block_t = 10;
pub const esp_efuse_block_t_EFUSE_BLK_MAX: esp_efuse_block_t = 11;
#[doc = " @brief Type of eFuse blocks ESP32C3"]
pub type esp_efuse_block_t = ::core::ffi::c_uint;
#[doc = "< None"]
pub const esp_efuse_coding_scheme_t_EFUSE_CODING_SCHEME_NONE: esp_efuse_coding_scheme_t = 0;
#[doc = "< Reed-Solomon coding"]
pub const esp_efuse_coding_scheme_t_EFUSE_CODING_SCHEME_RS: esp_efuse_coding_scheme_t = 3;
#[doc = " @brief Type of coding scheme"]
pub type esp_efuse_coding_scheme_t = ::core::ffi::c_uint;
#[doc = "< User purposes (software-only use)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_USER: esp_efuse_purpose_t = 0;
#[doc = "< Reserved"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_RESERVED: esp_efuse_purpose_t = 1;
#[doc = "< XTS_AES_128_KEY (flash/PSRAM encryption)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_XTS_AES_128_KEY: esp_efuse_purpose_t = 4;
#[doc = "< HMAC Downstream mode"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_HMAC_DOWN_ALL: esp_efuse_purpose_t = 5;
#[doc = "< JTAG soft enable key (uses HMAC Downstream mode)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_HMAC_DOWN_JTAG: esp_efuse_purpose_t = 6;
#[doc = "< Digital Signature peripheral key (uses HMAC Downstream mode)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_HMAC_DOWN_DIGITAL_SIGNATURE:
    esp_efuse_purpose_t = 7;
#[doc = "< HMAC Upstream mode"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_HMAC_UP: esp_efuse_purpose_t = 8;
#[doc = "< SECURE_BOOT_DIGEST0 (Secure Boot key digest)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_DIGEST0: esp_efuse_purpose_t = 9;
#[doc = "< SECURE_BOOT_DIGEST1 (Secure Boot key digest)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_DIGEST1: esp_efuse_purpose_t = 10;
#[doc = "< SECURE_BOOT_DIGEST2 (Secure Boot key digest)"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_SECURE_BOOT_DIGEST2: esp_efuse_purpose_t = 11;
#[doc = "< MAX PURPOSE"]
pub const esp_efuse_purpose_t_ESP_EFUSE_KEY_PURPOSE_MAX: esp_efuse_purpose_t = 12;
#[doc = " @brief Type of key purpose"]
pub type esp_efuse_purpose_t = ::core::ffi::c_uint;
#[doc = " @brief Type definition for an eFuse field"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct esp_efuse_desc_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Start bit [0..255]"]
    pub bit_start: u8,
    #[doc = "< Length of bit field [1..-]"]
    pub bit_count: u16,
}
impl Default for esp_efuse_desc_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl esp_efuse_desc_t {
    #[inline]
    pub fn efuse_block(&self) -> esp_efuse_block_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_efuse_block(&mut self, val: esp_efuse_block_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(efuse_block: esp_efuse_block_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let efuse_block: u32 = unsafe { ::core::mem::transmute(efuse_block) };
            efuse_block as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Always enable ROM logging"]
pub const esp_efuse_rom_log_scheme_t_ESP_EFUSE_ROM_LOG_ALWAYS_ON: esp_efuse_rom_log_scheme_t = 0;
#[doc = "< ROM logging is enabled when specific GPIO level is low during start up"]
pub const esp_efuse_rom_log_scheme_t_ESP_EFUSE_ROM_LOG_ON_GPIO_LOW: esp_efuse_rom_log_scheme_t = 1;
#[doc = "< ROM logging is enabled when specific GPIO level is high during start up"]
pub const esp_efuse_rom_log_scheme_t_ESP_EFUSE_ROM_LOG_ON_GPIO_HIGH: esp_efuse_rom_log_scheme_t = 2;
#[doc = "< Disable ROM logging permanently"]
pub const esp_efuse_rom_log_scheme_t_ESP_EFUSE_ROM_LOG_ALWAYS_OFF: esp_efuse_rom_log_scheme_t = 3;
#[doc = " @brief Type definition for ROM log scheme"]
pub type esp_efuse_rom_log_scheme_t = ::core::ffi::c_uint;
#[doc = " @brief Pointers to the trusted key digests.\n\n The number of digests depends on the SOC's capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_secure_boot_key_digests_t {
    #[doc = "< Pointers to the key digests"]
    pub key_digests: [*const ::core::ffi::c_void; 3usize],
}
impl Default for esp_secure_boot_key_digests_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Reads bits from EFUSE field and writes it into an array.\n\n The number of read bits will be limited to the minimum value\n from the description of the bits in \"field\" structure or \"dst_size_bits\" required size.\n Use \"esp_efuse_get_field_size()\" function to determine the length of the field.\n\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n @param[out] dst            A pointer to array that will contain the result of reading.\n @param[in]  dst_size_bits  The number of bits required to read.\n                            If the requested number of bits is greater than the field,\n                            the number will be limited to the field size.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments."]
    pub fn esp_efuse_read_field_blob(
        field: *mut *const esp_efuse_desc_t,
        dst: *mut ::core::ffi::c_void,
        dst_size_bits: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read a single bit eFuse field as a boolean value.\n\n @note The value must exist and must be a single bit wide. If there is any possibility of an error\n in the provided arguments, call esp_efuse_read_field_blob() and check the returned value instead.\n\n @note If assertions are enabled and the parameter is invalid, execution will abort\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n @return\n    - true: The field parameter is valid and the bit is set.\n    - false: The bit is not set, or the parameter is invalid and assertions are disabled.\n"]
    pub fn esp_efuse_read_field_bit(field: *mut *const esp_efuse_desc_t) -> bool;
}
extern "C" {
    #[doc = " @brief   Reads bits from EFUSE field and returns number of bits programmed as \"1\".\n\n If the bits are set not sequentially, they will still be counted.\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n @param[out] out_cnt        A pointer that will contain the number of programmed as \"1\" bits.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments."]
    pub fn esp_efuse_read_field_cnt(
        field: *mut *const esp_efuse_desc_t,
        out_cnt: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Writes array to EFUSE field.\n\n The number of write bits will be limited to the minimum value\n from the description of the bits in \"field\" structure or \"src_size_bits\" required size.\n Use \"esp_efuse_get_field_size()\" function to determine the length of the field.\n After the function is completed, the writing registers are cleared.\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n @param[in]  src            A pointer to array that contains the data for writing.\n @param[in]  src_size_bits  The number of bits required to write.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_write_field_blob(
        field: *mut *const esp_efuse_desc_t,
        src: *const ::core::ffi::c_void,
        src_size_bits: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Writes a required count of bits as \"1\" to EFUSE field.\n\n If there are no free bits in the field to set the required number of bits to \"1\",\n ESP_ERR_EFUSE_CNT_IS_FULL error is returned, the field will not be partially recorded.\n After the function is completed, the writing registers are cleared.\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n @param[in]  cnt            Required number of programmed as \"1\" bits.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set."]
    pub fn esp_efuse_write_field_cnt(field: *mut *const esp_efuse_desc_t, cnt: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write a single bit eFuse field to 1\n\n For use with eFuse fields that are a single bit. This function will write the bit to value 1 if\n it is not already set, or does nothing if the bit is already set.\n\n This is equivalent to calling esp_efuse_write_field_cnt() with the cnt parameter equal to 1,\n except that it will return ESP_OK if the field is already set to 1.\n\n @param[in] field Pointer to the structure describing the efuse field.\n\n @return\n - ESP_OK: The operation was successfully completed, or the bit was already set to value 1.\n - ESP_ERR_INVALID_ARG: Error in the passed arugments, including if the efuse field is not 1 bit wide."]
    pub fn esp_efuse_write_field_bit(field: *mut *const esp_efuse_desc_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Sets a write protection for the whole block.\n\n After that, it is impossible to write to this block.\n The write protection does not apply to block 0.\n @param[in]  blk          Block number of eFuse. (EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3)\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set.\n    - ESP_ERR_NOT_SUPPORTED: The block does not support this command."]
    pub fn esp_efuse_set_write_protect(blk: esp_efuse_block_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Sets a read protection for the whole block.\n\n After that, it is impossible to read from this block.\n The read protection does not apply to block 0.\n @param[in]  blk          Block number of eFuse. (EFUSE_BLK1, EFUSE_BLK2 and EFUSE_BLK3)\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_CNT_IS_FULL: Not all requested cnt bits is set.\n    - ESP_ERR_NOT_SUPPORTED: The block does not support this command."]
    pub fn esp_efuse_set_read_protect(blk: esp_efuse_block_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Returns the number of bits used by field.\n\n @param[in]  field          A pointer to the structure describing the fields of efuse.\n\n @return Returns the number of bits used by field."]
    pub fn esp_efuse_get_field_size(field: *mut *const esp_efuse_desc_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Returns value of efuse register.\n\n This is a thread-safe implementation.\n Example: EFUSE_BLK2_RDATA3_REG where (blk=2, num_reg=3)\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n @param[in]  blk     Block number of eFuse.\n @param[in]  num_reg The register number in the block.\n\n @return Value of register"]
    pub fn esp_efuse_read_reg(blk: esp_efuse_block_t, num_reg: ::core::ffi::c_uint) -> u32;
}
extern "C" {
    #[doc = " @brief   Write value to efuse register.\n\n Apply a coding scheme if necessary.\n This is a thread-safe implementation.\n Example: EFUSE_BLK3_WDATA0_REG where (blk=3, num_reg=0)\n @param[in]  blk     Block number of eFuse.\n @param[in]  num_reg The register number in the block.\n @param[in]  val     Value to write.\n\n @return\n      - ESP_OK: The operation was successfully completed.\n      - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden."]
    pub fn esp_efuse_write_reg(
        blk: esp_efuse_block_t,
        num_reg: ::core::ffi::c_uint,
        val: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Return efuse coding scheme for blocks.\n\n Note: The coding scheme is applicable only to 1, 2 and 3 blocks. For 0 block, the coding scheme is always ``NONE``.\n\n @param[in]  blk     Block number of eFuse.\n @return Return efuse coding scheme for blocks"]
    pub fn esp_efuse_get_coding_scheme(blk: esp_efuse_block_t) -> esp_efuse_coding_scheme_t;
}
extern "C" {
    #[doc = " @brief   Read key to efuse block starting at the offset and the required size.\n\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n @param[in]  blk             Block number of eFuse.\n @param[in]  dst_key         A pointer to array that will contain the result of reading.\n @param[in]  offset_in_bits  Start bit in block.\n @param[in]  size_bits       The number of bits required to read.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_read_block(
        blk: esp_efuse_block_t,
        dst_key: *mut ::core::ffi::c_void,
        offset_in_bits: usize,
        size_bits: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Write key to efuse block starting at the offset and the required size.\n\n @param[in]  blk             Block number of eFuse.\n @param[in]  src_key         A pointer to array that contains the key for writing.\n @param[in]  offset_in_bits  Start bit in block.\n @param[in]  size_bits       The number of bits required to write.\n\n @return\n    - ESP_OK: The operation was successfully completed.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits"]
    pub fn esp_efuse_write_block(
        blk: esp_efuse_block_t,
        src_key: *const ::core::ffi::c_void,
        offset_in_bits: usize,
        size_bits: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Returns chip package from efuse\n\n @return chip package"]
    pub fn esp_efuse_get_pkg_ver() -> u32;
}
extern "C" {
    #[doc = "  @brief Reset efuse write registers\n\n Efuse write registers are written to zero, to negate\n any changes that have been staged here.\n\n @note This function is not threadsafe, if calling code updates\n efuse values from multiple tasks then this is caller's\n responsibility to serialise."]
    pub fn esp_efuse_reset();
}
extern "C" {
    #[doc = "  @brief Disable ROM Download Mode via eFuse\n\n Permanently disables the ROM Download Mode feature. Once disabled, if the SoC is booted with\n strapping pins set for ROM Download Mode then an error is printed instead.\n\n @note Not all SoCs support this option. An error will be returned if called on an ESP32\n with a silicon revision lower than 3, as these revisions do not support this option.\n\n @note If ROM Download Mode is already disabled, this function does nothing and returns success.\n\n @return\n - ESP_OK If the eFuse was successfully burned, or had already been burned.\n - ESP_ERR_NOT_SUPPORTED (ESP32 only) This SoC is not capable of disabling UART download mode\n - ESP_ERR_INVALID_STATE (ESP32 only) This eFuse is write protected and cannot be written"]
    pub fn esp_efuse_disable_rom_download_mode() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set boot ROM log scheme via eFuse\n\n @note By default, the boot ROM will always print to console. This API can be called to set the log scheme only once per chip,\n       once the value is changed from the default it can't be changed again.\n\n @param log_scheme Supported ROM log scheme\n @return\n      - ESP_OK If the eFuse was successfully burned, or had already been burned.\n      - ESP_ERR_NOT_SUPPORTED (ESP32 only) This SoC is not capable of setting ROM log scheme\n      - ESP_ERR_INVALID_STATE This eFuse is write protected or has been burned already"]
    pub fn esp_efuse_set_rom_log_scheme(log_scheme: esp_efuse_rom_log_scheme_t) -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Switch ROM Download Mode to Secure Download mode via eFuse\n\n Permanently enables Secure Download mode. This mode limits the use of ROM Download Mode functions\n to simple flash read, write and erase operations, plus a command to return a summary of currently\n enabled security features.\n\n @note If Secure Download mode is already enabled, this function does nothing and returns success.\n\n @note Disabling the ROM Download Mode also disables Secure Download Mode.\n\n @return\n - ESP_OK If the eFuse was successfully burned, or had already been burned.\n - ESP_ERR_INVALID_STATE ROM Download Mode has been disabled via eFuse, so Secure Download mode is unavailable."]
    pub fn esp_efuse_enable_rom_secure_download_mode() -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Return secure_version from efuse field.\n @return Secure version from efuse field"]
    pub fn esp_efuse_read_secure_version() -> u32;
}
extern "C" {
    #[doc = "  @brief Check secure_version from app and secure_version and from efuse field.\n\n @param secure_version Secure version from app.\n @return\n          - True: If version of app is equal or more then secure_version from efuse."]
    pub fn esp_efuse_check_secure_version(secure_version: u32) -> bool;
}
extern "C" {
    #[doc = "  @brief Write efuse field by secure_version value.\n\n Update the secure_version value is available if the coding scheme is None.\n Note: Do not use this function in your applications. This function is called as part of the other API.\n\n @param[in] secure_version Secure version from app.\n @return\n          - ESP_OK: Successful.\n          - ESP_FAIL: secure version of app cannot be set to efuse field.\n          - ESP_ERR_NOT_SUPPORTED: Anti rollback is not supported with the 3/4 and Repeat coding scheme."]
    pub fn esp_efuse_update_secure_version(secure_version: u32) -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Set the batch mode of writing fields.\n\n This mode allows you to write the fields in the batch mode when need to burn several efuses at one time.\n To enable batch mode call begin() then perform as usually the necessary operations\n read and write and at the end call commit() to actually burn all written efuses.\n The batch mode can be used nested. The commit will be done by the last commit() function.\n The number of begin() functions should be equal to the number of commit() functions.\n\n @note Please note that reading in the batch mode does not show uncommitted changes.\n\n Note: If batch mode is enabled by the first task, at this time the second task cannot write/read efuses.\n The second task will wait for the first task to complete the batch operation.\n\n \\code{c}\n // Example of using the batch writing mode.\n\n // set the batch writing mode\n esp_efuse_batch_write_begin();\n\n // use any writing functions as usual\n esp_efuse_write_field_blob(ESP_EFUSE_...);\n esp_efuse_write_field_cnt(ESP_EFUSE_...);\n esp_efuse_set_write_protect(EFUSE_BLKx);\n esp_efuse_write_reg(EFUSE_BLKx, ...);\n esp_efuse_write_block(EFUSE_BLKx, ...);\n esp_efuse_write(ESP_EFUSE_1, 3);  // ESP_EFUSE_1 == 1, here we write a new value = 3. The changes will be burn by the commit() function.\n esp_efuse_read_...(ESP_EFUSE_1);  // this function returns ESP_EFUSE_1 == 1 because uncommitted changes are not readable, it will be available only after commit.\n ...\n\n // esp_efuse_batch_write APIs can be called recursively.\n esp_efuse_batch_write_begin();\n esp_efuse_set_write_protect(EFUSE_BLKx);\n esp_efuse_batch_write_commit(); // the burn will be skipped here, it will be done in the last commit().\n\n ...\n\n // Write all of these fields to the efuse registers\n esp_efuse_batch_write_commit();\n esp_efuse_read_...(ESP_EFUSE_1);  // this function returns ESP_EFUSE_1 == 3.\n\n \\endcode\n\n @return\n          - ESP_OK: Successful."]
    pub fn esp_efuse_batch_write_begin() -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Reset the batch mode of writing fields.\n\n It will reset the batch writing mode and any written changes.\n\n @return\n          - ESP_OK: Successful.\n          - ESP_ERR_INVALID_STATE: Tha batch mode was not set."]
    pub fn esp_efuse_batch_write_cancel() -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Writes all prepared data for the batch mode.\n\n Must be called to ensure changes are written to the efuse registers.\n After this the batch writing mode will be reset.\n\n @return\n          - ESP_OK: Successful.\n          - ESP_ERR_INVALID_STATE: The deferred writing mode was not set."]
    pub fn esp_efuse_batch_write_commit() -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Checks that the given block is empty.\n\n @return\n          - True: The block is empty.\n          - False: The block is not empty or was an error."]
    pub fn esp_efuse_block_is_empty(block: esp_efuse_block_t) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a read protection for the key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return True: The key block is read protected\n         False: The key block is readable."]
    pub fn esp_efuse_get_key_dis_read(block: esp_efuse_block_t) -> bool;
}
extern "C" {
    #[doc = " @brief Sets a read protection for the key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_key_dis_read(block: esp_efuse_block_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns a write protection for the key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return True: The key block is write protected\n         False: The key block is writeable."]
    pub fn esp_efuse_get_key_dis_write(block: esp_efuse_block_t) -> bool;
}
extern "C" {
    #[doc = " @brief Sets a write protection for the key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_key_dis_write(block: esp_efuse_block_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns true if the key block is unused, false otherwise.\n\n An unused key block is all zero content, not read or write protected,\n and has purpose 0 (ESP_EFUSE_KEY_PURPOSE_USER)\n\n @param block key block to check.\n\n @return\n         - True if key block is unused,\n         - False if key block is used or the specified block index is not a key block."]
    pub fn esp_efuse_key_block_unused(block: esp_efuse_block_t) -> bool;
}
extern "C" {
    #[doc = " @brief Find a key block with the particular purpose set.\n\n @param[in] purpose Purpose to search for.\n @param[out] block Pointer in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX which will be set to the key block if found.\n                   Can be NULL, if only need to test the key block exists.\n\n @return\n         - True: If found,\n         - False: If not found (value at block pointer is unchanged)."]
    pub fn esp_efuse_find_purpose(
        purpose: esp_efuse_purpose_t,
        block: *mut esp_efuse_block_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a write protection of the key purpose field for an efuse key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @note For ESP32: no keypurpose, it returns always True.\n\n @return True: The key purpose is write protected.\n         False: The key purpose is writeable."]
    pub fn esp_efuse_get_keypurpose_dis_write(block: esp_efuse_block_t) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the current purpose set for an efuse key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return\n         - Value: If Successful, it returns the value of the purpose related to the given key block.\n         - ESP_EFUSE_KEY_PURPOSE_MAX: Otherwise."]
    pub fn esp_efuse_get_key_purpose(block: esp_efuse_block_t) -> esp_efuse_purpose_t;
}
extern "C" {
    #[doc = " @brief Returns a pointer to a key purpose for an efuse key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n To get the value of this field use esp_efuse_read_field_blob() or esp_efuse_get_key_purpose().\n\n @return Pointer: If Successful returns a pointer to the corresponding efuse field otherwise NULL."]
    pub fn esp_efuse_get_purpose_field(block: esp_efuse_block_t) -> *mut *const esp_efuse_desc_t;
}
extern "C" {
    #[doc = " @brief Returns a pointer to a key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return Pointer: If Successful returns a pointer to the corresponding efuse field otherwise NULL."]
    pub fn esp_efuse_get_key(block: esp_efuse_block_t) -> *mut *const esp_efuse_desc_t;
}
extern "C" {
    #[doc = " @brief Sets a key purpose for an efuse key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n @param[in] purpose Key purpose.\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_key_purpose(
        block: esp_efuse_block_t,
        purpose: esp_efuse_purpose_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets a write protection of the key purpose field for an efuse key block.\n\n @param[in] block A key block in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_keypurpose_dis_write(block: esp_efuse_block_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Search for an unused key block and return the first one found.\n\n See esp_efuse_key_block_unused for a description of an unused key block.\n\n @return First unused key block, or EFUSE_BLK_KEY_MAX if no unused key block is found."]
    pub fn esp_efuse_find_unused_key_block() -> esp_efuse_block_t;
}
extern "C" {
    #[doc = " @brief Return the number of unused efuse key blocks in the range EFUSE_BLK_KEY0..EFUSE_BLK_KEY_MAX"]
    pub fn esp_efuse_count_unused_key_blocks() -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief Returns the status of the Secure Boot public key digest revocation bit.\n\n @param[in] num_digest The number of digest in range 0..2\n\n @return\n         - True: If key digest is revoked,\n         - False; If key digest is not revoked."]
    pub fn esp_efuse_get_digest_revoke(num_digest: ::core::ffi::c_uint) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the Secure Boot public key digest revocation bit.\n\n @param[in] num_digest The number of digest in range 0..2\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_digest_revoke(num_digest: ::core::ffi::c_uint) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns a write protection of the Secure Boot public key digest revocation bit.\n\n @param[in] num_digest The number of digest in range 0..2\n\n @return True: The revocation bit is write protected.\n         False: The revocation bit is writeable."]
    pub fn esp_efuse_get_write_protect_of_digest_revoke(num_digest: ::core::ffi::c_uint) -> bool;
}
extern "C" {
    #[doc = " @brief Sets a write protection of the Secure Boot public key digest revocation bit.\n\n @param[in] num_digest The number of digest in range 0..2\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_set_write_protect_of_digest_revoke(
        num_digest: ::core::ffi::c_uint,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Program a block of key data to an efuse block\n\n The burn of a key, protection bits, and a purpose happens in batch mode.\n\n @param[in] block Block to read purpose for. Must be in range EFUSE_BLK_KEY0 to EFUSE_BLK_KEY_MAX. Key block must be unused (esp_efuse_key_block_unused).\n @param[in] purpose Purpose to set for this key. Purpose must be already unset.\n @param[in] key Pointer to data to write.\n @param[in] key_size_bytes Bytes length of data to write.\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_INVALID_STATE: Error in efuses state, unused block not found.\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_write_key(
        block: esp_efuse_block_t,
        purpose: esp_efuse_purpose_t,
        key: *const ::core::ffi::c_void,
        key_size_bytes: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Program keys to unused efuse blocks\n\n The burn of keys, protection bits, and purposes happens in batch mode.\n\n @param[in] purposes Array of purposes (purpose[number_of_keys]).\n @param[in] keys Array of keys (uint8_t keys[number_of_keys][32]). Each key is 32 bytes long.\n @param[in] number_of_keys The number of keys to write (up to 6 keys).\n\n @return\n    - ESP_OK: Successful.\n    - ESP_ERR_INVALID_ARG: Error in the passed arguments.\n    - ESP_ERR_INVALID_STATE: Error in efuses state, unused block not found.\n    - ESP_ERR_NOT_ENOUGH_UNUSED_KEY_BLOCKS: Error not enough unused key blocks available\n    - ESP_ERR_EFUSE_REPEATED_PROG: Error repeated programming of programmed bits is strictly forbidden.\n    - ESP_ERR_CODING: Error range of data does not match the coding scheme."]
    pub fn esp_efuse_write_keys(
        purposes: *const esp_efuse_purpose_t,
        keys: *mut [u8; 32usize],
        number_of_keys: ::core::ffi::c_uint,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read key digests from efuse. Any revoked/missing digests will be marked as NULL\n\n @param[out] trusted_key_digests Trusted keys digests, stored in this parameter after successfully\n                                 completing this function.\n                                 The number of digests depends on the SOC's capabilities.\n\n @return\n    - ESP_OK: Successful.\n    - ESP_FAIL: If trusted_keys is NULL or there is no valid digest."]
    pub fn esp_secure_boot_read_key_digests(
        trusted_key_digests: *mut esp_secure_boot_key_digests_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Checks eFuse errors in BLOCK0.\n\n @note Refers to ESP32-C3 only.\n\n It does a BLOCK0 check if eFuse EFUSE_ERR_RST_ENABLE is set.\n If BLOCK0 has an error, it prints the error and returns ESP_FAIL, which should be treated as esp_restart.\n\n @return\n         - ESP_OK: No errors in BLOCK0.\n         - ESP_FAIL: Error in BLOCK0 requiring reboot."]
    pub fn esp_efuse_check_errors() -> esp_err_t;
}
#[doc = " @brief Power management config for ESP32C3\n\n Pass a pointer to this structure as an argument to esp_pm_configure function."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_pm_config_esp32c3_t {
    #[doc = "< Maximum CPU frequency, in MHz"]
    pub max_freq_mhz: ::core::ffi::c_int,
    #[doc = "< Minimum CPU frequency to use when no locks are taken, in MHz"]
    pub min_freq_mhz: ::core::ffi::c_int,
    #[doc = "< Enter light sleep when no locks are taken"]
    pub light_sleep_enable: bool,
}
#[doc = " Require CPU frequency to be at the maximum value set via esp_pm_configure.\n Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_CPU_FREQ_MAX: esp_pm_lock_type_t = 0;
#[doc = " Require APB frequency to be at the maximum value supported by the chip.\n Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_APB_FREQ_MAX: esp_pm_lock_type_t = 1;
#[doc = " Prevent the system from going into light sleep.\n Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_NO_LIGHT_SLEEP: esp_pm_lock_type_t = 2;
#[doc = " @brief Power management constraints"]
pub type esp_pm_lock_type_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Set implementation-specific power management configuration\n @param config pointer to implementation-specific configuration structure (e.g. esp_pm_config_esp32)\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the configuration values are not correct\n      - ESP_ERR_NOT_SUPPORTED if certain combination of values is not supported,\n        or if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_configure(config: *const ::core::ffi::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get implementation-specific power management configuration\n @param config pointer to implementation-specific configuration structure (e.g. esp_pm_config_esp32)\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the pointer is null"]
    pub fn esp_pm_get_configuration(config: *mut ::core::ffi::c_void) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_pm_lock {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to the power management lock"]
pub type esp_pm_lock_handle_t = *mut esp_pm_lock;
extern "C" {
    #[doc = " @brief Initialize a lock handle for certain power management parameter\n\n When lock is created, initially it is not taken.\n Call esp_pm_lock_acquire to take the lock.\n\n This function must not be called from an ISR.\n\n @param lock_type Power management constraint which the lock should control\n @param arg argument, value depends on lock_type, see esp_pm_lock_type_t\n @param name arbitrary string identifying the lock (e.g. \"wifi\" or \"spi\").\n             Used by the esp_pm_dump_locks function to list existing locks.\n             May be set to NULL. If not set to NULL, must point to a string which is valid\n             for the lifetime of the lock.\n @param[out] out_handle  handle returned from this function. Use this handle when calling\n                         esp_pm_lock_delete, esp_pm_lock_acquire, esp_pm_lock_release.\n                         Must not be NULL.\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if the lock structure can not be allocated\n      - ESP_ERR_INVALID_ARG if out_handle is NULL or type argument is not valid\n      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_create(
        lock_type: esp_pm_lock_type_t,
        arg: ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        out_handle: *mut esp_pm_lock_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take a power management lock\n\n Once the lock is taken, power management algorithm will not switch to the\n mode specified in a call to esp_pm_lock_create, or any of the lower power\n modes (higher numeric values of 'mode').\n\n The lock is recursive, in the sense that if esp_pm_lock_acquire is called\n a number of times, esp_pm_lock_release has to be called the same number of\n times in order to release the lock.\n\n This function may be called from an ISR.\n\n This function is not thread-safe w.r.t. calls to other esp_pm_lock_*\n functions for the same handle.\n\n @param handle handle obtained from esp_pm_lock_create function\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_acquire(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release the lock taken using esp_pm_lock_acquire.\n\n Call to this functions removes power management restrictions placed when\n taking the lock.\n\n Locks are recursive, so if esp_pm_lock_acquire is called a number of times,\n esp_pm_lock_release has to be called the same number of times in order to\n actually release the lock.\n\n This function may be called from an ISR.\n\n This function is not thread-safe w.r.t. calls to other esp_pm_lock_*\n functions for the same handle.\n\n @param handle handle obtained from esp_pm_lock_create function\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if lock is not acquired\n      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_release(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete a lock created using esp_pm_lock\n\n The lock must be released before calling this function.\n\n This function must not be called from an ISR.\n\n @param handle handle obtained from esp_pm_lock_create function\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle argument is NULL\n      - ESP_ERR_INVALID_STATE if the lock is still acquired\n      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_delete(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Dump the list of all locks to stderr\n\n This function dumps debugging information about locks created using\n esp_pm_lock_create to an output stream.\n\n This function must not be called from an ISR. If esp_pm_lock_acquire/release\n are called while this function is running, inconsistent results may be\n reported.\n\n @param stream stream to print information to; use stdout or stderr to print\n               to the console; use fmemopen/open_memstream to print to a\n               string buffer.\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_dump_locks(stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type\n @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = "!< Count of the methods for dispatching timer callback"]
pub const esp_timer_dispatch_t_ESP_TIMER_MAX: esp_timer_dispatch_t = 1;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = ::core::ffi::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut ::core::ffi::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const ::core::ffi::c_char,
    #[doc = "!< Skip unhandled events for periodic timers"]
    pub skip_unhandled_events: bool,
}
impl Default for esp_timer_create_args_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Minimal initialization of esp_timer\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n\n This function can be called very early in startup process, after this call\n only esp_timer_get_time function can be used.\n\n @return\n      - ESP_OK on success"]
    pub fn esp_timer_early_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library\n\n @note This function is called from startup code. Applications do not need\n to call this function before using other esp_timer APIs.\n Before calling this function, esp_timer_early_init must be called by the\n startup code.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if allocation has failed\n      - ESP_ERR_INVALID_STATE if already initialized\n      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library\n\n @note Normally this function should not be called from applications\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance\n\n @note When done using the timer, delete it with esp_timer_delete function.\n\n @param create_args   Pointer to a structure with timer creation arguments.\n                      Not saved by the library, can be allocated on the stack.\n @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which\n                         will hold the created timer handle.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if some of the create_args are not valid\n      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet\n      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer\n\n Timer should not be running when this function is called.\n\n @param timer timer handle created using esp_timer_create\n @param timeout_us timer timeout, in microseconds relative to the current moment\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer\n\n Timer should not be running when this function is called. This function will\n start the timer which will trigger every 'period' microseconds.\n\n @param timer timer handle created using esp_timer_create\n @param period timer period, in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Restart a currently running timer\n\n If the given timer is a one-shot timer, the timer is restarted immediately and will timeout once in `timeout_us` microseconds.\n If the given timer is a periodic timer, the timer is restarted immediately with a new period of `timeout_us` microseconds.\n\n @param timer timer Handle created using esp_timer_create\n @param timeout_us Timeout, in microseconds relative to the current time.\n                   In case of a periodic timer, also represents the new period.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the handle is invalid\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_restart(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer\n\n This function stops the timer previously started using esp_timer_start_once\n or esp_timer_start_periodic.\n\n @param timer timer handle created using esp_timer_create\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance\n\n The timer must be stopped before deleting. A one-shot timer which has expired\n does not need to be stopped.\n\n @param timer timer handle allocated using esp_timer_create\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if the timer is running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot\n @return number of microseconds since underlying timer has been started"]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur skipping those which have skip_unhandled_events flag\n @return Timestamp of the nearest timer event, in microseconds.\n         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm_for_wake_up() -> i64;
}
extern "C" {
    #[doc = " @brief Get the period of a timer\n\n This function fetches the timeout period of a timer.\n\n @note The timeout period is the time interval with which a timer restarts after expiry. For one-shot timers, the\n period is 0 as there is no periodicity associated with such timers.\n\n @param timer timer handle allocated using esp_timer_create\n @param period memory to store the timer period value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid"]
    pub fn esp_timer_get_period(timer: esp_timer_handle_t, period: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the expiry time of a one-shot timer\n\n This function fetches the expiry time of a one-shot timer.\n\n @note This API returns a valid expiry time only for a one-shot timer. It returns an error if the timer handle passed\n to the function is for a periodic timer.\n\n @param timer timer handle allocated using esp_timer_create\n @param expiry memory to store the timeout value in microseconds\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the arguments are invalid\n      - ESP_ERR_NOT_SUPPORTED if the timer type is periodic"]
    pub fn esp_timer_get_expiry_time(timer: esp_timer_handle_t, expiry: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream\n\n If CONFIG_ESP_TIMER_PROFILING option is enabled, this prints the list of all\n the existing timers. Otherwise, only the list active timers is printed.\n\n The format is:\n\n   name  period  alarm  times_armed  times_triggered  total_callback_run_time\n\n where:\n\n name — timer name (if CONFIG_ESP_TIMER_PROFILING is defined), or timer pointer\n period — period of timer, in microseconds, or 0 for one-shot timer\n alarm - time of the next alarm, in microseconds since boot, or 0 if the timer\n         is not started\n\n The following fields are printed if CONFIG_ESP_TIMER_PROFILING is defined:\n\n times_armed — number of times the timer was armed via esp_timer_start_X\n times_triggered - number of times the callback was called\n total_callback_run_time - total time taken by callback to execute, across all calls\n\n @param stream stream (such as stdout) to dump the information to\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns status of a timer, active or not\n\n This function is used to identify if the timer is still active or not.\n\n @param timer timer handle created using esp_timer_create\n @return\n      - 1 if timer is still active\n      - 0 if timer is not active."]
    pub fn esp_timer_is_active(timer: esp_timer_handle_t) -> bool;
}
#[doc = "< The chip doesn't have enough space for the current partition table"]
pub const ESP_ERR_FLASH_SIZE_NOT_MATCH: _bindgen_ty_4 = 260;
#[doc = "< Chip did not respond to the command, or timed out."]
pub const ESP_ERR_FLASH_NO_RESPONSE: _bindgen_ty_4 = 264;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
#[doc = " Definition of a common transaction. Also holds the return value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_trans_t {
    #[doc = "< Reserved, must be 0."]
    pub reserved: u8,
    #[doc = "< Output data length, in bytes"]
    pub mosi_len: u8,
    #[doc = "< Input data length, in bytes"]
    pub miso_len: u8,
    #[doc = "< Length of address in bits, set to 0 if command does not need an address"]
    pub address_bitlen: u8,
    #[doc = "< Address to perform operation on"]
    pub address: u32,
    #[doc = "< Output data to salve"]
    pub mosi_data: *const u8,
    #[doc = "< [out] Input data from slave, little endian"]
    pub miso_data: *mut u8,
    #[doc = "< Flags for this transaction. Set to 0 for now."]
    pub flags: u32,
    #[doc = "< Command to send"]
    pub command: u16,
    #[doc = "< Basic dummy bits to use"]
    pub dummy_bitlen: u8,
    #[doc = "< Flash working mode when `SPI_FLASH_IGNORE_BASEIO` is specified."]
    pub io_mode: u32,
}
impl Default for spi_flash_trans_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< The flash runs under 5MHz"]
pub const esp_flash_speed_s_ESP_FLASH_5MHZ: esp_flash_speed_s = 5;
#[doc = "< The flash runs under 10MHz"]
pub const esp_flash_speed_s_ESP_FLASH_10MHZ: esp_flash_speed_s = 10;
#[doc = "< The flash runs under 20MHz"]
pub const esp_flash_speed_s_ESP_FLASH_20MHZ: esp_flash_speed_s = 20;
#[doc = "< The flash runs under 26MHz"]
pub const esp_flash_speed_s_ESP_FLASH_26MHZ: esp_flash_speed_s = 26;
#[doc = "< The flash runs under 40MHz"]
pub const esp_flash_speed_s_ESP_FLASH_40MHZ: esp_flash_speed_s = 40;
#[doc = "< The flash runs under 80MHz"]
pub const esp_flash_speed_s_ESP_FLASH_80MHZ: esp_flash_speed_s = 80;
#[doc = "< The flash runs under 120MHz, 120MHZ can only be used by main flash after timing tuning in system. Do not use this directely in any API."]
pub const esp_flash_speed_s_ESP_FLASH_120MHZ: esp_flash_speed_s = 120;
#[doc = "< The maximum frequency supported by the host is ``ESP_FLASH_SPEED_MAX-1``."]
pub const esp_flash_speed_s_ESP_FLASH_SPEED_MAX: esp_flash_speed_s = 121;
#[doc = " @brief SPI flash clock speed values, always refer to them by the enum rather\n than the actual value (more speed may be appended into the list).\n\n A strategy to select the maximum allowed speed is to enumerate from the\n ``ESP_FLSH_SPEED_MAX-1`` or highest frequency supported by your flash, and\n decrease the speed until the probing success."]
pub type esp_flash_speed_s = ::core::ffi::c_uint;
#[doc = " @brief SPI flash clock speed values, always refer to them by the enum rather\n than the actual value (more speed may be appended into the list).\n\n A strategy to select the maximum allowed speed is to enumerate from the\n ``ESP_FLSH_SPEED_MAX-1`` or highest frequency supported by your flash, and\n decrease the speed until the probing success."]
pub use self::esp_flash_speed_s as esp_flash_speed_t;
#[doc = "< Data read using single I/O, some limits on speed"]
pub const esp_flash_io_mode_t_SPI_FLASH_SLOWRD: esp_flash_io_mode_t = 0;
#[doc = "< Data read using single I/O, no limit on speed"]
pub const esp_flash_io_mode_t_SPI_FLASH_FASTRD: esp_flash_io_mode_t = 1;
#[doc = "< Data read using dual I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_DOUT: esp_flash_io_mode_t = 2;
#[doc = "< Both address & data transferred using dual I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_DIO: esp_flash_io_mode_t = 3;
#[doc = "< Data read using quad I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_QOUT: esp_flash_io_mode_t = 4;
#[doc = "< Both address & data transferred using quad I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_QIO: esp_flash_io_mode_t = 5;
#[doc = "< Only support on OPI flash, flash read and write under STR mode"]
pub const esp_flash_io_mode_t_SPI_FLASH_OPI_STR: esp_flash_io_mode_t = 16;
#[doc = "< Only support on OPI flash, flash read and write under DTR mode"]
pub const esp_flash_io_mode_t_SPI_FLASH_OPI_DTR: esp_flash_io_mode_t = 17;
#[doc = "< The fastest io mode supported by the host is ``ESP_FLASH_READ_MODE_MAX-1``."]
pub const esp_flash_io_mode_t_SPI_FLASH_READ_MODE_MAX: esp_flash_io_mode_t = 18;
#[doc = " @brief Mode used for reading from SPI flash"]
pub type esp_flash_io_mode_t = ::core::ffi::c_uint;
#[doc = " Configuration structure for the flash chip suspend feature."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_flash_sus_cmd_conf {
    #[doc = "< SUS/SUS1/SUS2 bit in flash register."]
    pub sus_mask: u32,
    pub __bindgen_anon_1: spi_flash_sus_cmd_conf__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_flash_sus_cmd_conf__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl spi_flash_sus_cmd_conf__bindgen_ty_1 {
    #[inline]
    pub fn cmd_rdsr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_rdsr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sus_cmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sus_cmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn res_cmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_res_cmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmd_rdsr: u32,
        sus_cmd: u32,
        res_cmd: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cmd_rdsr: u32 = unsafe { ::core::mem::transmute(cmd_rdsr) };
            cmd_rdsr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sus_cmd: u32 = unsafe { ::core::mem::transmute(sus_cmd) };
            sus_cmd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let res_cmd: u32 = unsafe { ::core::mem::transmute(res_cmd) };
            res_cmd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure for flash encryption operations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_flash_encryption_t {
    #[doc = " @brief Enable the flash encryption"]
    pub flash_encryption_enable: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Disable the flash encryption"]
    pub flash_encryption_disable: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " Prepare flash encryption before operation.\n\n @param address The destination address in flash for the write operation.\n @param buffer Data for programming\n @param size Size to program.\n\n @note address and buffer must be 8-word aligned."]
    pub flash_encryption_data_prepare:
        ::core::option::Option<unsafe extern "C" fn(address: u32, buffer: *const u32, size: u32)>,
    #[doc = " @brief flash data encryption operation is done."]
    pub flash_encryption_done: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " Destroy encrypted result"]
    pub flash_encryption_destroy: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " Check if is qualified to encrypt the buffer\n\n @param address the address of written flash partition.\n @param length Buffer size."]
    pub flash_encryption_check:
        ::core::option::Option<unsafe extern "C" fn(address: u32, length: u32) -> bool>,
}
#[doc = " Host driver configuration and context structure."]
pub type spi_flash_host_driver_t = spi_flash_host_driver_s;
#[doc = " SPI Flash Host driver instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_host_inst_t {
    #[doc = "< Pointer to the implementation function table"]
    pub driver: *const spi_flash_host_driver_s,
}
impl Default for spi_flash_host_inst_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Host driver configuration and context structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_flash_host_driver_s {
    #[doc = " Configure the device-related register before transactions. This saves\n some time to re-configure those registers when we send continuously"]
    pub dev_config:
        ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t) -> esp_err_t>,
    #[doc = " Send an user-defined spi transaction to the device."]
    pub common_command: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            t: *mut spi_flash_trans_t,
        ) -> esp_err_t,
    >,
    #[doc = " Read flash ID."]
    pub read_id: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, id: *mut u32) -> esp_err_t,
    >,
    #[doc = " Erase whole flash chip."]
    pub erase_chip: ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t)>,
    #[doc = " Erase a specific sector by its start address."]
    pub erase_sector: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, start_address: u32),
    >,
    #[doc = " Erase a specific block by its start address."]
    pub erase_block: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, start_address: u32),
    >,
    #[doc = " Read the status of the flash chip."]
    pub read_status: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, out_sr: *mut u8) -> esp_err_t,
    >,
    #[doc = " Disable write protection."]
    pub set_write_protect: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, wp: bool) -> esp_err_t,
    >,
    #[doc = " Program a page of the flash. Check ``max_write_bytes`` for the maximum allowed writing length."]
    pub program_page: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            buffer: *const ::core::ffi::c_void,
            address: u32,
            length: u32,
        ),
    >,
    #[doc = " @brief Check whether the SPI host supports direct write\n\n When cache is disabled, SPI1 doesn't support directly write when buffer isn't internal."]
    pub supports_direct_write: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            p: *const ::core::ffi::c_void,
        ) -> bool,
    >,
    #[doc = " Slicer for write data. The `program_page` should be called iteratively with the return value\n of this function.\n\n @param address Beginning flash address to write\n @param len Length request to write\n @param align_addr Output of the aligned address to write to\n @param page_size Physical page size of the flash chip\n @return Length that can be actually written in one `program_page` call"]
    pub write_data_slicer: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            address: u32,
            len: u32,
            align_addr: *mut u32,
            page_size: u32,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Read data from the flash. Check ``max_read_bytes`` for the maximum allowed reading length."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            buffer: *mut ::core::ffi::c_void,
            address: u32,
            read_len: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Check whether the SPI host supports direct read\n\n When cache is disabled, SPI1 doesn't support directly read when the given buffer isn't internal."]
    pub supports_direct_read: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            p: *const ::core::ffi::c_void,
        ) -> bool,
    >,
    #[doc = " Slicer for read data. The `read` should be called iteratively with the return value\n of this function.\n\n @param address Beginning flash address to read\n @param len Length request to read\n @param align_addr Output of the aligned address to read\n @param page_size Physical page size of the flash chip\n @return Length that can be actually read in one `read` call"]
    pub read_data_slicer: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            address: u32,
            len: u32,
            align_addr: *mut u32,
            page_size: u32,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " Check the host status, 0:busy, 1:idle, 2:suspended."]
    pub host_status:
        ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t) -> u32>,
    #[doc = " Configure the host to work at different read mode. Responsible to compensate the timing and set IO mode."]
    pub configure_host_io_mode: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            command: u32,
            addr_bitlen: u32,
            dummy_bitlen_base: ::core::ffi::c_int,
            io_mode: esp_flash_io_mode_t,
        ) -> esp_err_t,
    >,
    #[doc = "  Internal use, poll the HW until the last operation is done."]
    pub poll_cmd_done:
        ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t)>,
    #[doc = " For some host (SPI1), they are shared with a cache. When the data is\n modified, the cache needs to be flushed. Left NULL if not supported."]
    pub flush_cache: ::core::option::Option<
        unsafe extern "C" fn(host: *mut spi_flash_host_inst_t, addr: u32, size: u32) -> esp_err_t,
    >,
    #[doc = " Suspend check erase/program operation, reserved for ESP32-C3 and ESP32-S3 spi flash ROM IMPL."]
    pub check_suspend:
        ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t)>,
    #[doc = " Resume flash from suspend manually"]
    pub resume: ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t)>,
    #[doc = " Set flash in suspend status manually"]
    pub suspend: ::core::option::Option<unsafe extern "C" fn(host: *mut spi_flash_host_inst_t)>,
    #[doc = " Suspend feature setup for setting cmd and status register mask."]
    pub sus_setup: ::core::option::Option<
        unsafe extern "C" fn(
            host: *mut spi_flash_host_inst_t,
            sus_conf: *const spi_flash_sus_cmd_conf,
        ) -> esp_err_t,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_chip_t {
    _unused: [u8; 0],
}
#[doc = " @brief Structure for describing a region of flash"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_flash_region_t {
    #[doc = "< Start address of this region"]
    pub offset: u32,
    #[doc = "< Size of the region"]
    pub size: u32,
}
#[doc = " @brief OS-level integration hooks for accessing flash chips inside a running OS\n\n It's in the public header because some instances should be allocated statically in the startup\n code. May be updated according to hardware version and new flash chip feature requirements,\n shouldn't be treated as public API.\n\n  For advanced developers, you may replace some of them with your implementations at your own\n  risk."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_flash_os_functions_t {
    #[doc = " Called before commencing any flash operation. Does not need to be\n recursive (ie is called at most once for each call to 'end')."]
    pub start:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> esp_err_t>,
    #[doc = " Called after completing any flash operation."]
    pub end:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> esp_err_t>,
    #[doc = " Called before any erase/write operations to check whether the region is limited by the OS"]
    pub region_protected: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            start_addr: usize,
            size: usize,
        ) -> esp_err_t,
    >,
    #[doc = " Delay for at least 'us' microseconds. Called in between 'start' and 'end'."]
    pub delay_us: ::core::option::Option<
        unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, us: u32) -> esp_err_t,
    >,
    #[doc = " Called for get temp buffer when buffer from application cannot be directly read into/write from."]
    pub get_temp_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            reqest_size: usize,
            out_size: *mut usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " Called for release temp buffer."]
    pub release_temp_buffer: ::core::option::Option<
        unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, temp_buf: *mut ::core::ffi::c_void),
    >,
    #[doc = " Yield to other tasks. Called during erase operations.\n @return ESP_OK means yield needs to be called (got an event to handle), while ESP_ERR_TIMEOUT means skip yield."]
    pub check_yield: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            chip_status: u32,
            out_request: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " Yield to other tasks. Called during erase operations."]
    pub yield_: ::core::option::Option<
        unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, out_status: *mut u32) -> esp_err_t,
    >,
    #[doc = " Called for get system time."]
    pub get_system_time:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> i64>,
    #[doc = " Call to set flash operation status"]
    pub set_flash_op_status: ::core::option::Option<unsafe extern "C" fn(op_status: u32)>,
}
#[doc = " @brief Structure to describe a SPI flash chip connected to the system.\n\nStructure must be initialized before use (passed to esp_flash_init()). It's in the public\nheader because some instances should be allocated statically in the startup code. May be\nupdated according to hardware version and new flash chip feature requirements, shouldn't be\ntreated as public API.\n\nFor advanced developers, you may replace some of them with your implementations at your own\nrisk."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_flash_t {
    #[doc = "< Pointer to hardware-specific \"host_driver\" structure. Must be initialized before used."]
    pub host: *mut spi_flash_host_inst_t,
    #[doc = "< Pointer to chip-model-specific \"adapter\" structure. If NULL, will be detected during initialisation."]
    pub chip_drv: *const spi_flash_chip_t,
    #[doc = "< Pointer to os-specific hook structure. Call ``esp_flash_init_os_functions()`` to setup this field, after the host is properly initialized."]
    pub os_func: *const esp_flash_os_functions_t,
    #[doc = "< Pointer to argument for os-specific hooks. Left NULL and will be initialized with ``os_func``."]
    pub os_func_data: *mut ::core::ffi::c_void,
    #[doc = "< Configured SPI flash read mode. Set before ``esp_flash_init`` is called."]
    pub read_mode: esp_flash_io_mode_t,
    #[doc = "< Size of SPI flash in bytes. If 0, size will be detected during initialisation. Note: this stands for the size in the binary image header. If you want to get the flash physical size, please call `esp_flash_get_physical_size`."]
    pub size: u32,
    #[doc = "< Detected chip id."]
    pub chip_id: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl Default for esp_flash_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl esp_flash_t {
    #[inline]
    pub fn busy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hpm_dummy_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hpm_dummy_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_flags(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        busy: u32,
        hpm_dummy_ena: u32,
        reserved_flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let busy: u32 = unsafe { ::core::mem::transmute(busy) };
            busy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hpm_dummy_ena: u32 = unsafe { ::core::mem::transmute(hpm_dummy_ena) };
            hpm_dummy_ena as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved_flags: u32 = unsafe { ::core::mem::transmute(reserved_flags) };
            reserved_flags as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Initialise SPI flash chip interface.\n\n This function must be called before any other API functions are called for this chip.\n\n @note Only the ``host`` and ``read_mode`` fields of the chip structure must\n       be initialised before this function is called. Other fields may be\n       auto-detected if left set to zero or NULL.\n\n @note If the chip->drv pointer is NULL, chip chip_drv will be auto-detected\n       based on its manufacturer & product IDs. See\n       ``esp_flash_registered_flash_drivers`` pointer for details of this process.\n\n @param chip Pointer to SPI flash chip to use. If NULL, esp_flash_default_chip is substituted.\n @return ESP_OK on success, or a flash error code if initialisation fails."]
    pub fn esp_flash_init(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if appropriate chip driver is set.\n\n @param chip Pointer to SPI flash chip to use. If NULL, esp_flash_default_chip is substituted.\n\n @return true if set, otherwise false."]
    pub fn esp_flash_chip_driver_initialized(chip: *const esp_flash_t) -> bool;
}
extern "C" {
    #[doc = " @brief Read flash ID via the common \"RDID\" SPI flash command.\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param[out] out_id Pointer to receive ID value.\n\n ID is a 24-bit value. Lower 16 bits of 'id' are the chip ID, upper 8 bits are the manufacturer ID.\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_read_id(chip: *mut esp_flash_t, out_id: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Detect flash size based on flash ID.\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param[out] out_size Detected size in bytes, standing for the size in the binary image header.\n\n @note 1. Most flash chips use a common format for flash ID, where the lower 4 bits specify the size as a power of 2. If\n the manufacturer doesn't follow this convention, the size may be incorrectly detected.\n       2. The out_size returned only stands for The out_size stands for the size in the binary image header.\n  If you want to get the real size of the chip, please call `esp_flash_get_physical_size` instead.\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_size(chip: *mut esp_flash_t, out_size: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Detect flash size based on flash ID.\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param[out] flash_size Detected size in bytes.\n\n @note Most flash chips use a common format for flash ID, where the lower 4 bits specify the size as a power of 2. If\n the manufacturer doesn't follow this convention, the size may be incorrectly detected.\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_physical_size(chip: *mut esp_flash_t, flash_size: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read flash unique ID via the common \"RDUID\" SPI flash command.\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init().\n @param[out] out_id Pointer to receive unique ID value.\n\n ID is a 64-bit value.\n\n @return\n      - ESP_OK on success, or a flash error code if operation failed.\n      - ESP_ERR_NOT_SUPPORTED if the chip doesn't support read id."]
    pub fn esp_flash_read_unique_chip_id(chip: *mut esp_flash_t, out_id: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase flash chip contents\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n\n\n @return\n      - ESP_OK on success,\n      - ESP_ERR_NOT_SUPPORTED if the chip is not able to perform the operation. This is indicated by WREN = 1 after the command is sent.\n      - Other flash error code if operation failed."]
    pub fn esp_flash_erase_chip(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase a region of the flash chip\n\n @param chip Pointer to identify flash chip. If NULL, esp_flash_default_chip is substituted. Must have been successfully initialised via esp_flash_init()\n @param start Address to start erasing flash. Must be sector aligned.\n @param len Length of region to erase. Must also be sector aligned.\n\n Sector size is specifyed in chip->drv->sector_size field (typically 4096 bytes.) ESP_ERR_INVALID_ARG will be\n returned if the start & length are not a multiple of this size.\n\n Erase is performed using block (multi-sector) erases where possible (block size is specified in\n chip->drv->block_erase_size field, typically 65536 bytes). Remaining sectors are erased using individual sector erase\n commands.\n\n @return\n      - ESP_OK on success,\n      - ESP_ERR_NOT_SUPPORTED if the chip is not able to perform the operation. This is indicated by WREN = 1 after the command is sent.\n      - Other flash error code if operation failed."]
    pub fn esp_flash_erase_region(chip: *mut esp_flash_t, start: u32, len: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read if the entire chip is write protected\n\n @param chip Pointer to identify flash chip. If NULL, esp_flash_default_chip is substituted. Must have been successfully initialised via esp_flash_init()\n @param[out] write_protected Pointer to boolean, set to the value of the write protect flag.\n\n @note A correct result for this flag depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'\n field).\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set write protection for the SPI flash chip\n\n @param chip Pointer to identify flash chip. If NULL, esp_flash_default_chip is substituted. Must have been successfully initialised via esp_flash_init()\n @param write_protect Boolean value for the write protect flag\n\n @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'\n field).\n\n Some SPI flash chips may require a power cycle before write protect status can be cleared. Otherwise,\n write protection can be removed via a follow-up call to this function.\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_set_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read the list of individually protectable regions of this SPI flash chip.\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param[out] out_regions Pointer to receive a pointer to the array of protectable regions of the chip.\n @param[out] out_num_regions Pointer to an integer receiving the count of protectable regions in the array returned in 'regions'.\n\n @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'\n field).\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_protectable_regions(
        chip: *const esp_flash_t,
        out_regions: *mut *const esp_flash_region_t,
        out_num_regions: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Detect if a region of the SPI flash chip is protected\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param region Pointer to a struct describing a protected region. This must match one of the regions returned from esp_flash_get_protectable_regions(...).\n @param[out] out_protected Pointer to a flag which is set based on the protected status for this region.\n\n @note It is possible for this result to be false and write operations to still fail, if protection is enabled for the entire chip.\n\n @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'\n field).\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        out_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Update the protected status for a region of the SPI flash chip\n\n @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()\n @param region Pointer to a struct describing a protected region. This must match one of the regions returned from esp_flash_get_protectable_regions(...).\n @param protect Write protection flag to set.\n\n @note It is possible for the region protection flag to be cleared and write operations to still fail, if protection is enabled for the entire chip.\n\n @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'\n field).\n\n @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_set_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from the SPI flash chip\n\n @param chip Pointer to identify flash chip. If NULL, esp_flash_default_chip is substituted. Must have been successfully initialised via esp_flash_init()\n @param buffer Pointer to a buffer where the data will be read. To get better performance, this should be in the DRAM and word aligned.\n @param address Address on flash to read from. Must be less than chip->size field.\n @param length Length (in bytes) of data to read.\n\n There are no alignment constraints on buffer, address or length.\n\n @note If on-chip flash encryption is used, this function returns raw (ie encrypted) data. Use the flash cache\n to transparently decrypt data.\n\n @return\n      - ESP_OK: success\n      - ESP_ERR_NO_MEM: Buffer is in external PSRAM which cannot be concurrently accessed, and a temporary internal buffer could not be allocated.\n      - or a flash error code if operation failed."]
    pub fn esp_flash_read(
        chip: *mut esp_flash_t,
        buffer: *mut ::core::ffi::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the SPI flash chip\n\n @param chip Pointer to identify flash chip. If NULL, esp_flash_default_chip is substituted. Must have been successfully initialised via esp_flash_init()\n @param address Address on flash to write to. Must be previously erased (SPI NOR flash can only write bits 1->0).\n @param buffer Pointer to a buffer with the data to write. To get better performance, this should be in the DRAM and word aligned.\n @param length Length (in bytes) of data to write.\n\n There are no alignment constraints on buffer, address or length.\n\n @return\n      - ESP_OK on success,\n      - ESP_ERR_NOT_SUPPORTED if the chip is not able to perform the operation. This is indicated by WREN = 1 after the command is sent.\n      - Other flash error code if operation failed."]
    pub fn esp_flash_write(
        chip: *mut esp_flash_t,
        buffer: *const ::core::ffi::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Encrypted and write data to the SPI flash chip using on-chip hardware flash encryption\n\n @param chip Pointer to identify flash chip. Must be NULL (the main flash chip). For other chips, encrypted write is not supported.\n @param address Address on flash to write to. 16 byte aligned. Must be previously erased (SPI NOR flash can only write bits 1->0).\n @param buffer Pointer to a buffer with the data to write.\n @param length Length (in bytes) of data to write. 16 byte aligned.\n\n @note Both address & length must be 16 byte aligned, as this is the encryption block size\n\n @return\n  - ESP_OK: on success\n  - ESP_ERR_NOT_SUPPORTED: encrypted write not supported for this chip.\n  - ESP_ERR_INVALID_ARG: Either the address, buffer or length is invalid."]
    pub fn esp_flash_write_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        buffer: *const ::core::ffi::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read and decrypt data from the SPI flash chip using on-chip hardware flash encryption\n\n @param chip Pointer to identify flash chip. Must be NULL (the main flash chip). For other chips, encrypted read is not supported.\n @param address Address on flash to read from.\n @param out_buffer Pointer to a buffer for the data to read to.\n @param length Length (in bytes) of data to read.\n\n @return\n  - ESP_OK: on success\n  - ESP_ERR_NOT_SUPPORTED: encrypted read not supported for this chip."]
    pub fn esp_flash_read_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        out_buffer: *mut ::core::ffi::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pointer to the \"default\" SPI flash chip, ie the main chip attached to the MCU.\n\nThis chip is used if the 'chip' argument pass to esp_flash_xxx API functions is ever NULL."]
    pub static mut esp_flash_default_chip: *mut esp_flash_t;
}
#[doc = "< map to data memory (Vaddr0), allows byte-aligned access, 4 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_DATA: spi_flash_mmap_memory_t = 0;
#[doc = "< map to instruction memory (Vaddr1-3), allows only 4-byte-aligned access, 11 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_INST: spi_flash_mmap_memory_t = 1;
#[doc = " @brief Enumeration which specifies memory space requested in an mmap call"]
pub type spi_flash_mmap_memory_t = ::core::ffi::c_uint;
#[doc = " @brief Opaque handle for memory region obtained from spi_flash_mmap."]
pub type spi_flash_mmap_handle_t = u32;
extern "C" {
    #[doc = " @brief Map region of flash memory into data or instruction address space\n\n This function allocates sufficient number of 64kB MMU pages and configures\n them to map the requested region of flash memory into the address space.\n It may reuse MMU pages which already provide the required mapping.\n\n As with any allocator, if mmap/munmap are heavily used then the address space\n may become fragmented. To troubleshoot issues with page allocation, use\n spi_flash_mmap_dump() function.\n\n @param src_addr  Physical address in flash where requested region starts.\n                  This address *must* be aligned to 64kB boundary\n                  (SPI_FLASH_MMU_PAGE_SIZE)\n @param size  Size of region to be mapped. This size will be rounded\n              up to a 64kB boundary\n @param memory  Address space where the region should be mapped (data or instruction)\n @param[out] out_ptr  Output, pointer to the mapped memory region\n @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call\n\n @return  ESP_OK on success, ESP_ERR_NO_MEM if pages can not be allocated"]
    pub fn spi_flash_mmap(
        src_addr: usize,
        size: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const ::core::ffi::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Map sequences of pages of flash memory into data or instruction address space\n\n This function allocates sufficient number of 64kB MMU pages and configures\n them to map the indicated pages of flash memory contiguously into address space.\n In this respect, it works in a similar way as spi_flash_mmap() but it allows mapping\n a (maybe non-contiguous) set of pages into a contiguous region of memory.\n\n @param pages An array of numbers indicating the 64kB pages in flash to be mapped\n              contiguously into memory. These indicate the indexes of the 64kB pages,\n              not the byte-size addresses as used in other functions.\n              Array must be located in internal memory.\n @param page_count  Number of entries in the pages array\n @param memory  Address space where the region should be mapped (instruction or data)\n @param[out] out_ptr  Output, pointer to the mapped memory region\n @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if pages can not be allocated\n      - ESP_ERR_INVALID_ARG if pagecount is zero or pages array is not in\n        internal memory"]
    pub fn spi_flash_mmap_pages(
        pages: *const ::core::ffi::c_int,
        page_count: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const ::core::ffi::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release region previously obtained using spi_flash_mmap\n\n @note Calling this function will not necessarily unmap memory region.\n       Region will only be unmapped when there are no other handles which\n       reference this region. In case of partially overlapping regions\n       it is possible that memory will be unmapped partially.\n\n @param handle  Handle obtained from spi_flash_mmap"]
    pub fn spi_flash_munmap(handle: spi_flash_mmap_handle_t);
}
extern "C" {
    #[doc = " @brief Display information about mapped regions\n\n This function lists handles obtained using spi_flash_mmap, along with range\n of pages allocated to each handle. It also lists all non-zero entries of\n MMU table and corresponding reference counts."]
    pub fn spi_flash_mmap_dump();
}
extern "C" {
    #[doc = " @brief get free pages number which can be mmap\n\n This function will return number of free pages available in mmu table. This could be useful\n before calling actual spi_flash_mmap (maps flash range to DCache or ICache memory) to check\n if there is sufficient space available for mapping.\n\n @param memory memory type of MMU table free page\n\n @return number of free pages which can be mmaped"]
    pub fn spi_flash_mmap_get_free_pages(memory: spi_flash_mmap_memory_t) -> u32;
}
extern "C" {
    #[doc = " @brief Given a memory address where flash is mapped, return the corresponding physical flash offset.\n\n Cache address does not have have been assigned via spi_flash_mmap(), any address in memory mapped flash space can be looked up.\n\n @param cached Pointer to flashed cached memory.\n\n @return\n - SPI_FLASH_CACHE2PHYS_FAIL If cache address is outside flash cache region, or the address is not mapped.\n - Otherwise, returns physical offset in flash"]
    pub fn spi_flash_cache2phys(cached: *const ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[doc = " @brief Given a physical offset in flash, return the address where it is mapped in the memory space.\n\n Physical address does not have to have been assigned via spi_flash_mmap(), any address in flash can be looked up.\n\n @note Only the first matching cache address is returned. If MMU flash cache table is configured so multiple entries\n point to the same physical address, there may be more than one cache address corresponding to that physical\n address. It is also possible for a single physical address to be mapped to both the IROM and DROM regions.\n\n @note This function doesn't impose any alignment constraints, but if memory argument is SPI_FLASH_MMAP_INST and\n phys_offs is not 4-byte aligned, then reading from the returned pointer will result in a crash.\n\n @param phys_offs Physical offset in flash memory to look up.\n @param memory Address space type to look up a flash cache address mapping for (instruction or data)\n\n @return\n - NULL if the physical address is invalid or not mapped to flash cache of the specified memory type.\n - Cached memory address (in IROM or DROM space) corresponding to phys_offs."]
    pub fn spi_flash_phys2cache(
        phys_offs: usize,
        memory: spi_flash_mmap_memory_t,
    ) -> *const ::core::ffi::c_void;
}
#[doc = "< SAR ADC 1"]
pub const adc_unit_t_ADC_UNIT_1: adc_unit_t = 0;
#[doc = "< SAR ADC 2"]
pub const adc_unit_t_ADC_UNIT_2: adc_unit_t = 1;
#[doc = " @brief ADC unit"]
pub type adc_unit_t = ::core::ffi::c_uint;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_0: adc_channel_t = 0;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_1: adc_channel_t = 1;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_2: adc_channel_t = 2;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_3: adc_channel_t = 3;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_4: adc_channel_t = 4;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_5: adc_channel_t = 5;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_6: adc_channel_t = 6;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_7: adc_channel_t = 7;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_8: adc_channel_t = 8;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_9: adc_channel_t = 9;
#[doc = " @brief ADC channels"]
pub type adc_channel_t = ::core::ffi::c_uint;
#[doc = "<No input attenuation, ADC can measure up to approx."]
pub const adc_atten_t_ADC_ATTEN_DB_0: adc_atten_t = 0;
#[doc = "<The input voltage of ADC will be attenuated extending the range of measurement by about 2.5 dB (1.33 x)"]
pub const adc_atten_t_ADC_ATTEN_DB_2_5: adc_atten_t = 1;
#[doc = "<The input voltage of ADC will be attenuated extending the range of measurement by about 6 dB (2 x)"]
pub const adc_atten_t_ADC_ATTEN_DB_6: adc_atten_t = 2;
#[doc = "<The input voltage of ADC will be attenuated extending the range of measurement by about 11 dB (3.55 x)"]
pub const adc_atten_t_ADC_ATTEN_DB_11: adc_atten_t = 3;
#[doc = " @brief ADC attenuation parameter. Different parameters determine the range of the ADC."]
pub type adc_atten_t = ::core::ffi::c_uint;
#[doc = "< Default ADC output bits, max supported width will be selected"]
pub const adc_bitwidth_t_ADC_BITWIDTH_DEFAULT: adc_bitwidth_t = 0;
#[doc = "< ADC output width is 9Bit"]
pub const adc_bitwidth_t_ADC_BITWIDTH_9: adc_bitwidth_t = 9;
#[doc = "< ADC output width is 10Bit"]
pub const adc_bitwidth_t_ADC_BITWIDTH_10: adc_bitwidth_t = 10;
#[doc = "< ADC output width is 11Bit"]
pub const adc_bitwidth_t_ADC_BITWIDTH_11: adc_bitwidth_t = 11;
#[doc = "< ADC output width is 12Bit"]
pub const adc_bitwidth_t_ADC_BITWIDTH_12: adc_bitwidth_t = 12;
#[doc = "< ADC output width is 13Bit"]
pub const adc_bitwidth_t_ADC_BITWIDTH_13: adc_bitwidth_t = 13;
pub type adc_bitwidth_t = ::core::ffi::c_uint;
#[doc = "< ADC ULP mode is disabled"]
pub const adc_ulp_mode_t_ADC_ULP_MODE_DISABLE: adc_ulp_mode_t = 0;
#[doc = "< ADC is controlled by ULP FSM"]
pub const adc_ulp_mode_t_ADC_ULP_MODE_FSM: adc_ulp_mode_t = 1;
#[doc = "< ADC is controlled by ULP RISCV"]
pub const adc_ulp_mode_t_ADC_ULP_MODE_RISCV: adc_ulp_mode_t = 2;
pub type adc_ulp_mode_t = ::core::ffi::c_uint;
#[doc = "< Only use ADC1 for conversion"]
pub const adc_digi_convert_mode_t_ADC_CONV_SINGLE_UNIT_1: adc_digi_convert_mode_t = 1;
#[doc = "< Only use ADC2 for conversion"]
pub const adc_digi_convert_mode_t_ADC_CONV_SINGLE_UNIT_2: adc_digi_convert_mode_t = 2;
#[doc = "< Use Both ADC1 and ADC2 for conversion simultaneously"]
pub const adc_digi_convert_mode_t_ADC_CONV_BOTH_UNIT: adc_digi_convert_mode_t = 3;
#[doc = "< Use both ADC1 and ADC2 for conversion by turn. e.g. ADC1 -> ADC2 -> ADC1 -> ADC2 ....."]
pub const adc_digi_convert_mode_t_ADC_CONV_ALTER_UNIT: adc_digi_convert_mode_t = 7;
#[doc = " @brief ADC digital controller (DMA mode) work mode."]
pub type adc_digi_convert_mode_t = ::core::ffi::c_uint;
#[doc = "< See `adc_digi_output_data_t.type1`"]
pub const adc_digi_output_format_t_ADC_DIGI_OUTPUT_FORMAT_TYPE1: adc_digi_output_format_t = 0;
#[doc = "< See `adc_digi_output_data_t.type2`"]
pub const adc_digi_output_format_t_ADC_DIGI_OUTPUT_FORMAT_TYPE2: adc_digi_output_format_t = 1;
#[doc = " @brief ADC digital controller (DMA mode) output data format option."]
pub type adc_digi_output_format_t = ::core::ffi::c_uint;
#[doc = " @brief ADC digital controller pattern configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct adc_digi_pattern_config_t {
    #[doc = "< Attenuation of this ADC channel"]
    pub atten: u8,
    #[doc = "< ADC channel"]
    pub channel: u8,
    #[doc = "< ADC unit"]
    pub unit: u8,
    #[doc = "< ADC output bit width"]
    pub bit_width: u8,
}
#[doc = " @brief ADC digital controller (DMA mode) output data format.\n        Used to analyze the acquired ADC (DMA) data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct adc_digi_output_data_t {
    pub __bindgen_anon_1: adc_digi_output_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union adc_digi_output_data_t__bindgen_ty_1 {
    #[doc = "<When the configured output format is 12bit."]
    pub type2: adc_digi_output_data_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "<Raw data value"]
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct adc_digi_output_data_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl adc_digi_output_data_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17_31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17_31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: u32,
        reserved12: u32,
        channel: u32,
        unit: u32,
        reserved17_31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let unit: u32 = unsafe { ::core::mem::transmute(unit) };
            unit as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17_31: u32 = unsafe { ::core::mem::transmute(reserved17_31) };
            reserved17_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for adc_digi_output_data_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for adc_digi_output_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< ADC capture width is 12Bit."]
pub const adc_bits_width_t_ADC_WIDTH_BIT_12: adc_bits_width_t = 12;
pub const adc_bits_width_t_ADC_WIDTH_MAX: adc_bits_width_t = 13;
#[doc = " @brief ADC resolution setting option.\n @note  Only used in single read mode"]
pub type adc_bits_width_t = ::core::ffi::c_uint;
#[doc = "< ADC1 channel 0 is GPIO0"]
pub const adc1_channel_t_ADC1_CHANNEL_0: adc1_channel_t = 0;
#[doc = "< ADC1 channel 1 is GPIO1"]
pub const adc1_channel_t_ADC1_CHANNEL_1: adc1_channel_t = 1;
#[doc = "< ADC1 channel 2 is GPIO2"]
pub const adc1_channel_t_ADC1_CHANNEL_2: adc1_channel_t = 2;
#[doc = "< ADC1 channel 3 is GPIO3"]
pub const adc1_channel_t_ADC1_CHANNEL_3: adc1_channel_t = 3;
#[doc = "< ADC1 channel 4 is GPIO4"]
pub const adc1_channel_t_ADC1_CHANNEL_4: adc1_channel_t = 4;
pub const adc1_channel_t_ADC1_CHANNEL_MAX: adc1_channel_t = 5;
pub type adc1_channel_t = ::core::ffi::c_uint;
#[doc = "< ADC2 channel 0 is GPIO5"]
pub const adc2_channel_t_ADC2_CHANNEL_0: adc2_channel_t = 0;
pub const adc2_channel_t_ADC2_CHANNEL_MAX: adc2_channel_t = 1;
pub type adc2_channel_t = ::core::ffi::c_uint;
#[doc = " @brief ADC DMA driver configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct adc_digi_init_config_s {
    #[doc = "< Max length of the converted data that driver can store before they are processed."]
    pub max_store_buf_size: u32,
    #[doc = "< Bytes of data that can be converted in 1 interrupt. This should be in multiples of `SOC_ADC_DIGI_DATA_BYTES_PER_CONV`."]
    pub conv_num_each_intr: u32,
    #[doc = "< Channel list of ADC1 to be initialized."]
    pub adc1_chan_mask: u32,
    #[doc = "< Channel list of ADC2 to be initialized."]
    pub adc2_chan_mask: u32,
}
#[doc = " @brief ADC DMA driver configuration"]
pub type adc_digi_init_config_t = adc_digi_init_config_s;
#[doc = " @brief ADC digital controller settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_digi_configuration_t {
    #[doc = "< Suggest leaving it empty, this parameter has been deprecated"]
    pub conv_limit_en: bool,
    #[doc = "< suggest leaving it empty, this parameter has been deprecated"]
    pub conv_limit_num: u32,
    #[doc = "< Number of ADC channels that will be used"]
    pub pattern_num: u32,
    #[doc = "< List of configs for each ADC channel that will be used"]
    pub adc_pattern: *mut adc_digi_pattern_config_t,
    #[doc = "< Please refer to `soc/soc_caps.h` to know the ADC sampling frequency range"]
    pub sample_freq_hz: u32,
    #[doc = "< ADC DMA conversion mode, see `adc_digi_convert_mode_t`."]
    pub conv_mode: adc_digi_convert_mode_t,
    #[doc = "< ADC DMA conversion output format, see `adc_digi_output_format_t`."]
    pub format: adc_digi_output_format_t,
}
impl Default for adc_digi_configuration_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Characterization based on reference voltage stored in eFuse"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_EFUSE_VREF: esp_adc_cal_value_t = 0;
#[doc = "< Characterization based on Two Point values stored in eFuse"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_EFUSE_TP: esp_adc_cal_value_t = 1;
#[doc = "< Characterization based on default reference voltage"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_DEFAULT_VREF: esp_adc_cal_value_t = 2;
#[doc = "< Characterization based on Two Point values and fitting curve coefficients stored in eFuse"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_EFUSE_TP_FIT: esp_adc_cal_value_t = 3;
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_MAX: esp_adc_cal_value_t = 4;
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_NOT_SUPPORTED: esp_adc_cal_value_t = 4;
#[doc = " @brief Type of calibration value used in characterization"]
pub type esp_adc_cal_value_t = ::core::ffi::c_uint;
#[doc = " @brief Structure storing characteristics of an ADC\n\n @note Call esp_adc_cal_characterize() to initialize the structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_adc_cal_characteristics_t {
    #[doc = "< ADC unit"]
    pub adc_num: adc_unit_t,
    #[doc = "< ADC attenuation"]
    pub atten: adc_atten_t,
    #[doc = "< ADC bit width"]
    pub bit_width: adc_bits_width_t,
    #[doc = "< Gradient of ADC-Voltage curve"]
    pub coeff_a: u32,
    #[doc = "< Offset of ADC-Voltage curve"]
    pub coeff_b: u32,
    #[doc = "< Vref used by lookup table"]
    pub vref: u32,
    #[doc = "< Pointer to low Vref curve of lookup table (NULL if unused)"]
    pub low_curve: *const u32,
    #[doc = "< Pointer to high Vref curve of lookup table (NULL if unused)"]
    pub high_curve: *const u32,
    #[doc = "< ADC Calibration"]
    pub version: u8,
}
impl Default for esp_adc_cal_characteristics_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Checks if ADC calibration values are burned into eFuse\n\n This function checks if ADC reference voltage or Two Point values have been\n burned to the eFuse of the current ESP32\n\n @param   value_type  Type of calibration value (ESP_ADC_CAL_VAL_EFUSE_VREF or ESP_ADC_CAL_VAL_EFUSE_TP)\n @note in ESP32S2, only ESP_ADC_CAL_VAL_EFUSE_TP is supported. Some old ESP32S2s do not support this, either.\n In which case you have to calibrate it manually, possibly by performing your own two-point calibration on the chip.\n\n @return\n      - ESP_OK: The calibration mode is supported in eFuse\n      - ESP_ERR_NOT_SUPPORTED: Error, eFuse values are not burned\n      - ESP_ERR_INVALID_ARG: Error, invalid argument (ESP_ADC_CAL_VAL_DEFAULT_VREF)"]
    pub fn esp_adc_cal_check_efuse(value_type: esp_adc_cal_value_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Characterize an ADC at a particular attenuation\n\n This function will characterize the ADC at a particular attenuation and generate\n the ADC-Voltage curve in the form of [y = coeff_a * x + coeff_b].\n Characterization can be based on Two Point values, eFuse Vref, or default Vref\n and the calibration values will be prioritized in that order.\n\n @note\n For ESP32, Two Point values and eFuse Vref calibration can be enabled/disabled using menuconfig.\n For ESP32s2, only Two Point values calibration and only ADC_WIDTH_BIT_13 is supported. The parameter default_vref is unused.\n\n\n @param[in]   adc_num         ADC to characterize (ADC_UNIT_1 or ADC_UNIT_2)\n @param[in]   atten           Attenuation to characterize\n @param[in]   bit_width       Bit width configuration of ADC\n @param[in]   default_vref    Default ADC reference voltage in mV (Only in ESP32, used if eFuse values is not available)\n @param[out]  chars           Pointer to empty structure used to store ADC characteristics\n\n @return\n      - ESP_ADC_CAL_VAL_EFUSE_VREF: eFuse Vref used for characterization\n      - ESP_ADC_CAL_VAL_EFUSE_TP: Two Point value used for characterization (only in Linear Mode)\n      - ESP_ADC_CAL_VAL_DEFAULT_VREF: Default Vref used for characterization"]
    pub fn esp_adc_cal_characterize(
        adc_num: adc_unit_t,
        atten: adc_atten_t,
        bit_width: adc_bits_width_t,
        default_vref: u32,
        chars: *mut esp_adc_cal_characteristics_t,
    ) -> esp_adc_cal_value_t;
}
extern "C" {
    #[doc = " @brief   Convert an ADC reading to voltage in mV\n\n This function converts an ADC reading to a voltage in mV based on the ADC's\n characteristics.\n\n @note    Characteristics structure must be initialized before this function\n          is called (call esp_adc_cal_characterize())\n\n @param[in]   adc_reading     ADC reading\n @param[in]   chars           Pointer to initialized structure containing ADC characteristics\n\n @return      Voltage in mV"]
    pub fn esp_adc_cal_raw_to_voltage(
        adc_reading: u32,
        chars: *const esp_adc_cal_characteristics_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief   Reads an ADC and converts the reading to a voltage in mV\n\n This function reads an ADC then converts the raw reading to a voltage in mV\n based on the characteristics provided. The ADC that is read is also\n determined by the characteristics.\n\n @note    The Characteristics structure must be initialized before this\n          function is called (call esp_adc_cal_characterize())\n\n @param[in]   channel     ADC Channel to read\n @param[in]   chars       Pointer to initialized ADC characteristics structure\n @param[out]  voltage     Pointer to store converted voltage\n\n @return\n      - ESP_OK: ADC read and converted to mV\n      - ESP_ERR_INVALID_ARG: Error due to invalid arguments\n      - ESP_ERR_INVALID_STATE: Reading result is invalid. Try to read again."]
    pub fn esp_adc_cal_get_voltage(
        channel: adc_channel_t,
        chars: *const esp_adc_cal_characteristics_t,
        voltage: *mut u32,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_cali_scheme_t {
    _unused: [u8; 0],
}
#[doc = " @brief ADC calibration handle"]
pub type adc_cali_handle_t = *mut adc_cali_scheme_t;
#[doc = "< Line fitting scheme"]
pub const adc_cali_scheme_ver_t_ADC_CALI_SCHEME_VER_LINE_FITTING: adc_cali_scheme_ver_t = 1;
#[doc = "< Curve fitting scheme"]
pub const adc_cali_scheme_ver_t_ADC_CALI_SCHEME_VER_CURVE_FITTING: adc_cali_scheme_ver_t = 2;
#[doc = " @brief ADC calibration scheme"]
pub type adc_cali_scheme_ver_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Check the supported ADC calibration scheme\n\n @param[out] scheme_mask    Supported ADC calibration scheme(s)\n\n @return\n        - ESP_OK:                On success\n        - ESP_ERR_INVALID_ARG:   Invalid argument\n        - ESP_ERR_NOT_SUPPORTED: No supported calibration scheme"]
    pub fn adc_cali_check_scheme(scheme_mask: *mut adc_cali_scheme_ver_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Convert ADC raw data to calibrated voltage\n\n @param[in]  handle     ADC calibration handle\n @param[in]  raw        ADC raw data\n @param[out] voltage    Calibrated ADC voltage (in mV)\n\n @return\n         - ESP_OK:                On success\n         - ESP_ERR_INVALID_ARG:   Invalid argument\n         - ESP_ERR_INVALID_STATE: Invalid state, scheme didn't registered"]
    pub fn adc_cali_raw_to_voltage(
        handle: adc_cali_handle_t,
        raw: ::core::ffi::c_int,
        voltage: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_cali_curve_fitting_config_t {
    #[doc = "< ADC unit"]
    pub unit_id: adc_unit_t,
    #[doc = "< ADC attenuation"]
    pub atten: adc_atten_t,
    #[doc = "< ADC raw output bitwidth"]
    pub bitwidth: adc_bitwidth_t,
}
impl Default for adc_cali_curve_fitting_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create a Curve Fitting calibration scheme\n\n After creating, you'll get a handle to this scheme. Then you can use the driver APIS in `esp_adc/adc_cali.h` to do the\n ADC calibration via the handle you get.\n\n @param[in]  config  Initial configurations\n @param[out] handle  ADC calibration handle\n\n @return\n        - ESP_OK:                On success\n        - ESP_ERR_INVALID_ARG:   Invalid argument\n        - ESP_ERR_NO_MEM:        No enough memory\n        - ESP_ERR_NOT_SUPPORTED: Scheme required eFuse bits not burnt"]
    pub fn adc_cali_create_scheme_curve_fitting(
        config: *const adc_cali_curve_fitting_config_t,
        ret_handle: *mut adc_cali_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the Curve Fitting calibration scheme handle\n\n @param[in] handle ADC calibration handle\n\n @return\n        - ESP_OK:                On success\n        - ESP_ERR_INVALID_ARG:   Invalid argument"]
    pub fn adc_cali_delete_scheme_curve_fitting(handle: adc_cali_handle_t) -> esp_err_t;
}
pub type esp_event_base_t = *const ::core::ffi::c_char;
pub type esp_event_loop_handle_t = *mut ::core::ffi::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut ::core::ffi::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut ::core::ffi::c_void,
    ),
>;
pub type esp_event_handler_instance_t = *mut ::core::ffi::c_void;
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,\na dedicated task is not created for event loop"]
    pub task_name: *const ::core::ffi::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,\nignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
impl Default for esp_event_loop_args_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create a new event loop.\n\n @param[in] event_loop_args configuration structure for the event loop to create\n @param[out] event_loop handle to the created event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: event_loop_args or event_loop was NULL\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop.\n\n @param[in] event_loop event loop to delete, must not be NULL\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - ESP_FAIL: Failed to create task loop\n  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop.\n\n This function is used to dispatch events posted to a loop with no dedicated task, i.e. task name was set to NULL\n in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time\n it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee\n that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have\n been dispatched during the call, as the function might have spent all the allotted time waiting on the event queue.\n Once an event has been dequeued, however, it is guaranteed to be dispatched. This guarantee contributes to not being\n able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the dequeued\n event, and (2) during  dispatch of the dequeued event there is no way to control the time occupied by handler code\n execution. The guaranteed time of exit is therefore the allotted time + amount of time required to dispatch\n the last dequeued event.\n\n In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is\n normal behavior.\n\n @param[in] event_loop event loop to dispatch posted events from, must not be NULL\n @param[in] ticks_to_run number of ticks to run the loop\n\n @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error.\n\n @return\n  - ESP_OK: Success\n  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop (legacy).\n\n @note This function is obsolete and will be deprecated soon, please use esp_event_handler_instance_register()\n       instead.\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Registering multiple handlers to events is possible. Registering a single handler to multiple events is\n also possible. However, registering the same handler to the same event multiple times would cause the\n previous registrations to be overwritten.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop (legacy).\n\n @note This function is obsolete and will be deprecated soon, please use esp_event_handler_instance_register_with()\n       instead.\n\n This function behaves in the same manner as esp_event_handler_register, except the additional\n specification of the event loop to register the handler to.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to a specific loop.\n\n This function can be used to register a handler for either: (1) specific events,\n (2) all events of a certain event base, or (3) all events known by the system event loop.\n\n  - specific events: specify exact event_base and event_id\n  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id\n  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id\n\n Besides the error, the function returns an instance object as output parameter to identify each registration.\n This is necessary to remove (unregister) the registration before the event loop is deleted.\n\n Registering multiple handlers to events, registering a single handler to multiple events as well as registering\n the same handler to the same event multiple times is possible.\n Each registration yields a distinct instance object which identifies it over the registration\n lifetime.\n\n @param[in] event_loop the event loop to register this handler function to, must not be NULL\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut ::core::ffi::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an instance of event handler to the default loop.\n\n This function does the same as esp_event_handler_instance_register_with, except that it registers the\n handler to the default event loop.\n\n @param[in] event_base the base ID of the event to register the handler for\n @param[in] event_id the ID of the event to register the handler for\n @param[in] event_handler the handler function which gets called when the event is dispatched\n @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called\n @param[out] instance An event handler instance object related to the registered event handler and data, can be NULL.\n             This needs to be kept if the specific callback instance should be unregistered before deleting the whole\n             event loop. Registering the same event handler multiple times is possible and yields distinct instance\n             objects. The data can be the same for all registrations.\n             If no unregistration is needed, but the handler should be deleted when the event loop is deleted,\n             instance can be NULL.\n\n @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should\n ensure that event_handler_arg still points to a valid location by the time the handler gets called\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID or instance is NULL\n  - Others: Fail"]
    pub fn esp_event_handler_instance_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut ::core::ffi::c_void,
        instance: *mut esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop (legacy).\n\n @note This function is obsolete and will be deprecated soon, please use esp_event_handler_instance_unregister()\n       instead.\n\n Unregisters a handler, so it will no longer be called during dispatch.\n Handlers can be unregistered for any combination of event_base and event_id which were previously registered.\n To unregister a handler, the event_base and event_id arguments must match exactly the arguments passed to\n esp_event_handler_register() when that handler was registered. Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID\n will only unregister handlers that were registered with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return ESP_OK success\n @return ESP_ERR_INVALID_ARG invalid combination of event base and event ID\n @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from a specific event loop (legacy).\n\n @note This function is obsolete and will be deprecated soon, please use esp_event_handler_instance_unregister_with()\n       instead.\n\n This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of\n the event loop to unregister the handler with.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] event_handler the handler to unregister\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler instance from a specific event loop.\n\n Unregisters a handler instance, so it will no longer be called during dispatch.\n Handler instances can be unregistered for any combination of event_base and event_id which were previously\n registered. To unregister a handler instance, the event_base and event_id arguments must match exactly the\n arguments passed to esp_event_handler_instance_register() when that handler instance was registered.\n Passing ESP_EVENT_ANY_BASE and/or ESP_EVENT_ANY_ID will only unregister handler instances that were registered\n with the same wildcard arguments.\n\n @note When using ESP_EVENT_ANY_ID, handlers registered to specific event IDs using the same base will not be\n       unregistered. When using ESP_EVENT_ANY_BASE, events registered to specific bases will also not be\n       unregistered. This avoids accidental unregistration of handlers registered by other users or components.\n\n @param[in] event_loop the event loop with which to unregister this handler function, must not be NULL\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler from the system event loop.\n\n This function does the same as esp_event_handler_instance_unregister_with, except that it unregisters the\n handler instance from the default event loop.\n\n @param[in] event_base the base of the event with which to unregister the handler\n @param[in] event_id the ID of the event with which to unregister the handler\n @param[in] instance the instance object of the registration to be unregistered\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_handler_instance_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        instance: esp_event_handler_instance_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const ::core::ffi::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages\n the copy's lifetime automatically (allocation + deletion); this ensures that the data the\n handler receives is always valid.\n\n This function behaves in the same manner as esp_event_post_to, except the additional specification of the event loop\n to post the event to.\n\n @param[in] event_loop the event loop to post to, must not be NULL\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[in] ticks_to_wait number of ticks to block on a full event queue\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,\n                      queue full when posting from ISR\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID\n  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const ::core::ffi::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post for posting events from interrupt handlers.\n\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data; max is 4 bytes\n @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with\n                            higher priority than currently running task has been unblocked by the posted event;\n                            a context switch should be requested before the interrupt is existed.\n\n @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled\n @note when this function is called from an interrupt handler placed in IRAM, this function should\n       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR\n\n @return\n  - ESP_OK: Success\n  - ESP_FAIL: Event queue for the default event loop full\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,\n                          data size of more than 4 bytes\n  - Others: Fail"]
    pub fn esp_event_isr_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const ::core::ffi::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special variant of esp_event_post_to for posting events from interrupt handlers\n\n @param[in] event_loop the event loop to post to, must not be NULL\n @param[in] event_base the event base that identifies the event\n @param[in] event_id the event ID that identifies the event\n @param[in] event_data the data, specific to the event occurrence, that gets passed to the handler\n @param[in] event_data_size the size of the event data\n @param[out] task_unblocked an optional parameter (can be NULL) which indicates that an event task with\n                            higher priority than currently running task has been unblocked by the posted event;\n                            a context switch should be requested before the interrupt is existed.\n\n @note this function is only available when CONFIG_ESP_EVENT_POST_FROM_ISR is enabled\n @note when this function is called from an interrupt handler placed in IRAM, this function should\n       be placed in IRAM as well by enabling CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR\n\n @return\n  - ESP_OK: Success\n  - ESP_FAIL: Event queue for the loop full\n  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event ID,\n                          data size of more than 4 bytes\n  - Others: Fail"]
    pub fn esp_event_isr_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *const ::core::ffi::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops.\n\n Dumps event loop info in the format:\n\n@verbatim\nevent loop\nhandler\nhandler\n...\nevent loop\nhandler\nhandler\n...\n\nwhere:\n\nevent loop\nformat: address,name rx:total_received dr:total_dropped\nwhere:\naddress - memory address of the event loop\nname - name of the event loop, 'none' if no dedicated task\ntotal_received - number of successfully posted events\ntotal_dropped - number of events unsuccessfully posted due to queue being full\n\nhandler\nformat: address ev:base,id inv:total_invoked run:total_runtime\nwhere:\naddress - address of the handler function\nbase,id - the event specified by event base and ID this handler executes\ntotal_invoked - number of times this handler has been invoked\ntotal_runtime - total amount of time used for invoking this handler\n\n@endverbatim\n\n @param[in] file the file stream to output to\n\n @note this function is a noop when CONFIG_ESP_EVENT_LOOP_PROFILING is disabled\n\n @return\n  - ESP_OK: Success\n  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list\n  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
#[doc = " @brief IPv6 address\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_ip6_addr {
    #[doc = "< IPv6 address"]
    pub addr: [u32; 4usize],
    #[doc = "< zone ID"]
    pub zone: u8,
}
#[doc = " @brief IPv4 address\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_ip4_addr {
    #[doc = "< IPv4 address"]
    pub addr: u32,
}
#[doc = " @brief IPv4 address\n"]
pub type esp_ip4_addr_t = esp_ip4_addr;
#[doc = " @brief IPv6 address\n"]
pub type esp_ip6_addr_t = esp_ip6_addr;
#[doc = " @brief IP address\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ip_addr {
    #[doc = "< IP address union"]
    pub u_addr: _ip_addr__bindgen_ty_1,
    #[doc = "< ipaddress type"]
    pub type_: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ip_addr__bindgen_ty_1 {
    #[doc = "< IPv6 address type"]
    pub ip6: esp_ip6_addr_t,
    #[doc = "< IPv4 address type"]
    pub ip4: esp_ip4_addr_t,
}
impl Default for _ip_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ip_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief IP address\n"]
pub type esp_ip_addr_t = _ip_addr;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_UNKNOWN: esp_ip6_addr_type_t = 0;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_GLOBAL: esp_ip6_addr_type_t = 1;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_LINK_LOCAL: esp_ip6_addr_type_t = 2;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_SITE_LOCAL: esp_ip6_addr_type_t = 3;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_UNIQUE_LOCAL: esp_ip6_addr_type_t = 4;
pub const esp_ip6_addr_type_t_ESP_IP6_ADDR_IS_IPV4_MAPPED_IPV6: esp_ip6_addr_type_t = 5;
pub type esp_ip6_addr_type_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief  Get the IPv6 address type\n\n @param[in]  ip6_addr IPv6 type\n\n @return IPv6 type in form of enum esp_ip6_addr_type_t"]
    pub fn esp_netif_ip6_get_addr_type(ip6_addr: *mut esp_ip6_addr_t) -> esp_ip6_addr_type_t;
}
#[doc = " @brief Type of esp_netif_object server"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_obj {
    _unused: [u8; 0],
}
pub type esp_netif_t = esp_netif_obj;
#[doc = "< DNS main server address"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_MAIN: esp_netif_dns_type_t = 0;
#[doc = "< DNS backup server address (Wi-Fi STA and Ethernet only)"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_BACKUP: esp_netif_dns_type_t = 1;
#[doc = "< DNS fallback server address (Wi-Fi STA and Ethernet only)"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_FALLBACK: esp_netif_dns_type_t = 2;
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_MAX: esp_netif_dns_type_t = 3;
#[doc = " @brief Type of DNS server"]
pub type esp_netif_dns_type_t = ::core::ffi::c_uint;
#[doc = " @brief DNS server info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_netif_dns_info_t {
    #[doc = "< IPV4 address of DNS server"]
    pub ip: esp_ip_addr_t,
}
impl Default for esp_netif_dns_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< DHCP client/server is in initial state (not yet started)"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_INIT: esp_netif_dhcp_status_t = 0;
#[doc = "< DHCP client/server has been started"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STARTED: esp_netif_dhcp_status_t = 1;
#[doc = "< DHCP client/server has been stopped"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STOPPED: esp_netif_dhcp_status_t = 2;
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STATUS_MAX: esp_netif_dhcp_status_t = 3;
#[doc = " @brief Status of DHCP client or DHCP server"]
pub type esp_netif_dhcp_status_t = ::core::ffi::c_uint;
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_START: esp_netif_dhcp_option_mode_t = 0;
#[doc = "< Set option"]
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_SET: esp_netif_dhcp_option_mode_t = 1;
#[doc = "< Get option"]
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_GET: esp_netif_dhcp_option_mode_t = 2;
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_MAX: esp_netif_dhcp_option_mode_t = 3;
#[doc = " @brief Mode for DHCP client or DHCP server option functions"]
pub type esp_netif_dhcp_option_mode_t = ::core::ffi::c_uint;
#[doc = "< Network mask"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_SUBNET_MASK: esp_netif_dhcp_option_id_t = 1;
#[doc = "< Domain name server"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_DOMAIN_NAME_SERVER: esp_netif_dhcp_option_id_t = 6;
#[doc = "< Solicitation router address"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_ROUTER_SOLICITATION_ADDRESS:
    esp_netif_dhcp_option_id_t = 32;
#[doc = "< Request specific IP address"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_REQUESTED_IP_ADDRESS: esp_netif_dhcp_option_id_t =
    50;
#[doc = "< Request IP address lease time"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_IP_ADDRESS_LEASE_TIME: esp_netif_dhcp_option_id_t =
    51;
#[doc = "< Request IP address retry counter"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_IP_REQUEST_RETRY_TIME: esp_netif_dhcp_option_id_t =
    52;
#[doc = "< Vendor Class Identifier of a DHCP client"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_VENDOR_CLASS_IDENTIFIER: esp_netif_dhcp_option_id_t =
    60;
#[doc = "< Vendor Specific Information of a DHCP server"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_VENDOR_SPECIFIC_INFO: esp_netif_dhcp_option_id_t =
    43;
#[doc = " @brief Supported options for DHCP client or DHCP server"]
pub type esp_netif_dhcp_option_id_t = ::core::ffi::c_uint;
#[doc = "< station got IP from connected AP"]
pub const ip_event_t_IP_EVENT_STA_GOT_IP: ip_event_t = 0;
#[doc = "< station lost IP and the IP is reset to 0"]
pub const ip_event_t_IP_EVENT_STA_LOST_IP: ip_event_t = 1;
#[doc = "< soft-AP assign an IP to a connected station"]
pub const ip_event_t_IP_EVENT_AP_STAIPASSIGNED: ip_event_t = 2;
#[doc = "< station or ap or ethernet interface v6IP addr is preferred"]
pub const ip_event_t_IP_EVENT_GOT_IP6: ip_event_t = 3;
#[doc = "< ethernet got IP from connected AP"]
pub const ip_event_t_IP_EVENT_ETH_GOT_IP: ip_event_t = 4;
#[doc = "< ethernet lost IP and the IP is reset to 0"]
pub const ip_event_t_IP_EVENT_ETH_LOST_IP: ip_event_t = 5;
#[doc = "< PPP interface got IP"]
pub const ip_event_t_IP_EVENT_PPP_GOT_IP: ip_event_t = 6;
#[doc = "< PPP interface lost IP"]
pub const ip_event_t_IP_EVENT_PPP_LOST_IP: ip_event_t = 7;
#[doc = " IP event declarations"]
pub type ip_event_t = ::core::ffi::c_uint;
extern "C" {
    pub static mut IP_EVENT: esp_event_base_t;
}
#[doc = " Event structure for IP_EVENT_STA_GOT_IP, IP_EVENT_ETH_GOT_IP events"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_netif_ip_info_t {
    #[doc = "< Interface IPV4 address"]
    pub ip: esp_ip4_addr_t,
    #[doc = "< Interface IPV4 netmask"]
    pub netmask: esp_ip4_addr_t,
    #[doc = "< Interface IPV4 gateway address"]
    pub gw: esp_ip4_addr_t,
}
#[doc = " @brief IPV6 IP address information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_netif_ip6_info_t {
    #[doc = "< Interface IPV6 address"]
    pub ip: esp_ip6_addr_t,
}
#[doc = " @brief Event structure for IP_EVENT_GOT_IP event\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_got_ip_t {
    #[doc = "< Pointer to corresponding esp-netif object"]
    pub esp_netif: *mut esp_netif_t,
    #[doc = "< IP address, netmask, gatway IP address"]
    pub ip_info: esp_netif_ip_info_t,
    #[doc = "< Whether the assigned IP has changed or not"]
    pub ip_changed: bool,
}
impl Default for ip_event_got_ip_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Event structure for IP_EVENT_GOT_IP6 event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_got_ip6_t {
    #[doc = "< Pointer to corresponding esp-netif object"]
    pub esp_netif: *mut esp_netif_t,
    #[doc = "< IPv6 address of the interface"]
    pub ip6_info: esp_netif_ip6_info_t,
    #[doc = "< IPv6 address index"]
    pub ip_index: ::core::ffi::c_int,
}
impl Default for ip_event_got_ip6_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Event structure for ADD_IP6 event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_event_add_ip6_t {
    #[doc = "< The address to be added to the interface"]
    pub addr: esp_ip6_addr_t,
    #[doc = "< The default preference of the address"]
    pub preferred: bool,
}
#[doc = " Event structure for IP_EVENT_AP_STAIPASSIGNED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_ap_staipassigned_t {
    #[doc = "< Pointer to the associated netif handle"]
    pub esp_netif: *mut esp_netif_t,
    #[doc = "< IP address which was assigned to the station"]
    pub ip: esp_ip4_addr_t,
    #[doc = "< MAC address of the connected client"]
    pub mac: [u8; 6usize],
}
impl Default for ip_event_ap_staipassigned_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const esp_netif_flags_ESP_NETIF_DHCP_CLIENT: esp_netif_flags = 1;
pub const esp_netif_flags_ESP_NETIF_DHCP_SERVER: esp_netif_flags = 2;
pub const esp_netif_flags_ESP_NETIF_FLAG_AUTOUP: esp_netif_flags = 4;
pub const esp_netif_flags_ESP_NETIF_FLAG_GARP: esp_netif_flags = 8;
pub const esp_netif_flags_ESP_NETIF_FLAG_EVENT_IP_MODIFIED: esp_netif_flags = 16;
pub const esp_netif_flags_ESP_NETIF_FLAG_IS_PPP: esp_netif_flags = 32;
pub const esp_netif_flags_ESP_NETIF_FLAG_IS_BRIDGE: esp_netif_flags = 64;
pub const esp_netif_flags_ESP_NETIF_FLAG_MLDV6_REPORT: esp_netif_flags = 128;
pub type esp_netif_flags = ::core::ffi::c_uint;
pub use self::esp_netif_flags as esp_netif_flags_t;
pub const esp_netif_ip_event_type_ESP_NETIF_IP_EVENT_GOT_IP: esp_netif_ip_event_type = 1;
pub const esp_netif_ip_event_type_ESP_NETIF_IP_EVENT_LOST_IP: esp_netif_ip_event_type = 2;
pub type esp_netif_ip_event_type = ::core::ffi::c_uint;
pub use self::esp_netif_ip_event_type as esp_netif_ip_event_type_t;
#[doc = " LwIP bridge configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bridgeif_config {
    #[doc = "< maximum number of entries in dynamic forwarding database"]
    pub max_fdb_dyn_entries: u16,
    #[doc = "< maximum number of entries in static forwarding database"]
    pub max_fdb_sta_entries: u16,
    #[doc = "< maximum number of ports the bridge can consist of"]
    pub max_ports: u8,
}
#[doc = " LwIP bridge configuration"]
pub type bridgeif_config_t = bridgeif_config;
#[doc = " @brief ESP-netif inherent config parameters\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_inherent_config {
    #[doc = "< flags that define esp-netif behavior"]
    pub flags: esp_netif_flags_t,
    #[doc = "< initial mac address for this interface"]
    pub mac: [u8; 6usize],
    #[doc = "< initial ip address for this interface"]
    pub ip_info: *const esp_netif_ip_info_t,
    #[doc = "< event id to be raised when interface gets an IP"]
    pub get_ip_event: u32,
    #[doc = "< event id to be raised when interface losts its IP"]
    pub lost_ip_event: u32,
    #[doc = "< string identifier of the interface"]
    pub if_key: *const ::core::ffi::c_char,
    #[doc = "< textual description of the interface"]
    pub if_desc: *const ::core::ffi::c_char,
    #[doc = "< numeric priority of this interface to become a default\nrouting if (if other netifs are up).\nA higher value of route_prio indicates\na higher priority"]
    pub route_prio: ::core::ffi::c_int,
    #[doc = "< LwIP bridge configuration"]
    pub bridge_info: *mut bridgeif_config_t,
}
impl Default for esp_netif_inherent_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief ESP-netif inherent config parameters\n"]
pub type esp_netif_inherent_config_t = esp_netif_inherent_config;
#[doc = " @brief  Generic esp_netif configuration"]
pub type esp_netif_config_t = esp_netif_config;
#[doc = " @brief  IO driver handle type"]
pub type esp_netif_iodriver_handle = *mut ::core::ffi::c_void;
#[doc = " @brief ESP-netif driver base handle\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_driver_base_s {
    #[doc = "< post attach function pointer"]
    pub post_attach: ::core::option::Option<
        unsafe extern "C" fn(netif: *mut esp_netif_t, h: esp_netif_iodriver_handle) -> esp_err_t,
    >,
    #[doc = "< netif handle"]
    pub netif: *mut esp_netif_t,
}
impl Default for esp_netif_driver_base_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief ESP-netif driver base handle\n"]
pub type esp_netif_driver_base_t = esp_netif_driver_base_s;
#[doc = " @brief  Specific IO driver configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_driver_ifconfig {
    #[doc = "< io-driver handle"]
    pub handle: esp_netif_iodriver_handle,
    #[doc = "< transmit function pointer"]
    pub transmit: ::core::option::Option<
        unsafe extern "C" fn(
            h: *mut ::core::ffi::c_void,
            buffer: *mut ::core::ffi::c_void,
            len: usize,
        ) -> esp_err_t,
    >,
    #[doc = "< transmit wrap function pointer"]
    pub transmit_wrap: ::core::option::Option<
        unsafe extern "C" fn(
            h: *mut ::core::ffi::c_void,
            buffer: *mut ::core::ffi::c_void,
            len: usize,
            netstack_buffer: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = "< free rx buffer function pointer"]
    pub driver_free_rx_buffer: ::core::option::Option<
        unsafe extern "C" fn(h: *mut ::core::ffi::c_void, buffer: *mut ::core::ffi::c_void),
    >,
}
impl Default for esp_netif_driver_ifconfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief  Specific IO driver configuration"]
pub type esp_netif_driver_ifconfig_t = esp_netif_driver_ifconfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_netstack_config {
    _unused: [u8; 0],
}
#[doc = " @brief  Specific L3 network stack configuration"]
pub type esp_netif_netstack_config_t = esp_netif_netstack_config;
#[doc = " @brief  Generic esp_netif configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_config {
    #[doc = "< base config"]
    pub base: *const esp_netif_inherent_config_t,
    #[doc = "< driver config"]
    pub driver: *const esp_netif_driver_ifconfig_t,
    #[doc = "< stack config"]
    pub stack: *const esp_netif_netstack_config_t,
}
impl Default for esp_netif_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief DHCP client's addr info (pair of MAC and IP address)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_netif_pair_mac_ip_t {
    #[doc = "< Clients MAC address"]
    pub mac: [u8; 6usize],
    #[doc = "< Clients IP address"]
    pub ip: esp_ip4_addr_t,
}
#[doc = " @brief  ESP-NETIF Receive function type"]
pub type esp_netif_receive_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_netif: *mut esp_netif_t,
        buffer: *mut ::core::ffi::c_void,
        len: usize,
        eb: *mut ::core::ffi::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    pub static mut _g_esp_netif_netstack_default_eth: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_br: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_wifi_sta: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_wifi_ap: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_ppp: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_sta_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_ap_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_eth_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_ppp_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_soft_ap_ip: esp_netif_ip_info_t;
}
extern "C" {
    #[doc = " @brief  Initialize the underlying TCP/IP stack\n\n @return\n         - ESP_OK on success\n         - ESP_FAIL if initializing failed\n\n @note This function should be called exactly once from application code, when the application starts up."]
    pub fn esp_netif_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinitialize the esp-netif component (and the underlying TCP/IP stack)\n\n          Note: Deinitialization is not supported yet\n\n @return\n         - ESP_ERR_INVALID_STATE if esp_netif not initialized\n         - ESP_ERR_NOT_SUPPORTED otherwise"]
    pub fn esp_netif_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Creates an instance of new esp-netif object based on provided config\n\n @param[in]     esp_netif_config pointer esp-netif configuration\n\n @return\n         - pointer to esp-netif object on success\n         - NULL otherwise"]
    pub fn esp_netif_new(esp_netif_config: *const esp_netif_config_t) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief   Destroys the esp_netif object\n\n @param[in]  esp_netif pointer to the object to be deleted"]
    pub fn esp_netif_destroy(esp_netif: *mut esp_netif_t);
}
extern "C" {
    #[doc = " @brief   Configures driver related options of esp_netif object\n\n @param[inout]  esp_netif pointer to the object to be configured\n @param[in]     driver_config pointer esp-netif io driver related configuration\n @return\n         - ESP_OK on success\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS if invalid parameters provided\n"]
    pub fn esp_netif_set_driver_config(
        esp_netif: *mut esp_netif_t,
        driver_config: *const esp_netif_driver_ifconfig_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Attaches esp_netif instance to the io driver handle\n\n Calling this function enables connecting specific esp_netif object\n with already initialized io driver to update esp_netif object with driver\n specific configuration (i.e. calls post_attach callback, which typically\n sets io driver callbacks to esp_netif instance and starts the driver)\n\n @param[inout]  esp_netif pointer to esp_netif object to be attached\n @param[in]  driver_handle pointer to the driver handle\n @return\n         - ESP_OK on success\n         - ESP_ERR_ESP_NETIF_DRIVER_ATTACH_FAILED if driver's pot_attach callback failed"]
    pub fn esp_netif_attach(
        esp_netif: *mut esp_netif_t,
        driver_handle: esp_netif_iodriver_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Passes the raw packets from communication media to the appropriate TCP/IP stack\n\n This function is called from the configured (peripheral) driver layer.\n The data are then forwarded as frames to the TCP/IP stack.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  buffer Received data\n @param[in]  len Length of the data frame\n @param[in]  eb Pointer to internal buffer (used in Wi-Fi driver)\n\n @return\n         - ESP_OK"]
    pub fn esp_netif_receive(
        esp_netif: *mut esp_netif_t,
        buffer: *mut ::core::ffi::c_void,
        len: usize,
        eb: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver start event\n Creates network interface, if AUTOUP enabled turns the interface on,\n if DHCPS enabled starts dhcp server\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_start(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver stop event\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_stop(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver connected event\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_connected(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver disconnected event\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_disconnected(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon network got IP event\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_got_ip(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IPv6 multicast group join\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_join_ip6_multicast_group(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IPv6 multicast group leave\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_leave_ip6_multicast_group(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IPv6 address added by the underlying stack\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_add_ip6_address(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IPv6 address removed by the underlying stack\n\n @note This API can be directly used as event handler\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param base\n @param event_id\n @param data"]
    pub fn esp_netif_action_remove_ip6_address(
        esp_netif: *mut ::core::ffi::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Manual configuration of the default netif\n\n This API overrides the automatic configuration of the default interface based on the route_prio\n If the selected netif is set default using this API, no other interface could be set-default disregarding\n its route_prio number (unless the selected netif gets destroyed)\n\n @param[in] esp_netif Handle to esp-netif instance\n @return ESP_OK on success"]
    pub fn esp_netif_set_default_netif(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to join a IPv6 multicast group\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  addr      The multicast group to join\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_MLD6_FAILED\n         - ESP_ERR_NO_MEM"]
    pub fn esp_netif_join_ip6_multicast_group(
        esp_netif: *mut esp_netif_t,
        addr: *const esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to leave a IPv6 multicast group\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  addr      The multicast group to leave\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_MLD6_FAILED\n         - ESP_ERR_NO_MEM"]
    pub fn esp_netif_leave_ip6_multicast_group(
        esp_netif: *mut esp_netif_t,
        addr: *const esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the mac address for the interface instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  mac Desired mac address for the related network interface\n @return\n         - ESP_OK - success\n         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error\n         - ESP_ERR_NOT_SUPPORTED - mac not supported on this interface"]
    pub fn esp_netif_set_mac(esp_netif: *mut esp_netif_t, mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the mac address for the interface instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out]  mac Resultant mac address for the related network interface\n @return\n         - ESP_OK - success\n         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error\n         - ESP_ERR_NOT_SUPPORTED - mac not supported on this interface"]
    pub fn esp_netif_get_mac(esp_netif: *mut esp_netif_t, mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the hostname of an interface\n\n The configured hostname overrides the default configuration value CONFIG_LWIP_LOCAL_HOSTNAME.\n Please note that when the hostname is altered after interface started/connected the changes\n would only be reflected once the interface restarts/reconnects\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]   hostname New hostname for the interface. Maximum length 32 bytes.\n\n @return\n         - ESP_OK - success\n         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS - parameter error"]
    pub fn esp_netif_set_hostname(
        esp_netif: *mut esp_netif_t,
        hostname: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface hostname.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out]   hostname Returns a pointer to the hostname. May be NULL if no hostname is set. If set non-NULL, pointer remains valid (and string may change if the hostname changes).\n\n @return\n         - ESP_OK - success\n         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS - parameter error"]
    pub fn esp_netif_get_hostname(
        esp_netif: *mut esp_netif_t,
        hostname: *mut *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Test if supplied interface is up or down\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return\n         - true - Interface is up\n         - false - Interface is down"]
    pub fn esp_netif_is_netif_up(esp_netif: *mut esp_netif_t) -> bool;
}
extern "C" {
    #[doc = " @brief  Get interface's IP address information\n\n If the interface is up, IP information is read directly from the TCP/IP stack.\n If the interface is down, IP information is read from a copy kept in the ESP-NETIF instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out]  ip_info If successful, IP information will be returned in this argument.\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_get_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *mut esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's old IP information\n\n Returns an \"old\" IP address previously stored for the interface when the valid IP changed.\n\n If the IP lost timer has expired (meaning the interface was down for longer than the configured interval)\n then the old IP information will be zero.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out]  ip_info If successful, IP information will be returned in this argument.\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_get_old_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *mut esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface's IP address information\n\n This function is mainly used to set a static IP on an interface.\n\n If the interface is up, the new IP information is set directly in the TCP/IP stack.\n\n The copy of IP information kept in the ESP-NETIF instance is also updated (this\n copy is returned if the IP is queried while the interface is still down.)\n\n @note DHCP client/server must be stopped (if enabled for this interface) before setting new IP information.\n\n @note Calling this interface for may generate a SYSTEM_EVENT_STA_GOT_IP or SYSTEM_EVENT_ETH_GOT_IP event.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in] ip_info IP information to set on the specified interface\n\n @return\n      - ESP_OK\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n      - ESP_ERR_ESP_NETIF_DHCP_NOT_STOPPED If DHCP server or client is still running"]
    pub fn esp_netif_set_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *const esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface old IP information\n\n This function is called from the DHCP client (if enabled), before a new IP is set.\n It is also called from the default handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events.\n\n Calling this function stores the previously configured IP, which can be used to determine if the IP changes in the future.\n\n If the interface is disconnected or down for too long, the \"IP lost timer\" will expire (after the configured interval) and set the old IP information to zero.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  ip_info Store the old IP information for the specified interface\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_set_old_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *const esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get net interface index from network stack implementation\n\n @note This index could be used in `setsockopt()` to bind socket with multicast interface\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return\n         implementation specific index of interface represented with supplied esp_netif"]
    pub fn esp_netif_get_netif_impl_index(esp_netif: *mut esp_netif_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief  Get net interface name from network stack implementation\n\n @note This name could be used in `setsockopt()` to bind socket with appropriate interface\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out]  name Interface name as specified in underlying TCP/IP stack. Note that the\n actual name will be copied to the specified buffer, which must be allocated to hold\n maximum interface name size (6 characters for lwIP)\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_get_netif_impl_name(
        esp_netif: *mut esp_netif_t,
        name: *mut ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP server option\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in] opt_op ESP_NETIF_OP_SET to set an option, ESP_NETIF_OP_GET to get an option.\n @param[in] opt_id Option index to get or set, must be one of the supported enum values.\n @param[inout] opt_val Pointer to the option parameter.\n @param[in] opt_len Length of the option parameter.\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcps_option(
        esp_netif: *mut esp_netif_t,
        opt_op: esp_netif_dhcp_option_mode_t,
        opt_id: esp_netif_dhcp_option_id_t,
        opt_val: *mut ::core::ffi::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP client option\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in] opt_op ESP_NETIF_OP_SET to set an option, ESP_NETIF_OP_GET to get an option.\n @param[in] opt_id Option index to get or set, must be one of the supported enum values.\n @param[inout] opt_val Pointer to the option parameter.\n @param[in] opt_len Length of the option parameter.\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcpc_option(
        esp_netif: *mut esp_netif_t,
        opt_op: esp_netif_dhcp_option_mode_t,
        opt_id: esp_netif_dhcp_option_id_t,
        opt_val: *mut ::core::ffi::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start DHCP client (only if enabled in interface object)\n\n @note The default event handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events call this function.\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED\n         - ESP_ERR_ESP_NETIF_DHCPC_START_FAILED"]
    pub fn esp_netif_dhcpc_start(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP client (only if enabled in interface object)\n\n @note Calling action_netif_stop() will also stop the DHCP Client if it is running.\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return\n      - ESP_OK\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n      - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED\n      - ESP_ERR_ESP_NETIF_IF_NOT_READY"]
    pub fn esp_netif_dhcpc_stop(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP client status\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out] status If successful, the status of DHCP client will be returned in this argument.\n\n @return\n         - ESP_OK"]
    pub fn esp_netif_dhcpc_get_status(
        esp_netif: *mut esp_netif_t,
        status: *mut esp_netif_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP Server status\n\n @param[in]   esp_netif Handle to esp-netif instance\n @param[out]  status If successful, the status of the DHCP server will be returned in this argument.\n\n @return\n         - ESP_OK"]
    pub fn esp_netif_dhcps_get_status(
        esp_netif: *mut esp_netif_t,
        status: *mut esp_netif_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start DHCP server (only if enabled in interface object)\n\n @param[in]   esp_netif Handle to esp-netif instance\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcps_start(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP server (only if enabled in interface object)\n\n @param[in]   esp_netif Handle to esp-netif instance\n\n @return\n      - ESP_OK\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS\n      - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED\n      - ESP_ERR_ESP_NETIF_IF_NOT_READY"]
    pub fn esp_netif_dhcps_stop(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Populate IP addresses of clients connected to DHCP server listed by their MAC addresses\n\n @param[in] esp_netif Handle to esp-netif instance\n @param[in] num Number of clients with specified MAC addresses in the array of pairs\n @param[in,out] mac_ip_pair Array of pairs of MAC and IP addresses (MAC are inputs, IP outputs)\n @return\n      - ESP_OK on success\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS on invalid params\n      - ESP_ERR_NOT_SUPPORTED if DHCP server not enabled"]
    pub fn esp_netif_dhcps_get_clients_by_mac(
        esp_netif: *mut esp_netif_t,
        num: ::core::ffi::c_int,
        mac_ip_pair: *mut esp_netif_pair_mac_ip_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set DNS Server information\n\n This function behaves differently if DHCP server or client is enabled\n\n   If DHCP client is enabled, main and backup DNS servers will be updated automatically\n   from the DHCP lease if the relevant DHCP options are set. Fallback DNS Server is never updated from the DHCP lease\n   and is designed to be set via this API.\n   If DHCP client is disabled, all DNS server types can be set via this API only.\n\n   If DHCP server is enabled, the Main DNS Server setting is used by the DHCP server to provide a DNS Server option\n   to DHCP clients (Wi-Fi stations).\n   - The default Main DNS server is typically the IP of the DHCP server itself.\n   - This function can override it by setting server type ESP_NETIF_DNS_MAIN.\n   - Other DNS Server types are not supported for the DHCP server.\n   - To propagate the DNS info to client, please stop the DHCP server before using this API.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  type Type of DNS Server to set: ESP_NETIF_DNS_MAIN, ESP_NETIF_DNS_BACKUP, ESP_NETIF_DNS_FALLBACK\n @param[in]  dns  DNS Server address to set\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS invalid params"]
    pub fn esp_netif_set_dns_info(
        esp_netif: *mut esp_netif_t,
        type_: esp_netif_dns_type_t,
        dns: *mut esp_netif_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DNS Server information\n\n Return the currently configured DNS Server address for the specified interface and Server type.\n\n This may be result of a previous call to esp_netif_set_dns_info(). If the interface's DHCP client is enabled,\n the Main or Backup DNS Server may be set by the current DHCP lease.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[in]  type Type of DNS Server to get: ESP_NETIF_DNS_MAIN, ESP_NETIF_DNS_BACKUP, ESP_NETIF_DNS_FALLBACK\n @param[out] dns  DNS Server result is written here on success\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_ESP_NETIF_INVALID_PARAMS invalid params"]
    pub fn esp_netif_get_dns_info(
        esp_netif: *mut esp_netif_t,
        type_: esp_netif_dns_type_t,
        dns: *mut esp_netif_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Create interface link-local IPv6 address\n\n Cause the TCP/IP stack to create a link-local IPv6 address for the specified interface.\n\n This function also registers a callback for the specified interface, so that if the link-local address becomes\n verified as the preferred address then a SYSTEM_EVENT_GOT_IP6 event will be sent.\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return\n         - ESP_OK\n         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_create_ip6_linklocal(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface link-local IPv6 address\n\n If the specified interface is up and a preferred link-local IPv6 address\n has been created for the interface, return a copy of it.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out] if_ip6 IPv6 information will be returned in this argument if successful.\n\n @return\n      - ESP_OK\n      - ESP_FAIL If interface is down, does not have a link-local IPv6 address,\n        or the link-local IPv6 address is not a preferred address."]
    pub fn esp_netif_get_ip6_linklocal(
        esp_netif: *mut esp_netif_t,
        if_ip6: *mut esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface global IPv6 address\n\n If the specified interface is up and a preferred global IPv6 address\n has been created for the interface, return a copy of it.\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out] if_ip6 IPv6 information will be returned in this argument if successful.\n\n @return\n      - ESP_OK\n      - ESP_FAIL If interface is down, does not have a global IPv6 address,\n        or the global IPv6 address is not a preferred address."]
    pub fn esp_netif_get_ip6_global(
        esp_netif: *mut esp_netif_t,
        if_ip6: *mut esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get all IPv6 addresses of the specified interface\n\n @param[in]  esp_netif Handle to esp-netif instance\n @param[out] if_ip6 Array of IPv6 addresses will be copied to the argument\n\n @return\n      number of returned IPv6 addresses"]
    pub fn esp_netif_get_all_ip6(
        esp_netif: *mut esp_netif_t,
        if_ip6: *mut esp_ip6_addr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Sets IPv4 address to the specified octets\n\n @param[out] addr IP address to be set\n @param a the first octet (127 for IP 127.0.0.1)\n @param b\n @param c\n @param d"]
    pub fn esp_netif_set_ip4_addr(addr: *mut esp_ip4_addr_t, a: u8, b: u8, c: u8, d: u8);
}
extern "C" {
    #[doc = " @brief Converts numeric IP address into decimal dotted ASCII representation.\n\n @param addr ip address in network order to convert\n @param buf target buffer where the string is stored\n @param buflen length of buf\n @return either pointer to buf which now holds the ASCII\n         representation of addr or NULL if buf was too small"]
    pub fn esp_ip4addr_ntoa(
        addr: *const esp_ip4_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Ascii internet address interpretation routine\n The value returned is in network order.\n\n @param addr IP address in ascii representation (e.g. \"127.0.0.1\")\n @return ip address in network order"]
    pub fn esp_ip4addr_aton(addr: *const ::core::ffi::c_char) -> u32;
}
extern "C" {
    #[doc = " @brief Converts Ascii internet IPv4 address into esp_ip4_addr_t\n\n @param[in] src IPv4 address in ascii representation (e.g. \"127.0.0.1\")\n @param[out] dst Address of the target esp_ip4_addr_t structure to receive converted address\n @return\n         - ESP_OK on success\n         - ESP_FAIL if conversion failed\n         - ESP_ERR_INVALID_ARG if invalid parameter is passed into"]
    pub fn esp_netif_str_to_ip4(
        src: *const ::core::ffi::c_char,
        dst: *mut esp_ip4_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Converts Ascii internet IPv6 address into esp_ip4_addr_t\n Zeros in the IP address can be stripped or completely ommited: \"2001:db8:85a3:0:0:0:2:1\" or \"2001:db8::2:1\")\n\n @param[in] src IPv6 address in ascii representation (e.g. \"\"2001:0db8:85a3:0000:0000:0000:0002:0001\")\n @param[out] dst Address of the target esp_ip6_addr_t structure to receive converted address\n @return\n         - ESP_OK on success\n         - ESP_FAIL if conversion failed\n         - ESP_ERR_INVALID_ARG if invalid parameter is passed into"]
    pub fn esp_netif_str_to_ip6(
        src: *const ::core::ffi::c_char,
        dst: *mut esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Gets media driver handle for this esp-netif instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return opaque pointer of related IO driver"]
    pub fn esp_netif_get_io_driver(esp_netif: *mut esp_netif_t) -> esp_netif_iodriver_handle;
}
extern "C" {
    #[doc = " @brief Searches over a list of created objects to find an instance with supplied if key\n\n @param if_key Textual description of network interface\n\n @return Handle to esp-netif instance"]
    pub fn esp_netif_get_handle_from_ifkey(if_key: *const ::core::ffi::c_char) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Returns configured flags for this interface\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return Configuration flags"]
    pub fn esp_netif_get_flags(esp_netif: *mut esp_netif_t) -> esp_netif_flags_t;
}
extern "C" {
    #[doc = " @brief Returns configured interface key for this esp-netif instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return Textual description of related interface"]
    pub fn esp_netif_get_ifkey(esp_netif: *mut esp_netif_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Returns configured interface type for this esp-netif instance\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return Enumerated type of this interface, such as station, AP, ethernet"]
    pub fn esp_netif_get_desc(esp_netif: *mut esp_netif_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Returns configured routing priority number\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return Integer representing the instance's route-prio, or -1 if invalid paramters"]
    pub fn esp_netif_get_route_prio(esp_netif: *mut esp_netif_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Returns configured event for this esp-netif instance and supplied event type\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @param event_type (either get or lost IP)\n\n @return specific event id which is configured to be raised if the interface lost or acquired IP address\n         -1 if supplied event_type is not known"]
    pub fn esp_netif_get_event_id(
        esp_netif: *mut esp_netif_t,
        event_type: esp_netif_ip_event_type_t,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Iterates over list of interfaces. Returns first netif if NULL given as parameter\n\n @param[in]  esp_netif Handle to esp-netif instance\n\n @return First netif from the list if supplied parameter is NULL, next one otherwise"]
    pub fn esp_netif_next(esp_netif: *mut esp_netif_t) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Returns number of registered esp_netif objects\n\n @return Number of esp_netifs"]
    pub fn esp_netif_get_nr_of_ifs() -> usize;
}
extern "C" {
    #[doc = " @brief increase the reference counter of net stack buffer\n\n @param[in]  netstack_buf the net stack buffer\n"]
    pub fn esp_netif_netstack_buf_ref(netstack_buf: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief free the netstack buffer\n\n @param[in]  netstack_buf the net stack buffer\n"]
    pub fn esp_netif_netstack_buf_free(netstack_buf: *mut ::core::ffi::c_void);
}
#[doc = " @brief  TCPIP thread safe callback used with esp_netif_tcpip_exec()"]
pub type esp_netif_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> esp_err_t>;
extern "C" {
    #[doc = " @brief Utility to execute the supplied callback in TCP/IP context\n @param fn Pointer to the callback\n @param ctx Parameter to the callback\n @return The error code (esp_err_t) returned by the callback"]
    pub fn esp_netif_tcpip_exec(
        fn_: esp_netif_callback_fn,
        ctx: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = "< null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< WiFi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< WiFi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< WiFi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 4;
pub type wifi_mode_t = ::core::ffi::c_uint;
pub const wifi_interface_t_WIFI_IF_STA: wifi_interface_t = 0;
pub const wifi_interface_t_WIFI_IF_AP: wifi_interface_t = 1;
pub type wifi_interface_t = ::core::ffi::c_uint;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
pub type wifi_country_policy_t = ::core::ffi::c_uint;
#[doc = " @brief Structure describing WiFi country-based regional restrictions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [::core::ffi::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< This field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power."]
    pub max_tx_power: i8,
    #[doc = "< country policy"]
    pub policy: wifi_country_policy_t,
}
impl Default for wifi_country_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< authenticate mode : WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< authenticate mode : WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_PSK: wifi_auth_mode_t = 6;
#[doc = "< authenticate mode : WPA2_WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_PSK: wifi_auth_mode_t = 7;
#[doc = "< authenticate mode : WAPI_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WAPI_PSK: wifi_auth_mode_t = 8;
#[doc = "< authenticate mode : OWE"]
pub const wifi_auth_mode_t_WIFI_AUTH_OWE: wifi_auth_mode_t = 9;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 10;
pub type wifi_auth_mode_t = ::core::ffi::c_uint;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
pub const wifi_err_reason_t_WIFI_REASON_BSS_TRANSITION_DISASSOC: wifi_err_reason_t = 12;
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
pub const wifi_err_reason_t_WIFI_REASON_TDLS_PEER_UNREACHABLE: wifi_err_reason_t = 25;
pub const wifi_err_reason_t_WIFI_REASON_TDLS_UNSPECIFIED: wifi_err_reason_t = 26;
pub const wifi_err_reason_t_WIFI_REASON_SSP_REQUESTED_DISASSOC: wifi_err_reason_t = 27;
pub const wifi_err_reason_t_WIFI_REASON_NO_SSP_ROAMING_AGREEMENT: wifi_err_reason_t = 28;
pub const wifi_err_reason_t_WIFI_REASON_BAD_CIPHER_OR_AKM: wifi_err_reason_t = 29;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHORIZED_THIS_LOCATION: wifi_err_reason_t = 30;
pub const wifi_err_reason_t_WIFI_REASON_SERVICE_CHANGE_PERCLUDES_TS: wifi_err_reason_t = 31;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED_QOS: wifi_err_reason_t = 32;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ENOUGH_BANDWIDTH: wifi_err_reason_t = 33;
pub const wifi_err_reason_t_WIFI_REASON_MISSING_ACKS: wifi_err_reason_t = 34;
pub const wifi_err_reason_t_WIFI_REASON_EXCEEDED_TXOP: wifi_err_reason_t = 35;
pub const wifi_err_reason_t_WIFI_REASON_STA_LEAVING: wifi_err_reason_t = 36;
pub const wifi_err_reason_t_WIFI_REASON_END_BA: wifi_err_reason_t = 37;
pub const wifi_err_reason_t_WIFI_REASON_UNKNOWN_BA: wifi_err_reason_t = 38;
pub const wifi_err_reason_t_WIFI_REASON_TIMEOUT: wifi_err_reason_t = 39;
pub const wifi_err_reason_t_WIFI_REASON_PEER_INITIATED: wifi_err_reason_t = 46;
pub const wifi_err_reason_t_WIFI_REASON_AP_INITIATED: wifi_err_reason_t = 47;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FT_ACTION_FRAME_COUNT: wifi_err_reason_t = 48;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_PMKID: wifi_err_reason_t = 49;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_MDE: wifi_err_reason_t = 50;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_FTE: wifi_err_reason_t = 51;
pub const wifi_err_reason_t_WIFI_REASON_TRANSMISSION_LINK_ESTABLISH_FAILED: wifi_err_reason_t = 67;
pub const wifi_err_reason_t_WIFI_REASON_ALTERATIVE_CHANNEL_OCCUPIED: wifi_err_reason_t = 68;
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
pub const wifi_err_reason_t_WIFI_REASON_AP_TSF_RESET: wifi_err_reason_t = 206;
pub const wifi_err_reason_t_WIFI_REASON_ROAMING: wifi_err_reason_t = 207;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_COMEBACK_TIME_TOO_LONG: wifi_err_reason_t = 208;
pub const wifi_err_reason_t_WIFI_REASON_SA_QUERY_TIMEOUT: wifi_err_reason_t = 209;
pub type wifi_err_reason_t = ::core::ffi::c_uint;
#[doc = "< the channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< the channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< the channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
pub type wifi_second_chan_t = ::core::ffi::c_uint;
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = ::core::ffi::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may\ncause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[doc = " @brief Parameters for an SSID scan."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< enable to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< scan time per channel"]
    pub scan_time: wifi_scan_time_t,
}
impl Default for wifi_scan_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< the cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< the cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< the cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< the cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< the cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< the cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< the cipher type is AES-CMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_CMAC128: wifi_cipher_type_t = 6;
#[doc = "< the cipher type is SMS4"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_SMS4: wifi_cipher_type_t = 7;
#[doc = "< the cipher type is GCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP: wifi_cipher_type_t = 8;
#[doc = "< the cipher type is GCMP-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_GCMP256: wifi_cipher_type_t = 9;
#[doc = "< the cipher type is AES-GMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC128: wifi_cipher_type_t = 10;
#[doc = "< the cipher type is AES-GMAC-256"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_GMAC256: wifi_cipher_type_t = 11;
#[doc = "< the cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 12;
pub type wifi_cipher_type_t = ::core::ffi::c_uint;
#[doc = "< WiFi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< WiFi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid WiFi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief WiFi antenna\n"]
pub type wifi_ant_t = ::core::ffi::c_uint;
#[doc = " @brief Description of a WiFi AP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< channel of AP"]
    pub primary: u8,
    #[doc = "< secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< signal strength of AP"]
    pub rssi: i8,
    #[doc = "< authmode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< country information of AP"]
    pub country: wifi_country_t,
}
impl Default for wifi_ap_record_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_responder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_responder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ftm_initiator(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ftm_initiator(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        wps: u32,
        ftm_responder: u32,
        ftm_initiator: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ftm_responder: u32 = unsafe { ::core::mem::transmute(ftm_responder) };
            ftm_responder as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ftm_initiator: u32 = unsafe { ::core::mem::transmute(ftm_initiator) };
            ftm_initiator as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
pub type wifi_scan_method_t = ::core::ffi::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
pub type wifi_sort_method_t = ::core::ffi::c_uint;
#[doc = " @brief Structure describing parameters for a WiFi fast scan"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode"]
    pub rssi: i8,
    #[doc = "< The weakest authmode to accept in the fast scan mode\nNote: Incase this value is not set and password is set as per WPA2 standards(password len >= 8), it will be defaulted to WPA2 and device won't connect to deprecated WEP/WPA networks. Please set authmode threshold as WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK to connect to WEP/WPA networks"]
    pub authmode: wifi_auth_mode_t,
}
impl Default for wifi_scan_threshold_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
pub type wifi_ps_type_t = ::core::ffi::c_uint;
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
pub type wifi_bandwidth_t = ::core::ffi::c_uint;
#[doc = " Configuration structure for Protected Management Frame"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_pmf_config_t {
    #[doc = "< Deprecated variable. Device will always connect in PMF mode if other device also advertizes PMF capability."]
    pub capable: bool,
    #[doc = "< Advertizes that Protected Management Frame is required. Device will not associate to non-PMF capable devices."]
    pub required: bool,
}
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_UNSPECIFIED: wifi_sae_pwe_method_t = 0;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HUNT_AND_PECK: wifi_sae_pwe_method_t = 1;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_HASH_TO_ELEMENT: wifi_sae_pwe_method_t = 2;
pub const wifi_sae_pwe_method_t_WPA3_SAE_PWE_BOTH: wifi_sae_pwe_method_t = 3;
#[doc = " Configuration for SAE PWE derivation"]
pub type wifi_sae_pwe_method_t = ::core::ffi::c_uint;
#[doc = " @brief Soft-AP configuration settings for the ESP32"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of ESP32 soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of ESP32 soft-AP."]
    pub password: [u8; 64usize],
    #[doc = "< Optional length of SSID field."]
    pub ssid_len: u8,
    #[doc = "< Channel of ESP32 soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of ESP32 soft-AP. Do not support AUTH_WEP in soft-AP mode"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in"]
    pub max_connection: u8,
    #[doc = "< Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU = 1024 us). Range: 100 ~ 60000. Default value: 100"]
    pub beacon_interval: u16,
    #[doc = "< pairwise cipher of SoftAP, group cipher will be derived using this. cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP and WIFI_CIPHER_TYPE_TKIP_CCMP."]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< Enable FTM Responder mode"]
    pub ftm_responder: bool,
    #[doc = "< Configuration for Protected Management Frame"]
    pub pmf_cfg: wifi_pmf_config_t,
}
impl Default for wifi_ap_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief STA configuration settings for the ESP32"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of target AP."]
    pub password: [u8; 64usize],
    #[doc = "< do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0."]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When sort_method is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
    #[doc = "< Configuration for Protected Management Frame. Will be advertized in RSN Capabilities in RSN IE."]
    pub pmf_cfg: wifi_pmf_config_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Whether SAE hash to element is enabled"]
    pub sae_pwe_h2e: wifi_sae_pwe_method_t,
    #[doc = "< Number of connection retries station will do before moving to next AP. scan_method should be set as WIFI_ALL_CHANNEL_SCAN to use this config. Note: Enabling this may cause connection time to increase incase best AP doesn't behave properly."]
    pub failure_retry_cnt: u8,
}
impl Default for wifi_sta_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wifi_sta_config_t {
    #[inline]
    pub fn rm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btm_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_btm_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mbo_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mbo_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owe_enabled(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owe_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transition_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transition_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rm_enabled: u32,
        btm_enabled: u32,
        mbo_enabled: u32,
        ft_enabled: u32,
        owe_enabled: u32,
        transition_disable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rm_enabled: u32 = unsafe { ::core::mem::transmute(rm_enabled) };
            rm_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let btm_enabled: u32 = unsafe { ::core::mem::transmute(btm_enabled) };
            btm_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mbo_enabled: u32 = unsafe { ::core::mem::transmute(mbo_enabled) };
            mbo_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ft_enabled: u32 = unsafe { ::core::mem::transmute(ft_enabled) };
            ft_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let owe_enabled: u32 = unsafe { ::core::mem::transmute(owe_enabled) };
            owe_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transition_disable: u32 = unsafe { ::core::mem::transmute(transition_disable) };
            transition_disable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Configuration data for ESP32 AP or STA.\n\n The usage of this union (for ap or sta configuration) is determined by the accompanying\n interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< configuration of STA"]
    pub sta: wifi_sta_config_t,
}
impl Default for wifi_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< mac address"]
    pub mac: [u8; 6usize],
    #[doc = "< current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mesh_child(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mesh_child(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        is_mesh_child: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_mesh_child: u32 = unsafe { ::core::mem::transmute(is_mesh_child) };
            is_mesh_child as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief List of stations associated with the ESP32 Soft-AP"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: ::core::ffi::c_int,
}
#[doc = "< all configuration will store in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< all configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
pub type wifi_storage_t = ::core::ffi::c_uint;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type\n\n Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = ::core::ffi::c_uint;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index\n\n Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = ::core::ffi::c_uint;
#[doc = " @brief Vendor Information Element header\n\n The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
impl Default for wifi_pkt_rx_ctrl_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> ::core::ffi::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: ::core::ffi::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> ::core::ffi::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(160usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: ::core::ffi::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(160usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(255usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(255usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(352usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(352usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(376usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(376usize, 8u8, val as u64)
        }
    }
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
#[derive(Debug)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
impl Default for wifi_promiscuous_pkt_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indiciates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type\n\n Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer.\n"]
pub type wifi_promiscuous_pkt_type_t = ::core::ffi::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[doc = " @brief Channel state information(CSI) configuration type\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
}
#[doc = " @brief CSI data type\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< destination MAC address of the CSI data"]
    pub dmac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not"]
    pub first_word_invalid: bool,
    #[doc = "< buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< length of CSI data"]
    pub len: u16,
}
impl Default for wifi_csi_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief WiFi GPIO configuration for antenna selection\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpio_select: u8, gpio_num: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief WiFi GPIOs configuration for antenna selection\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable WiFi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable WiFi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable WiFi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid WiFi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief WiFi antenna mode\n"]
pub type wifi_ant_mode_t = ::core::ffi::c_uint;
#[doc = " @brief WiFi antenna configuration\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< WiFi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< WiFi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for wifi_ant_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief     The Rx callback function of Action Tx operations\n\n @param     hdr pointer to the IEEE 802.11 Header structure\n @param     payload pointer to the Payload following 802.11 Header\n @param     len length of the Payload\n @param     channel channel number the frame is received on\n"]
pub type wifi_action_rx_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        hdr: *mut u8,
        payload: *mut u8,
        len: usize,
        channel: u8,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief Action Frame Tx Request\n\n"]
#[repr(C)]
#[derive(Debug)]
pub struct wifi_action_tx_req_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Destination MAC address"]
    pub dest_mac: [u8; 6usize],
    #[doc = "< Indicates no ack required"]
    pub no_ack: bool,
    #[doc = "< Rx Callback to receive any response"]
    pub rx_cb: wifi_action_rx_cb_t,
    #[doc = "< Length of the appended Data"]
    pub data_len: u32,
    #[doc = "< Appended Data payload"]
    pub data: __IncompleteArrayField<u8>,
}
impl Default for wifi_action_tx_req_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief FTM Initiator configuration\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_ftm_initiator_cfg_t {
    #[doc = "< MAC address of the FTM Responder"]
    pub resp_mac: [u8; 6usize],
    #[doc = "< Primary channel of the FTM Responder"]
    pub channel: u8,
    #[doc = "< No. of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0(No pref), 16, 24, 32, 64)"]
    pub frm_count: u8,
    #[doc = "< Requested time period between consecutive FTM bursts in 100's of milliseconds (0 - No pref)"]
    pub burst_period: u16,
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI, 6.5 Mbps for 20MHz, 13.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI, 13 Mbps for 20MHz, 27 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI, 19.5 Mbps for 20MHz, 40.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI, 26 Mbps for 20MHz, 54 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI, 39 Mbps for 20MHz, 81 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI, 52 Mbps for 20MHz, 108 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI, 58.5 Mbps for 20MHz, 121.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS0 with short GI, 7.2 Mbps for 20MHz, 15 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 24;
#[doc = "< MCS1 with short GI, 14.4 Mbps for 20MHz, 30 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 25;
#[doc = "< MCS2 with short GI, 21.7 Mbps for 20MHz, 45 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS3 with short GI, 28.9 Mbps for 20MHz, 60 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS4 with short GI, 43.3 Mbps for 20MHz, 90 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS5 with short GI, 57.8 Mbps for 20MHz, 120 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS6 with short GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS7 with short GI, 72.2 Mbps for 20MHz, 150 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 31;
#[doc = "< 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief WiFi PHY rate encodings\n"]
pub type wifi_phy_rate_t = ::core::ffi::c_uint;
#[doc = "< ESP32 WiFi ready"]
pub const wifi_event_t_WIFI_EVENT_WIFI_READY: wifi_event_t = 0;
#[doc = "< ESP32 finish scanning AP"]
pub const wifi_event_t_WIFI_EVENT_SCAN_DONE: wifi_event_t = 1;
#[doc = "< ESP32 station start"]
pub const wifi_event_t_WIFI_EVENT_STA_START: wifi_event_t = 2;
#[doc = "< ESP32 station stop"]
pub const wifi_event_t_WIFI_EVENT_STA_STOP: wifi_event_t = 3;
#[doc = "< ESP32 station connected to AP"]
pub const wifi_event_t_WIFI_EVENT_STA_CONNECTED: wifi_event_t = 4;
#[doc = "< ESP32 station disconnected from AP"]
pub const wifi_event_t_WIFI_EVENT_STA_DISCONNECTED: wifi_event_t = 5;
#[doc = "< the auth mode of AP connected by ESP32 station changed"]
pub const wifi_event_t_WIFI_EVENT_STA_AUTHMODE_CHANGE: wifi_event_t = 6;
#[doc = "< ESP32 station wps succeeds in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_SUCCESS: wifi_event_t = 7;
#[doc = "< ESP32 station wps fails in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_FAILED: wifi_event_t = 8;
#[doc = "< ESP32 station wps timeout in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_TIMEOUT: wifi_event_t = 9;
#[doc = "< ESP32 station wps pin code in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PIN: wifi_event_t = 10;
#[doc = "< ESP32 station wps overlap in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: wifi_event_t = 11;
#[doc = "< ESP32 soft-AP start"]
pub const wifi_event_t_WIFI_EVENT_AP_START: wifi_event_t = 12;
#[doc = "< ESP32 soft-AP stop"]
pub const wifi_event_t_WIFI_EVENT_AP_STOP: wifi_event_t = 13;
#[doc = "< a station connected to ESP32 soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STACONNECTED: wifi_event_t = 14;
#[doc = "< a station disconnected from ESP32 soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STADISCONNECTED: wifi_event_t = 15;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const wifi_event_t_WIFI_EVENT_AP_PROBEREQRECVED: wifi_event_t = 16;
#[doc = "< Receive report of FTM procedure"]
pub const wifi_event_t_WIFI_EVENT_FTM_REPORT: wifi_event_t = 17;
#[doc = "< AP's RSSI crossed configured threshold"]
pub const wifi_event_t_WIFI_EVENT_STA_BSS_RSSI_LOW: wifi_event_t = 18;
#[doc = "< Status indication of Action Tx operation"]
pub const wifi_event_t_WIFI_EVENT_ACTION_TX_STATUS: wifi_event_t = 19;
#[doc = "< Remain-on-Channel operation complete"]
pub const wifi_event_t_WIFI_EVENT_ROC_DONE: wifi_event_t = 20;
#[doc = "< ESP32 station beacon timeout"]
pub const wifi_event_t_WIFI_EVENT_STA_BEACON_TIMEOUT: wifi_event_t = 21;
#[doc = "< ESP32 connectionless module wake interval start"]
pub const wifi_event_t_WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START: wifi_event_t = 22;
#[doc = "< Soft-AP wps succeeds in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_SUCCESS: wifi_event_t = 23;
#[doc = "< Soft-AP wps fails in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_FAILED: wifi_event_t = 24;
#[doc = "< Soft-AP wps timeout in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_TIMEOUT: wifi_event_t = 25;
#[doc = "< Soft-AP wps pin code in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PIN: wifi_event_t = 26;
#[doc = "< Soft-AP wps overlap in registrar mode"]
pub const wifi_event_t_WIFI_EVENT_AP_WPS_RG_PBC_OVERLAP: wifi_event_t = 27;
#[doc = "< Invalid WiFi event ID"]
pub const wifi_event_t_WIFI_EVENT_MAX: wifi_event_t = 28;
#[doc = " WiFi event declarations"]
pub type wifi_event_t = ::core::ffi::c_uint;
extern "C" {
    pub static mut WIFI_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for WIFI_EVENT_SCAN_DONE event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_sta_scan_done_t {
    #[doc = "< status of scanning APs: 0 — success, 1 - failure"]
    pub status: u32,
    #[doc = "< number of scan results"]
    pub number: u8,
    #[doc = "< scan sequence number, used for block scan"]
    pub scan_id: u8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_CONNECTED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of connected AP"]
    pub channel: u8,
    #[doc = "< authentication mode used by AP"]
    pub authmode: wifi_auth_mode_t,
}
impl Default for wifi_event_sta_connected_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< reason of disconnection"]
    pub reason: u8,
    #[doc = "< rssi of disconnection"]
    pub rssi: i8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_authmode_change_t {
    #[doc = "< the old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< the new auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
impl Default for wifi_event_sta_authmode_change_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< ESP32 WPS normal fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    wifi_event_sta_wps_fail_reason_t = 0;
#[doc = "< ESP32 WPS receive M2D frame"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    wifi_event_sta_wps_fail_reason_t = 1;
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX: wifi_event_sta_wps_fail_reason_t =
    2;
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event"]
pub type wifi_event_sta_wps_fail_reason_t = ::core::ffi::c_uint;
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t {
    #[doc = "< Number of AP credentials received"]
    pub ap_cred_cnt: u8,
    #[doc = "< All AP credentials received from WPS handshake"]
    pub ap_cred: [wifi_event_sta_wps_er_success_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_wps_er_success_t__bindgen_ty_1 {
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Passphrase for the AP"]
    pub passphrase: [u8; 64usize],
}
impl Default for wifi_event_sta_wps_er_success_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for wifi_event_sta_wps_er_success_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gives to the station connected to"]
    pub aid: u8,
    #[doc = "< flag to identify mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gave to the station disconnects to"]
    pub aid: u8,
    #[doc = "< flag to identify mesh child"]
    pub is_mesh_child: bool,
}
#[doc = " Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: ::core::ffi::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[doc = " Argument structure for WIFI_EVENT_STA_BSS_RSSI_LOW event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_bss_rssi_low_t {
    #[doc = "< RSSI value of bss"]
    pub rssi: i32,
}
#[doc = "< FTM exchange is successful"]
pub const wifi_ftm_status_t_FTM_STATUS_SUCCESS: wifi_ftm_status_t = 0;
#[doc = "< Peer does not support FTM"]
pub const wifi_ftm_status_t_FTM_STATUS_UNSUPPORTED: wifi_ftm_status_t = 1;
#[doc = "< Peer rejected FTM configuration in FTM Request"]
pub const wifi_ftm_status_t_FTM_STATUS_CONF_REJECTED: wifi_ftm_status_t = 2;
#[doc = "< Peer did not respond to FTM Requests"]
pub const wifi_ftm_status_t_FTM_STATUS_NO_RESPONSE: wifi_ftm_status_t = 3;
#[doc = "< Unknown error during FTM exchange"]
pub const wifi_ftm_status_t_FTM_STATUS_FAIL: wifi_ftm_status_t = 4;
#[doc = " @brief FTM operation status types\n"]
pub type wifi_ftm_status_t = ::core::ffi::c_uint;
#[doc = " Argument structure for"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_ftm_report_entry_t {
    #[doc = "< Dialog Token of the FTM frame"]
    pub dlog_token: u8,
    #[doc = "< RSSI of the FTM frame received"]
    pub rssi: i8,
    #[doc = "< Round Trip Time in pSec with a peer"]
    pub rtt: u32,
    #[doc = "< Time of departure of FTM frame from FTM Responder in pSec"]
    pub t1: u64,
    #[doc = "< Time of arrival of FTM frame at FTM Initiator in pSec"]
    pub t2: u64,
    #[doc = "< Time of departure of ACK from FTM Initiator in pSec"]
    pub t3: u64,
    #[doc = "< Time of arrival of ACK at FTM Responder in pSec"]
    pub t4: u64,
}
#[doc = " Argument structure for WIFI_EVENT_FTM_REPORT event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_ftm_report_t {
    #[doc = "< MAC address of the FTM Peer"]
    pub peer_mac: [u8; 6usize],
    #[doc = "< Status of the FTM operation"]
    pub status: wifi_ftm_status_t,
    #[doc = "< Raw average Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_raw: u32,
    #[doc = "< Estimated Round-Trip-Time with peer in Nano-Seconds"]
    pub rtt_est: u32,
    #[doc = "< Estimated one-way distance in Centi-Meters"]
    pub dist_est: u32,
    #[doc = "< Pointer to FTM Report with multiple entries, should be freed after use"]
    pub ftm_report_data: *mut wifi_ftm_report_entry_t,
    #[doc = "< Number of entries in the FTM Report data"]
    pub ftm_report_num_entries: u8,
}
impl Default for wifi_event_ftm_report_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_ACTION_TX_STATUS event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_action_tx_status_t {
    #[doc = "< WiFi interface to send request to"]
    pub ifx: wifi_interface_t,
    #[doc = "< Context to identify the request"]
    pub context: u32,
    #[doc = "< Destination MAC address"]
    pub da: [u8; 6usize],
    #[doc = "< Status of the operation"]
    pub status: u8,
}
impl Default for wifi_event_action_tx_status_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_ROC_DONE event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_roc_done_t {
    #[doc = "< Context to identify the request"]
    pub context: u32,
}
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_PIN event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_ap_wps_rg_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< WPS normal fail reason"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_NORMAL: wps_fail_reason_t = 0;
#[doc = "< WPS failed due to incorrect config"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_CONFIG: wps_fail_reason_t = 1;
#[doc = "< WPS failed during auth"]
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_AUTH: wps_fail_reason_t = 2;
pub const wps_fail_reason_t_WPS_AP_FAIL_REASON_MAX: wps_fail_reason_t = 3;
pub type wps_fail_reason_t = ::core::ffi::c_uint;
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_FAILED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_ap_wps_rg_fail_reason_t {
    #[doc = "< WPS failure reason wps_fail_reason_t"]
    pub reason: wps_fail_reason_t,
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
impl Default for wifi_event_ap_wps_rg_fail_reason_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Argument structure for WIFI_EVENT_AP_WPS_RG_SUCCESS event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_event_ap_wps_rg_success_t {
    #[doc = "< Enrollee mac address"]
    pub peer_macaddr: [u8; 6usize],
}
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = ::core::ffi::c_uint;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The AES callback function when do WPS connect.\n\n @param key  Encryption key.\n @param iv  Encryption IV for CBC mode (16 bytes).\n @param data  Data to encrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        iv: *const ::core::ffi::c_uchar,
        data: *mut ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The AES callback function when do WPS connect.\n\n @param key  Decryption key.\n @param iv  Decryption IV for CBC mode (16 bytes).\n @param data  Data to decrypt in-place.\n @param data_len  Length of data in bytes (must be divisible by 16)\n"]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        iv: *const ::core::ffi::c_uchar,
        data: *mut ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect.\n\n @param kek  16-octet Key encryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param plain  Plaintext key to be wrapped, n * 64 bits\n @param cipher  Wrapped key, (n + 1) * 64 bits\n"]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const ::core::ffi::c_uchar,
        n: ::core::ffi::c_int,
        plain: *const ::core::ffi::c_uchar,
        cipher: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect.\n\n @param kek  16-octet Key decryption key (KEK).\n @param n  Length of the plaintext key in 64-bit units;\n @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits\n @param plain  Plaintext key, n * 64 bits\n"]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const ::core::ffi::c_uchar,
        n: ::core::ffi::c_int,
        cipher: *const ::core::ffi::c_uchar,
        plain: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The SHA256 callback function when do WPS connect.\n\n @param key  Key for HMAC operations.\n @param key_len  Length of the key in bytes.\n @param num_elem  Number of elements in the data vector.\n @param addr  Pointers to the data areas.\n @param len  Lengths of the data blocks.\n @param mac  Buffer for the hash (32 bytes).\n"]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_int,
        num_elem: ::core::ffi::c_int,
        addr: *mut *const ::core::ffi::c_uchar,
        len: *const ::core::ffi::c_int,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect.\n\n @param key  Key for PRF.\n @param key_len  Length of the key in bytes.\n @param label  A unique label for each purpose of the PRF.\n @param data  Extra data to bind into the key.\n @param data_len  Length of the data.\n @param buf  Buffer for the generated pseudo-random key.\n @param buf_len  Number of bytes of key to generate.\n"]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_int,
        label: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_uchar,
        buf_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief HMAC-MD5 over data buffer (RFC 2104)'\n\n @key: Key for HMAC operations\n @key_len: Length of the key in bytes\n @data: Pointers to the data area\n @data_len: Length of the data area\n @mac: Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_uint,
        data: *const ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief HMAC-MD5 over data vector (RFC 2104)\n\n @key: Key for HMAC operations\n @key_len: Length of the key in bytes\n @num_elem: Number of elements in the data vector\n @addr: Pointers to the data areas\n @len: Lengths of the data blocks\n @mac: Buffer for the hash (16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_uint,
        num_elem: ::core::ffi::c_uint,
        addr: *mut *const ::core::ffi::c_uchar,
        len: *const ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data buffer (RFC 2104)\n\n @key: Key for HMAC operations\n @key_len: Length of the key in bytes\n @data: Pointers to the data area\n @data_len: Length of the data area\n @mac: Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_uint,
        data: *const ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data vector (RFC 2104)\n\n @key: Key for HMAC operations\n @key_len: Length of the key in bytes\n @num_elem: Number of elements in the data vector\n @addr: Pointers to the data areas\n @len: Lengths of the data blocks\n @mac: Buffer for the hash (20 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_uint,
        num_elem: ::core::ffi::c_uint,
        addr: *mut *const ::core::ffi::c_uchar,
        len: *const ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1)\n\n @key: Key for PRF\n @key_len: Length of the key in bytes\n @label: A unique label for each purpose of the PRF\n @data: Extra data to bind into the key\n @data_len: Length of the data\n @buf: Buffer for the generated pseudo-random key\n @buf_len: Number of bytes of key to generate\n Returns: 0 on success, -1 of failure\n\n This function is used to derive new, cryptographically separate keys from a\n given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        key_len: ::core::ffi::c_uint,
        label: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_uint,
        buf: *mut ::core::ffi::c_uchar,
        buf_len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief SHA-1 hash for data vector\n\n @num_elem: Number of elements in the data vector\n @addr: Pointers to the data areas\n @len: Lengths of the data blocks\n @mac: Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: ::core::ffi::c_uint,
        addr: *mut *const ::core::ffi::c_uchar,
        len: *const ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) for IEEE 802.11i\n\n @passphrase: ASCII passphrase\n @ssid: SSID\n @ssid_len: SSID length in bytes\n @iterations: Number of iterations to run\n @buf: Buffer for the generated key\n @buflen: Length of the buffer in bytes\n Returns: 0 on success, -1 of failure\n\n This function is used to derive PSK for WPA-PSK. For this protocol,\n iterations is set to 4096 and buflen to 32. This function is described in\n IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const ::core::ffi::c_char,
        ssid: *const ::core::ffi::c_char,
        ssid_len: ::core::ffi::c_uint,
        iterations: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_uchar,
        buflen: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief XOR RC4 stream to given data with skip-stream-start\n\n @key: RC4 key\n @keylen: RC4 key length\n @skip: number of bytes to skip from the beginning of the RC4 stream\n @data: data to be XOR'ed with RC4 stream\n @data_len: buf length\n Returns: 0 on success, -1 on failure\n\n Generate RC4 pseudo random stream for the given key, skip beginning of the\n stream, and XOR the end result with the data buffer to perform RC4\n encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        keylen: ::core::ffi::c_uint,
        skip: ::core::ffi::c_uint,
        data: *mut ::core::ffi::c_uchar,
        data_len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief MD5 hash for data vector\n\n @num_elem: Number of elements in the data vector\n @addr: Pointers to the data areas\n @len: Lengths of the data blocks\n @mac: Buffer for the hash\n Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: ::core::ffi::c_uint,
        addr: *mut *const ::core::ffi::c_uchar,
        len: *const ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief Encrypt one AES block\n\n @ctx: Context pointer from aes_encrypt_init()\n @plain: Plaintext data to be encrypted (16 bytes)\n @crypt: Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        plain: *const ::core::ffi::c_uchar,
        crypt: *mut ::core::ffi::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for encryption\n\n @key: Encryption key\n @len: Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void,
>;
#[doc = " @brief Deinitialize AES encryption\n\n @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " @brief Decrypt one AES block\n\n @ctx: Context pointer from aes_encrypt_init()\n @crypt: Encrypted data (16 bytes)\n @plain: Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        crypt: *const ::core::ffi::c_uchar,
        plain: *mut ::core::ffi::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for decryption\n\n @key: Decryption key\n @len: Key length in bytes (usually 16, i.e., 128 bits)\n Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void,
>;
#[doc = " @brief Deinitialize AES decryption\n\n @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " @brief One-Key CBC MAC (OMAC1) hash with AES-128 for MIC computation\n\n @key: 128-bit key for the hash operation\n @data: Data buffer for which a MIC is computed\n @data_len: Length of data buffer in bytes\n @mic: Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_omac1_aes_128_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        data: *const u8,
        data_len: usize,
        mic: *mut u8,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief Decrypt data using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @tk: 128-bit Temporal Key for obtained during 4-way handshake\n @hdr: Pointer to IEEE802.11 frame headeri needed for AAD\n @data: Pointer to encrypted data buffer\n @data_len: Encrypted data length in bytes\n @decrypted_len: Length of decrypted data\n @espnow_pkt: Indicates if it's an ESPNOW packet\n Returns: Pointer to decrypted data on success, NULL on failure"]
pub type esp_ccmp_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        ieee80211_hdr: *const u8,
        data: *const u8,
        data_len: usize,
        decrypted_len: *mut usize,
        espnow_pkt: bool,
    ) -> *mut u8,
>;
#[doc = " @brief Encrypt data using CCMP (Counter Mode CBC-MAC Protocol OR\n        Counter Mode Cipher Block Chaining Message Authentication\n        Code Protocol) which is used in IEEE 802.11i RSN standard.\n @tk: 128-bit Temporal Key for obtained during 4-way handshake\n @frame: Pointer to IEEE802.11 frame including header\n @len: Length of the frame including header\n @hdrlen: Length of the header\n @pn: Packet Number counter\n @keyid: Key ID to be mentioned in CCMP Vector\n @encrypted_len: Length of the encrypted frame including header"]
pub type esp_ccmp_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        frame: *mut u8,
        len: usize,
        hdrlen: usize,
        pn: *mut u8,
        keyid: ::core::ffi::c_int,
        encrypted_len: *mut usize,
    ) -> *mut u8,
>;
#[doc = " @brief One-Key GMAC hash with AES for MIC computation\n\n @key: key for the hash operation\n @keylen: key length\n @iv: initialization vector\n @iv_len: initialization vector length\n @aad: aad\n @aad_len: aad length\n @mic: Buffer for MIC (128 bits, i.e., 16 bytes)\n Returns: 0 on success, -1 on failure"]
pub type esp_aes_gmac_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        keylen: usize,
        iv: *const u8,
        iv_len: usize,
        aad: *const u8,
        aad_len: usize,
        mic: *mut u8,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief The crypto callback function structure used when do station security connect.\n        The structure can be set as software crypto or the crypto optimized by ESP32\n        hardware."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< station connect function used when send EAPOL frame"]
    pub aes_wrap: esp_aes_wrap_t,
    #[doc = "< station connect function used when decrypt key data"]
    pub aes_unwrap: esp_aes_unwrap_t,
    #[doc = "< station connect function used when check MIC"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< station connect function used when check MIC"]
    pub sha256_prf: esp_sha256_prf_t,
    pub hmac_md5: esp_hmac_md5_t,
    pub hamc_md5_vector: esp_hmac_md5_vector_t,
    pub hmac_sha1: esp_hmac_sha1_t,
    pub hmac_sha1_vector: esp_hmac_sha1_vector_t,
    pub sha1_prf: esp_sha1_prf_t,
    pub sha1_vector: esp_sha1_vector_t,
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    pub rc4_skip: esp_rc4_skip_t,
    pub md5_vector: esp_md5_vector_t,
    pub aes_encrypt: esp_aes_encrypt_t,
    pub aes_encrypt_init: esp_aes_encrypt_init_t,
    pub aes_encrypt_deinit: esp_aes_encrypt_deinit_t,
    pub aes_decrypt: esp_aes_decrypt_t,
    pub aes_decrypt_init: esp_aes_decrypt_init_t,
    pub aes_decrypt_deinit: esp_aes_decrypt_deinit_t,
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
    pub omac1_aes_128: esp_omac1_aes_128_t,
    pub ccmp_decrypt: esp_ccmp_decrypt_t,
    pub ccmp_encrypt: esp_ccmp_encrypt_t,
    pub aes_gmac: esp_aes_gmac_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The\n        structure can be set as software crypto or the crypto optimized by ESP32\n        hardware."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _set_intr: ::core::option::Option<
        unsafe extern "C" fn(cpu_no: i32, intr_source: u32, intr_num: u32, intr_prio: i32),
    >,
    pub _clear_intr: ::core::option::Option<unsafe extern "C" fn(intr_source: u32, intr_num: u32)>,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(n: i32, f: *mut ::core::ffi::c_void, arg: *mut ::core::ffi::c_void),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _is_from_isr: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _spin_lock_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _spin_lock_delete:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    pub _wifi_int_disable:
        ::core::option::Option<unsafe extern "C" fn(wifi_int_mux: *mut ::core::ffi::c_void) -> u32>,
    pub _wifi_int_restore: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut ::core::ffi::c_void, tmp: u32),
    >,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut ::core::ffi::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut ::core::ffi::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut ::core::ffi::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut ::core::ffi::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _mutex_create: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut ::core::ffi::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut ::core::ffi::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut ::core::ffi::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut ::core::ffi::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut ::core::ffi::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut ::core::ffi::c_void,
            item: *mut ::core::ffi::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut ::core::ffi::c_void,
            item: *mut ::core::ffi::c_void,
            hptw: *mut ::core::ffi::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut ::core::ffi::c_void,
            item: *mut ::core::ffi::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut ::core::ffi::c_void,
            item: *mut ::core::ffi::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut ::core::ffi::c_void,
            item: *mut ::core::ffi::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut ::core::ffi::c_void) -> u32>,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut ::core::ffi::c_void)>,
    pub _event_group_set_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut ::core::ffi::c_void, bits: u32) -> u32,
    >,
    pub _event_group_clear_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut ::core::ffi::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut ::core::ffi::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: ::core::ffi::c_int,
            wait_for_all_bits: ::core::ffi::c_int,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut ::core::ffi::c_void,
            name: *const ::core::ffi::c_char,
            stack_depth: u32,
            param: *mut ::core::ffi::c_void,
            prio: u32,
            task_handle: *mut ::core::ffi::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut ::core::ffi::c_void,
            name: *const ::core::ffi::c_char,
            stack_depth: u32,
            param: *mut ::core::ffi::c_void,
            prio: u32,
            task_handle: *mut ::core::ffi::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut ::core::ffi::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut ::core::ffi::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const ::core::ffi::c_char,
            event_id: i32,
            event_data: *mut ::core::ffi::c_void,
            event_data_size: usize,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_request: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_apb80m_release: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_update_country_info: ::core::option::Option<
        unsafe extern "C" fn(country: *const ::core::ffi::c_char) -> ::core::ffi::c_int,
    >,
    pub _read_mac: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut u8, type_: ::core::ffi::c_uint) -> ::core::ffi::c_int,
    >,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut ::core::ffi::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut ::core::ffi::c_void)>,
    pub _timer_done: ::core::option::Option<unsafe extern "C" fn(ptimer: *mut ::core::ffi::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut ::core::ffi::c_void,
            pfunction: *mut ::core::ffi::c_void,
            parg: *mut ::core::ffi::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut ::core::ffi::c_void, us: u32, repeat: bool),
    >,
    pub _wifi_reset_mac: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_enable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _wifi_rtc_disable_iso: ::core::option::Option<unsafe extern "C" fn()>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            value: i8,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            out_value: *mut i8,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            value: u8,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            out_value: *mut u8,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            value: u16,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            out_value: *mut u16,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const ::core::ffi::c_char,
            open_mode: ::core::ffi::c_uint,
            out_handle: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit:
        ::core::option::Option<unsafe extern "C" fn(handle: u32) -> ::core::ffi::c_int>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            value: *const ::core::ffi::c_void,
            length: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const ::core::ffi::c_char,
            out_value: *mut ::core::ffi::c_void,
            length: *mut usize,
        ) -> ::core::ffi::c_int,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const ::core::ffi::c_char) -> ::core::ffi::c_int,
    >,
    pub _get_random: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut u8, len: usize) -> ::core::ffi::c_int,
    >,
    pub _get_time: ::core::option::Option<
        unsafe extern "C" fn(t: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
    >,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_ulong>,
    pub _slowclk_cal_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: ::core::ffi::c_uint,
            tag: *const ::core::ffi::c_char,
            format: *const ::core::ffi::c_char,
            ...
        ),
    >,
    pub _log_writev: ::core::option::Option<
        unsafe extern "C" fn(
            level: ::core::ffi::c_uint,
            tag: *const ::core::ffi::c_char,
            format: *const ::core::ffi::c_char,
            args: va_list,
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut ::core::ffi::c_void,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut ::core::ffi::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut ::core::ffi::c_void,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut ::core::ffi::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(
            queue_len: ::core::ffi::c_int,
            item_size: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut ::core::ffi::c_void)>,
    pub _coex_init: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>,
    pub _coex_deinit: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_enable: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>,
    pub _coex_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> ::core::ffi::c_int,
    >,
    pub _coex_wifi_release:
        ::core::option::Option<unsafe extern "C" fn(event: u32) -> ::core::ffi::c_int>,
    pub _coex_wifi_channel_set: ::core::option::Option<
        unsafe extern "C" fn(primary: u8, secondary: u8) -> ::core::ffi::c_int,
    >,
    pub _coex_event_duration_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, duration: *mut u32) -> ::core::ffi::c_int,
    >,
    pub _coex_pti_get: ::core::option::Option<
        unsafe extern "C" fn(event: u32, pti: *mut u8) -> ::core::ffi::c_int,
    >,
    pub _coex_schm_status_bit_clear:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_status_bit_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, status: u32)>,
    pub _coex_schm_interval_set:
        ::core::option::Option<unsafe extern "C" fn(interval: u32) -> ::core::ffi::c_int>,
    pub _coex_schm_interval_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_schm_curr_period_get: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub _coex_schm_curr_phase_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub _coex_schm_curr_phase_idx_set:
        ::core::option::Option<unsafe extern "C" fn(idx: ::core::ffi::c_int) -> ::core::ffi::c_int>,
    pub _coex_schm_curr_phase_idx_get:
        ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>,
    pub _coex_register_start_cb: ::core::option::Option<
        unsafe extern "C" fn(
            cb: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>,
        ) -> ::core::ffi::c_int,
    >,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi station interface to supplied netif\n\n @param esp_netif instance to attach the wifi station to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_station(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi soft AP interface to supplied netif\n\n @param esp_netif instance to attach the wifi AP to\n\n @return\n  - ESP_OK on success\n  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_ap(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_sta_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for AP interface\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_ap_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clears default wifi event handlers for supplied network interface\n\n @param esp_netif instance of corresponding if object\n\n @return\n  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_clear_default_wifi_driver_and_handlers(
        esp_netif: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI AP. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi access point config,\n attaches the netif to wifi and registers default wifi handlers.\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_ap() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI STA. In case of any init error this API aborts.\n\n @note The API creates esp_netif object with default WiFi station config,\n attaches the netif to wifi and registers default wifi handlers.\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_sta() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Destroys default WIFI netif created with esp_netif_create_default_wifi_...() API.\n\n @param[in] esp_netif object to detach from WiFi and destroy\n\n @note This API unregisters wifi handlers and detaches the created object from the wifi.\n (this function is a no-operation if esp_netif is NULL)"]
    pub fn esp_netif_destroy_default_wifi(esp_netif: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Creates esp_netif WiFi object based on the custom configuration.\n\n @attention This API DOES NOT register default handlers!\n\n @param[in] wifi_if type of wifi interface\n @param[in] esp_netif_config inherent esp-netif configuration pointer\n\n @return pointer to esp-netif instance"]
    pub fn esp_netif_create_wifi(
        wifi_if: wifi_interface_t,
        esp_netif_config: *mut esp_netif_inherent_config_t,
    ) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default STA and AP network interfaces for esp-mesh.\n\n Both netifs are almost identical to the default station and softAP, but with\n DHCP client and server disabled. Please note that the DHCP client is typically\n enabled only if the device is promoted to a root node.\n\n Returns created interfaces which could be ignored setting parameters to NULL\n if an application code does not need to save the interface instances\n for further processing.\n\n @param[out] p_netif_sta pointer where the resultant STA interface is saved (if non NULL)\n @param[out] p_netif_ap pointer where the resultant AP interface is saved (if non NULL)\n\n @return ESP_OK on success"]
    pub fn esp_netif_create_default_wifi_mesh_netifs(
        p_netif_sta: *mut *mut esp_netif_t,
        p_netif_ap: *mut *mut esp_netif_t,
    ) -> esp_err_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: ::core::ffi::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: ::core::ffi::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: ::core::ffi::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: ::core::ffi::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: ::core::ffi::c_int,
    #[doc = "< WiFi TX cache buffer number"]
    pub cache_tx_buf_num: ::core::ffi::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: ::core::ffi::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: ::core::ffi::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: ::core::ffi::c_int,
    #[doc = "< WiFi AMSDU TX feature enable flag"]
    pub amsdu_tx_enable: ::core::ffi::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: ::core::ffi::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: ::core::ffi::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: ::core::ffi::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: ::core::ffi::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: ::core::ffi::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: ::core::ffi::c_int,
    #[doc = "< Enables additional WiFi features and capabilities"]
    pub feature_caps: u64,
    #[doc = "< WiFi Power Management for station at disconnected status"]
    pub sta_disconnected_pm: bool,
    #[doc = "< Maximum encrypt number of peers supported by espnow"]
    pub espnow_max_encrypt_num: ::core::ffi::c_int,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: ::core::ffi::c_int,
}
impl Default for wifi_init_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @addtogroup WPA_APIs\n @{"]
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub static mut g_wifi_feature_caps: u64;
}
extern "C" {
    #[doc = " @brief  Initialize WiFi\n         Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n         WiFi NVS structure etc. This WiFi also starts WiFi task\n\n @attention 1. This API must be called before all other WiFi API can be called\n @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can\n               guarantee all the fields get correct value when more fields are added into wifi_init_config_t\n               in future release. If you want to set your own initial values, overwrite the default values\n               which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of\n               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!\n\n @param  config pointer to WiFi initialized configuration structure; can point to a temporary variable.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi\n         Free all resource allocated in esp_wifi_init and stop WiFi task\n\n @attention 1. This API should be called if you want to remove WiFi driver from the system\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode\n\n            Set the WiFi operating mode as station, soft-AP or station+soft-AP,\n            The default mode is station mode.\n\n @param     mode  WiFi operating mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi\n\n @param[out]  mode  store current WiFi mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration\n         If mode is WIFI_MODE_STA, it create station control block and start station\n         If mode is WIFI_MODE_AP, it create soft-AP control block and start soft-AP\n         If mode is WIFI_MODE_APSTA, it create soft-AP and station control block and start soft-AP and station\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi\n         If mode is WIFI_MODE_STA, it stop station and free station control block\n         If mode is WIFI_MODE_AP, it stop soft-AP and free soft-AP control block\n         If mode is WIFI_MODE_APSTA, it stop station/soft-AP and free station/soft-AP control block\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values\n\n This function will reset settings made using the following APIs:\n - esp_wifi_set_bandwidth,\n - esp_wifi_set_protocol,\n - esp_wifi_set_config related\n - esp_wifi_set_mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect the ESP32 WiFi station to the AP.\n\n @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode\n @attention 2. If the ESP32 is connected to an AP, call esp_wifi_disconnect to disconnect.\n @attention 3. The scanning triggered by esp_wifi_scan_start() will not be effective until connection between ESP32 and the AP is established.\n               If ESP32 is scanning and connecting at the same time, ESP32 will abort scanning and return a warning message and error\n               number ESP_ERR_WIFI_STATE.\n               If you want to do reconnection after ESP32 received disconnect event, remember to add the maximum retry time, otherwise the called\n               scan will not work. This is especially true when the AP doesn't exist, and you still try reconnection after ESP32 received disconnect\n               event with the reason code WIFI_REASON_NO_AP_FOUND.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong\n    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect the ESP32 WiFi station from the AP.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API\n\n\n @return\n    - ESP_OK: succeed\n    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid\n\n @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs.\n\n @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory and the\n            will be freed in esp_wifi_scan_get_ap_records, so generally, call esp_wifi_scan_get_ap_records to cause\n            the memory to be freed once the scan is done\n @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds.\n            Values above 1500ms may cause station to disconnect from AP and are not recommended.\n\n @param     config  configuration of scanning\n @param     block if block is true, this API will block the caller until the scan is done, otherwise\n                         it will return immediately\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout\n    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start\n    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan\n\n @param[out] number  store number of APIs found in last scan\n\n @attention This API can only be called when the scan is completed, otherwise it may get wrong value.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan\n\n @param[inout]  number As input param, it stores max AP number ap_records can hold.\n                As output param, it receives the actual AP number this API returns.\n @param         ap_records  wifi_ap_record_t array to hold the found APs\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Clear AP list found in last scan\n\n @attention When the obtained ap list fails,bss info must be cleared,otherwise it may cause memory leakage.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_clear_ap_list() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP which the ESP32 station is associated with\n\n @attention When the obtained country information is empty, it means that the AP does not carry country information\n\n @param     ap_info  the wifi_ap_record_t to hold AP information\n            sta can get the connected ap's phy mode info through the struct member\n            phy_11b，phy_11g，phy_11n，phy_lr in the wifi_ap_record_t struct.\n            For example, phy_11b = 1 imply that ap support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_CONN: The station interface don't initialized\n    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param     type  power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type\n\n @attention Default power save type is WIFI_PS_MIN_MODEM.\n\n @param[out]  type: store current power save type\n\n @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface\n            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)\n\n @attention Support 802.11b or 802.11bg or 802.11bgn or LR mode\n\n @param     ifx  interfaces\n @param     protocol_bitmap  WiFi protocol bitmap\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface\n\n @param     ifx  interface\n @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of ESP32 specified interface\n\n @attention 1. API return false if try to configure an interface that is not enabled\n @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N\n\n @param     ifx  interface to be configured\n @param     bw  bandwidth\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of ESP32 specified interface\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     ifx interface to be configured\n @param[out] bw  store bandwidth of interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of ESP32\n\n @attention 1. This API should be called after esp_wifi_start()\n @attention 2. When ESP32 is in STA mode, this API should not be called when STA is scanning or connecting to an external AP\n @attention 3. When ESP32 is in softAP mode, this API should not be called when softAP has connected to external STAs\n @attention 4. When ESP32 is in STA+softAP mode, this API should not be called when in the scenarios described above\n @attention 5. The channel info set by this API will not be stored in NVS. So If you want to remeber the channel used before wifi stop,\n               you need to call this API again after wifi start, or you can call `esp_wifi_set_config()` to store the channel info in NVS.\n\n @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel\n @param     second   for HT20, second is ignored, for HT40, second is the second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of ESP32\n\n @attention 1. API return false if try to get a interface that is not enable\n\n @param     primary   store current primary channel\n @param[out]  second  store current second channel\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info\n\n @attention 1. It is discouraged to call this API since this doesn't validate the per-country rules,\n               it's up to the user to fill in all fields according to local regulations.\n               Please use esp_wifi_set_country_code instead.\n @attention 2. The default country is \"01\" (world safe mode) {.cc=\"01\", .schan=1, .nchan=11, .policy=WIFI_COUNTRY_POLICY_AUTO}.\n @attention 3. The third octect of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n @attention 4. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country info is {.cc=\"US\", .schan=1, .nchan=11}\n               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}\n               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               {.cc=\"US\", .schan=1, .nchan=11} in the example.\n @attention 5. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, then the configured country info is used always.\n @attention 6. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 7. The country configuration is stored into flash.\n @attention 8. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n\n @param     country   the configured country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info\n\n @param     country  country info\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of the ESP32 WiFi station or the soft-AP interface.\n\n @attention 1. This API can only be called when the interface is disabled\n @attention 2. ESP32 soft-AP and station have different MAC addresses, do not set them to be the same.\n @attention 3. The bit 0 of the first byte of ESP32 MAC address can not be 1. For example, the MAC address\n      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\".\n\n @param     ifx  interface\n @param     mac  the MAC address\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MAC: invalid mac address\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface\n\n @param      ifx  interface\n @param[out] mac  store mac of the interface ifx\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode.\n        Each time a packet is received, the callback function will be called.\n\n @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter.\n @param type  promiscuous packet type.\n"]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut ::core::ffi::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode.\n\n Each time a packet is received, the registered callback function will be called.\n\n @param cb  callback\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode.\n\n @param     en  false - disable, true - enable\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode.\n\n @param[out] en  store the current status of promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter.\n\n @note The default filter is to filter all packets except WIFI_PKT_MISC\n\n @param filter the packet type filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter.\n\n @param[out] filter  store the current status of promiscuous filter\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode.\n\n @note The default filter is to filter none control packet.\n\n @param filter the subtype of the control packet filtered in promiscuous mode.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode.\n\n @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the ESP32 STA or AP\n\n @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail\n @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP.\n @attention 3. ESP32 is limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as\n               the channel of the ESP32 station.\n @attention 4. The configuration will be stored in NVS\n\n @param     interface  interface\n @param     conf  station or soft-AP configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface\n    - ESP_ERR_WIFI_MODE: invalid mode\n    - ESP_ERR_WIFI_PASSWORD: invalid password\n    - ESP_ERR_WIFI_NVS: WiFi internal NVS error\n    - others: refer to the erro code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface\n\n @param     interface  interface\n @param[out]  conf  station or soft-AP configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP\n\n @attention SSC only API\n\n @param[out] sta  station list\n             ap can get the connected sta's phy mode info through the struct member\n             phy_11b，phy_11g，phy_11n，phy_lr in the wifi_sta_info_t struct.\n             For example, phy_11b = 1 imply that sta support 802.11b mode\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AID of STA connected with soft-AP\n\n @param     mac  STA's mac address\n @param[out]  aid  Store the AID corresponding to STA mac\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument\n    - ESP_ERR_NOT_FOUND: Requested resource not found\n    - ESP_ERR_WIFI_MODE: WiFi mode is wrong\n    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_aid(mac: *const u8, aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type\n\n @attention 1. The default value is WIFI_STORAGE_FLASH\n\n @param     storage : storage type\n\n @return\n   - ESP_OK: succeed\n   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback.\n @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback.\n @param     type Information element type, based on frame type received.\n @param     sa Source 802.11 address.\n @param     vnd_ie Pointer to the vendor specific element data received.\n @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: ::core::ffi::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element\n\n @param     enable If true, specified IE is enabled. If false, specified IE is removed.\n @param     type Information Element type. Determines the frame type to associate with the IE.\n @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1).\n @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t.\n            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()\n    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)\n      or second byte is an invalid length.\n    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback.\n\n @param     cb   Callback function\n @param     ctx  Context argument, passed to callback function.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum transmitting power after WiFi start.\n\n @attention 1. Maximum power before wifi startup is limited by PHY init data bin.\n @attention 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable.\n @attention 3. Mapping Table {Power, max_tx_power} = {{8,   2}, {20,  5}, {28,  7}, {34,  8}, {44, 11},\n                                                      {52, 13}, {56, 14}, {60, 15}, {66, 16}, {72, 18}, {80, 20}}.\n @attention 4. Param power unit is 0.25dBm, range is [8, 84] corresponding to 2dBm - 20dBm.\n @attention 5. Relationship between set value and actual value. As follows: {set value range, actual value} = {{[8,  19],8}, {[20, 27],20}, {[28, 33],28}, {[34, 43],34}, {[44, 51],44}, {[52, 55],52}, {[56, 59],56}, {[60, 65],60}, {[66, 71],66}, {[72, 79],72}, {[80, 84],80}}.\n\n @param     power  Maximum WiFi transmitting power.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is out of range"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum transmiting power after WiFi start\n\n @param     power Maximum WiFi transmitting power, unit is 0.25dBm.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events\n\n @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants.\n               Events which have corresponding bit set in the mask will not be delivered to the system event handler.\n @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED.\n @attention 3. There may be lots of stations sending probe request data around.\n               Don't unmask this event unless you need to receive probe request data.\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events\n\n @param     mask  WiFi event mask.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data\n\n @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS\n            data frame\n\n @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi\n            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the\n            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF.\n @param     buffer raw ieee80211 buffer\n @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes\n @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the\n            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with\n            the system sequence number.\n            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both\n            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi\n            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_WIFI_ARG is returned.\n\n @return\n    - ESP_OK: success\n    - ESP_ERR_WIFI_IF: Invalid interface\n    - ESP_ERR_INVALID_ARG: Invalid parameter\n    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const ::core::ffi::c_void,
        len: ::core::ffi::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function.\n @param data CSI data received. The memory that it points to will be deallocated after callback function returns.\n"]
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data.\n\n        Each time a CSI data is received, the callback function will be called.\n\n @param cb  callback\n @param ctx context argument, passed to callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut ::core::ffi::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration\n\n @param config configuration\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI\n\n @param en true - enable, false - disable\n\n return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration\n\n @param     config  Antenna GPIO configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration\n\n @param     config  Antenna configuration.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the TSF time\n             In Station mode or SoftAP+Station mode if station is not connected or station doesn't receive at least\n             one beacon after connected, will return 0\n\n @attention  Enabling power save may cause the return value inaccurate, except WiFi modem sleep\n\n @param      interface The interface whose tsf_time is to be retrieved.\n\n @return     0 or the TSF time"]
    pub fn esp_wifi_get_tsf_time(interface: wifi_interface_t) -> i64;
}
extern "C" {
    #[doc = " @brief     Set the inactive time of the ESP32 STA or AP\n\n @attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,\n               disconnect from SoftAP. Default 6s.\n @attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,\n               the softAP will force deauth the STA. Default is 300s.\n @attention 3. The inactive time configuration is not stored into flash\n\n @param     ifx  interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n    - ESP_ERR_WIFI_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."]
    pub fn esp_wifi_set_inactive_time(ifx: wifi_interface_t, sec: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get inactive time of specified interface\n\n @param     ifx  Interface to be configured.\n @param     sec  Inactive time. Unit seconds.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_inactive_time(ifx: wifi_interface_t, sec: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Dump WiFi statistics\n\n @param     modules statistic modules to be dumped\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_statis_dump(modules: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set RSSI threshold below which APP will get an event\n\n @attention  This API needs to be called every time after WIFI_EVENT_STA_BSS_RSSI_LOW event is received.\n\n @param      rssi threshold value in dbm between -100 to 0\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_set_rssi_threshold(rssi: i32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Start an FTM Initiator session by sending FTM request\n             If successful, event WIFI_EVENT_FTM_REPORT is generated with the result of the FTM procedure\n\n @attention  1. Use this API only in Station mode.\n @attention  2. If FTM is initiated on a different channel than Station is connected in or internal SoftAP is started in,\n                FTM defaults to a single burst in ASAP mode.\n\n @param      cfg  FTM Initiator session configuration\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_initiate_session(cfg: *mut wifi_ftm_initiator_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      End the ongoing FTM Initiator session\n\n @attention  This API works only on FTM Initiator\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_end_session() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set offset in cm for FTM Responder. An equivalent offset is calculated in picoseconds\n             and added in TOD of FTM Measurement frame (T1).\n\n @attention  Use this API only in AP mode before performing FTM as responder\n\n @param      offset_cm  T1 Offset to be added in centimeters\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_ftm_resp_set_offset(offset_cm: i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable or disable 11b rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n @attention  2. Only when really need to disable 11b rate call this API otherwise don't call this.\n\n @param      ifx  Interface to be configured.\n @param      disable true means disable 11b rate while false means enable 11b rate.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_11b_rate(ifx: wifi_interface_t, disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set wake interval for connectionless modules to wake up periodically.\n\n @attention 1. Only one wake interval for all connectionless modules.\n @attention 2. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 3. Event WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START would be posted each time wake interval starts.\n @attention 4. Recommend to configure interval in multiples of hundred. (e.g. 100ms)\n @attention 5. Recommend to configure interval to ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE to get stable performance at coexistence mode.\n\n @param      wake_interval  Milliseconds after would the chip wake up, from 1 to 65535."]
    pub fn esp_wifi_connectionless_module_set_wake_interval(wake_interval: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country\n\n @attention 1. When ieee80211d_enabled, the country info of the AP to which\n               the station is connected is used. E.g. if the configured country is US\n               and the country info of the AP to which the station is connected is JP\n               then the country info that will be used is JP. If the station disconnected\n               from the AP the country info is set back to the country info of the station automatically,\n               US in the example.\n @attention 2. When ieee80211d_enabled is disabled, then the configured country info is used always.\n @attention 3. When the country info is changed because of configuration or because the station connects to a different\n               external AP, the country IE in probe response/beacon of the soft-AP is also changed.\n @attention 4. The country configuration is stored into flash.\n @attention 5. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the\n               country info.\n @attention 6. Supported country codes are \"01\"(world safe mode) \"AT\",\"AU\",\"BE\",\"BG\",\"BR\",\n               \"CA\",\"CH\",\"CN\",\"CY\",\"CZ\",\"DE\",\"DK\",\"EE\",\"ES\",\"FI\",\"FR\",\"GB\",\"GR\",\"HK\",\"HR\",\"HU\",\n               \"IE\",\"IN\",\"IS\",\"IT\",\"JP\",\"KR\",\"LI\",\"LT\",\"LU\",\"LV\",\"MT\",\"MX\",\"NL\",\"NO\",\"NZ\",\"PL\",\"PT\",\n               \"RO\",\"SE\",\"SI\",\"SK\",\"TW\",\"US\"\n\n @attention 7. When country code \"01\" (world safe mode) is set, SoftAP mode won't contain country IE.\n @attention 8. The default country is \"01\" (world safe mode) and ieee80211d_enabled is TRUE.\n @attention 9. The third octect of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n\n @param     country   the configured country ISO code\n @param     ieee80211d_enabled   802.11d is enabled or not\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country_code(
        country: *const ::core::ffi::c_char,
        ieee80211d_enabled: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country code\n\n @param     country  country code\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country_code(country: *mut ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config 80211 tx rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_init() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_80211_tx_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable PMF configuration for specified interface\n\n @attention  This API should be called after esp_wifi_set_config() and before esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_disable_pmf_config(ifx: wifi_interface_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_netif_driver {
    _unused: [u8; 0],
}
#[doc = " @brief Forward declaration of WiFi interface handle"]
pub type wifi_netif_driver_t = *mut wifi_netif_driver;
extern "C" {
    #[doc = " @brief Creates wifi driver instance to be used with esp-netif\n\n @param wifi_if wifi interface type (station, softAP)\n\n @return\n  - pointer to wifi interface handle on success\n  - NULL otherwise"]
    pub fn esp_wifi_create_if_driver(wifi_if: wifi_interface_t) -> wifi_netif_driver_t;
}
extern "C" {
    #[doc = " @brief Destroys wifi driver instance\n\n @param h pointer to wifi interface handle\n"]
    pub fn esp_wifi_destroy_if_driver(h: wifi_netif_driver_t);
}
extern "C" {
    #[doc = " @brief Return mac of specified wifi driver instance\n\n @param[in] ifx pointer to wifi interface handle\n @param[out] mac output mac address\n\n @return ESP_OK on success\n"]
    pub fn esp_wifi_get_if_mac(ifx: wifi_netif_driver_t, mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Return true if the supplied interface instance is ready after start.\n Typically used when registering on receive callback, which ought to be\n installed as soon as AP started, but once STA gets connected.\n\n @param[in] ifx pointer to wifi interface handle\n\n @return\n      - true if ready after interface started (typically Access Point type)\n      - false if ready once interface connected (typically for Station type)"]
    pub fn esp_wifi_is_if_ready_when_started(ifx: wifi_netif_driver_t) -> bool;
}
extern "C" {
    #[doc = " @brief Register interface receive callback function with argument\n\n @param[in] ifx pointer to wifi interface handle\n @param[in] fn  function to be registered (typically esp_netif_receive)\n @param[in] arg argument to be supplied to registered function (typically esp_netif ptr)\n\n @return ESP_OK on success\n"]
    pub fn esp_wifi_register_if_rxcb(
        ifx: wifi_netif_driver_t,
        fn_: esp_netif_receive_t,
        arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = "< Send ESPNOW data successfully"]
pub const esp_now_send_status_t_ESP_NOW_SEND_SUCCESS: esp_now_send_status_t = 0;
#[doc = "< Send ESPNOW data fail"]
pub const esp_now_send_status_t_ESP_NOW_SEND_FAIL: esp_now_send_status_t = 1;
#[doc = " @brief Status of sending ESPNOW data ."]
pub type esp_now_send_status_t = ::core::ffi::c_uint;
#[doc = " @brief ESPNOW peer information parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_now_peer_info {
    #[doc = "< ESPNOW peer MAC address that is also the MAC address of station or softap"]
    pub peer_addr: [u8; 6usize],
    #[doc = "< ESPNOW peer local master key that is used to encrypt data"]
    pub lmk: [u8; 16usize],
    #[doc = "< Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0,\nuse the current channel which station or softap is on. Otherwise, it must be\nset as the channel that station or softap is on."]
    pub channel: u8,
    #[doc = "< Wi-Fi interface that peer uses to send/receive ESPNOW data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< ESPNOW data that this peer sends/receives is encrypted or not"]
    pub encrypt: bool,
    #[doc = "< ESPNOW peer private data"]
    pub priv_: *mut ::core::ffi::c_void,
}
impl Default for esp_now_peer_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief ESPNOW peer information parameters."]
pub type esp_now_peer_info_t = esp_now_peer_info;
#[doc = " @brief Number of ESPNOW peers which exist currently."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_now_peer_num {
    #[doc = "< Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM"]
    pub total_num: ::core::ffi::c_int,
    #[doc = "< Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM"]
    pub encrypt_num: ::core::ffi::c_int,
}
#[doc = " @brief Number of ESPNOW peers which exist currently."]
pub type esp_now_peer_num_t = esp_now_peer_num;
#[doc = " @brief ESPNOW packet information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_now_recv_info {
    #[doc = "< Source address of ESPNOW packet"]
    pub src_addr: *mut u8,
    #[doc = "< Destination address of ESPNOW packet"]
    pub des_addr: *mut u8,
    #[doc = "< Rx control info of ESPNOW packet"]
    pub rx_ctrl: *mut wifi_pkt_rx_ctrl_t,
}
impl Default for esp_now_recv_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief ESPNOW packet information"]
pub type esp_now_recv_info_t = esp_now_recv_info;
#[doc = " @brief     Callback function of receiving ESPNOW data\n @param     esp_now_info received ESPNOW packet information\n @param     data received data\n @param     data_len length of received data\n @attention esp_now_info is a local variable，it can only be used in the callback."]
pub type esp_now_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_now_info: *const esp_now_recv_info_t,
        data: *const u8,
        data_len: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief     Callback function of sending ESPNOW data\n @param     mac_addr peer MAC address\n @param     status status of sending ESPNOW data (succeed or fail)"]
pub type esp_now_send_cb_t = ::core::option::Option<
    unsafe extern "C" fn(mac_addr: *const u8, status: esp_now_send_status_t),
>;
extern "C" {
    #[doc = " @brief     Initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_INTERNAL : Internal error"]
    pub fn esp_now_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize ESPNOW function\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_now_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the version of ESPNOW\n\n @param     version  ESPNOW version\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_version(version: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of receiving ESPNOW data\n\n @param     cb  callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of receiving ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_recv_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of sending ESPNOW data\n\n @param     cb  callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of sending ESPNOW data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_send_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send ESPNOW data\n\n @attention 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr\n @attention 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list\n @attention 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN\n @attention 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns\n\n @param     peer_addr  peer MAC address\n @param     data  data to send\n @param     len  length of data\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_INTERNAL : internal error\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory, when this happens, you can delay a while before sending the next data\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found\n          - ESP_ERR_ESPNOW_IF : current WiFi interface doesn't match that of peer"]
    pub fn esp_now_send(peer_addr: *const u8, data: *const u8, len: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Add a peer to peer list\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full\n          - ESP_ERR_ESPNOW_NO_MEM : out of memory\n          - ESP_ERR_ESPNOW_EXIST : peer has existed"]
    pub fn esp_now_add_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Delete a peer from peer list\n\n @param     peer_addr  peer MAC address\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_del_peer(peer_addr: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Modify a peer\n\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    pub fn esp_now_mod_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Config ESPNOW rate of specified interface\n\n @attention  1. This API should be called after esp_wifi_start().\n\n @param      ifx  Interface to be configured.\n @param      rate Phy rate to be configured.\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_config_espnow_rate(ifx: wifi_interface_t, rate: wifi_phy_rate_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get a peer whose MAC address matches peer_addr from peer list\n\n @param     peer_addr  peer MAC address\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_get_peer(peer_addr: *const u8, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Fetch a peer from peer list. Only return the peer which address is unicast, for the multicast/broadcast address, the function will ignore and try to find the next in the peer list.\n\n @param     from_head  fetch from head of list or not\n @param     peer  peer information\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument\n          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_fetch_peer(from_head: bool, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Peer exists or not\n\n @param     peer_addr  peer MAC address\n\n @return\n          - true : peer exists\n          - false : peer not exists"]
    pub fn esp_now_is_peer_exist(peer_addr: *const u8) -> bool;
}
extern "C" {
    #[doc = " @brief     Get the number of peers\n\n @param     num  number of peers\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_peer_num(num: *mut esp_now_peer_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the primary master key\n\n @param     pmk  primary master key\n\n @attention 1. primary master key is used to encrypt local master key\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized\n          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_set_pmk(pmk: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set wake window for esp_now to wake up in interval unit\n\n @param     window  Milliseconds would the chip keep waked each interval, from 0 to 65535.\n\n @attention 1. This configuration could work at connected status.\n               When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status.\n @attention 2. Default value is the maximum.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_set_wake_window(window: u16) -> esp_err_t;
}
#[doc = "< protocol: ESPTouch"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH: smartconfig_type_t = 0;
#[doc = "< protocol: AirKiss"]
pub const smartconfig_type_t_SC_TYPE_AIRKISS: smartconfig_type_t = 1;
#[doc = "< protocol: ESPTouch and AirKiss"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_AIRKISS: smartconfig_type_t = 2;
#[doc = "< protocol: ESPTouch v2"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_V2: smartconfig_type_t = 3;
pub type smartconfig_type_t = ::core::ffi::c_uint;
#[doc = "< ESP32 station smartconfig has finished to scan for APs"]
pub const smartconfig_event_t_SC_EVENT_SCAN_DONE: smartconfig_event_t = 0;
#[doc = "< ESP32 station smartconfig has found the channel of the target AP"]
pub const smartconfig_event_t_SC_EVENT_FOUND_CHANNEL: smartconfig_event_t = 1;
#[doc = "< ESP32 station smartconfig got the SSID and password"]
pub const smartconfig_event_t_SC_EVENT_GOT_SSID_PSWD: smartconfig_event_t = 2;
#[doc = "< ESP32 station smartconfig has sent ACK to cellphone"]
pub const smartconfig_event_t_SC_EVENT_SEND_ACK_DONE: smartconfig_event_t = 3;
#[doc = " Smartconfig event declarations"]
pub type smartconfig_event_t = ::core::ffi::c_uint;
extern "C" {
    pub static mut SC_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for SC_EVENT_GOT_SSID_PSWD event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smartconfig_event_got_ssid_pswd_t {
    #[doc = "< SSID of the AP. Null terminated string."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of the AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< whether set MAC address of target AP or not."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP."]
    pub bssid: [u8; 6usize],
    #[doc = "< Type of smartconfig(ESPTouch or AirKiss)."]
    pub type_: smartconfig_type_t,
    #[doc = "< Token from cellphone which is used to send ACK to cellphone."]
    pub token: u8,
    #[doc = "< IP address of cellphone."]
    pub cellphone_ip: [u8; 4usize],
}
impl Default for smartconfig_event_got_ssid_pswd_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Configure structure for esp_smartconfig_start"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smartconfig_start_config_t {
    #[doc = "< Enable smartconfig logs."]
    pub enable_log: bool,
    #[doc = "< Enable ESPTouch v2 crypt."]
    pub esp_touch_v2_enable_crypt: bool,
    #[doc = "< ESPTouch v2 crypt key, len should be 16."]
    pub esp_touch_v2_key: *mut ::core::ffi::c_char,
}
impl Default for smartconfig_start_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief  Get the version of SmartConfig.\n\n @return\n     - SmartConfig version const char."]
    pub fn esp_smartconfig_get_version() -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set timeout of SmartConfig process.\n\n @attention Timing starts from SC_STATUS_FIND_CHANNEL status. SmartConfig will restart if timeout.\n\n @param     time_s  range 15s~255s, offset:45s.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_esptouch_set_timeout(time_s: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of SmartConfig.\n\n @attention If users need to set the SmartConfig type, please set it before calling\n            esp_smartconfig_start.\n\n @param     type  Choose from the smartconfig_type_t.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_set_type(type_: smartconfig_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mode of SmartConfig. default normal mode.\n\n @attention 1. Please call it before API esp_smartconfig_start.\n @attention 2. Fast mode have corresponding APP(phone).\n @attention 3. Two mode is compatible.\n\n @param     enable  false-disable(default); true-enable;\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_fast_mode(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get reserved data of ESPTouch v2.\n\n @param     rvd_data  reserved  data\n @param     len length  of  reserved data\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_get_rvd_data(rvd_data: *mut u8, len: u8) -> esp_err_t;
}
#[doc = "< Set the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_SET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 1;
#[doc = "< Get the configuration of STA's HT2040 coexist management"]
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_GET_STA_HT2040_COEX: wifi_ioctl_cmd_t = 2;
pub const wifi_ioctl_cmd_t_WIFI_IOCTL_MAX: wifi_ioctl_cmd_t = 3;
#[doc = " @brief WiFi ioctl command type\n"]
pub type wifi_ioctl_cmd_t = ::core::ffi::c_uint;
#[doc = " @brief Configuration for STA's HT2040 coexist management\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wifi_ht2040_coex_t {
    #[doc = "< Indicate whether STA's HT2040 coexist management is enabled or not"]
    pub enable: ::core::ffi::c_int,
}
#[doc = " @brief Configuration for WiFi ioctl\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ioctl_config_t {
    #[doc = "< Configuration of ioctl command"]
    pub data: wifi_ioctl_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_ioctl_config_t__bindgen_ty_1 {
    #[doc = "< Configuration of STA's HT2040 coexist management"]
    pub ht2040_coex: wifi_ht2040_coex_t,
}
impl Default for wifi_ioctl_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for wifi_ioctl_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_static_queue_t {
    #[doc = "< FreeRTOS queue handler"]
    pub handle: QueueHandle_t,
    #[doc = "< storage for FreeRTOS queue"]
    pub storage: *mut ::core::ffi::c_void,
}
impl Default for wifi_static_queue_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const wifi_log_level_t_WIFI_LOG_NONE: wifi_log_level_t = 0;
pub const wifi_log_level_t_WIFI_LOG_ERROR: wifi_log_level_t = 1;
pub const wifi_log_level_t_WIFI_LOG_WARNING: wifi_log_level_t = 2;
pub const wifi_log_level_t_WIFI_LOG_INFO: wifi_log_level_t = 3;
pub const wifi_log_level_t_WIFI_LOG_DEBUG: wifi_log_level_t = 4;
pub const wifi_log_level_t_WIFI_LOG_VERBOSE: wifi_log_level_t = 5;
#[doc = " @brief WiFi log level\n"]
pub type wifi_log_level_t = ::core::ffi::c_uint;
pub const wifi_log_module_t_WIFI_LOG_MODULE_ALL: wifi_log_module_t = 0;
pub const wifi_log_module_t_WIFI_LOG_MODULE_WIFI: wifi_log_module_t = 1;
pub const wifi_log_module_t_WIFI_LOG_MODULE_COEX: wifi_log_module_t = 2;
pub const wifi_log_module_t_WIFI_LOG_MODULE_MESH: wifi_log_module_t = 3;
#[doc = " @brief WiFi log module definition\n"]
pub type wifi_log_module_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Initialize Wi-Fi Driver\n     Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_init().\n\n This function may be called, if you only need to initialize the Wi-Fi driver\n without having to use the network stack on top.\n\n @param  config provide WiFi init configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: out of memory\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init_internal(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize Wi-Fi Driver\n     Free resource for WiFi driver, such as WiFi control structure, RX/TX buffer,\n     WiFi NVS structure among others.\n\n For the most part, you need not call this function directly. It gets called\n from esp_wifi_deinit().\n\n This function may be called, if you call esp_wifi_init_internal to initialize\n WiFi driver.\n\n @return\n    - ESP_OK: succeed\n    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_deinit_internal() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  free the rx buffer which allocated by wifi driver\n\n @param  void* buffer: rx buffer pointer"]
    pub fn esp_wifi_internal_free_rx_buffer(buffer: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief  transmit the buffer via wifi driver\n\n This API makes a copy of the input buffer and then forwards the buffer\n copy to WiFi driver.\n\n @param  wifi_interface_t wifi_if : wifi interface id\n @param  void *buffer : the buffer to be tansmit\n @param  uint16_t len : the length of buffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_WIFI_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx(
        wifi_if: wifi_interface_t,
        buffer: *mut ::core::ffi::c_void,
        len: u16,
    ) -> ::core::ffi::c_int;
}
#[doc = " @brief     The net stack buffer reference counter callback function\n"]
pub type wifi_netstack_buf_ref_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut ::core::ffi::c_void)>;
#[doc = " @brief     The net stack buffer free callback function\n"]
pub type wifi_netstack_buf_free_cb_t =
    ::core::option::Option<unsafe extern "C" fn(netstack_buf: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief  transmit the buffer by reference via wifi driver\n\n This API firstly increases the reference counter of the input buffer and\n then forwards the buffer to WiFi driver. The WiFi driver will free the buffer\n after processing it. Use esp_wifi_internal_tx() if the uplayer buffer doesn't\n supports reference counter.\n\n @param  wifi_if : wifi interface id\n @param  buffer : the buffer to be tansmit\n @param  len : the length of buffer\n @param  netstack_buf : the netstack buffer related to bufffer\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - ESP_ERR_NO_MEM: out of memory\n    - ESP_ERR_WIFI_ARG: invalid argument\n    - ESP_ERR_WIFI_IF : WiFi interface is invalid\n    - ESP_ERR_WIFI_CONN : WiFi interface is not created, e.g. send the data to STA while WiFi mode is AP mode\n    - ESP_ERR_WIFI_NOT_STARTED : WiFi is not started\n    - ESP_ERR_WIFI_STATE : WiFi internal state is not ready, e.g. WiFi is not started\n    - ESP_ERR_WIFI_NOT_ASSOC : WiFi is not associated\n    - ESP_ERR_WIFI_TX_DISALLOW : WiFi TX is disallowed, e.g. WiFi hasn't pass the authentication\n    - ESP_ERR_WIFI_POST : caller fails to post event to WiFi task"]
    pub fn esp_wifi_internal_tx_by_ref(
        ifx: wifi_interface_t,
        buffer: *mut ::core::ffi::c_void,
        len: usize,
        netstack_buf: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Initialize WAPI function when wpa_supplicant initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WAPI_INTERNAL : Internal error"]
    pub fn esp_wifi_internal_wapi_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize WAPI function when wpa_supplicant de-initialize.\n\n This API is privately used, be careful not open to external applicantion.\n\n @return\n          - ESP_OK : succeed"]
    pub fn esp_wifi_internal_wapi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  register the net stack buffer reference increasing and free callback\n\n @param  ref : net stack buffer reference callback\n @param  free: net stack buffer free callback\n\n @return\n    - ESP_OK  : Successfully transmit the buffer to wifi driver\n    - others  : failed to register the callback"]
    pub fn esp_wifi_internal_reg_netstack_buf_cb(
        ref_: wifi_netstack_buf_ref_cb_t,
        free: wifi_netstack_buf_free_cb_t,
    ) -> esp_err_t;
}
#[doc = " @brief     The WiFi RX callback function\n\n            Each time the WiFi need to forward the packets to high layer, the callback function will be called"]
pub type wifi_rxcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::core::ffi::c_void,
        len: u16,
        eb: *mut ::core::ffi::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief     Set the WiFi RX callback\n\n @attention 1. Currently we support only one RX callback for each interface\n\n @param     wifi_interface_t ifx : interface\n @param     wifi_rxcb_t fn : WiFi RX callback\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_reg_rxcb(ifx: wifi_interface_t, fn_: wifi_rxcb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Notify WIFI driver that the station got ip successfully\n\n @return\n     - ESP_OK : succeed\n     - others : fail"]
    pub fn esp_wifi_internal_set_sta_ip() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  enable or disable transmitting WiFi MAC frame with fixed rate\n\n @attention 1. If fixed rate is enabled, both management and data frame are transmitted with fixed rate\n @attention 2. Make sure that the receiver is able to receive the frame with the fixed rate if you want the frame to be received\n @attention 3. Not support to set fix rate for espnow and 80211_tx\n\n @param  ifx : wifi interface\n @param  en : false - disable, true - enable\n @param  rate : PHY rate\n\n @return\n    - ERR_OK  : succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n    - ESP_ERR_WIFI_IF : invalid WiFi interface\n    - ESP_ERR_INVALID_ARG : invalid rate\n    - ESP_ERR_NOT_SUPPORTED : do not support to set fixed rate if TX AMPDU is enabled"]
    pub fn esp_wifi_internal_set_fix_rate(
        ifx: wifi_interface_t,
        en: bool,
        rate: wifi_phy_rate_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP.\n            Device sniffer special packets from the air that containing SSID and password of target AP.\n\n @attention 1. This API can be called in station or softAP-station mode.\n @attention 2. Can not call esp_smartconfig_start twice before it finish, please call\n               esp_smartconfig_stop first.\n\n @param     config pointer to smartconfig start configure structure\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_start(config: *const smartconfig_start_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start.\n\n @attention Whether connect to AP succeed or not, this API should be called to free\n            memory taken by smartconfig_start.\n\n @return\n     - ESP_OK: succeed\n     - others: fail"]
    pub fn esp_smartconfig_internal_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the OS adapter header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_osi_funcs_md5_check(md5: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the crypto types header files in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_crypto_funcs_md5_check(md5: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi_types.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_wifi_type_md5_check(md5: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check the MD5 values of the esp_wifi.h in IDF and WiFi library\n\n @attention 1. It is used for internal CI version check\n\n @return\n     - ESP_OK : succeed\n     - ESP_WIFI_INVALID_ARG : MD5 check fail"]
    pub fn esp_wifi_internal_esp_wifi_md5_check(md5: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Allocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_malloc(size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief     Reallocate a chunk of memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     void * ptr  : Pointer to previously allocated memory, or NULL for a new allocation.\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_realloc(ptr: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief     Callocate memory for WiFi driver\n\n @attention This API is not used for DMA memory allocation.\n\n @param     size_t n    : Number of continuing chunks of memory to allocate\n @param     size_t size : Size, in bytes, of the amount of memory to allocate\n\n @return    A pointer to the memory allocated on success, NULL on failure"]
    pub fn wifi_calloc(n: usize, size: usize) -> *mut ::core::ffi::c_void;
}
#[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
pub type wifi_mac_time_update_cb_t =
    ::core::option::Option<unsafe extern "C" fn(time_delta: u32) -> esp_err_t>;
extern "C" {
    #[doc = " @brief     Update WiFi MAC time\n\n @param     uint32_t time_delta : time duration since the WiFi/BT common clock is disabled\n\n @return    Always returns ESP_OK"]
    pub fn esp_wifi_internal_update_mac_time(time_delta: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi log level\n\n @param     level   Log level.\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: level is invalid"]
    pub fn esp_wifi_internal_set_log_level(level: wifi_log_level_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current log module and submodule\n\n @param     module      Log module\n @param     submodule   Log submodule\n @param     enable      enable or disable\n            If module == 0 && enable == 0, all log modules are disabled.\n            If module == 0 && enable == 1, all log modules are enabled.\n            If submodule == 0 && enable == 0, all log submodules are disabled.\n            If submodule == 0 && enable == 1, all log submodules are enabled.\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_internal_set_log_mod(
        module: wifi_log_module_t,
        submodule: u32,
        enable: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi log info\n\n @param     log_level  the return log level.\n @param     log_mod    the return log module and submodule\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_log(
        log_level: *mut wifi_log_level_t,
        log_mod: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     A general API to set/get WiFi internal configuration, it's for debug only\n\n @param     cmd : ioctl command type\n @param     cfg : configuration for the command\n\n @return\n    - ESP_OK: succeed\n    - others: failed"]
    pub fn esp_wifi_internal_ioctl(
        cmd: ::core::ffi::c_int,
        cfg: *mut wifi_ioctl_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the user-configured channel info\n\n @param     ifx : WiFi interface\n @param     primary : store the configured primary channel\n @param     second : store the configured second channel\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_config_channel(
        ifx: wifi_interface_t,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated channel info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     aid : the connection number when a STA connects to the softAP\n @param     primary : store the negotiated primary channel\n @param     second : store the negotiated second channel\n @attention the aid param is only works when the ESP32 in softAP/softAP+STA mode\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_channel(
        ifx: wifi_interface_t,
        aid: u8,
        primary: *mut u8,
        second: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the negotiated bandwidth info after WiFi connection established\n\n @param     ifx : WiFi interface\n @param     bw : store the negotiated bandwidth\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_internal_get_negotiated_bandwidth(
        ifx: wifi_interface_t,
        aid: u8,
        bw: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Check if WiFi TSF is active\n\n @return\n    - true: Active\n    - false: Not active"]
    pub fn esp_wifi_internal_is_tsf_active() -> bool;
}
extern "C" {
    #[doc = " @brief     Update WIFI light sleep wake ahead time\n"]
    pub fn esp_wifi_internal_update_light_sleep_wake_ahead_time(arg1: u32);
}
extern "C" {
    #[doc = " @brief     Update WiFi TSF tick interval\n\n @return\n    - true: Active\n    - false: Not active"]
    pub fn esp_wifi_update_tsf_tick_interval() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wifi power domain power on"]
    pub fn esp_wifi_power_domain_on();
}
extern "C" {
    #[doc = " @brief Wifi power domain power off"]
    pub fn esp_wifi_power_domain_off();
}
#[doc = " @breif    TxDone callback function type. Should be registered using esp_wifi_set_tx_done_cb()\n\n @param    ifidx The interface id that the tx callback has been triggered from\n @param    data Pointer to the data transmitted\n @param    data_len Length of the data transmitted\n @param    txStatus True:if the data was transmitted sucessfully False: if data transmission failed"]
pub type wifi_tx_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ifidx: u8, data: *mut u8, data_len: *mut u16, txStatus: bool),
>;
extern "C" {
    #[doc = " @brief    Register the txDone callback function of type wifi_tx_done_cb_t\n\n @param    cb The callback function\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_tx_done_cb(cb: wifi_tx_done_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set device spp amsdu attributes\n\n @param     ifx: WiFi interface\n @param     spp_cap: spp amsdu capable\n @param     spp_req: spp amsdu require\n\n @return\n     - ESP_OK: succeed\n     - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n     - ESP_ERR_WIFI_IF : invalid WiFi interface"]
    pub fn esp_wifi_internal_set_spp_amsdu(
        ifidx: wifi_interface_t,
        spp_cap: bool,
        spp_req: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Update WIFI light sleep default parameters\n\n @param   min_freq_mhz: minimum frequency of DFS\n @param   max_freq_mhz: maximum frequency of DFS"]
    pub fn esp_wifi_internal_update_light_sleep_default_params(
        min_freq_mhz: ::core::ffi::c_int,
        max_freq_mhz: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief   Set the delay time for wifi to enter the sleep state when light sleep\n\n @param   return_to_sleep_delay: minimum timeout time  for waiting to receive\n                      data, when no data is received during the timeout period,\n                      the wifi enters the sleep process."]
    pub fn esp_wifi_set_sleep_delay_time(return_to_sleep_delay: u32);
}
extern "C" {
    #[doc = " @brief   Set wifi keep alive time\n\n @param   keep_alive_time: keep alive time"]
    pub fn esp_wifi_set_keep_alive_time(keep_alive_time: u32);
}
extern "C" {
    #[doc = " @brief   Configure wifi beacon montior default parameters\n\n @param   enable: enable or disable beacon monitor\n @param   timeout: timeout time for close rf phy when beacon loss occurs, Unit: 1024 microsecond\n @param   threshold: maximum number of consecutive lost beacons allowed"]
    pub fn esp_wifi_beacon_monitor_configure(
        enable: bool,
        timeout: ::core::ffi::c_int,
        threshold: ::core::ffi::c_int,
        delta_intr_early: ::core::ffi::c_int,
        delta_timeout: ::core::ffi::c_int,
    );
}
#[doc = "                Structures"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_attempts_t {
    #[doc = "< minimum scan times before being a root, default:10"]
    pub scan: ::core::ffi::c_int,
    #[doc = "< max vote times in self-healing, default:1000"]
    pub vote: ::core::ffi::c_int,
    #[doc = "< parent selection fail times, if the scan times reach this value,\ndevice will disconnect with associated children and join self-healing. default:60"]
    pub fail: ::core::ffi::c_int,
    #[doc = "< acceptable times of parent networking IE change before update its own networking IE. default:3"]
    pub monitor_ie: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_switch_parent_t {
    pub duration_ms: ::core::ffi::c_int,
    pub cnx_rssi: ::core::ffi::c_int,
    pub select_rssi: ::core::ffi::c_int,
    pub switch_rssi: ::core::ffi::c_int,
    pub backoff_rssi: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_rssi_threshold_t {
    pub high: ::core::ffi::c_int,
    pub medium: ::core::ffi::c_int,
    pub low: ::core::ffi::c_int,
}
#[doc = " @brief Mesh networking IE"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_assoc_t {
    #[doc = "< element ID"]
    pub eid: u8,
    #[doc = "< element length"]
    pub len: u8,
    #[doc = "< organization identifier */\n/**< mesh networking IE content"]
    pub oui: [u8; 3usize],
    pub type_: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< mesh device type"]
    pub mesh_type: u8,
    #[doc = "< mesh ID"]
    pub mesh_id: [u8; 6usize],
    #[doc = "< max layer"]
    pub layer_cap: u8,
    #[doc = "< current layer"]
    pub layer: u8,
    #[doc = "< max connections of mesh AP"]
    pub assoc_cap: u8,
    #[doc = "< current connections"]
    pub assoc: u8,
    #[doc = "< leaf capacity"]
    pub leaf_cap: u8,
    #[doc = "< the number of current connected leaf"]
    pub leaf_assoc: u8,
    #[doc = "< root capacity"]
    pub root_cap: u16,
    #[doc = "< self capacity"]
    pub self_cap: u16,
    #[doc = "< layer2 capacity"]
    pub layer2_cap: u16,
    #[doc = "< the number of scanning APs"]
    pub scan_ap_num: u16,
    #[doc = "< RSSI of the parent"]
    pub rssi: i8,
    #[doc = "< RSSI of the router"]
    pub router_rssi: i8,
    #[doc = "< flag of networking"]
    pub flag: u8,
    #[doc = "< root address"]
    pub rc_addr: [u8; 6usize],
    #[doc = "< root RSSI"]
    pub rc_rssi: i8,
    #[doc = "< voter address"]
    pub vote_addr: [u8; 6usize],
    #[doc = "< vote RSSI of the router"]
    pub vote_rssi: i8,
    #[doc = "< vote ttl"]
    pub vote_ttl: u8,
    #[doc = "< votes"]
    pub votes: u16,
    #[doc = "< my votes"]
    pub my_votes: u16,
    #[doc = "< reason"]
    pub reason: u8,
    #[doc = "< child address"]
    pub child: [u8; 6usize],
    #[doc = "< toDS state"]
    pub toDS: u8,
}
impl mesh_assoc_t {
    #[inline]
    pub fn encrypted(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encrypted(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(encrypted: u8, version: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let encrypted: u8 = unsafe { ::core::mem::transmute(encrypted) };
            encrypted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_chain_layer_t {
    pub layer_cap: u16,
    pub layer: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_chain_assoc_t {
    pub tree: mesh_assoc_t,
    pub chain: mesh_chain_layer_t,
}
#[doc = " @brief Mesh PS duties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_mesh_ps_duties_t {
    pub device: u8,
    pub parent: u8,
    pub child: [esp_mesh_ps_duties_t__bindgen_ty_1; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_mesh_ps_duties_t__bindgen_ty_1 {
    pub used: bool,
    pub duty: u8,
    pub mac: [u8; 6usize],
}
extern "C" {
    #[doc = "                Function Definitions\n/\n/**\n @brief      Set mesh softAP beacon interval\n\n @param[in]  interval  beacon interval (msecs) (100 msecs ~ 60000 msecs)\n\n @return\n    - ESP_OK\n    - ESP_FAIL\n    - ESP_ERR_WIFI_ARG"]
    pub fn esp_mesh_set_beacon_interval(interval_ms: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh softAP beacon interval\n\n @param[out] interval  beacon interval (msecs)\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_get_beacon_interval(interval_ms: *mut ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set attempts for mesh self-organized networking\n\n @param[in] attempts\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_attempts(attempts: *mut mesh_attempts_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get attempts for mesh self-organized networking\n\n @param[out] attempts\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_attempts(attempts: *mut mesh_attempts_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set parameters for parent switch\n\n @param[in]  paras  parameters for parent switch\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_set_switch_parent_paras(paras: *mut mesh_switch_parent_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get parameters for parent switch\n\n @param[out] paras  parameters for parent switch\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_switch_parent_paras(paras: *mut mesh_switch_parent_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set RSSI threshold\n             - The default high RSSI threshold value is -78 dBm.\n             - The default medium RSSI threshold value is -82 dBm.\n             - The default low RSSI threshold value is -85 dBm.\n\n @param[in]  threshold  RSSI threshold\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_set_rssi_threshold(threshold: *const mesh_rssi_threshold_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get RSSI threshold\n\n @param[out] threshold  RSSI threshold\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_rssi_threshold(threshold: *mut mesh_rssi_threshold_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable the minimum rate to 6 Mbps\n\n @attention  This API shall be called before Wi-Fi is started.\n\n @param[in]  is_6m  enable or not\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_set_6m_rate(is_6m: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Print the number of txQ waiting\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_print_txQ_waiting() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Print the number of rxQ waiting\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_print_rxQ_waiting() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set passive scan time\n\n @param[in]  interval_ms  passive scan time (msecs)\n\n @return\n    - ESP_OK\n    - ESP_FAIL\n    - ESP_ERR_ARGUMENT"]
    pub fn esp_mesh_set_passive_scan_time(time_ms: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get passive scan time\n\n @return     interval_ms  passive scan time (msecs)"]
    pub fn esp_mesh_get_passive_scan_time() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set announce interval\n             - The default short interval is 500 milliseconds.\n             - The default long interval is 3000 milliseconds.\n\n @param[in]  short_ms  shall be greater than the default value\n @param[in]  long_ms  shall be greater than the default value\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_set_announce_interval(
        short_ms: ::core::ffi::c_int,
        long_ms: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get announce interval\n\n @param[out] short_ms  short interval\n @param[out] long_ms  long interval\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_get_announce_interval(
        short_ms: *mut ::core::ffi::c_int,
        long_ms: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the running duties of device, parent and children\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_ps_get_duties(ps_duties: *mut esp_mesh_ps_duties_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Enable mesh print scan result\n\n @param[in]  enable  enable or not\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_print_scan_result(enable: bool) -> esp_err_t;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[must_use]
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[must_use]
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut environ: *mut *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn access(
        __path: *const ::core::ffi::c_char,
        __amode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn alarm(__secs: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn chdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chmod(__path: *const ::core::ffi::c_char, __mode: mode_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chown(
        __path: *const ::core::ffi::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn close(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn confstr(
        __name: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn daemon(nochdir: ::core::ffi::c_int, noclose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dup(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dup2(__fildes: ::core::ffi::c_int, __fildes2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execl(
        __path: *const ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execlpe(
        __file: *const ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execve(
        __path: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
        __envp: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: ::core::ffi::c_int,
        __path: *const ::core::ffi::c_char,
        __mode: ::core::ffi::c_int,
        __flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchdir(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchmod(__fildes: ::core::ffi::c_int, __mode: mode_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchown(
        __fildes: ::core::ffi::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchownat(
        __dirfd: ::core::ffi::c_int,
        __path: *const ::core::ffi::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::core::ffi::c_int,
        __argv: *const *mut ::core::ffi::c_char,
        __envp: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(__fd: ::core::ffi::c_int, __name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn fsync(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::core::ffi::c_char, __size: usize) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getentropy(arg1: *mut ::core::ffi::c_void, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(
        __gidsetsize: ::core::ffi::c_int,
        __grouplist: *mut gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gethostid() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn getlogin() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getpass(__prompt: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getpagesize() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::core::ffi::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn getusershell() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn iruserok(
        raddr: ::core::ffi::c_ulong,
        superuser: ::core::ffi::c_int,
        ruser: *const ::core::ffi::c_char,
        luser: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isatty(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn issetugid() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lchown(
        __path: *const ::core::ffi::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn link(
        __path1: *const ::core::ffi::c_char,
        __path2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linkat(
        __dirfd1: ::core::ffi::c_int,
        __path1: *const ::core::ffi::c_char,
        __dirfd2: ::core::ffi::c_int,
        __path2: *const ::core::ffi::c_char,
        __flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nice(__nice_value: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lseek(
        __fildes: ::core::ffi::c_int,
        __offset: off_t,
        __whence: ::core::ffi::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn lockf(
        __fd: ::core::ffi::c_int,
        __cmd: ::core::ffi::c_int,
        __len: off_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pathconf(
        __path: *const ::core::ffi::c_char,
        __name: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn pause() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pipe(__fildes: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::core::ffi::c_int,
        __buf: *const ::core::ffi::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn read(
        __fd: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbyte: usize,
    ) -> _ssize_t;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn revoke(__path: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ruserok(
        rhost: *const ::core::ffi::c_char,
        superuser: ::core::ffi::c_int,
        ruser: *const ::core::ffi::c_char,
        luser: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sbrk(__incr: isize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setegid(__gid: gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setgroups(ngroups: ::core::ffi::c_int, grouplist: *const gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn sleep(__seconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn sysconf(__name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn tcgetpgrp(__fildes: ::core::ffi::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fildes: ::core::ffi::c_int, __pgrp_id: pid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ttyname(__fildes: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unlink(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usleep(__useconds: useconds_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vhangup() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::core::ffi::c_int,
        __buf: *const ::core::ffi::c_void,
        __nbyte: usize,
    ) -> _ssize_t;
}
extern "C" {
    pub static mut optarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut optind: ::core::ffi::c_int;
}
extern "C" {
    pub static mut opterr: ::core::ffi::c_int;
}
extern "C" {
    pub static mut optopt: ::core::ffi::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: ::core::ffi::c_int,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut optreset: ::core::ffi::c_int;
}
extern "C" {
    pub fn vfork() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::core::ffi::c_int, __length: off_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const ::core::ffi::c_char, __length: off_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ualarm(__useconds: useconds_t, __interval: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn gethostname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setdtablesize(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn readlink(
        __path: *const ::core::ffi::c_char,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlink(
        __name1: *const ::core::ffi::c_char,
        __name2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn readlinkat(
        __dirfd1: ::core::ffi::c_int,
        __path: *const ::core::ffi::c_char,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_type: ::core::ffi::c_short,
    pub l_whence: ::core::ffi::c_short,
    pub l_start: ::core::ffi::c_long,
    pub l_len: ::core::ffi::c_long,
    pub l_pid: ::core::ffi::c_short,
    pub l_xxx: ::core::ffi::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct eflock {
    pub l_type: ::core::ffi::c_short,
    pub l_whence: ::core::ffi::c_short,
    pub l_start: ::core::ffi::c_long,
    pub l_len: ::core::ffi::c_long,
    pub l_pid: ::core::ffi::c_short,
    pub l_xxx: ::core::ffi::c_short,
    pub l_rpid: ::core::ffi::c_long,
    pub l_rsys: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: blksize_t,
    pub st_blocks: blkcnt_t,
    pub st_spare4: [::core::ffi::c_long; 2usize],
}
extern "C" {
    pub fn fstat(__fd: ::core::ffi::c_int, __sbuf: *mut stat) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkdir(_path: *const ::core::ffi::c_char, __mode: mode_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::core::ffi::c_char, __mode: mode_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn stat(__path: *const ::core::ffi::c_char, __sbuf: *mut stat) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn umask(__mask: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: mode_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut stat,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: mode_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: mode_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn utimensat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: *const timespec,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn futimens(arg1: ::core::ffi::c_int, arg2: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn open(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn creat(arg1: *const ::core::ffi::c_char, arg2: mode_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fcntl(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flock(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ioctl(fd: ::core::ffi::c_int, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pollfd {
    pub fd: ::core::ffi::c_int,
    pub events: ::core::ffi::c_short,
    pub revents: ::core::ffi::c_short,
}
pub type nfds_t = ::core::ffi::c_uint;
extern "C" {
    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief  Get one random 32-bit word from hardware RNG\n\n If Wi-Fi or Bluetooth are enabled, this function returns true random numbers. In other\n situations, if true random numbers are required then consult the ESP-IDF Programming\n Guide \"Random Number Generation\" section for necessary prerequisites.\n\n This function automatically busy-waits to ensure enough external entropy has been\n introduced into the hardware RNG state, before returning a new random number. This delay\n is very short (always less than 100 CPU cycles).\n\n @return Random value between 0 and UINT32_MAX"]
    pub fn esp_random() -> u32;
}
extern "C" {
    #[doc = " @brief Fill a buffer with random bytes from hardware RNG\n\n @note This function is implemented via calls to esp_random(), so the same\n constraints apply.\n\n @param buf Pointer to buffer to fill with random numbers.\n @param len Length of buffer in bytes"]
    pub fn esp_fill_random(buf: *mut ::core::ffi::c_void, len: usize);
}
extern "C" {
    #[doc = " @brief Get the sync interval of SNTP operation\n\n @return  the sync interval"]
    pub fn sntp_get_sync_interval() -> u32;
}
extern "C" {
    #[doc = " @brief system time setter used in the sntp module\n @note The lwip sntp uses u32_t types for sec and us arguments"]
    pub fn sntp_set_system_time(sec: u32, us: u32);
}
extern "C" {
    #[doc = " @brief system time getter used in the sntp module\n @note The lwip sntp uses u32_t types for sec and us arguments"]
    pub fn sntp_get_system_time(sec: *mut u32, us: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwip_sock {
    _unused: [u8; 0],
}
extern "C" {
    pub fn lwip_setsockopt_impl_ext(
        sock: *mut lwip_sock,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: u32,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    pub fn lwip_getsockopt_impl_ext(
        sock: *mut lwip_sock,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut u32,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
}
pub type sys_sem_t = SemaphoreHandle_t;
pub type sys_mutex_t = SemaphoreHandle_t;
pub type sys_thread_t = TaskHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_mbox_s {
    pub os_mbox: QueueHandle_t,
    pub owner: *mut ::core::ffi::c_void,
}
impl Default for sys_mbox_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sys_mbox_t = *mut sys_mbox_s;
extern "C" {
    pub fn sys_delay_ms(ms: u32);
}
extern "C" {
    pub fn sys_thread_sem_init() -> *mut sys_sem_t;
}
extern "C" {
    pub fn sys_thread_sem_deinit();
}
extern "C" {
    pub fn sys_thread_sem_get() -> *mut sys_sem_t;
}
pub const sys_thread_core_lock_t_LWIP_CORE_LOCK_QUERY_HOLDER: sys_thread_core_lock_t = 0;
pub const sys_thread_core_lock_t_LWIP_CORE_LOCK_MARK_HOLDER: sys_thread_core_lock_t = 1;
pub const sys_thread_core_lock_t_LWIP_CORE_LOCK_UNMARK_HOLDER: sys_thread_core_lock_t = 2;
pub const sys_thread_core_lock_t_LWIP_CORE_MARK_TCPIP_TASK: sys_thread_core_lock_t = 3;
pub const sys_thread_core_lock_t_LWIP_CORE_IS_TCPIP_INITIALIZED: sys_thread_core_lock_t = 4;
pub type sys_thread_core_lock_t = ::core::ffi::c_uint;
extern "C" {
    pub fn sys_thread_tcpip(type_: sys_thread_core_lock_t) -> bool;
}
pub type error_t = ::core::ffi::c_int;
extern "C" {
    pub fn __errno() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub static _sys_errlist: [*const ::core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::core::ffi::c_int;
}
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type sys_prot_t = ::core::ffi::c_int;
pub type u64_t = u64;
pub type s64_t = i64;
pub type mem_ptr_t = usize;
extern "C" {
    pub fn isalnum(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isalpha(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscntrl(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isdigit(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isgraph(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn islower(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isprint(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ispunct(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isspace(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isupper(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isxdigit(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tolower(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn toupper(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isblank(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isascii(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn toascii(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isalnum_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isalpha_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isblank_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscntrl_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isdigit_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isgraph_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn islower_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isprint_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ispunct_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isspace_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isupper_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isxdigit_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isascii_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn toascii_l(__c: ::core::ffi::c_int, __l: locale_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub static _ctype_: [::core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(result: *mut ::core::ffi::c_char, bufsize: usize, number: ::core::ffi::c_int);
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_stricmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const ::core::ffi::c_char,
        token: *const ::core::ffi::c_char,
        n: usize,
    ) -> *mut ::core::ffi::c_char;
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
pub type ip4_addr_t = ip4_addr;
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const ::core::ffi::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(
        cp: *const ::core::ffi::c_char,
        addr: *mut ip4_addr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
#[doc = " Unknown"]
pub const lwip_ipv6_scope_type_IP6_UNKNOWN: lwip_ipv6_scope_type = 0;
#[doc = " Unicast"]
pub const lwip_ipv6_scope_type_IP6_UNICAST: lwip_ipv6_scope_type = 1;
#[doc = " Multicast"]
pub const lwip_ipv6_scope_type_IP6_MULTICAST: lwip_ipv6_scope_type = 2;
#[doc = " Symbolic constants for the 'type' parameters in some of the macros.\n These exist for efficiency only, allowing the macros to avoid certain tests\n when the address is known not to be of a certain type. Dead code elimination\n will do the rest. IP6_MULTICAST is supported but currently not optimized.\n @see ip6_addr_has_scope, ip6_addr_assign_zone, ip6_addr_lacks_zone."]
pub type lwip_ipv6_scope_type = ::core::ffi::c_uint;
#[doc = " This is the aligned version of ip6_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip6_addr {
    pub addr: [u32_t; 4usize],
    pub zone: u8_t,
}
#[doc = " This is the aligned version of ip6_addr_t,\nused as local variable, on the stack, etc."]
pub type ip6_addr_t = ip6_addr;
extern "C" {
    pub fn ip6addr_aton(
        cp: *const ::core::ffi::c_char,
        addr: *mut ip6_addr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip6addr_ntoa(addr: *const ip6_addr_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ip6addr_ntoa_r(
        addr: *const ip6_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
#[doc = " IPv4"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
#[doc = " IPv6"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
#[doc = " IPv4+IPv6 (\"dual-stack\")"]
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
#[doc = " @ingroup ipaddr\n IP address types for use in ip_addr_t.type member.\n @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type()."]
pub type lwip_ip_addr_type = ::core::ffi::c_uint;
#[doc = " @ingroup ipaddr\n A union struct for both IP version's addresses.\n ATTENTION: watch out for its size when adding IPv6 address scope!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_addr {
    pub u_addr: ip_addr__bindgen_ty_1,
    #[doc = " @ref lwip_ip_addr_type"]
    pub type_: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_addr__bindgen_ty_1 {
    pub ip6: ip6_addr_t,
    pub ip4: ip4_addr_t,
}
impl Default for ip_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ip_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @ingroup ipaddr\n A union struct for both IP version's addresses.\n ATTENTION: watch out for its size when adding IPv6 address scope!"]
pub type ip_addr_t = ip_addr;
extern "C" {
    pub static ip_addr_any_type: ip_addr_t;
}
extern "C" {
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ipaddr_aton(cp: *const ::core::ffi::c_char, addr: *mut ip_addr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
extern "C" {
    pub static ip6_addr_any: ip_addr_t;
}
#[doc = "< mesh is started"]
pub const mesh_event_id_t_MESH_EVENT_STARTED: mesh_event_id_t = 0;
#[doc = "< mesh is stopped"]
pub const mesh_event_id_t_MESH_EVENT_STOPPED: mesh_event_id_t = 1;
#[doc = "< channel switch"]
pub const mesh_event_id_t_MESH_EVENT_CHANNEL_SWITCH: mesh_event_id_t = 2;
#[doc = "< a child is connected on softAP interface"]
pub const mesh_event_id_t_MESH_EVENT_CHILD_CONNECTED: mesh_event_id_t = 3;
#[doc = "< a child is disconnected on softAP interface"]
pub const mesh_event_id_t_MESH_EVENT_CHILD_DISCONNECTED: mesh_event_id_t = 4;
#[doc = "< routing table is changed by adding newly joined children"]
pub const mesh_event_id_t_MESH_EVENT_ROUTING_TABLE_ADD: mesh_event_id_t = 5;
#[doc = "< routing table is changed by removing leave children"]
pub const mesh_event_id_t_MESH_EVENT_ROUTING_TABLE_REMOVE: mesh_event_id_t = 6;
#[doc = "< parent is connected on station interface"]
pub const mesh_event_id_t_MESH_EVENT_PARENT_CONNECTED: mesh_event_id_t = 7;
#[doc = "< parent is disconnected on station interface"]
pub const mesh_event_id_t_MESH_EVENT_PARENT_DISCONNECTED: mesh_event_id_t = 8;
#[doc = "< no parent found"]
pub const mesh_event_id_t_MESH_EVENT_NO_PARENT_FOUND: mesh_event_id_t = 9;
#[doc = "< layer changes over the mesh network"]
pub const mesh_event_id_t_MESH_EVENT_LAYER_CHANGE: mesh_event_id_t = 10;
#[doc = "< state represents whether the root is able to access external IP network.\nThis state is a manual event that needs to be triggered with esp_mesh_post_toDS_state()."]
pub const mesh_event_id_t_MESH_EVENT_TODS_STATE: mesh_event_id_t = 11;
#[doc = "< the process of voting a new root is started either by children or by the root"]
pub const mesh_event_id_t_MESH_EVENT_VOTE_STARTED: mesh_event_id_t = 12;
#[doc = "< the process of voting a new root is stopped"]
pub const mesh_event_id_t_MESH_EVENT_VOTE_STOPPED: mesh_event_id_t = 13;
#[doc = "< the root address is obtained. It is posted by mesh stack automatically."]
pub const mesh_event_id_t_MESH_EVENT_ROOT_ADDRESS: mesh_event_id_t = 14;
#[doc = "< root switch request sent from a new voted root candidate"]
pub const mesh_event_id_t_MESH_EVENT_ROOT_SWITCH_REQ: mesh_event_id_t = 15;
#[doc = "< root switch acknowledgment responds the above request sent from current root"]
pub const mesh_event_id_t_MESH_EVENT_ROOT_SWITCH_ACK: mesh_event_id_t = 16;
#[doc = "< the root is asked yield by a more powerful existing root. If self organized is disabled\nand this device is specified to be a root by users, users should set a new parent\nfor this device. if self organized is enabled, this device will find a new parent\nby itself, users could ignore this event."]
pub const mesh_event_id_t_MESH_EVENT_ROOT_ASKED_YIELD: mesh_event_id_t = 17;
#[doc = "< when devices join a network, if the setting of Fixed Root for one device is different\nfrom that of its parent, the device will update the setting the same as its parent's.\nFixed Root Setting of each device is variable as that setting changes of the root."]
pub const mesh_event_id_t_MESH_EVENT_ROOT_FIXED: mesh_event_id_t = 18;
#[doc = "< if self-organized networking is disabled, user can call esp_wifi_scan_start() to trigger\nthis event, and add the corresponding scan done handler in this event."]
pub const mesh_event_id_t_MESH_EVENT_SCAN_DONE: mesh_event_id_t = 19;
#[doc = "< network state, such as whether current mesh network has a root."]
pub const mesh_event_id_t_MESH_EVENT_NETWORK_STATE: mesh_event_id_t = 20;
#[doc = "< the root stops reconnecting to the router and non-root devices stop reconnecting to their parents."]
pub const mesh_event_id_t_MESH_EVENT_STOP_RECONNECTION: mesh_event_id_t = 21;
#[doc = "< when the channel field in mesh configuration is set to zero, mesh stack will perform a\nfull channel scan to find a mesh network that can join, and return the channel value\nafter finding it."]
pub const mesh_event_id_t_MESH_EVENT_FIND_NETWORK: mesh_event_id_t = 22;
#[doc = "< if users specify BSSID of the router in mesh configuration, when the root connects to another\nrouter with the same SSID, this event will be posted and the new router information is attached."]
pub const mesh_event_id_t_MESH_EVENT_ROUTER_SWITCH: mesh_event_id_t = 23;
#[doc = "< parent duty"]
pub const mesh_event_id_t_MESH_EVENT_PS_PARENT_DUTY: mesh_event_id_t = 24;
#[doc = "< child duty"]
pub const mesh_event_id_t_MESH_EVENT_PS_CHILD_DUTY: mesh_event_id_t = 25;
#[doc = "< device duty"]
pub const mesh_event_id_t_MESH_EVENT_PS_DEVICE_DUTY: mesh_event_id_t = 26;
pub const mesh_event_id_t_MESH_EVENT_MAX: mesh_event_id_t = 27;
#[doc = "                Enumerations\n/\n/**\n @brief Enumerated list of mesh event id"]
pub type mesh_event_id_t = ::core::ffi::c_uint;
extern "C" {
    pub static mut MESH_EVENT: esp_event_base_t;
}
#[doc = "< hasn't joined the mesh network yet"]
pub const mesh_type_t_MESH_IDLE: mesh_type_t = 0;
#[doc = "< the only sink of the mesh network. Has the ability to access external IP network"]
pub const mesh_type_t_MESH_ROOT: mesh_type_t = 1;
#[doc = "< intermediate device. Has the ability to forward packets over the mesh network"]
pub const mesh_type_t_MESH_NODE: mesh_type_t = 2;
#[doc = "< has no forwarding ability"]
pub const mesh_type_t_MESH_LEAF: mesh_type_t = 3;
#[doc = "< connect to router with a standlone Wi-Fi station mode, no network expansion capability"]
pub const mesh_type_t_MESH_STA: mesh_type_t = 4;
#[doc = " @brief Device type"]
pub type mesh_type_t = ::core::ffi::c_uint;
#[doc = "< binary"]
pub const mesh_proto_t_MESH_PROTO_BIN: mesh_proto_t = 0;
#[doc = "< HTTP protocol"]
pub const mesh_proto_t_MESH_PROTO_HTTP: mesh_proto_t = 1;
#[doc = "< JSON format"]
pub const mesh_proto_t_MESH_PROTO_JSON: mesh_proto_t = 2;
#[doc = "< MQTT protocol"]
pub const mesh_proto_t_MESH_PROTO_MQTT: mesh_proto_t = 3;
#[doc = "< IP network mesh communication of node's AP interface"]
pub const mesh_proto_t_MESH_PROTO_AP: mesh_proto_t = 4;
#[doc = "< IP network mesh communication of node's STA interface"]
pub const mesh_proto_t_MESH_PROTO_STA: mesh_proto_t = 5;
#[doc = " @brief Protocol of transmitted application data"]
pub type mesh_proto_t = ::core::ffi::c_uint;
#[doc = "< provide P2P (point-to-point) retransmission on mesh stack by default"]
pub const mesh_tos_t_MESH_TOS_P2P: mesh_tos_t = 0;
#[doc = "< provide E2E (end-to-end) retransmission on mesh stack (Unimplemented)"]
pub const mesh_tos_t_MESH_TOS_E2E: mesh_tos_t = 1;
#[doc = "< no retransmission on mesh stack"]
pub const mesh_tos_t_MESH_TOS_DEF: mesh_tos_t = 2;
#[doc = " @brief For reliable transmission, mesh stack provides three type of services"]
pub type mesh_tos_t = ::core::ffi::c_uint;
#[doc = "< vote is initiated by the root"]
pub const mesh_vote_reason_t_MESH_VOTE_REASON_ROOT_INITIATED: mesh_vote_reason_t = 1;
#[doc = "< vote is initiated by children"]
pub const mesh_vote_reason_t_MESH_VOTE_REASON_CHILD_INITIATED: mesh_vote_reason_t = 2;
#[doc = " @brief Vote reason"]
pub type mesh_vote_reason_t = ::core::ffi::c_uint;
#[doc = "< cyclic is detected"]
pub const mesh_disconnect_reason_t_MESH_REASON_CYCLIC: mesh_disconnect_reason_t = 100;
#[doc = "< parent is idle"]
pub const mesh_disconnect_reason_t_MESH_REASON_PARENT_IDLE: mesh_disconnect_reason_t = 101;
#[doc = "< the connected device is changed to a leaf"]
pub const mesh_disconnect_reason_t_MESH_REASON_LEAF: mesh_disconnect_reason_t = 102;
#[doc = "< in different mesh ID"]
pub const mesh_disconnect_reason_t_MESH_REASON_DIFF_ID: mesh_disconnect_reason_t = 103;
#[doc = "< root conflict is detected"]
pub const mesh_disconnect_reason_t_MESH_REASON_ROOTS: mesh_disconnect_reason_t = 104;
#[doc = "< parent has stopped the mesh"]
pub const mesh_disconnect_reason_t_MESH_REASON_PARENT_STOPPED: mesh_disconnect_reason_t = 105;
#[doc = "< scan fail"]
pub const mesh_disconnect_reason_t_MESH_REASON_SCAN_FAIL: mesh_disconnect_reason_t = 106;
#[doc = "< unknown IE"]
pub const mesh_disconnect_reason_t_MESH_REASON_IE_UNKNOWN: mesh_disconnect_reason_t = 107;
#[doc = "< waive root"]
pub const mesh_disconnect_reason_t_MESH_REASON_WAIVE_ROOT: mesh_disconnect_reason_t = 108;
#[doc = "< parent with very poor RSSI"]
pub const mesh_disconnect_reason_t_MESH_REASON_PARENT_WORSE: mesh_disconnect_reason_t = 109;
#[doc = "< use an empty password to connect to an encrypted parent"]
pub const mesh_disconnect_reason_t_MESH_REASON_EMPTY_PASSWORD: mesh_disconnect_reason_t = 110;
#[doc = "< connect to an unencrypted parent/router"]
pub const mesh_disconnect_reason_t_MESH_REASON_PARENT_UNENCRYPTED: mesh_disconnect_reason_t = 111;
#[doc = " @brief Mesh disconnect reason code"]
pub type mesh_disconnect_reason_t = ::core::ffi::c_uint;
#[doc = "< tree topology"]
pub const esp_mesh_topology_t_MESH_TOPO_TREE: esp_mesh_topology_t = 0;
#[doc = "< chain topology"]
pub const esp_mesh_topology_t_MESH_TOPO_CHAIN: esp_mesh_topology_t = 1;
#[doc = " @brief Mesh topology"]
pub type esp_mesh_topology_t = ::core::ffi::c_uint;
#[doc = "                Structures\n/\n/**\n @brief IP address and port"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mip_t {
    #[doc = "< IP address"]
    pub ip4: ip4_addr_t,
    #[doc = "< port"]
    pub port: u16,
}
#[doc = " @brief Mesh address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mesh_addr_t {
    #[doc = "< mac address"]
    pub addr: [u8; 6usize],
    #[doc = "< mip address"]
    pub mip: mip_t,
}
impl Default for mesh_addr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Channel switch information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_channel_switch_t {
    #[doc = "< new channel"]
    pub channel: u8,
}
#[doc = " @brief Parent connected information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_event_connected_t {
    #[doc = "< parent information, same as Wi-Fi event SYSTEM_EVENT_STA_CONNECTED does"]
    pub connected: wifi_event_sta_connected_t,
    #[doc = "< layer"]
    pub self_layer: u16,
    #[doc = "< parent duty"]
    pub duty: u8,
}
impl Default for mesh_event_connected_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief No parent found information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_no_parent_found_t {
    #[doc = "< scan times being through"]
    pub scan_times: ::core::ffi::c_int,
}
#[doc = " @brief Layer change information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_layer_change_t {
    #[doc = "< new layer"]
    pub new_layer: u16,
}
#[doc = "< the root isn't able to access external IP network"]
pub const mesh_event_toDS_state_t_MESH_TODS_UNREACHABLE: mesh_event_toDS_state_t = 0;
#[doc = "< the root is able to access external IP network"]
pub const mesh_event_toDS_state_t_MESH_TODS_REACHABLE: mesh_event_toDS_state_t = 1;
#[doc = " @brief The reachability of the root to a DS (distribute system)"]
pub type mesh_event_toDS_state_t = ::core::ffi::c_uint;
#[doc = " @brief vote started information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_event_vote_started_t {
    #[doc = "< vote reason, vote could be initiated by children or by the root itself"]
    pub reason: ::core::ffi::c_int,
    #[doc = "< max vote attempts before stopped"]
    pub attempts: ::core::ffi::c_int,
    #[doc = "< root address specified by users via API esp_mesh_waive_root()"]
    pub rc_addr: mesh_addr_t,
}
impl Default for mesh_event_vote_started_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief find a mesh network that this device can join"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_find_network_t {
    #[doc = "< channel number of the new found network"]
    pub channel: u8,
    #[doc = "< router BSSID"]
    pub router_bssid: [u8; 6usize],
}
#[doc = " @brief Mesh address"]
pub type mesh_event_root_address_t = mesh_addr_t;
#[doc = " Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
pub type mesh_event_disconnected_t = wifi_event_sta_disconnected_t;
#[doc = " Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
pub type mesh_event_child_connected_t = wifi_event_ap_staconnected_t;
#[doc = " Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
pub type mesh_event_child_disconnected_t = wifi_event_ap_stadisconnected_t;
#[doc = " @brief Root switch request information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_event_root_switch_req_t {
    #[doc = "< root switch reason, generally root switch is initialized by users via API esp_mesh_waive_root()"]
    pub reason: ::core::ffi::c_int,
    #[doc = "< the address of root switch requester"]
    pub rc_addr: mesh_addr_t,
}
impl Default for mesh_event_root_switch_req_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Other powerful root address"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_root_conflict_t {
    #[doc = "< rssi with router"]
    pub rssi: i8,
    #[doc = "< the number of devices in current network"]
    pub capacity: u16,
    #[doc = "< other powerful root address"]
    pub addr: [u8; 6usize],
}
#[doc = " @brief Routing table change"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_routing_table_change_t {
    #[doc = "< the new value"]
    pub rt_size_new: u16,
    #[doc = "< the changed value"]
    pub rt_size_change: u16,
}
#[doc = " @brief Root fixed"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_root_fixed_t {
    #[doc = "< status"]
    pub is_fixed: bool,
}
#[doc = " @brief Scan done\u{3000}event information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_scan_done_t {
    #[doc = "< the number of APs scanned"]
    pub number: u8,
}
#[doc = " @brief Network state information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_network_state_t {
    #[doc = "< whether current mesh network has a root"]
    pub is_rootless: bool,
}
#[doc = " Argument structure for WIFI_EVENT_STA_CONNECTED event"]
pub type mesh_event_router_switch_t = wifi_event_sta_connected_t;
#[doc = " @brief PS duty information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_event_ps_duty_t {
    #[doc = "< parent or child duty"]
    pub duty: u8,
    #[doc = "< child info"]
    pub child_connected: mesh_event_child_connected_t,
}
#[doc = " @brief Mesh event information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mesh_event_info_t {
    #[doc = "< channel switch"]
    pub channel_switch: mesh_event_channel_switch_t,
    #[doc = "< child connected"]
    pub child_connected: mesh_event_child_connected_t,
    #[doc = "< child disconnected"]
    pub child_disconnected: mesh_event_child_disconnected_t,
    #[doc = "< routing table change"]
    pub routing_table: mesh_event_routing_table_change_t,
    #[doc = "< parent connected"]
    pub connected: mesh_event_connected_t,
    #[doc = "< parent disconnected"]
    pub disconnected: mesh_event_disconnected_t,
    #[doc = "< no parent found"]
    pub no_parent: mesh_event_no_parent_found_t,
    #[doc = "< layer change"]
    pub layer_change: mesh_event_layer_change_t,
    #[doc = "< toDS state, devices shall check this state firstly before trying to send packets to\nexternal IP network. This state indicates right now whether the root is capable of sending\npackets out. If not, devices had better to wait until this state changes to be\nMESH_TODS_REACHABLE."]
    pub toDS_state: mesh_event_toDS_state_t,
    #[doc = "< vote started"]
    pub vote_started: mesh_event_vote_started_t,
    #[doc = "< root address"]
    pub root_addr: mesh_event_root_address_t,
    #[doc = "< root switch request"]
    pub switch_req: mesh_event_root_switch_req_t,
    #[doc = "< other powerful root"]
    pub root_conflict: mesh_event_root_conflict_t,
    #[doc = "< fixed root"]
    pub root_fixed: mesh_event_root_fixed_t,
    #[doc = "< scan done"]
    pub scan_done: mesh_event_scan_done_t,
    #[doc = "< network state, such as whether current mesh network has a root."]
    pub network_state: mesh_event_network_state_t,
    #[doc = "< network found that can join"]
    pub find_network: mesh_event_find_network_t,
    #[doc = "< new router information"]
    pub router_switch: mesh_event_router_switch_t,
    #[doc = "< PS duty information"]
    pub ps_duty: mesh_event_ps_duty_t,
}
impl Default for mesh_event_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Mesh option"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_opt_t {
    #[doc = "< option type"]
    pub type_: u8,
    #[doc = "< option length"]
    pub len: u16,
    #[doc = "< option value"]
    pub val: *mut u8,
}
impl Default for mesh_opt_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Mesh data for esp_mesh_send() and esp_mesh_recv()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_data_t {
    #[doc = "< data"]
    pub data: *mut u8,
    #[doc = "< data size"]
    pub size: u16,
    #[doc = "< data protocol"]
    pub proto: mesh_proto_t,
    #[doc = "< data type of service"]
    pub tos: mesh_tos_t,
}
impl Default for mesh_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Router configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_router_t {
    #[doc = "< SSID"]
    pub ssid: [u8; 32usize],
    #[doc = "< length of SSID"]
    pub ssid_len: u8,
    #[doc = "< BSSID, if this value is specified, users should also specify \"allow_router_switch\"."]
    pub bssid: [u8; 6usize],
    #[doc = "< password"]
    pub password: [u8; 64usize],
    #[doc = "< if the BSSID is specified and this value is also set, when the router of this specified BSSID\nfails to be found after \"fail\" (mesh_attempts_t) times, the whole network is allowed to switch\nto another router with the same SSID. The new router might also be on a different channel.\nThe default value is false.\nThere is a risk that if the password is different between the new switched router and the previous\none, the mesh network could be established but the root will never connect to the new switched router."]
    pub allow_router_switch: bool,
}
impl Default for mesh_router_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Mesh softAP configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_ap_cfg_t {
    #[doc = "< mesh softAP password"]
    pub password: [u8; 64usize],
    #[doc = "< max mesh connections"]
    pub max_connection: u8,
    #[doc = "< max non-mesh connections"]
    pub nonmesh_max_connection: u8,
}
impl Default for mesh_ap_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Mesh initialization configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_cfg_t {
    #[doc = "< channel, the mesh network on"]
    pub channel: u8,
    #[doc = "< if this value is set, when \"fail\" (mesh_attempts_t) times is reached, device will change to\na full channel scan for a network that could join. The default value is false."]
    pub allow_channel_switch: bool,
    #[doc = "< mesh network identification"]
    pub mesh_id: mesh_addr_t,
    #[doc = "< router configuration"]
    pub router: mesh_router_t,
    #[doc = "< mesh softAP configuration"]
    pub mesh_ap: mesh_ap_cfg_t,
    #[doc = "< crypto functions"]
    pub crypto_funcs: *const mesh_crypto_funcs_t,
}
impl Default for mesh_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Vote address configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mesh_rc_config_t {
    #[doc = "< max vote attempts before a new root is elected automatically by mesh network. (min:15, 15 by default)"]
    pub attempts: ::core::ffi::c_int,
    #[doc = "< a new root address specified by users for API esp_mesh_waive_root()"]
    pub rc_addr: mesh_addr_t,
}
impl Default for mesh_rc_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Vote"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mesh_vote_t {
    #[doc = "< vote percentage threshold for approval of being a root"]
    pub percentage: f32,
    #[doc = "< if true, rc_addr shall be specified (Unimplemented).\nif false, attempts value shall be specified to make network start root election."]
    pub is_rc_specified: bool,
    #[doc = "< vote address configuration"]
    pub config: mesh_rc_config_t,
}
impl Default for mesh_vote_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The number of packets pending in the queue waiting to be sent by the mesh stack"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_tx_pending_t {
    #[doc = "< to parent queue"]
    pub to_parent: ::core::ffi::c_int,
    #[doc = "< to parent (P2P) queue"]
    pub to_parent_p2p: ::core::ffi::c_int,
    #[doc = "< to child queue"]
    pub to_child: ::core::ffi::c_int,
    #[doc = "< to child (P2P) queue"]
    pub to_child_p2p: ::core::ffi::c_int,
    #[doc = "< management queue"]
    pub mgmt: ::core::ffi::c_int,
    #[doc = "< broadcast and multicast queue"]
    pub broadcast: ::core::ffi::c_int,
}
#[doc = " @brief The number of packets available in the queue waiting to be received by applications"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mesh_rx_pending_t {
    #[doc = "< to external DS"]
    pub toDS: ::core::ffi::c_int,
    #[doc = "< to self"]
    pub toSelf: ::core::ffi::c_int,
}
extern "C" {
    #[doc = "                Variable Declaration"]
    pub static g_wifi_default_mesh_crypto_funcs: mesh_crypto_funcs_t;
}
extern "C" {
    #[doc = "                Function Definitions\n/\n/**\n @brief      Mesh initialization\n             - Check whether Wi-Fi is started.\n             - Initialize mesh global variables with default values.\n\n @attention  This API shall be called after Wi-Fi is started.\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Mesh de-initialization\n\n             - Release resources and stop the mesh\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Start mesh\n             - Initialize mesh IE.\n             - Start mesh network management service.\n             - Create TX and RX queues according to the configuration.\n             - Register mesh packets receive callback.\n\n @attention\u{3000}\u{3000}This API shall be called after mesh initialization and configuration.\n\n @return\n    - ESP_OK\n    - ESP_FAIL\n    - ESP_ERR_MESH_NOT_INIT\n    - ESP_ERR_MESH_NOT_CONFIG\n    - ESP_ERR_MESH_NO_MEMORY"]
    pub fn esp_mesh_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Stop mesh\n             - Deinitialize mesh IE.\n             - Disconnect with current parent.\n             - Disassociate all currently associated children.\n             - Stop mesh network management service.\n             - Unregister mesh packets receive callback.\n             - Delete TX and RX queues.\n             - Release resources.\n             - Restore Wi-Fi softAP to default settings if Wi-Fi dual mode is enabled.\n             - Set Wi-Fi Power Save type to WIFI_PS_NONE.\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Send a packet over the mesh network\n             - Send a packet to any device in the mesh network.\n             - Send a packet to external IP network.\n\n @attention  This API is not reentrant.\n\n @param[in]  to  the address of the final destination of the packet\n             - If the packet is to the root, set this parameter to NULL.\n             - If the packet is to an external IP network, set this parameter to the IPv4:PORT combination.\n               This packet will be delivered to the root firstly, then the root will forward this packet to the final IP server address.\n @param[in]  data  pointer to a sending mesh packet\n             - Field size should not exceed MESH_MPS. Note that the size of one mesh packet should not exceed MESH_MTU.\n             - Field proto should be set to data protocol in use (default is MESH_PROTO_BIN for binary).\n             - Field tos should be set to transmission tos (type of service) in use (default is MESH_TOS_P2P for point-to-point reliable).\n @param[in]  flag  bitmap for data sent\n             -  Speed up the route search\n               - If the packet is to the root and \"to\" parameter is NULL, set this parameter to 0.\n               - If the packet is to an internal device, MESH_DATA_P2P should be set.\n               - If the packet is to the root (\"to\" parameter isn't NULL) or to external IP network, MESH_DATA_TODS should be set.\n               - If the packet is from the root to an internal device, MESH_DATA_FROMDS should be set.\n             - Specify whether this API is block or non-block, block by default\n               - If needs non-blocking, MESH_DATA_NONBLOCK should be set. Otherwise, may use esp_mesh_send_block_time() to specify a blocking time.\n             - In the situation of the root change, MESH_DATA_DROP identifies this packet can be dropped by the new root\n               for upstream data to external IP network, we try our best to avoid data loss caused by the root change, but\n               there is a risk that the new root is running out of memory because most of memory is occupied by the pending data which\n               isn't read out in time by esp_mesh_recv_toDS().\n\n               Generally, we suggest esp_mesh_recv_toDS() is called after a connection with IP network is created. Thus data outgoing\n               to external IP network via socket is just from reading esp_mesh_recv_toDS() which avoids unnecessary memory copy.\n\n @param[in]  opt  options\n             - In case of sending a packet to a certain group, MESH_OPT_SEND_GROUP is a good choice.\n               In this option, the value field should be set to the target receiver addresses in this group.\n             - Root sends a packet to an internal device, this packet is from external IP network in case the receiver device responds\n             this packet, MESH_OPT_RECV_DS_ADDR is required to attach the target DS address.\n @param[in]  opt_count  option count\n             - Currently, this API only takes one option, so opt_count is only supported to be 1.\n\n @return\n    - ESP_OK\n    - ESP_FAIL\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_START\n    - ESP_ERR_MESH_DISCONNECTED\n    - ESP_ERR_MESH_OPT_UNKNOWN\n    - ESP_ERR_MESH_EXCEED_MTU\n    - ESP_ERR_MESH_NO_MEMORY\n    - ESP_ERR_MESH_TIMEOUT\n    - ESP_ERR_MESH_QUEUE_FULL\n    - ESP_ERR_MESH_NO_ROUTE_FOUND\n    - ESP_ERR_MESH_DISCARD"]
    pub fn esp_mesh_send(
        to: *const mesh_addr_t,
        data: *const mesh_data_t,
        flag: ::core::ffi::c_int,
        opt: *const mesh_opt_t,
        opt_count: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set blocking time of esp_mesh_send()\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  time_ms  blocking time of esp_mesh_send(), unit:ms\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_send_block_time(time_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Receive a packet targeted to self over the mesh network\n\n @attention  Mesh RX queue should be checked regularly to avoid running out of memory.\n             - Use esp_mesh_get_rx_pending() to check the number of packets available in the queue waiting\n             to be received by applications.\n\n @param[out] from  the address of the original source of the packet\n @param[out] data  pointer to the received mesh packet\n             - Field proto is the data protocol in use. Should follow it to parse the received data.\n             - Field tos is the transmission tos (type of service) in use.\n @param[in]  timeout_ms  wait time if a packet isn't immediately available (0:no wait, portMAX_DELAY:wait forever)\n @param[out] flag  bitmap for data received\n             - MESH_DATA_FROMDS represents data from external IP network\n             - MESH_DATA_TODS represents data directed upward within the mesh network\n\n             flag could be MESH_DATA_FROMDS or MESH_DATA_TODS.\n @param[out] opt  options desired to receive\n             - MESH_OPT_RECV_DS_ADDR attaches the DS address\n @param[in]  opt_count  option count desired to receive\n             - Currently, this API only takes one option, so opt_count is only supported to be 1.\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_START\n    - ESP_ERR_MESH_TIMEOUT\n    - ESP_ERR_MESH_DISCARD"]
    pub fn esp_mesh_recv(
        from: *mut mesh_addr_t,
        data: *mut mesh_data_t,
        timeout_ms: ::core::ffi::c_int,
        flag: *mut ::core::ffi::c_int,
        opt: *mut mesh_opt_t,
        opt_count: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Receive a packet targeted to external IP network\n             - Root uses this API to receive packets destined to external IP network\n             - Root forwards the received packets to the final destination via socket.\n             - If no socket connection is ready to send out the received packets and this esp_mesh_recv_toDS()\n             hasn't been called by applications, packets from the whole mesh network will be pending in toDS queue.\n\n             Use esp_mesh_get_rx_pending() to check the number of packets available in the queue waiting\n             to be received by applications in case of running out of memory in the root.\n\n             Using esp_mesh_set_xon_qsize() users may configure the RX queue size, default:32. If this size is too large,\n             and esp_mesh_recv_toDS() isn't called in time, there is a risk that a great deal of memory is occupied\n             by the pending packets. If this size is too small, it will impact the efficiency on upstream. How to\n             decide this value depends on the specific application scenarios.\n\n @attention  This API is only called by the root.\n\n @param[out] from  the address of the original source of the packet\n @param[out] to  the address contains remote IP address and port (IPv4:PORT)\n @param[out] data  pointer to the received packet\n             - Contain the protocol and applications should follow it to parse the data.\n @param[in]  timeout_ms  wait time if a packet isn't immediately available (0:no wait, portMAX_DELAY:wait forever)\n @param[out] flag  bitmap for data received\n             - MESH_DATA_TODS represents the received data target to external IP network. Root shall forward this data to external IP network via the association with router.\n\n             flag could be MESH_DATA_TODS.\n @param[out] opt  options desired to receive\n @param[in]  opt_count  option count desired to receive\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_START\n    - ESP_ERR_MESH_TIMEOUT\n    - ESP_ERR_MESH_DISCARD\n    - ESP_ERR_MESH_RECV_RELEASE"]
    pub fn esp_mesh_recv_toDS(
        from: *mut mesh_addr_t,
        to: *mut mesh_addr_t,
        data: *mut mesh_data_t,
        timeout_ms: ::core::ffi::c_int,
        flag: *mut ::core::ffi::c_int,
        opt: *mut mesh_opt_t,
        opt_count: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set mesh stack configuration\n             - Use MESH_INIT_CONFIG_DEFAULT() to initialize the default values, mesh IE is encrypted by default.\n             - Mesh network is established on a fixed channel (1-14).\n             - Mesh event callback is mandatory.\n             - Mesh ID is an identifier of an MBSS. Nodes with the same mesh ID can communicate with each other.\n             - Regarding to the router configuration, if the router is hidden, BSSID field is mandatory.\n\n             If BSSID field isn't set and there exists more than one router with same SSID, there is a risk that more\n             roots than one connected with different BSSID will appear. It means more than one mesh network is established\n             with the same mesh ID.\n\n             Root conflict function could eliminate redundant roots connected with the same BSSID, but couldn't handle roots\n             connected with different BSSID. Because users might have such requirements of setting up routers with same SSID\n             for the future replacement. But in that case, if the above situations happen, please make sure applications\n             implement forward functions on the root to guarantee devices in different mesh networks can communicate with each other.\n             max_connection of mesh softAP is limited by the max number of Wi-Fi softAP supported (max:10).\n\n @attention  This API shall be called before mesh is started after mesh is initialized.\n\n @param[in]  config  pointer to mesh stack configuration\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_config(config: *const mesh_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh stack configuration\n\n @param[out] config  pointer to mesh stack configuration\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_config(config: *mut mesh_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get router configuration\n\n @attention  This API is used to dynamically modify the router configuration after mesh is configured.\n\n @param[in]  router  pointer to router configuration\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_set_router(router: *const mesh_router_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get router configuration\n\n @param[out] router  pointer to router configuration\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_router(router: *mut mesh_router_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set mesh network ID\n\n @attention  This API is used to dynamically modify the mesh network ID.\n\n @param[in]  id  pointer to mesh network ID\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT: invalid argument"]
    pub fn esp_mesh_set_id(id: *const mesh_addr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh network ID\n\n @param[out] id  pointer to mesh network ID\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_id(id: *mut mesh_addr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Designate device type over the mesh network\n            - MESH_IDLE: designates a device as a self-organized node for a mesh network\n            - MESH_ROOT: designates the root node for a mesh network\n            - MESH_LEAF: designates a device as a standalone Wi-Fi station that connects to a parent\n            - MESH_STA: designates a device as a standalone Wi-Fi station that connects to a router\n\n @param[in]  type  device type\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_type(type_: mesh_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get device type over mesh network\n\n @attention  This API shall be called after having received the event MESH_EVENT_PARENT_CONNECTED.\n\n @return     mesh type\n"]
    pub fn esp_mesh_get_type() -> mesh_type_t;
}
extern "C" {
    #[doc = " @brief      Set network max layer value\n             - for tree topology, the max is 25.\n             - for chain topology, the max is 1000.\n             - Network max layer limits the max hop count.\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  max_layer  max layer value\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_max_layer(max_layer: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get max layer value\n\n @return     max layer value"]
    pub fn esp_mesh_get_max_layer() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set mesh softAP password\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  pwd  pointer to the password\n @param[in]  len  password length\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_ap_password(pwd: *const u8, len: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set mesh softAP authentication mode\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  authmode  authentication mode\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_ap_authmode(authmode: wifi_auth_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh softAP authentication mode\n\n @return     authentication mode"]
    pub fn esp_mesh_get_ap_authmode() -> wifi_auth_mode_t;
}
extern "C" {
    #[doc = " @brief      Set mesh max connection value\n             - Set mesh softAP max connection = mesh max connection + non-mesh max connection\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  connections  the number of max connections\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_set_ap_connections(connections: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh max connection configuration\n\n @return     the number of mesh max connections"]
    pub fn esp_mesh_get_ap_connections() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get non-mesh max connection configuration\n\n @return     the number of non-mesh max connections"]
    pub fn esp_mesh_get_non_mesh_connections() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get current layer value over the mesh network\n\n @attention  This API shall be called after having received the event MESH_EVENT_PARENT_CONNECTED.\n\n @return     layer value\n"]
    pub fn esp_mesh_get_layer() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get the parent BSSID\n\n @attention  This API shall be called after having received the event MESH_EVENT_PARENT_CONNECTED.\n\n @param[out] bssid  pointer to parent BSSID\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_get_parent_bssid(bssid: *mut mesh_addr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Return whether the device is the root node of the network\n\n @return     true/false"]
    pub fn esp_mesh_is_root() -> bool;
}
extern "C" {
    #[doc = " @brief      Enable/disable self-organized networking\n             - Self-organized networking has three main functions:\n             select the root node;\n             find a preferred parent;\n             initiate reconnection if a disconnection is detected.\n             - Self-organized networking is enabled by default.\n             - If self-organized is disabled, users should set a parent for the device via esp_mesh_set_parent().\n\n @attention  This API is used to dynamically modify whether to enable the self organizing.\n\n @param[in]  enable  enable or disable self-organized networking\n @param[in]  select_parent  Only valid when self-organized networking is enabled.\n             - if select_parent is set to true, the root will give up its mesh root status and search for a new parent\n             like other non-root devices.\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_self_organized(enable: bool, select_parent: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Return whether enable self-organized networking or not\n\n @return     true/false"]
    pub fn esp_mesh_get_self_organized() -> bool;
}
extern "C" {
    #[doc = " @brief      Cause the root device to give up (waive) its mesh root status\n             - A device is elected root primarily based on RSSI from the external router.\n             - If external router conditions change, users can call this API to perform a root switch.\n             - In this API, users could specify a desired root address to replace itself or specify an attempts value\n             to ask current root to initiate a new round of voting. During the voting, a better root candidate would\n             be expected to find to replace the current one.\n             - If no desired root candidate, the vote will try a specified number of attempts (at least 15). If no better\n             root candidate is found, keep the current one. If a better candidate is found, the new better one will\n             send a root switch request to the current root, current root will respond with a root switch acknowledgment.\n             - After that, the new candidate will connect to the router to be a new root, the previous root will disconnect\n             with the router and choose another parent instead.\n\n             Root switch is completed with minimal disruption to the whole mesh network.\n\n @attention  This API is only called by the root.\n\n @param[in]  vote  vote configuration\n             - If this parameter is set NULL, the vote will perform the default 15 times.\n\n             - Field percentage threshold is 0.9 by default.\n             - Field is_rc_specified shall be false.\n             - Field attempts shall be at least 15 times.\n @param[in]  reason  only accept MESH_VOTE_REASON_ROOT_INITIATED for now\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_QUEUE_FULL\n    - ESP_ERR_MESH_DISCARD\n    - ESP_FAIL"]
    pub fn esp_mesh_waive_root(vote: *const mesh_vote_t, reason: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set vote percentage threshold for approval of being a root (default:0.9)\n             - During the networking, only obtaining vote percentage reaches this threshold,\n             the device could be a root.\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  percentage  vote percentage threshold\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_vote_percentage(percentage: f32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get vote percentage threshold for approval of being a root\n\n @return     percentage threshold"]
    pub fn esp_mesh_get_vote_percentage() -> f32;
}
extern "C" {
    #[doc = " @brief      Set mesh softAP associate expired time (default:10 seconds)\n             - If mesh softAP hasn't received any data from an associated child within this time,\n             mesh softAP will take this child inactive and disassociate it.\n             - If mesh softAP is encrypted, this value should be set a greater value, such as 30 seconds.\n\n @param[in]  seconds  the expired time\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_ap_assoc_expire(seconds: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh softAP associate expired time\n\n @return     seconds"]
    pub fn esp_mesh_get_ap_assoc_expire() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get total number of devices in current network (including the root)\n\n @attention  The returned value might be incorrect when the network is changing.\n\n @return     total number of devices (including the root)"]
    pub fn esp_mesh_get_total_node_num() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get the number of devices in this device's sub-network (including self)\n\n @return     the number of devices over this device's sub-network (including self)"]
    pub fn esp_mesh_get_routing_table_size() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get routing table of this device's sub-network (including itself)\n\n @param[out] mac  pointer to routing table\n @param[in]  len  routing table size(in bytes)\n @param[out] size  pointer to the number of devices in routing table (including itself)\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_routing_table(
        mac: *mut mesh_addr_t,
        len: ::core::ffi::c_int,
        size: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Post the toDS state to the mesh stack\n\n @attention  This API is only for the root.\n\n @param[in]  reachable  this state represents whether the root is able to access external IP network\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_post_toDS_state(reachable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Return the number of packets pending in the queue waiting to be sent by the mesh stack\n\n @param[out] pending  pointer to the TX pending\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_get_tx_pending(pending: *mut mesh_tx_pending_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Return the number of packets available in the queue waiting to be received by applications\n\n @param[out] pending  pointer to the RX pending\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_get_rx_pending(pending: *mut mesh_rx_pending_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Return the number of packets could be accepted from the specified address\n\n @param[in]  addr  self address or an associate children address\n @param[out] xseqno_in  sequence number of the last received packet from the specified address\n\n @return    the number of upQ for a certain address"]
    pub fn esp_mesh_available_txupQ_num(
        addr: *const mesh_addr_t,
        xseqno_in: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set the number of RX queue for the node, the average number of window allocated to one of\n             its child node is: wnd = xon_qsize / (2 * max_connection + 1).\n             However, the window of each child node is not strictly equal to the average value,\n             it is affected by the traffic also.\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  qsize  default:32 (min:16)\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_xon_qsize(qsize: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get queue size\n\n @return     the number of queue"]
    pub fn esp_mesh_get_xon_qsize() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set whether allow more than one root existing in one network\n\n @param[in]  allowed  allow or not\n\n @return\n    - ESP_OK\n    - ESP_WIFI_ERR_NOT_INIT\n    - ESP_WIFI_ERR_NOT_START"]
    pub fn esp_mesh_allow_root_conflicts(allowed: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Check whether allow more than one root to exist in one network\n\n @return     true/false"]
    pub fn esp_mesh_is_root_conflicts_allowed() -> bool;
}
extern "C" {
    #[doc = " @brief      Set group ID addresses\n\n @param[in]  addr  pointer to new group ID addresses\n @param[in]  num  the number of group ID addresses\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_set_group_id(addr: *const mesh_addr_t, num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Delete group ID addresses\n\n @param[in]  addr  pointer to deleted group ID address\n @param[in]  num  the number of group ID addresses\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_delete_group_id(addr: *const mesh_addr_t, num: ::core::ffi::c_int)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the number of group ID addresses\n\n @return     the number of group ID addresses"]
    pub fn esp_mesh_get_group_num() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get group ID addresses\n\n @param[out] addr  pointer to group ID addresses\n @param[in]  num  the number of group ID addresses\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_get_group_list(addr: *mut mesh_addr_t, num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Check whether the specified group address is my group\n\n @return     true/false"]
    pub fn esp_mesh_is_my_group(addr: *const mesh_addr_t) -> bool;
}
extern "C" {
    #[doc = " @brief      Set mesh network capacity (max:1000, default:300)\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  num  mesh network capacity\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_NOT_ALLOWED\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_set_capacity_num(num: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh network capacity\n\n @return     mesh network capacity"]
    pub fn esp_mesh_get_capacity_num() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set mesh IE crypto functions\n\n @attention  This API can be called at any time after mesh is initialized.\n\n @param[in]  crypto_funcs  crypto functions for mesh IE\n           - If crypto_funcs is set to NULL, mesh IE is no longer encrypted.\n @return\n    - ESP_OK"]
    pub fn esp_mesh_set_ie_crypto_funcs(crypto_funcs: *const mesh_crypto_funcs_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set mesh IE crypto key\n\n @attention  This API can be called at any time after mesh is initialized.\n\n @param[in]  key  ASCII crypto key\n @param[in]  len  length in bytes, range:8~64\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_set_ie_crypto_key(
        key: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh IE crypto key\n\n @param[out] key  ASCII crypto key\n @param[in]  len  length in bytes, range:8~64\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT"]
    pub fn esp_mesh_get_ie_crypto_key(
        key: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set delay time before starting root healing\n\n @param[in]  delay_ms  delay time in milliseconds\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_set_root_healing_delay(delay_ms: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get delay time before network starts root healing\n\n @return     delay time in milliseconds"]
    pub fn esp_mesh_get_root_healing_delay() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Enable network Fixed Root Setting\n             - Enabling fixed root disables automatic election of the root node via voting.\n             - All devices in the network shall use the same Fixed Root Setting (enabled or disabled).\n             - If Fixed Root is enabled, users should make sure a root node is designated for the network.\n\n @param[in]  enable  enable or not\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_fix_root(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Check whether network Fixed Root Setting is enabled\n             - Enable/disable network Fixed Root Setting by API esp_mesh_fix_root().\n             - Network Fixed Root Setting also changes with the \"flag\" value in parent networking IE.\n\n @return     true/false"]
    pub fn esp_mesh_is_root_fixed() -> bool;
}
extern "C" {
    #[doc = " @brief      Set a specified parent for the device\n\n @attention  This API can be called at any time after mesh is configured.\n\n @param[in]  parent  parent configuration, the SSID and the channel of the parent are mandatory.\n             - If the BSSID is set, make sure that the SSID and BSSID represent the same parent,\n             otherwise the device will never find this specified parent.\n @param[in]  parent_mesh_id  parent mesh ID,\n             - If this value is not set, the original mesh ID is used.\n @param[in]  my_type  mesh type\n             - MESH_STA is not supported.\n             - If the parent set for the device is the same as the router in the network configuration,\n            then my_type shall set MESH_ROOT and my_layer shall set MESH_ROOT_LAYER.\n @param[in]  my_layer  mesh layer\n             - my_layer of the device may change after joining the network.\n             - If my_type is set MESH_NODE, my_layer shall be greater than MESH_ROOT_LAYER.\n             - If my_type is set MESH_LEAF, the device becomes a standalone Wi-Fi station and no longer\n             has the ability to extend the network.\n\n @return\n    - ESP_OK\n    - ESP_ERR_ARGUMENT\n    - ESP_ERR_MESH_NOT_CONFIG"]
    pub fn esp_mesh_set_parent(
        parent: *const wifi_config_t,
        parent_mesh_id: *const mesh_addr_t,
        my_type: mesh_type_t,
        my_layer: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh networking IE length of one AP\n\n @param[out] len  mesh networking IE length\n\n @return\n    - ESP_OK\n    - ESP_ERR_WIFI_NOT_INIT\n    - ESP_ERR_WIFI_ARG\n    - ESP_ERR_WIFI_FAIL"]
    pub fn esp_mesh_scan_get_ap_ie_len(len: *mut ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get AP record\n\n @attention  Different from esp_wifi_scan_get_ap_records(), this API only gets one of APs scanned each time.\n             See \"manual_networking\" example.\n\n @param[out] ap_record  pointer to one AP record\n @param[out] buffer  pointer to the mesh networking IE of this AP\n\n @return\n    - ESP_OK\n    - ESP_ERR_WIFI_NOT_INIT\n    - ESP_ERR_WIFI_ARG\n    - ESP_ERR_WIFI_FAIL"]
    pub fn esp_mesh_scan_get_ap_record(
        ap_record: *mut wifi_ap_record_t,
        buffer: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Flush upstream packets pending in to_parent queue and to_parent_p2p queue\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_flush_upstream_packets() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the number of nodes in the subnet of a specific child\n\n @param[in]  child_mac  an associated child address of this device\n @param[out] nodes_num  pointer to the number of nodes in the subnet of a specific child\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_NOT_START\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_subnet_nodes_num(
        child_mac: *const mesh_addr_t,
        nodes_num: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get nodes in the subnet of a specific child\n\n @param[in]  child_mac  an associated child address of this device\n @param[out] nodes  pointer to nodes in the subnet of a specific child\n @param[in]  nodes_num  the number of nodes in the subnet of a specific child\n\n @return\n    - ESP_OK\n    - ESP_ERR_MESH_NOT_START\n    - ESP_ERR_MESH_ARGUMENT"]
    pub fn esp_mesh_get_subnet_nodes_list(
        child_mac: *const mesh_addr_t,
        nodes: *mut mesh_addr_t,
        nodes_num: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disconnect from current parent\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Connect to current parent\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Flush scan result\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_flush_scan_result() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Cause the root device to add Channel Switch Announcement Element (CSA IE) to beacon\n             - Set the new channel\n             - Set how many beacons with CSA IE will be sent before changing a new channel\n             - Enable the channel switch function\n\n @attention  This API is only called by the root.\n\n @param[in]  new_bssid  the new router BSSID if the router changes\n @param[in]  csa_newchan  the new channel number to which the whole network is moving\n @param[in]  csa_count  channel switch period(beacon count), unit is based on beacon interval of its softAP, the default value is 15.\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_switch_channel(
        new_bssid: *const u8,
        csa_newchan: ::core::ffi::c_int,
        csa_count: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the router BSSID\n\n @param[out] router_bssid  pointer to the router BSSID\n\n @return\n    - ESP_OK\n    - ESP_ERR_WIFI_NOT_INIT\n    - ESP_ERR_WIFI_ARG"]
    pub fn esp_mesh_get_router_bssid(router_bssid: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the TSF time\n\n @return     the TSF time"]
    pub fn esp_mesh_get_tsf_time() -> i64;
}
extern "C" {
    #[doc = " @brief      Set mesh topology. The default value is MESH_TOPO_TREE\n             - MESH_TOPO_CHAIN supports up to 1000 layers\n\n @attention  This API shall be called before mesh is started.\n\n @param[in]  topo  MESH_TOPO_TREE or MESH_TOPO_CHAIN\n\n @return\n    - ESP_OK\n    - ESP_MESH_ERR_ARGUMENT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_set_topology(topo: esp_mesh_topology_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get mesh topology\n\n @return     MESH_TOPO_TREE or MESH_TOPO_CHAIN"]
    pub fn esp_mesh_get_topology() -> esp_mesh_topology_t;
}
extern "C" {
    #[doc = " @brief      Enable mesh Power Save function\n\n @attention  This API shall be called before mesh is started.\n\n @return\n    - ESP_OK\n    - ESP_ERR_WIFI_NOT_INIT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_enable_ps() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable mesh Power Save function\n\n @attention  This API shall be called before mesh is started.\n\n @return\n    - ESP_OK\n    - ESP_ERR_WIFI_NOT_INIT\n    - ESP_ERR_MESH_NOT_ALLOWED"]
    pub fn esp_mesh_disable_ps() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Check whether the mesh Power Save function is enabled\n\n @return     true/false"]
    pub fn esp_mesh_is_ps_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief      Check whether the device is in active state\n             - If the device is not in active state, it will neither transmit nor receive frames.\n\n @return     true/false"]
    pub fn esp_mesh_is_device_active() -> bool;
}
extern "C" {
    #[doc = " @brief      Set the device duty cycle and type\n             - The range of dev_duty values is 1 to 100. The default value is 10.\n             - dev_duty = 100, the PS will be stopped.\n             - dev_duty is better to not less than 5.\n             - dev_duty_type could be MESH_PS_DEVICE_DUTY_REQUEST or MESH_PS_DEVICE_DUTY_DEMAND.\n             - If dev_duty_type is set to MESH_PS_DEVICE_DUTY_REQUEST, the device will use a nwk_duty provided by the network.\n             - If dev_duty_type is set to MESH_PS_DEVICE_DUTY_DEMAND, the device will use the specified dev_duty.\n\n @attention  This API can be called at any time after mesh is started.\n\n @param[in]  dev_duty  device duty cycle\n @param[in]  dev_duty_type  device PS duty cycle type, not accept MESH_PS_NETWORK_DUTY_MASTER\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_active_duty_cycle(
        dev_duty: ::core::ffi::c_int,
        dev_duty_type: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get device duty cycle and type\n\n @param[out] dev_duty  device duty cycle\n @param[out] dev_duty_type  device PS duty cycle type\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_get_active_duty_cycle(
        dev_duty: *mut ::core::ffi::c_int,
        dev_duty_type: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set the network duty cycle, duration and rule\n             - The range of nwk_duty values is 1 to 100. The default value is 10.\n             - nwk_duty is the network duty cycle the entire network or the up-link path will use. A device that successfully\n             sets the nwk_duty is known as a NWK-DUTY-MASTER.\n             - duration_mins specifies how long the specified nwk_duty will be used. Once duration_mins expires, the root will take\n             over as the NWK-DUTY-MASTER. If an existing NWK-DUTY-MASTER leaves the network, the root will take over as the\n             NWK-DUTY-MASTER again.\n             - duration_mins = (-1) represents nwk_duty will be used until a new NWK-DUTY-MASTER with a different nwk_duty appears.\n             - Only the root can set duration_mins to (-1).\n             - If applied_rule is set to MESH_PS_NETWORK_DUTY_APPLIED_ENTIRE, the nwk_duty will be used by the entire network.\n             - If applied_rule is set to MESH_PS_NETWORK_DUTY_APPLIED_UPLINK, the nwk_duty will only be used by the up-link path nodes.\n             - The root does not accept MESH_PS_NETWORK_DUTY_APPLIED_UPLINK.\n             - A nwk_duty with duration_mins(-1) set by the root is the default network duty cycle used by the entire network.\n\n @attention  This API can be called at any time after mesh is started.\n             - In self-organized network, if this API is called before mesh is started in all devices, (1)nwk_duty shall be set to the\n             same value for all devices; (2)duration_mins shall be set to (-1); (3)applied_rule shall be set to\n             MESH_PS_NETWORK_DUTY_APPLIED_ENTIRE; after the voted root appears, the root will become the NWK-DUTY-MASTER and broadcast\n             the nwk_duty and its identity of NWK-DUTY-MASTER.\n             - If the root is specified (FIXED-ROOT), call this API in the root to provide a default nwk_duty for the entire network.\n             - After joins the network, any device can call this API to change the nwk_duty, duration_mins or applied_rule.\n\n @param[in]  nwk_duty  network duty cycle\n @param[in]  duration_mins  duration (unit: minutes)\n @param[in]  applied_rule  only support MESH_PS_NETWORK_DUTY_APPLIED_ENTIRE\n\n @return\n    - ESP_OK\n    - ESP_FAIL"]
    pub fn esp_mesh_set_network_duty_cycle(
        nwk_duty: ::core::ffi::c_int,
        duration_mins: ::core::ffi::c_int,
        applied_rule: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the network duty cycle, duration, type and rule\n\n @param[out] nwk_duty  current network duty cycle\n @param[out] duration_mins  the duration of current nwk_duty\n @param[out] dev_duty_type  if it includes MESH_PS_DEVICE_DUTY_MASTER, this device is the current NWK-DUTY-MASTER.\n @param[out] applied_rule  MESH_PS_NETWORK_DUTY_APPLIED_ENTIRE\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_get_network_duty_cycle(
        nwk_duty: *mut ::core::ffi::c_int,
        duration_mins: *mut ::core::ffi::c_int,
        dev_duty_type: *mut ::core::ffi::c_int,
        applied_rule: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the running active duty cycle\n          - The running active duty cycle of the root is 100.\n          - If duty type is set to MESH_PS_DEVICE_DUTY_REQUEST, the running active duty cycle is nwk_duty provided by the network.\n          - If duty type is set to MESH_PS_DEVICE_DUTY_DEMAND, the running active duty cycle is dev_duty specified by the users.\n          - In a mesh network, devices are typically working with a certain duty-cycle (transmitting, receiving and sleep) to\n            reduce the power consumption. The running active duty cycle decides the amount of awake time within a beacon interval.\n            At each start of beacon interval, all devices wake up, broadcast beacons, and transmit packets if they do have pending\n            packets for their parents or for their children. Note that Low-duty-cycle means devices may not be active in most of\n            the time, the latency of data transmission might be greater.\n\n @return     the running active duty cycle"]
    pub fn esp_mesh_get_running_active_duty_cycle() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Duty signaling\n\n @param[in]  fwd_times  the times of forwarding duty signaling packets\n\n @return\n    - ESP_OK"]
    pub fn esp_mesh_ps_duty_signaling(fwd_times: ::core::ffi::c_int) -> esp_err_t;
}
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_EAP: esp_eap_ttls_phase2_types = 0;
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAPV2: esp_eap_ttls_phase2_types = 1;
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_MSCHAP: esp_eap_ttls_phase2_types = 2;
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_PAP: esp_eap_ttls_phase2_types = 3;
pub const esp_eap_ttls_phase2_types_ESP_EAP_TTLS_PHASE2_CHAP: esp_eap_ttls_phase2_types = 4;
pub type esp_eap_ttls_phase2_types = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_eap_fast_config {
    pub fast_provisioning: ::core::ffi::c_int,
    pub fast_max_pac_list_len: ::core::ffi::c_int,
    pub fast_pac_format_binary: bool,
}
extern "C" {
    #[doc = " @brief  Enable wpa2 enterprise authentication.\n\n @attention 1. wpa2 enterprise authentication can only be used when station mode is enabled.\n @attention 2. wpa2 enterprise authentication can only support TLS, PEAP-MSCHAPv2 and TTLS-MSCHAPv2 method.\n\n @return\n    - ESP_OK: succeed.\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable wpa2 enterprise authentication.\n\n @attention 1. wpa2 enterprise authentication can only be used when station mode is enabled.\n @attention 2. wpa2 enterprise authentication can only support TLS, PEAP-MSCHAPv2 and TTLS-MSCHAPv2 method.\n\n @return\n    - ESP_OK: succeed."]
    pub fn esp_wifi_sta_wpa2_ent_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set identity for PEAP/TTLS method.\n\n @attention The API only passes the parameter identity to the global pointer variable in wpa2 enterprise module.\n\n @param  identity: point to address where stores the identity;\n @param  len: length of identity, limited to 1~127\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: fail(len <= 0 or len >= 128)\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_identity(
        identity: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear identity for PEAP/TTLS method."]
    pub fn esp_wifi_sta_wpa2_ent_clear_identity();
}
extern "C" {
    #[doc = " @brief  Set username for PEAP/TTLS method.\n\n @attention The API only passes the parameter username to the global pointer variable in wpa2 enterprise module.\n\n @param  username: point to address where stores the username;\n @param  len: length of username, limited to 1~127\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: fail(len <= 0 or len >= 128)\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_username(
        username: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear username for PEAP/TTLS method."]
    pub fn esp_wifi_sta_wpa2_ent_clear_username();
}
extern "C" {
    #[doc = " @brief  Set password for PEAP/TTLS method..\n\n @attention The API only passes the parameter password to the global pointer variable in wpa2 enterprise module.\n\n @param  password: point to address where stores the password;\n @param  len: length of password(len > 0)\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: fail(len <= 0)\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_password(
        password: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear password for PEAP/TTLS method.."]
    pub fn esp_wifi_sta_wpa2_ent_clear_password();
}
extern "C" {
    #[doc = " @brief  Set new password for MSCHAPv2 method..\n\n @attention 1. The API only passes the parameter password to the global pointer variable in wpa2 enterprise module.\n @attention 2. The new password is used to substitute the old password when eap-mschapv2 failure request message with error code ERROR_PASSWD_EXPIRED is received.\n\n @param  new_password: point to address where stores the password;\n @param  len: length of password\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: fail(len <= 0)\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_new_password(
        new_password: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear new password for MSCHAPv2 method.."]
    pub fn esp_wifi_sta_wpa2_ent_clear_new_password();
}
extern "C" {
    #[doc = " @brief  Set CA certificate for PEAP/TTLS method.\n\n @attention 1. The API only passes the parameter ca_cert to the global pointer variable in wpa2 enterprise module.\n @attention 2. The ca_cert should be zero terminated.\n\n @param  ca_cert: point to address where stores the CA certificate;\n @param  ca_cert_len: length of ca_cert\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_ent_set_ca_cert(
        ca_cert: *const ::core::ffi::c_uchar,
        ca_cert_len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear CA certificate for PEAP/TTLS method."]
    pub fn esp_wifi_sta_wpa2_ent_clear_ca_cert();
}
extern "C" {
    #[doc = " @brief  Set client certificate and key.\n\n @attention 1. The API only passes the parameter client_cert, private_key and private_key_passwd to the global pointer variable in wpa2 enterprise module.\n @attention 2. The client_cert, private_key and private_key_passwd should be zero terminated.\n\n @param  client_cert: point to address where stores the client certificate;\n @param  client_cert_len: length of client certificate;\n @param  private_key: point to address where stores the private key;\n @param  private_key_len: length of private key, limited to 1~2048;\n @param  private_key_password: point to address where stores the private key password;\n @param  private_key_password_len: length of private key password;\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_ent_set_cert_key(
        client_cert: *const ::core::ffi::c_uchar,
        client_cert_len: ::core::ffi::c_int,
        private_key: *const ::core::ffi::c_uchar,
        private_key_len: ::core::ffi::c_int,
        private_key_passwd: *const ::core::ffi::c_uchar,
        private_key_passwd_len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear client certificate and key."]
    pub fn esp_wifi_sta_wpa2_ent_clear_cert_key();
}
extern "C" {
    #[doc = " @brief  Set wpa2 enterprise certs time check(disable or not).\n\n @param  true: disable wpa2 enterprise certs time check\n @param  false: enable wpa2 enterprise certs time check\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_ent_set_disable_time_check(disable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get wpa2 enterprise certs time check(disable or not).\n\n @param  disable: store disable value\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_ent_get_disable_time_check(disable: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set wpa2 enterprise ttls phase2 method\n\n @param  type: the type of phase 2 method to be used\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_ent_set_ttls_phase2_method(
        type_: esp_eap_ttls_phase2_types,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  enable/disable 192 bit suite b certification checks\n\n @param  enable: bool to enable/disable it.\n\n @return\n    - ESP_OK: succeed"]
    pub fn esp_wifi_sta_wpa2_set_suiteb_192bit_certification(enable: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set client pac file\n\n @attention  1. For files read from the file system, length has to be decremented by 1 byte.\n @attention  2. Disabling the WPA_MBEDTLS_CRYPTO config is required to use EAP-FAST.\n\n @param  pac_file: pointer to the pac file\n         pac_file_len: length of the pac file\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_pac_file(
        pac_file: *const ::core::ffi::c_uchar,
        pac_file_len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set Phase 1 parameters for EAP-FAST\n\n @attention  1. Disabling the WPA_MBEDTLS_CRYPTO config is required to use EAP-FAST.\n\n @param  config: eap fast phase 1 configuration\n\n @return\n    - ESP_OK: succeed\n    - ESP_ERR_INVALID_ARG: fail(out of bound arguments)\n    - ESP_ERR_NO_MEM: fail(internal memory malloc fail)"]
    pub fn esp_wifi_sta_wpa2_ent_set_fast_phase1_params(config: esp_eap_fast_config) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Use default CA cert bundle for server validation\n\n @use_default_bundle : whether to use bundle or not\n\n @return\n    - ESP_OK: succeed\n    - ESP_FAIL: fail"]
    pub fn esp_wifi_sta_wpa2_use_default_cert_bundle(use_default_bundle: bool) -> esp_err_t;
}
#[doc = " @brief  Callback function type to get neighbor report\n\n @param  ctx: neighbor report context\n @param  report: neighbor report\n @param  report_len: neighbor report length\n\n @return\n    - void"]
pub type neighbor_rep_request_cb = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, report: *const u8, report_len: usize),
>;
extern "C" {
    #[doc = " @brief  Send Radio measurement neighbor report request to connected AP\n\n @param  cb: callback function for neighbor report\n @param  cb_ctx: callback context\n\n @return\n    - 0: success\n    - -1: AP does not support RRM\n    - -2: station not connected to AP"]
    pub fn esp_rrm_send_neighbor_rep_request(
        cb: neighbor_rep_request_cb,
        cb_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief  Check RRM capability of connected AP\n\n @return\n    - true: AP supports RRM\n    - false: AP does not support RRM or station not connected to AP"]
    pub fn esp_rrm_is_rrm_supported_connection() -> bool;
}
pub const btm_query_reason_REASON_UNSPECIFIED: btm_query_reason = 0;
pub const btm_query_reason_REASON_FRAME_LOSS: btm_query_reason = 1;
pub const btm_query_reason_REASON_DELAY: btm_query_reason = 2;
pub const btm_query_reason_REASON_BANDWIDTH: btm_query_reason = 3;
pub const btm_query_reason_REASON_LOAD_BALANCE: btm_query_reason = 4;
pub const btm_query_reason_REASON_RSSI: btm_query_reason = 5;
pub const btm_query_reason_REASON_RETRANSMISSIONS: btm_query_reason = 6;
pub const btm_query_reason_REASON_INTERFERENCE: btm_query_reason = 7;
pub const btm_query_reason_REASON_GRAY_ZONE: btm_query_reason = 8;
pub const btm_query_reason_REASON_PREMIUM_AP: btm_query_reason = 9;
#[doc = " enum btm_query_reason: Reason code for sending btm query"]
pub type btm_query_reason = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief  Send bss transition query to connected AP\n\n @param  query_reason: reason for sending query\n @param  btm_candidates: btm candidates list if available\n @param  cand_list: whether candidate list to be included from scan results available in supplicant's cache.\n\n @return\n    - 0: success\n    - -1: AP does not support BTM\n    - -2: station not connected to AP"]
    pub fn esp_wnm_send_bss_transition_mgmt_query(
        query_reason: btm_query_reason,
        btm_candidates: *const ::core::ffi::c_char,
        cand_list: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief  Check bss trasition capability of connected AP\n\n @return\n    - true: AP supports BTM\n    - false: AP does not support BTM or station not connected to AP"]
    pub fn esp_wnm_is_btm_supported_connection() -> bool;
}
extern "C" {
    #[doc = " @brief     Supplicant initialization\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_NO_MEM : out of memory"]
    pub fn esp_supplicant_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Supplicant deinitialization\n\n @return\n          - ESP_OK : succeed\n          - others: failed"]
    pub fn esp_supplicant_deinit() -> esp_err_t;
}
pub const wps_type_WPS_TYPE_DISABLE: wps_type = 0;
pub const wps_type_WPS_TYPE_PBC: wps_type = 1;
pub const wps_type_WPS_TYPE_PIN: wps_type = 2;
pub const wps_type_WPS_TYPE_MAX: wps_type = 3;
pub type wps_type = ::core::ffi::c_uint;
pub use self::wps_type as wps_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wps_factory_information_t {
    #[doc = "< Manufacturer, null-terminated string. The default manufcturer is used if the string is empty"]
    pub manufacturer: [::core::ffi::c_char; 65usize],
    #[doc = "< Model number, null-terminated string. The default model number is used if the string is empty"]
    pub model_number: [::core::ffi::c_char; 33usize],
    #[doc = "< Model name, null-terminated string. The default model name is used if the string is empty"]
    pub model_name: [::core::ffi::c_char; 33usize],
    #[doc = "< Device name, null-terminated string. The default device name is used if the string is empty"]
    pub device_name: [::core::ffi::c_char; 33usize],
}
impl Default for wps_factory_information_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_wps_config_t {
    pub wps_type: wps_type_t,
    pub factory_info: wps_factory_information_t,
    pub pin: [::core::ffi::c_char; 9usize],
}
impl Default for esp_wps_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief     Enable Wi-Fi WPS function.\n\n @attention WPS can only be used when station is enabled.\n\n @param     wps_type_t wps_type : WPS type, so far only WPS_TYPE_PBC and WPS_TYPE_PIN is supported\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_TYPE : wps type is invalid\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on\n          - ESP_FAIL : wps initialization fails"]
    pub fn esp_wifi_wps_enable(config: *const esp_wps_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable Wi-Fi WPS function and release resource it taken.\n\n @param  null\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on"]
    pub fn esp_wifi_wps_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     WPS starts to work.\n\n @attention WPS can only be used when station is enabled.\n\n @param     timeout_ms : maximum blocking time before API return.\n          - 0 : non-blocking\n          - 1~120000 : blocking time (not supported in IDF v1.0)\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_TYPE : wps type is invalid\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on\n          - ESP_ERR_WIFI_WPS_SM : wps state machine is not initialized\n          - ESP_FAIL : wps initialization fails"]
    pub fn esp_wifi_wps_start(timeout_ms: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable Wi-Fi AP WPS function.\n\n @attention WPS can only be used when softAP is enabled.\n\n @param     esp_wps_config_t config: wps configuration to be used.\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_TYPE : wps type is invalid\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on\n          - ESP_FAIL : wps initialization fails"]
    pub fn esp_wifi_ap_wps_enable(config: *const esp_wps_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable Wi-Fi SoftAP WPS function and release resource it taken.\n\n @param  null\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on"]
    pub fn esp_wifi_ap_wps_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     WPS starts to work.\n\n @attention WPS can only be used when softAP is enabled.\n\n @param  pin : Pin to be used in case of WPS mode is pin.\n               If Pin is not provided, device will use the pin generated/provided\n               during esp_wifi_ap_wps_enable() and reported in WIFI_EVENT_AP_WPS_RG_PIN\n\n @return\n          - ESP_OK : succeed\n          - ESP_ERR_WIFI_WPS_TYPE : wps type is invalid\n          - ESP_ERR_WIFI_WPS_MODE : wifi is not in station mode or sniffer mode is on\n          - ESP_ERR_WIFI_WPS_SM : wps state machine is not initialized\n          - ESP_FAIL : wps initialization fails"]
    pub fn esp_wifi_ap_wps_start(pin: *const ::core::ffi::c_uchar) -> esp_err_t;
}
#[doc = "< Reduced Media Independent Interface"]
pub const eth_data_interface_t_EMAC_DATA_INTERFACE_RMII: eth_data_interface_t = 0;
#[doc = "< Media Independent Interface"]
pub const eth_data_interface_t_EMAC_DATA_INTERFACE_MII: eth_data_interface_t = 1;
#[doc = " @brief Ethernet interface"]
pub type eth_data_interface_t = ::core::ffi::c_uint;
#[doc = "< Ethernet link is up"]
pub const eth_link_t_ETH_LINK_UP: eth_link_t = 0;
#[doc = "< Ethernet link is down"]
pub const eth_link_t_ETH_LINK_DOWN: eth_link_t = 1;
#[doc = " @brief Ethernet link status"]
pub type eth_link_t = ::core::ffi::c_uint;
#[doc = "< Ethernet speed is 10Mbps"]
pub const eth_speed_t_ETH_SPEED_10M: eth_speed_t = 0;
#[doc = "< Ethernet speed is 100Mbps"]
pub const eth_speed_t_ETH_SPEED_100M: eth_speed_t = 1;
#[doc = "< Max speed mode (for checking purpose)"]
pub const eth_speed_t_ETH_SPEED_MAX: eth_speed_t = 2;
#[doc = " @brief Ethernet speed"]
pub type eth_speed_t = ::core::ffi::c_uint;
#[doc = "< Ethernet is in half duplex"]
pub const eth_duplex_t_ETH_DUPLEX_HALF: eth_duplex_t = 0;
#[doc = "< Ethernet is in full duplex"]
pub const eth_duplex_t_ETH_DUPLEX_FULL: eth_duplex_t = 1;
#[doc = " @brief Ethernet duplex mode"]
pub type eth_duplex_t = ::core::ffi::c_uint;
#[doc = "< Ethernet checksum calculate by software"]
pub const eth_checksum_t_ETH_CHECKSUM_SW: eth_checksum_t = 0;
#[doc = "< Ethernet checksum calculate by hardware"]
pub const eth_checksum_t_ETH_CHECKSUM_HW: eth_checksum_t = 1;
#[doc = " @brief Ethernet Checksum"]
pub type eth_checksum_t = ::core::ffi::c_uint;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_32: eth_mac_dma_burst_len_t = 0;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_16: eth_mac_dma_burst_len_t = 1;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_8: eth_mac_dma_burst_len_t = 2;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_4: eth_mac_dma_burst_len_t = 3;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_2: eth_mac_dma_burst_len_t = 4;
pub const eth_mac_dma_burst_len_t_ETH_DMA_BURST_LEN_1: eth_mac_dma_burst_len_t = 5;
#[doc = " @brief Internal ethernet EMAC's DMA available burst sizes"]
pub type eth_mac_dma_burst_len_t = ::core::ffi::c_uint;
#[doc = "< Lowlevel init done"]
pub const esp_eth_state_t_ETH_STATE_LLINIT: esp_eth_state_t = 0;
#[doc = "< Deinit done"]
pub const esp_eth_state_t_ETH_STATE_DEINIT: esp_eth_state_t = 1;
#[doc = "< Link status changed"]
pub const esp_eth_state_t_ETH_STATE_LINK: esp_eth_state_t = 2;
#[doc = "< Speed updated"]
pub const esp_eth_state_t_ETH_STATE_SPEED: esp_eth_state_t = 3;
#[doc = "< Duplex updated"]
pub const esp_eth_state_t_ETH_STATE_DUPLEX: esp_eth_state_t = 4;
#[doc = "< Pause ability updated"]
pub const esp_eth_state_t_ETH_STATE_PAUSE: esp_eth_state_t = 5;
#[doc = " @brief Ethernet driver state"]
pub type esp_eth_state_t = ::core::ffi::c_uint;
#[doc = " @brief Ethernet mediator"]
pub type esp_eth_mediator_t = esp_eth_mediator_s;
#[doc = " @brief Ethernet mediator"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_eth_mediator_s {
    #[doc = " @brief Read PHY register\n\n @param[in] eth: mediator of Ethernet driver\n @param[in] phy_addr: PHY Chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[out] reg_value: PHY register value\n\n @return\n       - ESP_OK: read PHY register successfully\n       - ESP_FAIL: read PHY register failed because some error occurred\n"]
    pub phy_reg_read: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Write PHY register\n\n @param[in] eth: mediator of Ethernet driver\n @param[in] phy_addr: PHY Chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[in] reg_value: PHY register value\n\n @return\n       - ESP_OK: write PHY register successfully\n       - ESP_FAIL: write PHY register failed because some error occurred"]
    pub phy_reg_write: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Deliver packet to upper stack\n\n @param[in] eth: mediator of Ethernet driver\n @param[in] buffer: packet buffer\n @param[in] length: length of the packet\n\n @return\n       - ESP_OK: deliver packet to upper stack successfully\n       - ESP_FAIL: deliver packet failed because some error occurred\n"]
    pub stack_input: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            buffer: *mut u8,
            length: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Callback on Ethernet state changed\n\n @param[in] eth: mediator of Ethernet driver\n @param[in] state: new state\n @param[in] args: optional argument for the new state\n\n @return\n       - ESP_OK: process the new state successfully\n       - ESP_FAIL: process the new state failed because some error occurred\n"]
    pub on_state_changed: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            state: esp_eth_state_t,
            args: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
}
#[doc = "< Ethernet driver start"]
pub const eth_event_t_ETHERNET_EVENT_START: eth_event_t = 0;
#[doc = "< Ethernet driver stop"]
pub const eth_event_t_ETHERNET_EVENT_STOP: eth_event_t = 1;
#[doc = "< Ethernet got a valid link"]
pub const eth_event_t_ETHERNET_EVENT_CONNECTED: eth_event_t = 2;
#[doc = "< Ethernet lost a valid link"]
pub const eth_event_t_ETHERNET_EVENT_DISCONNECTED: eth_event_t = 3;
#[doc = " @brief Ethernet event declarations"]
pub type eth_event_t = ::core::ffi::c_uint;
extern "C" {
    pub static mut ETH_EVENT: esp_event_base_t;
}
#[doc = "< SPI1"]
pub const spi_host_device_t_SPI1_HOST: spi_host_device_t = 0;
#[doc = "< SPI2"]
pub const spi_host_device_t_SPI2_HOST: spi_host_device_t = 1;
#[doc = "< invalid host value"]
pub const spi_host_device_t_SPI_HOST_MAX: spi_host_device_t = 2;
#[doc = " @brief Enum with the three SPI peripherals that are software-accessible in it"]
pub type spi_host_device_t = ::core::ffi::c_uint;
#[doc = "< Select APB as the source clock"]
pub const spi_clock_source_t_SPI_CLK_APB: spi_clock_source_t = 0;
#[doc = "< Select XTAL as the source clock"]
pub const spi_clock_source_t_SPI_CLK_XTAL: spi_clock_source_t = 1;
pub type spi_clock_source_t = ::core::ffi::c_uint;
#[doc = "< The buffer has sent data to master."]
pub const spi_event_t_SPI_EV_BUF_TX: spi_event_t = 1;
#[doc = "< The buffer has received data from master."]
pub const spi_event_t_SPI_EV_BUF_RX: spi_event_t = 2;
#[doc = "< Slave has loaded its TX data buffer to the hardware (DMA)."]
pub const spi_event_t_SPI_EV_SEND_DMA_READY: spi_event_t = 4;
#[doc = "< Master has received certain number of the data, the number is determined by Master."]
pub const spi_event_t_SPI_EV_SEND: spi_event_t = 8;
#[doc = "< Slave has loaded its RX data buffer to the hardware (DMA)."]
pub const spi_event_t_SPI_EV_RECV_DMA_READY: spi_event_t = 16;
#[doc = "< Slave has received certain number of data from master, the number is determined by Master."]
pub const spi_event_t_SPI_EV_RECV: spi_event_t = 32;
#[doc = "< Received CMD9 from master."]
pub const spi_event_t_SPI_EV_CMD9: spi_event_t = 64;
#[doc = "< Received CMDA from master."]
pub const spi_event_t_SPI_EV_CMDA: spi_event_t = 128;
#[doc = "< A transaction has done"]
pub const spi_event_t_SPI_EV_TRANS: spi_event_t = 256;
#[doc = " SPI Events"]
pub type spi_event_t = ::core::ffi::c_uint;
#[doc = " @brief Line mode of SPI transaction phases: CMD, ADDR, DOUT/DIN."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_line_mode_t {
    #[doc = "< The line width of command phase, e.g. 2-line-cmd-phase."]
    pub cmd_lines: u8,
    #[doc = "< The line width of address phase, e.g. 1-line-addr-phase."]
    pub addr_lines: u8,
    #[doc = "< The line width of data phase, e.g. 4-line-data-phase."]
    pub data_lines: u8,
}
pub const spi_command_t_SPI_CMD_HD_WRBUF: spi_command_t = 1;
pub const spi_command_t_SPI_CMD_HD_RDBUF: spi_command_t = 2;
pub const spi_command_t_SPI_CMD_HD_WRDMA: spi_command_t = 4;
pub const spi_command_t_SPI_CMD_HD_RDDMA: spi_command_t = 8;
pub const spi_command_t_SPI_CMD_HD_SEG_END: spi_command_t = 16;
pub const spi_command_t_SPI_CMD_HD_EN_QPI: spi_command_t = 32;
pub const spi_command_t_SPI_CMD_HD_WR_END: spi_command_t = 64;
pub const spi_command_t_SPI_CMD_HD_INT0: spi_command_t = 128;
pub const spi_command_t_SPI_CMD_HD_INT1: spi_command_t = 256;
pub const spi_command_t_SPI_CMD_HD_INT2: spi_command_t = 512;
#[doc = " @brief SPI command."]
pub type spi_command_t = ::core::ffi::c_uint;
#[doc = "< Do not enable DMA for SPI"]
pub const spi_common_dma_t_SPI_DMA_DISABLED: spi_common_dma_t = 0;
#[doc = "< Enable DMA, channel is automatically selected by driver"]
pub const spi_common_dma_t_SPI_DMA_CH_AUTO: spi_common_dma_t = 3;
#[doc = " @brief SPI DMA channels"]
pub type spi_common_dma_t = ::core::ffi::c_uint;
#[doc = " @brief SPI DMA channels"]
pub use self::spi_common_dma_t as spi_dma_chan_t;
#[doc = " @brief This is a configuration structure for a SPI bus.\n\n You can use this structure to specify the GPIO pins of the bus. Normally, the driver will use the\n GPIO matrix to route the signals. An exception is made when all signals either can be routed through\n the IO_MUX or are -1. In that case, the IO_MUX is used, allowing for >40MHz speeds.\n\n @note Be advised that the slave driver does not use the quadwp/quadhd lines and fields in spi_bus_config_t refering to these lines will be ignored and can thus safely be left uninitialized."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_bus_config_t {
    pub __bindgen_anon_1: spi_bus_config_t__bindgen_ty_1,
    pub __bindgen_anon_2: spi_bus_config_t__bindgen_ty_2,
    #[doc = "< GPIO pin for SPI Clock signal, or -1 if not used."]
    pub sclk_io_num: ::core::ffi::c_int,
    pub __bindgen_anon_3: spi_bus_config_t__bindgen_ty_3,
    pub __bindgen_anon_4: spi_bus_config_t__bindgen_ty_4,
    #[doc = "< GPIO pin for spi data4 signal in octal mode, or -1 if not used."]
    pub data4_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data5 signal in octal mode, or -1 if not used."]
    pub data5_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data6 signal in octal mode, or -1 if not used."]
    pub data6_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data7 signal in octal mode, or -1 if not used."]
    pub data7_io_num: ::core::ffi::c_int,
    #[doc = "< Maximum transfer size, in bytes. Defaults to 4092 if 0 when DMA enabled, or to `SOC_SPI_MAXIMUM_BUFFER_SIZE` if DMA is disabled."]
    pub max_transfer_sz: ::core::ffi::c_int,
    #[doc = "< Abilities of bus to be checked by the driver. Or-ed value of ``SPICOMMON_BUSFLAG_*`` flags."]
    pub flags: u32,
    #[doc = "< Interrupt flag for the bus to set the priority, and IRAM attribute, see\n  ``esp_intr_alloc.h``. Note that the EDGE, INTRDISABLED attribute are ignored\n  by the driver. Note that if ESP_INTR_FLAG_IRAM is set, ALL the callbacks of\n  the driver, and their callee functions, should be put in the IRAM."]
    pub intr_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_bus_config_t__bindgen_ty_1 {
    #[doc = "< GPIO pin for Master Out Slave In (=spi_d) signal, or -1 if not used."]
    pub mosi_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data0 signal in quad/octal mode, or -1 if not used."]
    pub data0_io_num: ::core::ffi::c_int,
}
impl Default for spi_bus_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_bus_config_t__bindgen_ty_2 {
    #[doc = "< GPIO pin for Master In Slave Out (=spi_q) signal, or -1 if not used."]
    pub miso_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data1 signal in quad/octal mode, or -1 if not used."]
    pub data1_io_num: ::core::ffi::c_int,
}
impl Default for spi_bus_config_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_bus_config_t__bindgen_ty_3 {
    #[doc = "< GPIO pin for WP (Write Protect) signal, or -1 if not used."]
    pub quadwp_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data2 signal in quad/octal mode, or -1 if not used."]
    pub data2_io_num: ::core::ffi::c_int,
}
impl Default for spi_bus_config_t__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_bus_config_t__bindgen_ty_4 {
    #[doc = "< GPIO pin for HD (Hold) signal, or -1 if not used."]
    pub quadhd_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO pin for spi data3 signal in quad/octal mode, or -1 if not used."]
    pub data3_io_num: ::core::ffi::c_int,
}
impl Default for spi_bus_config_t__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for spi_bus_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize a SPI bus\n\n @warning SPI0/1 is not supported\n\n @param host_id       SPI peripheral that controls this bus\n @param bus_config    Pointer to a spi_bus_config_t struct specifying how the host should be initialized\n @param dma_chan      - Selecting a DMA channel for an SPI bus allows transactions on the bus with size only limited by the amount of internal memory.\n                      - Selecting SPI_DMA_DISABLED limits the size of transactions.\n                      - Set to SPI_DMA_DISABLED if only the SPI flash uses this bus.\n                      - Set to SPI_DMA_CH_AUTO to let the driver to allocate the DMA channel.\n\n @warning If a DMA channel is selected, any transmit and receive buffer used should be allocated in\n          DMA-capable memory.\n\n @warning The ISR of SPI is always executed on the core which calls this\n          function. Never starve the ISR on this core or the SPI transactions will not\n          be handled.\n\n @return\n         - ESP_ERR_INVALID_ARG   if configuration is invalid\n         - ESP_ERR_INVALID_STATE if host already is in use\n         - ESP_ERR_NOT_FOUND     if there is no available DMA channel\n         - ESP_ERR_NO_MEM        if out of memory\n         - ESP_OK                on success"]
    pub fn spi_bus_initialize(
        host_id: spi_host_device_t,
        bus_config: *const spi_bus_config_t,
        dma_chan: spi_dma_chan_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free a SPI bus\n\n @warning In order for this to succeed, all devices have to be removed first.\n\n @param host_id SPI peripheral to free\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_INVALID_STATE if bus hasn't been initialized before, or not all devices on the bus are freed\n         - ESP_OK                on success"]
    pub fn spi_bus_free(host_id: spi_host_device_t) -> esp_err_t;
}
pub type transaction_cb_t =
    ::core::option::Option<unsafe extern "C" fn(trans: *mut spi_transaction_t)>;
#[doc = " @brief This is a configuration for a SPI slave device that is connected to one of the SPI buses."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_device_interface_config_t {
    #[doc = "< Default amount of bits in command phase (0-16), used when ``SPI_TRANS_VARIABLE_CMD`` is not used, otherwise ignored."]
    pub command_bits: u8,
    #[doc = "< Default amount of bits in address phase (0-64), used when ``SPI_TRANS_VARIABLE_ADDR`` is not used, otherwise ignored."]
    pub address_bits: u8,
    #[doc = "< Amount of dummy bits to insert between address and data phase"]
    pub dummy_bits: u8,
    #[doc = "< SPI mode, representing a pair of (CPOL, CPHA) configuration:\n- 0: (0, 0)\n- 1: (0, 1)\n- 2: (1, 0)\n- 3: (1, 1)"]
    pub mode: u8,
    #[doc = "< Duty cycle of positive clock, in 1/256th increments (128 = 50%/50% duty). Setting this to 0 (=not setting it) is equivalent to setting this to 128."]
    pub duty_cycle_pos: u16,
    #[doc = "< Amount of SPI bit-cycles the cs should be activated before the transmission (0-16). This only works on half-duplex transactions."]
    pub cs_ena_pretrans: u16,
    #[doc = "< Amount of SPI bit-cycles the cs should stay active after the transmission (0-16)"]
    pub cs_ena_posttrans: u8,
    #[doc = "< Clock speed, divisors of 80MHz, in Hz. See ``SPI_MASTER_FREQ_*``."]
    pub clock_speed_hz: ::core::ffi::c_int,
    #[doc = "< Maximum data valid time of slave. The time required between SCLK and MISO\nvalid, including the possible clock delay from slave to master. The driver uses this value to give an extra\ndelay before the MISO is ready on the line. Leave at 0 unless you know you need a delay. For better timing\nperformance at high frequency (over 8MHz), it's suggest to have the right value."]
    pub input_delay_ns: ::core::ffi::c_int,
    #[doc = "< CS GPIO pin for this device, or -1 if not used"]
    pub spics_io_num: ::core::ffi::c_int,
    #[doc = "< Bitwise OR of SPI_DEVICE_* flags"]
    pub flags: u32,
    #[doc = "< Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_device_queue_trans but not yet finished using spi_device_get_trans_result) at the same time"]
    pub queue_size: ::core::ffi::c_int,
    #[doc = "< Callback to be called before a transmission is started.\n\n  This callback is called within interrupt\n  context should be in IRAM for best\n  performance, see \"Transferring Speed\"\n  section in the SPI Master documentation for\n  full details. If not, the callback may crash\n  during flash operation when the driver is\n  initialized with ESP_INTR_FLAG_IRAM."]
    pub pre_cb: transaction_cb_t,
    #[doc = "< Callback to be called after a transmission has completed.\n\n  This callback is called within interrupt\n  context should be in IRAM for best\n  performance, see \"Transferring Speed\"\n  section in the SPI Master documentation for\n  full details. If not, the callback may crash\n  during flash operation when the driver is\n  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_cb: transaction_cb_t,
}
#[doc = " This structure describes one SPI transaction. The descriptor should not be modified until the transaction finishes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_t {
    #[doc = "< Bitwise OR of SPI_TRANS_* flags"]
    pub flags: u32,
    #[doc = "< Command data, of which the length is set in the ``command_bits`` of spi_device_interface_config_t.\n\n  <b>NOTE: this field, used to be \"command\" in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF 3.0.</b>\n\n  Example: write 0x0123 and command_bits=12 to send command 0x12, 0x3_ (in previous version, you may have to write 0x3_12)."]
    pub cmd: u16,
    #[doc = "< Address data, of which the length is set in the ``address_bits`` of spi_device_interface_config_t.\n\n  <b>NOTE: this field, used to be \"address\" in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF3.0.</b>\n\n  Example: write 0x123400 and address_bits=24 to send address of 0x12, 0x34, 0x00 (in previous version, you may have to write 0x12340000)."]
    pub addr: u64,
    #[doc = "< Total data length, in bits"]
    pub length: usize,
    #[doc = "< Total data length received, should be not greater than ``length`` in full-duplex mode (0 defaults this to the value of ``length``)."]
    pub rxlength: usize,
    #[doc = "< User-defined variable. Can be used to store eg transaction ID."]
    pub user: *mut ::core::ffi::c_void,
    pub __bindgen_anon_1: spi_transaction_t__bindgen_ty_1,
    pub __bindgen_anon_2: spi_transaction_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_1 {
    #[doc = "< Pointer to transmit buffer, or NULL for no MOSI phase"]
    pub tx_buffer: *const ::core::ffi::c_void,
    #[doc = "< If SPI_TRANS_USE_TXDATA is set, data set here is sent directly from this variable."]
    pub tx_data: [u8; 4usize],
}
impl Default for spi_transaction_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_2 {
    #[doc = "< Pointer to receive buffer, or NULL for no MISO phase. Written by 4 bytes-unit if DMA is used."]
    pub rx_buffer: *mut ::core::ffi::c_void,
    #[doc = "< If SPI_TRANS_USE_RXDATA is set, data is received directly to this variable"]
    pub rx_data: [u8; 4usize],
}
impl Default for spi_transaction_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for spi_transaction_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This struct is for SPI transactions which may change their address and command length.\n Please do set the flags in base to ``SPI_TRANS_VARIABLE_CMD_ADR`` to use the bit length here."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_ext_t {
    #[doc = "< Transaction data, so that pointer to spi_transaction_t can be converted into spi_transaction_ext_t"]
    pub base: spi_transaction_t,
    #[doc = "< The command length in this transaction, in bits."]
    pub command_bits: u8,
    #[doc = "< The address length in this transaction, in bits."]
    pub address_bits: u8,
    #[doc = "< The dummy length in this transaction, in bits."]
    pub dummy_bits: u8,
}
impl Default for spi_transaction_ext_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_device_t {
    _unused: [u8; 0],
}
pub type spi_device_handle_t = *mut spi_device_t;
extern "C" {
    #[doc = " @brief Allocate a device on a SPI bus\n\n This initializes the internal structures for a device, plus allocates a CS pin on the indicated SPI master\n peripheral and routes it to the indicated GPIO. All SPI master devices have three CS pins and can thus control\n up to three devices.\n\n @note While in general, speeds up to 80MHz on the dedicated SPI pins and 40MHz on GPIO-matrix-routed pins are\n       supported, full-duplex transfers routed over the GPIO matrix only support speeds up to 26MHz.\n\n @param host_id SPI peripheral to allocate device on\n @param dev_config SPI interface protocol config for the device\n @param handle Pointer to variable to hold the device handle\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_NOT_FOUND     if host doesn't have any free CS slots\n         - ESP_ERR_NO_MEM        if out of memory\n         - ESP_OK                on success"]
    pub fn spi_bus_add_device(
        host_id: spi_host_device_t,
        dev_config: *const spi_device_interface_config_t,
        handle: *mut spi_device_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove a device from the SPI bus\n\n @param handle Device handle to free\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_INVALID_STATE if device already is freed\n         - ESP_OK                on success"]
    pub fn spi_bus_remove_device(handle: spi_device_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a SPI transaction for interrupt transaction execution. Get the result by ``spi_device_get_trans_result``.\n\n @note Normally a device cannot start (queue) polling and interrupt\n      transactions simultaneously.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param trans_desc Description of transaction to execute\n @param ticks_to_wait Ticks to wait until there's room in the queue; use portMAX_DELAY to\n                      never time out.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid. This can happen if SPI_TRANS_CS_KEEP_ACTIVE flag is specified while\n                                 the bus was not acquired (`spi_device_acquire_bus()` should be called first)\n         - ESP_ERR_TIMEOUT       if there was no room in the queue before ticks_to_wait expired\n         - ESP_ERR_NO_MEM        if allocating DMA-capable temporary buffer failed\n         - ESP_ERR_INVALID_STATE if previous transactions are not finished\n         - ESP_OK                on success"]
    pub fn spi_device_queue_trans(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the result of a SPI transaction queued earlier by ``spi_device_queue_trans``.\n\n This routine will wait until a transaction to the given device\n succesfully completed. It will then return the description of the\n completed transaction so software can inspect the result and e.g. free the memory or\n re-use the buffers.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param trans_desc Pointer to variable able to contain a pointer to the description of the transaction\nthat is executed. The descriptor should not be modified until the descriptor is returned by\nspi_device_get_trans_result.\n @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time\nout.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_TIMEOUT       if there was no completed transaction before ticks_to_wait expired\n         - ESP_OK                on success"]
    pub fn spi_device_get_trans_result(
        handle: spi_device_handle_t,
        trans_desc: *mut *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send a SPI transaction, wait for it to complete, and return the result\n\n This function is the equivalent of calling spi_device_queue_trans() followed by spi_device_get_trans_result().\n Do not use this when there is still a transaction separately queued (started) from spi_device_queue_trans() or polling_start/transmit that hasn't been finalized.\n\n @note This function is not thread safe when multiple tasks access the same SPI device.\n      Normally a device cannot start (queue) polling and interrupt\n      transactions simutanuously.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param trans_desc Description of transaction to execute\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_OK                on success"]
    pub fn spi_device_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Immediately start a polling transaction.\n\n @note Normally a device cannot start (queue) polling and interrupt\n      transactions simutanuously. Moreover, a device cannot start a new polling\n      transaction if another polling transaction is not finished.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param trans_desc Description of transaction to execute\n @param ticks_to_wait Ticks to wait until there's room in the queue;\n              currently only portMAX_DELAY is supported.\n\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid. This can happen if SPI_TRANS_CS_KEEP_ACTIVE flag is specified while\n                                 the bus was not acquired (`spi_device_acquire_bus()` should be called first)\n         - ESP_ERR_TIMEOUT       if the device cannot get control of the bus before ``ticks_to_wait`` expired\n         - ESP_ERR_NO_MEM        if allocating DMA-capable temporary buffer failed\n         - ESP_ERR_INVALID_STATE if previous transactions are not finished\n         - ESP_OK                on success"]
    pub fn spi_device_polling_start(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Poll until the polling transaction ends.\n\n This routine will not return until the transaction to the given device has\n succesfully completed. The task is not blocked, but actively busy-spins for\n the transaction to be completed.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time\nout.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_TIMEOUT       if the transaction cannot finish before ticks_to_wait expired\n         - ESP_OK                on success"]
    pub fn spi_device_polling_end(
        handle: spi_device_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send a polling transaction, wait for it to complete, and return the result\n\n This function is the equivalent of calling spi_device_polling_start() followed by spi_device_polling_end().\n Do not use this when there is still a transaction that hasn't been finalized.\n\n @note This function is not thread safe when multiple tasks access the same SPI device.\n      Normally a device cannot start (queue) polling and interrupt\n      transactions simutanuously.\n\n @param handle Device handle obtained using spi_host_add_dev\n @param trans_desc Description of transaction to execute\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_OK                on success"]
    pub fn spi_device_polling_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Occupy the SPI bus for a device to do continuous transactions.\n\n Transactions to all other devices will be put off until ``spi_device_release_bus`` is called.\n\n @note The function will wait until all the existing transactions have been sent.\n\n @param device The device to occupy the bus.\n @param wait Time to wait before the the bus is occupied by the device. Currently MUST set to portMAX_DELAY.\n\n @return\n      - ESP_ERR_INVALID_ARG : ``wait`` is not set to portMAX_DELAY.\n      - ESP_OK : Success."]
    pub fn spi_device_acquire_bus(device: spi_device_handle_t, wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release the SPI bus occupied by the device. All other devices can start sending transactions.\n\n @param dev The device to release the bus."]
    pub fn spi_device_release_bus(dev: spi_device_handle_t);
}
extern "C" {
    #[doc = " @brief Calculate the working frequency that is most close to desired frequency.\n\n @param fapb The frequency of apb clock, should be ``APB_CLK_FREQ``.\n @param hz Desired working frequency\n @param duty_cycle Duty cycle of the spi clock\n\n @return Actual working frequency that most fit."]
    pub fn spi_get_actual_clock(
        fapb: ::core::ffi::c_int,
        hz: ::core::ffi::c_int,
        duty_cycle: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Calculate the timing settings of specified frequency and settings.\n\n @param gpio_is_used True if using GPIO matrix, or False if iomux pins are used.\n @param input_delay_ns Input delay from SCLK launch edge to MISO data valid.\n @param eff_clk Effective clock frequency (in Hz) from `spi_get_actual_clock()`.\n @param dummy_o Address of dummy bits used output. Set to NULL if not needed.\n @param cycles_remain_o Address of cycles remaining (after dummy bits are used) output.\n         - -1 If too many cycles remaining, suggest to compensate half a clock.\n         - 0 If no remaining cycles or dummy bits are not used.\n         - positive value: cycles suggest to compensate.\n\n @note If **dummy_o* is not zero, it means dummy bits should be applied in half duplex mode, and full duplex mode may not work."]
    pub fn spi_get_timing(
        gpio_is_used: bool,
        input_delay_ns: ::core::ffi::c_int,
        eff_clk: ::core::ffi::c_int,
        dummy_o: *mut ::core::ffi::c_int,
        cycles_remain_o: *mut ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get the frequency limit of current configurations.\n         SPI master working at this limit is OK, while above the limit, full duplex mode and DMA will not work,\n         and dummy bits will be aplied in the half duplex mode.\n\n @param gpio_is_used True if using GPIO matrix, or False if native pins are used.\n @param input_delay_ns Input delay from SCLK launch edge to MISO data valid.\n @return Frequency limit of current configurations."]
    pub fn spi_get_freq_limit(
        gpio_is_used: bool,
        input_delay_ns: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
#[doc = " @brief Ethernet MAC"]
pub type esp_eth_mac_t = esp_eth_mac_s;
#[doc = " @brief Ethernet MAC"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_eth_mac_s {
    #[doc = " @brief Set mediator for Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[in] eth: Ethernet mediator\n\n @return\n      - ESP_OK: set mediator for Ethernet MAC successfully\n      - ESP_ERR_INVALID_ARG: set mediator for Ethernet MAC failed because of invalid argument\n"]
    pub set_mediator: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, eth: *mut esp_eth_mediator_t) -> esp_err_t,
    >,
    #[doc = " @brief Initialize Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n\n @return\n      - ESP_OK: initialize Ethernet MAC successfully\n      - ESP_ERR_TIMEOUT: initialize Ethernet MAC failed because of timeout\n      - ESP_FAIL: initialize Ethernet MAC failed because some other error occurred\n"]
    pub init: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Deinitialize Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n\n @return\n      - ESP_OK: deinitialize Ethernet MAC successfully\n      - ESP_FAIL: deinitialize Ethernet MAC failed because some error occurred\n"]
    pub deinit: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Start Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n\n @return\n      - ESP_OK: start Ethernet MAC successfully\n      - ESP_FAIL: start Ethernet MAC failed because some other error occurred\n"]
    pub start: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Stop Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n\n @return\n      - ESP_OK: stop Ethernet MAC successfully\n      - ESP_FAIL: stop Ethernet MAC failed because some error occurred\n"]
    pub stop: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Transmit packet from Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[in] buf: packet buffer to transmit\n @param[in] length: length of packet\n\n @return\n      - ESP_OK: transmit packet successfully\n      - ESP_ERR_INVALID_SIZE: number of actually sent bytes differs to expected\n      - ESP_FAIL: transmit packet failed because some other error occurred\n\n @note Returned error codes may differ for each specific MAC chip.\n"]
    pub transmit: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, buf: *mut u8, length: u32) -> esp_err_t,
    >,
    #[doc = " @brief Transmit packet from Ethernet MAC constructed with special parameters at Layer2.\n\n @param[in] mac: Ethernet MAC instance\n @param[in] argc: number variable arguments\n @param[in] args: variable arguments\n\n @note Typical intended use case is to make possible to construct a frame from multiple higher layer\n       buffers without a need of buffer reallocations. However, other use cases are not limited.\n\n @return\n      - ESP_OK: transmit packet successfully\n      - ESP_ERR_INVALID_SIZE: number of actually sent bytes differs to expected\n      - ESP_FAIL: transmit packet failed because some other error occurred\n\n @note Returned error codes may differ for each specific MAC chip.\n"]
    pub transmit_vargs: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, argc: u32, args: va_list) -> esp_err_t,
    >,
    #[doc = " @brief Receive packet from Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[out] buf: packet buffer which will preserve the received frame\n @param[out] length: length of the received packet\n\n @note Memory of buf is allocated in the Layer2, make sure it get free after process.\n @note Before this function got invoked, the value of \"length\" should set by user, equals the size of buffer.\n       After the function returned, the value of \"length\" means the real length of received data.\n\n @return\n      - ESP_OK: receive packet successfully\n      - ESP_ERR_INVALID_ARG: receive packet failed because of invalid argument\n      - ESP_ERR_INVALID_SIZE: input buffer size is not enough to hold the incoming data.\n                              in this case, value of returned \"length\" indicates the real size of incoming data.\n      - ESP_FAIL: receive packet failed because some other error occurred\n"]
    pub receive: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, buf: *mut u8, length: *mut u32) -> esp_err_t,
    >,
    #[doc = " @brief Read PHY register\n\n @param[in] mac: Ethernet MAC instance\n @param[in] phy_addr: PHY chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[out] reg_value: PHY register value\n\n @return\n      - ESP_OK: read PHY register successfully\n      - ESP_ERR_INVALID_ARG: read PHY register failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: read PHY register failed because of wrong state of MAC\n      - ESP_ERR_TIMEOUT: read PHY register failed because of timeout\n      - ESP_FAIL: read PHY register failed because some other error occurred\n"]
    pub read_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            mac: *mut esp_eth_mac_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Write PHY register\n\n @param[in] mac: Ethernet MAC instance\n @param[in] phy_addr: PHY chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[in] reg_value: PHY register value\n\n @return\n      - ESP_OK: write PHY register successfully\n      - ESP_ERR_INVALID_STATE: write PHY register failed because of wrong state of MAC\n      - ESP_ERR_TIMEOUT: write PHY register failed because of timeout\n      - ESP_FAIL: write PHY register failed because some other error occurred\n"]
    pub write_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            mac: *mut esp_eth_mac_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Set MAC address\n\n @param[in] mac: Ethernet MAC instance\n @param[in] addr: MAC address\n\n @return\n      - ESP_OK: set MAC address successfully\n      - ESP_ERR_INVALID_ARG: set MAC address failed because of invalid argument\n      - ESP_FAIL: set MAC address failed because some other error occurred\n"]
    pub set_addr: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, addr: *mut u8) -> esp_err_t,
    >,
    #[doc = " @brief Get MAC address\n\n @param[in] mac: Ethernet MAC instance\n @param[out] addr: MAC address\n\n @return\n      - ESP_OK: get MAC address successfully\n      - ESP_ERR_INVALID_ARG: get MAC address failed because of invalid argument\n      - ESP_FAIL: get MAC address failed because some other error occurred\n"]
    pub get_addr: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, addr: *mut u8) -> esp_err_t,
    >,
    #[doc = " @brief Set speed of MAC\n\n @param[in] ma:c Ethernet MAC instance\n @param[in] speed: MAC speed\n\n @return\n      - ESP_OK: set MAC speed successfully\n      - ESP_ERR_INVALID_ARG: set MAC speed failed because of invalid argument\n      - ESP_FAIL: set MAC speed failed because some other error occurred\n"]
    pub set_speed: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, speed: eth_speed_t) -> esp_err_t,
    >,
    #[doc = " @brief Set duplex mode of MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[in] duplex: MAC duplex\n\n @return\n      - ESP_OK: set MAC duplex mode successfully\n      - ESP_ERR_INVALID_ARG: set MAC duplex failed because of invalid argument\n      - ESP_FAIL: set MAC duplex failed because some other error occurred\n"]
    pub set_duplex: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, duplex: eth_duplex_t) -> esp_err_t,
    >,
    #[doc = " @brief Set link status of MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[in] link: Link status\n\n @return\n      - ESP_OK: set link status successfully\n      - ESP_ERR_INVALID_ARG: set link status failed because of invalid argument\n      - ESP_FAIL: set link status failed because some other error occurred\n"]
    pub set_link: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, link: eth_link_t) -> esp_err_t,
    >,
    #[doc = " @brief Set promiscuous of MAC\n\n @param[in] mac: Ethernet MAC instance\n @param[in] enable: set true to enable promiscuous mode; set false to disable promiscuous mode\n\n @return\n      - ESP_OK: set promiscuous mode successfully\n      - ESP_FAIL: set promiscuous mode failed because some error occurred\n"]
    pub set_promiscuous: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Enable flow control on MAC layer or not\n\n @param[in] mac: Ethernet MAC instance\n @param[in] enable: set true to enable flow control; set false to disable flow control\n\n @return\n      - ESP_OK: set flow control successfully\n      - ESP_FAIL: set flow control failed because some error occurred\n"]
    pub enable_flow_ctrl: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Set the PAUSE ability of peer node\n\n @param[in] mac: Ethernet MAC instance\n @param[in] ability: zero indicates that pause function is supported by link partner; non-zero indicates that pause function is not supported by link partner\n\n @return\n      - ESP_OK: set peer pause ability successfully\n      - ESP_FAIL: set peer pause ability failed because some error occurred"]
    pub set_peer_pause_ability: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, ability: u32) -> esp_err_t,
    >,
    #[doc = " @brief Custom IO function of MAC driver. This function is intended to extend common options of esp_eth_ioctl to cover specifics of MAC chip.\n\n @note This function may not be assigned when the MAC chip supports only most common set of configuration options.\n\n @param[in] mac: Ethernet MAC instance\n @param[in] cmd: IO control command\n @param[in, out] data: address of data for `set` command or address where to store the data when used with `get` command\n\n @return\n       - ESP_OK: process io command successfully\n       - ESP_ERR_INVALID_ARG: process io command failed because of some invalid argument\n       - ESP_FAIL: process io command failed because some other error occurred\n       - ESP_ERR_NOT_SUPPORTED: requested feature is not supported"]
    pub custom_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            mac: *mut esp_eth_mac_t,
            cmd: u32,
            data: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Free memory of Ethernet MAC\n\n @param[in] mac: Ethernet MAC instance\n\n @return\n      - ESP_OK: free Ethernet MAC instance successfully\n      - ESP_FAIL: free Ethernet MAC instance failed because some error occurred\n"]
    pub del: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
}
#[doc = " @brief Default values configured using Kconfig are going to be used when \"Default\" selected.\n"]
pub const emac_rmii_clock_mode_t_EMAC_CLK_DEFAULT: emac_rmii_clock_mode_t = 0;
#[doc = " @brief Input RMII Clock from external. EMAC Clock GPIO number needs to be configured when this option is selected.\n\n @note MAC will get RMII clock from outside. Note that ESP32 only supports GPIO0 to input the RMII clock.\n"]
pub const emac_rmii_clock_mode_t_EMAC_CLK_EXT_IN: emac_rmii_clock_mode_t = 1;
#[doc = " @brief Output RMII Clock from internal APLL Clock. EMAC Clock GPIO number needs to be configured when this option is selected.\n"]
pub const emac_rmii_clock_mode_t_EMAC_CLK_OUT: emac_rmii_clock_mode_t = 2;
#[doc = " @brief RMII Clock Mode Options\n"]
pub type emac_rmii_clock_mode_t = ::core::ffi::c_uint;
#[doc = " @brief MAC will get RMII clock from outside at this GPIO.\n\n @note ESP32 only supports GPIO0 to input the RMII clock.\n"]
pub const emac_rmii_clock_gpio_t_EMAC_CLK_IN_GPIO: emac_rmii_clock_gpio_t = 0;
#[doc = " @brief Output RMII Clock from internal APLL Clock available at GPIO0\n\n @note GPIO0 can be set to output a pre-divided PLL clock (test only!). Enabling this option will configure GPIO0 to output a 50MHz clock.\n In fact this clock doesn’t have directly relationship with EMAC peripheral. Sometimes this clock won’t work well with your PHY chip.\n You might need to add some extra devices after GPIO0 (e.g. inverter). Note that outputting RMII clock on GPIO0 is an experimental practice.\n If you want the Ethernet to work with WiFi, don’t select GPIO0 output mode for stability.\n"]
pub const emac_rmii_clock_gpio_t_EMAC_APPL_CLK_OUT_GPIO: emac_rmii_clock_gpio_t = 0;
#[doc = " @brief Output RMII Clock from internal APLL Clock available at GPIO16\n"]
pub const emac_rmii_clock_gpio_t_EMAC_CLK_OUT_GPIO: emac_rmii_clock_gpio_t = 16;
#[doc = " @brief Inverted Output RMII Clock from internal APLL Clock available at GPIO17\n"]
pub const emac_rmii_clock_gpio_t_EMAC_CLK_OUT_180_GPIO: emac_rmii_clock_gpio_t = 17;
#[doc = " @brief RMII Clock GPIO number Options\n"]
pub type emac_rmii_clock_gpio_t = ::core::ffi::c_uint;
#[doc = " @brief Ethernet MAC Clock Configuration\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union eth_mac_clock_config_t {
    #[doc = "< EMAC MII Clock Configuration"]
    pub mii: eth_mac_clock_config_t__bindgen_ty_1,
    #[doc = "< EMAC RMII Clock Configuration"]
    pub rmii: eth_mac_clock_config_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct eth_mac_clock_config_t__bindgen_ty_1 {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_mac_clock_config_t__bindgen_ty_2 {
    #[doc = "< RMII Clock Mode Configuration"]
    pub clock_mode: emac_rmii_clock_mode_t,
    #[doc = "< RMII Clock GPIO Configuration"]
    pub clock_gpio: emac_rmii_clock_gpio_t,
}
impl Default for eth_mac_clock_config_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for eth_mac_clock_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Configuration of Ethernet MAC object"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct eth_mac_config_t {
    #[doc = "< Software reset timeout value (Unit: ms)"]
    pub sw_reset_timeout_ms: u32,
    #[doc = "< Stack size of the receive task"]
    pub rx_task_stack_size: u32,
    #[doc = "< Priority of the receive task"]
    pub rx_task_prio: u32,
    #[doc = "< Flags that specify extra capability for mac driver"]
    pub flags: u32,
}
pub const eth_phy_autoneg_cmd_t_ESP_ETH_PHY_AUTONEGO_RESTART: eth_phy_autoneg_cmd_t = 0;
pub const eth_phy_autoneg_cmd_t_ESP_ETH_PHY_AUTONEGO_EN: eth_phy_autoneg_cmd_t = 1;
pub const eth_phy_autoneg_cmd_t_ESP_ETH_PHY_AUTONEGO_DIS: eth_phy_autoneg_cmd_t = 2;
pub const eth_phy_autoneg_cmd_t_ESP_ETH_PHY_AUTONEGO_G_STAT: eth_phy_autoneg_cmd_t = 3;
#[doc = " @brief Auto-negotiation controll commands\n"]
pub type eth_phy_autoneg_cmd_t = ::core::ffi::c_uint;
#[doc = " @brief Ethernet PHY"]
pub type esp_eth_phy_t = esp_eth_phy_s;
#[doc = " @brief Ethernet PHY"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_eth_phy_s {
    #[doc = " @brief Set mediator for PHY\n\n @param[in] phy: Ethernet PHY instance\n @param[in] mediator: mediator of Ethernet driver\n\n @return\n      - ESP_OK: set mediator for Ethernet PHY instance successfully\n      - ESP_ERR_INVALID_ARG: set mediator for Ethernet PHY instance failed because of some invalid arguments\n"]
    pub set_mediator: ::core::option::Option<
        unsafe extern "C" fn(
            phy: *mut esp_eth_phy_t,
            mediator: *mut esp_eth_mediator_t,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Software Reset Ethernet PHY\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: reset Ethernet PHY successfully\n      - ESP_FAIL: reset Ethernet PHY failed because some error occurred\n"]
    pub reset: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Hardware Reset Ethernet PHY\n\n @note Hardware reset is mostly done by pull down and up PHY's nRST pin\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: reset Ethernet PHY successfully\n      - ESP_FAIL: reset Ethernet PHY failed because some error occurred\n"]
    pub reset_hw:
        ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Initialize Ethernet PHY\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: initialize Ethernet PHY successfully\n      - ESP_FAIL: initialize Ethernet PHY failed because some error occurred\n"]
    pub init: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Deinitialize Ethernet PHY\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: deinitialize Ethernet PHY successfully\n      - ESP_FAIL: deinitialize Ethernet PHY failed because some error occurred\n"]
    pub deinit: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Configure auto negotiation\n\n @param[in] phy: Ethernet PHY instance\n @param[in] cmd: Configuration command, it is possible to Enable (restart), Disable or get current status\n                   of PHY auto negotiation\n @param[out] autonego_en_stat: Address where to store current status of auto negotiation configuration\n\n @return\n      - ESP_OK: restart auto negotiation successfully\n      - ESP_FAIL: restart auto negotiation failed because some error occurred\n      - ESP_ERR_INVALID_ARG: invalid command\n"]
    pub autonego_ctrl: ::core::option::Option<
        unsafe extern "C" fn(
            phy: *mut esp_eth_phy_t,
            cmd: eth_phy_autoneg_cmd_t,
            autonego_en_stat: *mut bool,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Get Ethernet PHY link status\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: get Ethernet PHY link status successfully\n      - ESP_FAIL: get Ethernet PHY link status failed because some error occurred\n"]
    pub get_link:
        ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Power control of Ethernet PHY\n\n @param[in] phy: Ethernet PHY instance\n @param[in] enable: set true to power on Ethernet PHY; ser false to power off Ethernet PHY\n\n @return\n      - ESP_OK: control Ethernet PHY power successfully\n      - ESP_FAIL: control Ethernet PHY power failed because some error occurred\n"]
    pub pwrctl: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Set PHY chip address\n\n @param[in] phy: Ethernet PHY instance\n @param[in] addr: PHY chip address\n\n @return\n      - ESP_OK: set Ethernet PHY address successfully\n      - ESP_FAIL: set Ethernet PHY address failed because some error occurred\n"]
    pub set_addr: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, addr: u32) -> esp_err_t,
    >,
    #[doc = " @brief Get PHY chip address\n\n @param[in] phy: Ethernet PHY instance\n @param[out] addr: PHY chip address\n\n @return\n      - ESP_OK: get Ethernet PHY address successfully\n      - ESP_ERR_INVALID_ARG: get Ethernet PHY address failed because of invalid argument\n"]
    pub get_addr: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, addr: *mut u32) -> esp_err_t,
    >,
    #[doc = " @brief Advertise pause function supported by MAC layer\n\n @param[in] phy: Ethernet PHY instance\n @param[out] addr: Pause ability\n\n @return\n      - ESP_OK: Advertise pause ability successfully\n      - ESP_ERR_INVALID_ARG: Advertise pause ability failed because of invalid argument\n"]
    pub advertise_pause_ability: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, ability: u32) -> esp_err_t,
    >,
    #[doc = " @brief Sets the PHY to loopback mode\n\n @param[in] phy: Ethernet PHY instance\n @param[in] enable: enables or disables PHY loopback\n\n @return\n      - ESP_OK: PHY instance loopback mode has been configured successfully\n      - ESP_FAIL: PHY instance loopback configuration failed because some error occurred\n"]
    pub loopback: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Sets PHY speed mode\n\n @note Autonegotiation feature needs to be disabled prior to calling this function for the new\n       setting to be applied\n\n @param[in] phy: Ethernet PHY instance\n @param[in] speed: Speed mode to be set\n\n @return\n      - ESP_OK: PHY instance speed mode has been configured successfully\n      - ESP_FAIL: PHY instance speed mode configuration failed because some error occurred\n"]
    pub set_speed: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, speed: eth_speed_t) -> esp_err_t,
    >,
    #[doc = " @brief Sets PHY duplex mode\n\n @note Autonegotiation feature needs to be disabled prior to calling this function for the new\n       setting to be applied\n\n @param[in] phy: Ethernet PHY instance\n @param[in] duplex: Duplex mode to be set\n\n @return\n      - ESP_OK: PHY instance duplex mode has been configured successfully\n      - ESP_FAIL: PHY instance duplex mode configuration failed because some error occurred\n"]
    pub set_duplex: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, duplex: eth_duplex_t) -> esp_err_t,
    >,
    #[doc = " @brief Custom IO function of PHY driver. This function is intended to extend common options of esp_eth_ioctl to cover specifics of PHY chip.\n\n @note This function may not be assigned when the PHY chip supports only most common set of configuration options.\n\n @param[in] phy: Ethernet PHY instance\n @param[in] cmd: IO control command\n @param[in, out] data: address of data for `set` command or address where to store the data when used with `get` command\n\n @return\n       - ESP_OK: process io command successfully\n       - ESP_ERR_INVALID_ARG: process io command failed because of some invalid argument\n       - ESP_FAIL: process io command failed because some other error occurred\n       - ESP_ERR_NOT_SUPPORTED: requested feature is not supported"]
    pub custom_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            phy: *mut esp_eth_phy_t,
            cmd: u32,
            data: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Free memory of Ethernet PHY instance\n\n @param[in] phy: Ethernet PHY instance\n\n @return\n      - ESP_OK: free PHY instance successfully\n      - ESP_FAIL: free PHY instance failed because some error occurred\n"]
    pub del: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
}
#[doc = " @brief Ethernet PHY configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct eth_phy_config_t {
    #[doc = "< PHY address, set -1 to enable PHY address detection at initialization stage"]
    pub phy_addr: i32,
    #[doc = "< Reset timeout value (Unit: ms)"]
    pub reset_timeout_ms: u32,
    #[doc = "< Auto-negotiation timeout value (Unit: ms)"]
    pub autonego_timeout_ms: u32,
    #[doc = "< Reset GPIO number, -1 means no hardware reset"]
    pub reset_gpio_num: ::core::ffi::c_int,
}
extern "C" {
    #[doc = " @brief Create a PHY instance of IP101\n\n @param[in] config: configuration of PHY\n\n @return\n      - instance: create PHY instance successfully\n      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_ip101(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of RTL8201\n\n @param[in] config: configuration of PHY\n\n @return\n      - instance: create PHY instance successfully\n      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_rtl8201(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of LAN87xx\n\n @param[in] config: configuration of PHY\n\n @return\n      - instance: create PHY instance successfully\n      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_lan87xx(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of DP83848\n\n @param[in] config: configuration of PHY\n\n @return\n      - instance: create PHY instance successfully\n      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_dp83848(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of KSZ80xx\n\n The phy model from the KSZ80xx series is detected automatically. If the driver\n is unable to detect a supported model, \\c NULL is returned.\n\n Currently, the following models are supported:\n KSZ8001, KSZ8021, KSZ8031, KSZ8041, KSZ8051, KSZ8061, KSZ8081, KSZ8091\n\n @param[in] config: configuration of PHY\n\n @return\n      - instance: create PHY instance successfully\n      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_ksz80xx(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
#[doc = " @brief Handle of Ethernet driver"]
pub type esp_eth_handle_t = *mut ::core::ffi::c_void;
#[doc = " @brief Configuration of Ethernet driver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_config_t {
    #[doc = " @brief Ethernet MAC object\n"]
    pub mac: *mut esp_eth_mac_t,
    #[doc = " @brief Ethernet PHY object\n"]
    pub phy: *mut esp_eth_phy_t,
    #[doc = " @brief Period time of checking Ethernet link status\n"]
    pub check_link_period_ms: u32,
    #[doc = " @brief Input frame buffer to user's stack\n\n @param[in] eth_handle: handle of Ethernet driver\n @param[in] buffer: frame buffer that will get input to upper stack\n @param[in] length: length of the frame buffer\n\n @return\n      - ESP_OK: input frame buffer to upper stack successfully\n      - ESP_FAIL: error occurred when inputting buffer to upper stack\n"]
    pub stack_input: ::core::option::Option<
        unsafe extern "C" fn(
            eth_handle: esp_eth_handle_t,
            buffer: *mut u8,
            length: u32,
            priv_: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Callback function invoked when lowlevel initialization is finished\n\n @param[in] eth_handle: handle of Ethernet driver\n\n @return\n       - ESP_OK: process extra lowlevel initialization successfully\n       - ESP_FAIL: error occurred when processing extra lowlevel initialization"]
    pub on_lowlevel_init_done:
        ::core::option::Option<unsafe extern "C" fn(eth_handle: esp_eth_handle_t) -> esp_err_t>,
    #[doc = " @brief Callback function invoked when lowlevel deinitialization is finished\n\n @param[in] eth_handle: handle of Ethernet driver\n\n @return\n       - ESP_OK: process extra lowlevel deinitialization successfully\n       - ESP_FAIL: error occurred when processing extra lowlevel deinitialization"]
    pub on_lowlevel_deinit_done:
        ::core::option::Option<unsafe extern "C" fn(eth_handle: esp_eth_handle_t) -> esp_err_t>,
    #[doc = " @brief Read PHY register\n\n @note Usually the PHY register read/write function is provided by MAC (SMI interface),\n       but if the PHY device is managed by other interface (e.g. I2C), then user needs to\n       implement the corresponding read/write.\n       Setting this to NULL means your PHY device is managed by MAC's SMI interface.\n\n @param[in] eth_handle: handle of Ethernet driver\n @param[in] phy_addr: PHY chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[out] reg_value: PHY register value\n\n @return\n      - ESP_OK: read PHY register successfully\n      - ESP_ERR_INVALID_ARG: read PHY register failed because of invalid argument\n      - ESP_ERR_TIMEOUT: read PHY register failed because of timeout\n      - ESP_FAIL: read PHY register failed because some other error occurred"]
    pub read_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            eth_handle: esp_eth_handle_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Write PHY register\n\n @note Usually the PHY register read/write function is provided by MAC (SMI interface),\n       but if the PHY device is managed by other interface (e.g. I2C), then user needs to\n       implement the corresponding read/write.\n       Setting this to NULL means your PHY device is managed by MAC's SMI interface.\n\n @param[in] eth_handle: handle of Ethernet driver\n @param[in] phy_addr: PHY chip address (0~31)\n @param[in] phy_reg: PHY register index code\n @param[in] reg_value: PHY register value\n\n @return\n      - ESP_OK: write PHY register successfully\n      - ESP_ERR_INVALID_ARG: read PHY register failed because of invalid argument\n      - ESP_ERR_TIMEOUT: write PHY register failed because of timeout\n      - ESP_FAIL: write PHY register failed because some other error occurred"]
    pub write_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            eth_handle: esp_eth_handle_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: u32,
        ) -> esp_err_t,
    >,
}
impl Default for esp_eth_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Get MAC address"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_MAC_ADDR: esp_eth_io_cmd_t = 0;
#[doc = "< Set MAC address"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_MAC_ADDR: esp_eth_io_cmd_t = 1;
#[doc = "< Get PHY address"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_PHY_ADDR: esp_eth_io_cmd_t = 2;
#[doc = "< Set PHY address"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_PHY_ADDR: esp_eth_io_cmd_t = 3;
#[doc = "< Get PHY Auto Negotiation"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_AUTONEGO: esp_eth_io_cmd_t = 4;
#[doc = "< Set PHY Auto Negotiation"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_AUTONEGO: esp_eth_io_cmd_t = 5;
#[doc = "< Get Speed"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_SPEED: esp_eth_io_cmd_t = 6;
#[doc = "< Set Speed"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_SPEED: esp_eth_io_cmd_t = 7;
#[doc = "< Set promiscuous mode"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_PROMISCUOUS: esp_eth_io_cmd_t = 8;
#[doc = "< Set flow control"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_FLOW_CTRL: esp_eth_io_cmd_t = 9;
#[doc = "< Get Duplex mode"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_DUPLEX_MODE: esp_eth_io_cmd_t = 10;
#[doc = "< Set Duplex mode"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_DUPLEX_MODE: esp_eth_io_cmd_t = 11;
#[doc = "< Set PHY loopback"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_PHY_LOOPBACK: esp_eth_io_cmd_t = 12;
pub const esp_eth_io_cmd_t_ETH_CMD_CUSTOM_MAC_CMDS: esp_eth_io_cmd_t = 4095;
pub const esp_eth_io_cmd_t_ETH_CMD_CUSTOM_PHY_CMDS: esp_eth_io_cmd_t = 8191;
#[doc = " @brief Command list for ioctl API"]
pub type esp_eth_io_cmd_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Install Ethernet driver\n\n @param[in]  config: configuration of the Ethernet driver\n @param[out] out_hdl: handle of Ethernet driver\n\n @return\n       - ESP_OK: install esp_eth driver successfully\n       - ESP_ERR_INVALID_ARG: install esp_eth driver failed because of some invalid argument\n       - ESP_ERR_NO_MEM: install esp_eth driver failed because there's no memory for driver\n       - ESP_FAIL: install esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_driver_install(
        config: *const esp_eth_config_t,
        out_hdl: *mut esp_eth_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall Ethernet driver\n @note It's not recommended to uninstall Ethernet driver unless it won't get used any more in application code.\n       To uninstall Ethernet driver, you have to make sure, all references to the driver are released.\n       Ethernet driver can only be uninstalled successfully when reference counter equals to one.\n\n @param[in] hdl: handle of Ethernet driver\n\n @return\n       - ESP_OK: uninstall esp_eth driver successfully\n       - ESP_ERR_INVALID_ARG: uninstall esp_eth driver failed because of some invalid argument\n       - ESP_ERR_INVALID_STATE: uninstall esp_eth driver failed because it has more than one reference\n       - ESP_FAIL: uninstall esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_driver_uninstall(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start Ethernet driver **ONLY** in standalone mode (i.e. without TCP/IP stack)\n\n @note This API will start driver state machine and internal software timer (for checking link status).\n\n @param[in] hdl handle of Ethernet driver\n\n @return\n       - ESP_OK: start esp_eth driver successfully\n       - ESP_ERR_INVALID_ARG: start esp_eth driver failed because of some invalid argument\n       - ESP_ERR_INVALID_STATE: start esp_eth driver failed because driver has started already\n       - ESP_FAIL: start esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_start(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop Ethernet driver\n\n @note This function does the oppsite operation of `esp_eth_start`.\n\n @param[in] hdl handle of Ethernet driver\n @return\n       - ESP_OK: stop esp_eth driver successfully\n       - ESP_ERR_INVALID_ARG: stop esp_eth driver failed because of some invalid argument\n       - ESP_ERR_INVALID_STATE: stop esp_eth driver failed because driver has not started yet\n       - ESP_FAIL: stop esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_stop(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Update Ethernet data input path (i.e. specify where to pass the input buffer)\n\n @note After install driver, Ethernet still don't know where to deliver the input buffer.\n       In fact, this API registers a callback function which get invoked when Ethernet received new packets.\n\n @param[in] hdl handle of Ethernet driver\n @param[in] stack_input function pointer, which does the actual process on incoming packets\n @param[in] priv private resource, which gets passed to `stack_input` callback without any modification\n @return\n       - ESP_OK: update input path successfully\n       - ESP_ERR_INVALID_ARG: update input path failed because of some invalid argument\n       - ESP_FAIL: update input path failed because some other error occurred"]
    pub fn esp_eth_update_input_path(
        hdl: esp_eth_handle_t,
        stack_input: ::core::option::Option<
            unsafe extern "C" fn(
                hdl: esp_eth_handle_t,
                buffer: *mut u8,
                length: u32,
                priv_: *mut ::core::ffi::c_void,
            ) -> esp_err_t,
        >,
        priv_: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief General Transmit\n\n @param[in] hdl: handle of Ethernet driver\n @param[in] buf: buffer of the packet to transfer\n @param[in] length: length of the buffer to transfer\n\n @return\n       - ESP_OK: transmit frame buffer successfully\n       - ESP_ERR_INVALID_ARG: transmit frame buffer failed because of some invalid argument\n       - ESP_ERR_INVALID_STATE: invalid driver state (e.i. driver is not started)\n       - ESP_ERR_TIMEOUT: transmit frame buffer failed because HW was not get available in predefined period\n       - ESP_FAIL: transmit frame buffer failed because some other error occurred"]
    pub fn esp_eth_transmit(
        hdl: esp_eth_handle_t,
        buf: *mut ::core::ffi::c_void,
        length: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Special Transmit with variable number of arguments\n\n @param[in] hdl handle of Ethernet driver\n @param[in] argc number variable arguments\n @param ... variable arguments\n @return\n       - ESP_OK: transmit successfull\n       - ESP_ERR_INVALID_STATE: invalid driver state (e.i. driver is not started)\n       - ESP_ERR_TIMEOUT: transmit frame buffer failed because HW was not get available in predefined period\n       - ESP_FAIL: transmit frame buffer failed because some other error occurred"]
    pub fn esp_eth_transmit_vargs(hdl: esp_eth_handle_t, argc: u32, ...) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Misc IO function of Etherent driver\n\n @param[in] hdl: handle of Ethernet driver\n @param[in] cmd: IO control command\n @param[in, out] data: address of data for `set` command or address where to store the data when used with `get` command\n\n @return\n       - ESP_OK: process io command successfully\n       - ESP_ERR_INVALID_ARG: process io command failed because of some invalid argument\n       - ESP_FAIL: process io command failed because some other error occurred\n       - ESP_ERR_NOT_SUPPORTED: requested feature is not supported\n\n The following common IO control commands are supported:\n @li @c ETH_CMD_S_MAC_ADDR sets Ethernet interface MAC address. @c data argument is pointer to MAC address buffer with expected size of 6 bytes.\n @li @c ETH_CMD_G_MAC_ADDR gets Ethernet interface MAC address. @c data argument is pointer to a buffer to which MAC address is to be copied. The buffer size must be at least 6 bytes.\n @li @c ETH_CMD_S_PHY_ADDR sets PHY address in range of <0-31>. @c data argument is pointer to memory of uint32_t datatype from where the configuration option is read.\n @li @c ETH_CMD_G_PHY_ADDR gets PHY address. @c data argument is pointer to memory of uint32_t datatype to which the PHY address is to be stored.\n @li @c ETH_CMD_S_AUTONEGO enables or disables Ethernet link speed and duplex mode autonegotiation. @c data argument is pointer to memory of bool datatype from which the configuration option is read.\n                           Preconditions: Ethernet driver needs to be stopped.\n @li @c ETH_CMD_G_AUTONEGO gets current configuration of the Ethernet link speed and duplex mode autonegotiation. @c data argument is pointer to memory of bool datatype to which the current configuration is to be stored.\n @li @c ETH_CMD_S_SPEED sets the Ethernet link speed. @c data argument is pointer to memory of eth_speed_t datatype from which the configuration option is read.\n                           Preconditions: Ethernet driver needs to be stopped and auto-negotiation disabled.\n @li @c ETH_CMD_G_SPEED gets current Ethernet link speed. @c data argument is pointer to memory of eth_speed_t datatype to which the speed is to be stored.\n @li @c ETH_CMD_S_PROMISCUOUS sets/resets Ethernet interface promiscuous mode. @c data argument is pointer to memory of bool datatype from which the configuration option is read.\n @li @c ETH_CMD_S_FLOW_CTRL sets/resets Ethernet interface flow control. @c data argument is pointer to memory of bool datatype from which the configuration option is read.\n @li @c ETH_CMD_S_DUPLEX_MODE sets the Ethernet duplex mode. @c data argument is pointer to memory of eth_duplex_t datatype from which the configuration option is read.\n                            Preconditions: Ethernet driver needs to be stopped and auto-negotiation disabled.\n @li @c ETH_CMD_G_DUPLEX_MODE gets current Ethernet link duplex mode.  @c data argument is pointer to memory of eth_duplex_t datatype to which the duplex mode is to be stored.\n @li @c ETH_CMD_S_PHY_LOOPBACK sets/resets PHY to/from loopback mode. @c data argument is pointer to memory of bool datatype from which the configuration option is read.\n\n @li Note that additional control commands may be available for specific MAC or PHY chips. Please consult specific MAC or PHY documentation or driver code."]
    pub fn esp_eth_ioctl(
        hdl: esp_eth_handle_t,
        cmd: esp_eth_io_cmd_t,
        data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Increase Ethernet driver reference\n @note Ethernet driver handle can be obtained by os timer, netif, etc.\n       It's dangerous when thread A is using Ethernet but thread B uninstall the driver.\n       Using reference counter can prevent such risk, but care should be taken, when you obtain Ethernet driver,\n       this API must be invoked so that the driver won't be uninstalled during your using time.\n\n\n @param[in] hdl: handle of Ethernet driver\n @return\n       - ESP_OK: increase reference successfully\n       - ESP_ERR_INVALID_ARG: increase reference failed because of some invalid argument"]
    pub fn esp_eth_increase_reference(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Decrease Ethernet driver reference\n\n @param[in] hdl: handle of Ethernet driver\n @return\n       - ESP_OK: increase reference successfully\n       - ESP_ERR_INVALID_ARG: increase reference failed because of some invalid argument"]
    pub fn esp_eth_decrease_reference(hdl: esp_eth_handle_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_netif_glue_t {
    _unused: [u8; 0],
}
#[doc = " @brief Handle of netif glue - an intermediate layer between netif and Ethernet driver\n"]
pub type esp_eth_netif_glue_handle_t = *mut esp_eth_netif_glue_t;
extern "C" {
    #[doc = " @brief Create a netif glue for Ethernet driver\n @note netif glue is used to attach io driver to TCP/IP netif\n\n @param eth_hdl Ethernet driver handle\n @return glue object, which inherits esp_netif_driver_base_t"]
    pub fn esp_eth_new_netif_glue(eth_hdl: esp_eth_handle_t) -> esp_eth_netif_glue_handle_t;
}
extern "C" {
    #[doc = " @brief Delete netif glue of Ethernet driver\n\n @param eth_netif_glue netif glue\n @return -ESP_OK: delete netif glue successfully"]
    pub fn esp_eth_del_netif_glue(eth_netif_glue: esp_eth_netif_glue_handle_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
extern "C" {
    pub fn utimes(__path: *const ::core::ffi::c_char, __tvp: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::core::ffi::c_int, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::core::ffi::c_int, __value: *mut itimerval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::core::ffi::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct utimbuf {
    pub actime: time_t,
    pub modtime: time_t,
}
extern "C" {
    pub fn utime(path: *const ::core::ffi::c_char, times: *const utimbuf) -> ::core::ffi::c_int;
}
#[doc = " Restart output."]
pub type cc_t = u8;
pub type speed_t = u32;
pub type tcflag_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    #[doc = " Input modes"]
    pub c_oflag: tcflag_t,
    #[doc = " Output modes"]
    pub c_cflag: tcflag_t,
    #[doc = " Control modes"]
    pub c_lflag: tcflag_t,
    #[doc = " Local modes"]
    pub c_cc: [cc_t; 11usize],
    #[doc = " Control characters"]
    pub c_ispeed: speed_t,
    #[doc = " input baud rate"]
    pub c_ospeed: speed_t,
}
extern "C" {
    #[doc = " @brief Extracts the input baud rate from the input structure exactly (without interpretation).\n\n @param p input termios structure\n @return input baud rate"]
    pub fn cfgetispeed(p: *const termios) -> speed_t;
}
extern "C" {
    #[doc = " @brief Extracts the output baud rate from the input structure exactly (without interpretation).\n\n @param p input termios structure\n @return output baud rate"]
    pub fn cfgetospeed(p: *const termios) -> speed_t;
}
extern "C" {
    #[doc = " @brief Set input baud rate in the termios structure\n\n There is no effect in hardware until a subsequent call of tcsetattr().\n\n @param p input termios structure\n @param sp input baud rate\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn cfsetispeed(p: *mut termios, sp: speed_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set output baud rate in the termios structure\n\n There is no effect in hardware until a subsequent call of tcsetattr().\n\n @param p input termios structure\n @param sp output baud rate\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn cfsetospeed(p: *mut termios, sp: speed_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Wait for transmission of output\n\n @param fd file descriptor of the terminal\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcdrain(fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Suspend or restart the transmission or reception of data\n\n @param fd file descriptor of the terminal\n @param action selects actions to do\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcflow(fd: ::core::ffi::c_int, action: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Flush non-transmitted output data and non-read input data\n\n @param fd file descriptor of the terminal\n @param select selects what should be flushed\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcflush(fd: ::core::ffi::c_int, select: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Gets the parameters of the terminal\n\n @param fd file descriptor of the terminal\n @param p output termios structure\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcgetattr(fd: ::core::ffi::c_int, p: *mut termios) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get process group ID for session leader for controlling terminal\n\n @param fd file descriptor of the terminal\n @return process group ID when successful, -1 otherwise with errno set"]
    pub fn tcgetsid(fd: ::core::ffi::c_int) -> pid_t;
}
extern "C" {
    #[doc = " @brief Send a break for a specific duration\n\n @param fd file descriptor of the terminal\n @param duration duration of break\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcsendbreak(fd: ::core::ffi::c_int, duration: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Sets the parameters of the terminal\n\n @param fd file descriptor of the terminal\n @param optional_actions optional actions\n @param p input termios structure\n @return 0 when successful, -1 otherwise with errno set"]
    pub fn tcsetattr(
        fd: ::core::ffi::c_int,
        optional_actions: ::core::ffi::c_int,
        p: *const termios,
    ) -> ::core::ffi::c_int;
}
#[doc = " @brief Opaque directory structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DIR {
    #[doc = "< VFS index, not to be used by applications"]
    pub dd_vfs_idx: u16,
    #[doc = "< field reserved for future extension"]
    pub dd_rsv: u16,
}
#[doc = " @brief Directory entry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    #[doc = "< file number"]
    pub d_ino: ino_t,
    #[doc = "< not defined in POSIX, but present in BSD and Linux"]
    pub d_type: u8,
    #[doc = "< zero-terminated file name"]
    pub d_name: [::core::ffi::c_char; 256usize],
}
impl Default for dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn opendir(name: *const ::core::ffi::c_char) -> *mut DIR;
}
extern "C" {
    pub fn readdir(pdir: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn telldir(pdir: *mut DIR) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn seekdir(pdir: *mut DIR, loc: ::core::ffi::c_long);
}
extern "C" {
    pub fn rewinddir(pdir: *mut DIR);
}
extern "C" {
    pub fn closedir(pdir: *mut DIR) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn readdir_r(
        pdir: *mut DIR,
        entry: *mut dirent,
        out_dirent: *mut *mut dirent,
    ) -> ::core::ffi::c_int;
}
pub type esp_vfs_id_t = ::core::ffi::c_int;
#[doc = " @brief VFS semaphore type for select()\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_vfs_select_sem_t {
    #[doc = "< type of \"sem\" is SemaphoreHandle_t when true, defined by socket driver otherwise"]
    pub is_sem_local: bool,
    #[doc = "< semaphore instance"]
    pub sem: *mut ::core::ffi::c_void,
}
impl Default for esp_vfs_select_sem_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief VFS definition structure\n\n This structure should be filled with pointers to corresponding\n FS driver functions.\n\n VFS component will translate all FDs so that the filesystem implementation\n sees them starting at zero. The caller sees a global FD which is prefixed\n with an pre-filesystem-implementation.\n\n Some FS implementations expect some state (e.g. pointer to some structure)\n to be passed in as a first argument. For these implementations,\n populate the members of this structure which have _p suffix, set\n flags member to ESP_VFS_FLAG_CONTEXT_PTR and provide the context pointer\n to esp_vfs_register function.\n If the implementation doesn't use this extra argument, populate the\n members without _p suffix and set flags member to ESP_VFS_FLAG_DEFAULT.\n\n If the FS driver doesn't provide some of the functions, set corresponding\n members to NULL."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_vfs_t {
    #[doc = "< ESP_VFS_FLAG_CONTEXT_PTR or ESP_VFS_FLAG_DEFAULT"]
    pub flags: ::core::ffi::c_int,
    pub __bindgen_anon_1: esp_vfs_t__bindgen_ty_1,
    pub __bindgen_anon_2: esp_vfs_t__bindgen_ty_2,
    pub __bindgen_anon_3: esp_vfs_t__bindgen_ty_3,
    pub __bindgen_anon_4: esp_vfs_t__bindgen_ty_4,
    pub __bindgen_anon_5: esp_vfs_t__bindgen_ty_5,
    pub __bindgen_anon_6: esp_vfs_t__bindgen_ty_6,
    pub __bindgen_anon_7: esp_vfs_t__bindgen_ty_7,
    pub __bindgen_anon_8: esp_vfs_t__bindgen_ty_8,
    pub __bindgen_anon_9: esp_vfs_t__bindgen_ty_9,
    pub __bindgen_anon_10: esp_vfs_t__bindgen_ty_10,
    pub __bindgen_anon_11: esp_vfs_t__bindgen_ty_11,
    pub __bindgen_anon_12: esp_vfs_t__bindgen_ty_12,
    pub __bindgen_anon_13: esp_vfs_t__bindgen_ty_13,
    pub __bindgen_anon_14: esp_vfs_t__bindgen_ty_14,
    pub __bindgen_anon_15: esp_vfs_t__bindgen_ty_15,
    pub __bindgen_anon_16: esp_vfs_t__bindgen_ty_16,
    pub __bindgen_anon_17: esp_vfs_t__bindgen_ty_17,
    pub __bindgen_anon_18: esp_vfs_t__bindgen_ty_18,
    pub __bindgen_anon_19: esp_vfs_t__bindgen_ty_19,
    pub __bindgen_anon_20: esp_vfs_t__bindgen_ty_20,
    pub __bindgen_anon_21: esp_vfs_t__bindgen_ty_21,
    pub __bindgen_anon_22: esp_vfs_t__bindgen_ty_22,
    pub __bindgen_anon_23: esp_vfs_t__bindgen_ty_23,
    pub __bindgen_anon_24: esp_vfs_t__bindgen_ty_24,
    pub __bindgen_anon_25: esp_vfs_t__bindgen_ty_25,
    pub __bindgen_anon_26: esp_vfs_t__bindgen_ty_26,
    pub __bindgen_anon_27: esp_vfs_t__bindgen_ty_27,
    pub __bindgen_anon_28: esp_vfs_t__bindgen_ty_28,
    pub __bindgen_anon_29: esp_vfs_t__bindgen_ty_29,
    pub __bindgen_anon_30: esp_vfs_t__bindgen_ty_30,
    pub __bindgen_anon_31: esp_vfs_t__bindgen_ty_31,
    pub __bindgen_anon_32: esp_vfs_t__bindgen_ty_32,
    pub __bindgen_anon_33: esp_vfs_t__bindgen_ty_33,
    pub __bindgen_anon_34: esp_vfs_t__bindgen_ty_34,
    #[doc = " start_select is called for setting up synchronous I/O multiplexing of the desired file descriptors in the given VFS"]
    pub start_select: ::core::option::Option<
        unsafe extern "C" fn(
            nfds: ::core::ffi::c_int,
            readfds: *mut fd_set,
            writefds: *mut fd_set,
            exceptfds: *mut fd_set,
            sem: esp_vfs_select_sem_t,
            end_select_args: *mut *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " socket select function for socket FDs with the functionality of POSIX select(); this should be set only for the socket VFS"]
    pub socket_select: ::core::option::Option<
        unsafe extern "C" fn(
            nfds: ::core::ffi::c_int,
            readfds: *mut fd_set,
            writefds: *mut fd_set,
            errorfds: *mut fd_set,
            timeout: *mut timeval,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " called by VFS to interrupt the socket_select call when select is activated from a non-socket VFS driver; set only for the socket driver"]
    pub stop_socket_select:
        ::core::option::Option<unsafe extern "C" fn(sem: *mut ::core::ffi::c_void)>,
    #[doc = " stop_socket_select which can be called from ISR; set only for the socket driver"]
    pub stop_socket_select_isr: ::core::option::Option<
        unsafe extern "C" fn(sem: *mut ::core::ffi::c_void, woken: *mut BaseType_t),
    >,
    #[doc = " end_select is called to stop the I/O multiplexing and deinitialize the environment created by start_select for the given VFS"]
    pub get_socket_select_semaphore:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " get_socket_select_semaphore returns semaphore allocated in the socket driver; set only for the socket driver"]
    pub end_select: ::core::option::Option<
        unsafe extern "C" fn(end_select_args: *mut ::core::ffi::c_void) -> esp_err_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_1 {
    #[doc = "< Write with context pointer"]
    pub write_p: ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            data: *const ::core::ffi::c_void,
            size: usize,
        ) -> isize,
    >,
    #[doc = "< Write without context pointer"]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            data: *const ::core::ffi::c_void,
            size: usize,
        ) -> isize,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_2 {
    #[doc = "< Seek with context pointer"]
    pub lseek_p: ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            size: off_t,
            mode: ::core::ffi::c_int,
        ) -> off_t,
    >,
    #[doc = "< Seek without context pointer"]
    pub lseek: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            size: off_t,
            mode: ::core::ffi::c_int,
        ) -> off_t,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_3 {
    #[doc = "< Read with context pointer"]
    pub read_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            dst: *mut ::core::ffi::c_void,
            size: usize,
        ) -> isize,
    >,
    #[doc = "< Read without context pointer"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            dst: *mut ::core::ffi::c_void,
            size: usize,
        ) -> isize,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_4 {
    #[doc = "< pread with context pointer"]
    pub pread_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            dst: *mut ::core::ffi::c_void,
            size: usize,
            offset: off_t,
        ) -> isize,
    >,
    #[doc = "< pread without context pointer"]
    pub pread: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            dst: *mut ::core::ffi::c_void,
            size: usize,
            offset: off_t,
        ) -> isize,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_5 {
    #[doc = "< pwrite with context pointer"]
    pub pwrite_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            src: *const ::core::ffi::c_void,
            size: usize,
            offset: off_t,
        ) -> isize,
    >,
    #[doc = "< pwrite without context pointer"]
    pub pwrite: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            src: *const ::core::ffi::c_void,
            size: usize,
            offset: off_t,
        ) -> isize,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_6 {
    #[doc = "< open with context pointer"]
    pub open_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
            flags: ::core::ffi::c_int,
            mode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< open without context pointer"]
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            path: *const ::core::ffi::c_char,
            flags: ::core::ffi::c_int,
            mode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_7 {
    #[doc = "< close with context pointer"]
    pub close_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< close without context pointer"]
    pub close:
        ::core::option::Option<unsafe extern "C" fn(fd: ::core::ffi::c_int) -> ::core::ffi::c_int>,
}
impl Default for esp_vfs_t__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_8 {
    #[doc = "< fstat with context pointer"]
    pub fstat_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            st: *mut stat,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< fstat without context pointer"]
    pub fstat: ::core::option::Option<
        unsafe extern "C" fn(fd: ::core::ffi::c_int, st: *mut stat) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_9 {
    #[doc = "< stat with context pointer"]
    pub stat_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
            st: *mut stat,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< stat without context pointer"]
    pub stat: ::core::option::Option<
        unsafe extern "C" fn(path: *const ::core::ffi::c_char, st: *mut stat) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_10 {
    #[doc = "< link with context pointer"]
    pub link_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            n1: *const ::core::ffi::c_char,
            n2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< link without context pointer"]
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            n1: *const ::core::ffi::c_char,
            n2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_11 {
    #[doc = "< unlink with context pointer"]
    pub unlink_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< unlink without context pointer"]
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_12 {
    #[doc = "< rename with context pointer"]
    pub rename_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_char,
            dst: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< rename without context pointer"]
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            src: *const ::core::ffi::c_char,
            dst: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_13 {
    #[doc = "< opendir with context pointer"]
    pub opendir_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            name: *const ::core::ffi::c_char,
        ) -> *mut DIR,
    >,
    #[doc = "< opendir without context pointer"]
    pub opendir:
        ::core::option::Option<unsafe extern "C" fn(name: *const ::core::ffi::c_char) -> *mut DIR>,
}
impl Default for esp_vfs_t__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_14 {
    #[doc = "< readdir with context pointer"]
    pub readdir_p: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, pdir: *mut DIR) -> *mut dirent,
    >,
    #[doc = "< readdir without context pointer"]
    pub readdir: ::core::option::Option<unsafe extern "C" fn(pdir: *mut DIR) -> *mut dirent>,
}
impl Default for esp_vfs_t__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_15 {
    #[doc = "< readdir_r with context pointer"]
    pub readdir_r_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            pdir: *mut DIR,
            entry: *mut dirent,
            out_dirent: *mut *mut dirent,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< readdir_r without context pointer"]
    pub readdir_r: ::core::option::Option<
        unsafe extern "C" fn(
            pdir: *mut DIR,
            entry: *mut dirent,
            out_dirent: *mut *mut dirent,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_16 {
    #[doc = "< telldir with context pointer"]
    pub telldir_p: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, pdir: *mut DIR) -> ::core::ffi::c_long,
    >,
    #[doc = "< telldir without context pointer"]
    pub telldir:
        ::core::option::Option<unsafe extern "C" fn(pdir: *mut DIR) -> ::core::ffi::c_long>,
}
impl Default for esp_vfs_t__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_17 {
    #[doc = "< seekdir with context pointer"]
    pub seekdir_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            pdir: *mut DIR,
            offset: ::core::ffi::c_long,
        ),
    >,
    #[doc = "< seekdir without context pointer"]
    pub seekdir:
        ::core::option::Option<unsafe extern "C" fn(pdir: *mut DIR, offset: ::core::ffi::c_long)>,
}
impl Default for esp_vfs_t__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_18 {
    #[doc = "< closedir with context pointer"]
    pub closedir_p: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, pdir: *mut DIR) -> ::core::ffi::c_int,
    >,
    #[doc = "< closedir without context pointer"]
    pub closedir:
        ::core::option::Option<unsafe extern "C" fn(pdir: *mut DIR) -> ::core::ffi::c_int>,
}
impl Default for esp_vfs_t__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_19 {
    #[doc = "< mkdir with context pointer"]
    pub mkdir_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            name: *const ::core::ffi::c_char,
            mode: mode_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< mkdir without context pointer"]
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(name: *const ::core::ffi::c_char, mode: mode_t) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_20 {
    #[doc = "< rmdir with context pointer"]
    pub rmdir_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            name: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< rmdir without context pointer"]
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_21 {
    #[doc = "< fcntl with context pointer"]
    pub fcntl_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            cmd: ::core::ffi::c_int,
            arg: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< fcntl without context pointer"]
    pub fcntl: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            cmd: ::core::ffi::c_int,
            arg: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_22 {
    #[doc = "< ioctl with context pointer"]
    pub ioctl_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            cmd: ::core::ffi::c_int,
            args: va_list,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< ioctl without context pointer"]
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            cmd: ::core::ffi::c_int,
            args: va_list,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_23 {
    #[doc = "< fsync with context pointer"]
    pub fsync_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< fsync without context pointer"]
    pub fsync:
        ::core::option::Option<unsafe extern "C" fn(fd: ::core::ffi::c_int) -> ::core::ffi::c_int>,
}
impl Default for esp_vfs_t__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_24 {
    #[doc = "< access with context pointer"]
    pub access_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
            amode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< access without context pointer"]
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            path: *const ::core::ffi::c_char,
            amode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_25 {
    #[doc = "< truncate with context pointer"]
    pub truncate_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
            length: off_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< truncate without context pointer"]
    pub truncate: ::core::option::Option<
        unsafe extern "C" fn(path: *const ::core::ffi::c_char, length: off_t) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_26 {
    #[doc = "< ftruncate with context pointer"]
    pub ftruncate_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            length: off_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< ftruncate without context pointer"]
    pub ftruncate: ::core::option::Option<
        unsafe extern "C" fn(fd: ::core::ffi::c_int, length: off_t) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_27 {
    #[doc = "< utime with context pointer"]
    pub utime_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            path: *const ::core::ffi::c_char,
            times: *const utimbuf,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< utime without context pointer"]
    pub utime: ::core::option::Option<
        unsafe extern "C" fn(
            path: *const ::core::ffi::c_char,
            times: *const utimbuf,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_28 {
    #[doc = "< tcsetattr with context pointer"]
    pub tcsetattr_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            optional_actions: ::core::ffi::c_int,
            p: *const termios,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcsetattr without context pointer"]
    pub tcsetattr: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            optional_actions: ::core::ffi::c_int,
            p: *const termios,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_29 {
    #[doc = "< tcgetattr with context pointer"]
    pub tcgetattr_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            p: *mut termios,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcgetattr without context pointer"]
    pub tcgetattr: ::core::option::Option<
        unsafe extern "C" fn(fd: ::core::ffi::c_int, p: *mut termios) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_30 {
    #[doc = "< tcdrain with context pointer"]
    pub tcdrain_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcdrain without context pointer"]
    pub tcdrain:
        ::core::option::Option<unsafe extern "C" fn(fd: ::core::ffi::c_int) -> ::core::ffi::c_int>,
}
impl Default for esp_vfs_t__bindgen_ty_30 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_31 {
    #[doc = "< tcflush with context pointer"]
    pub tcflush_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            select: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcflush without context pointer"]
    pub tcflush: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            select: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_32 {
    #[doc = "< tcflow with context pointer"]
    pub tcflow_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            action: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcflow without context pointer"]
    pub tcflow: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            action: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_33 {
    #[doc = "< tcgetsid with context pointer"]
    pub tcgetsid_p: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, fd: ::core::ffi::c_int) -> pid_t,
    >,
    #[doc = "< tcgetsid without context pointer"]
    pub tcgetsid: ::core::option::Option<unsafe extern "C" fn(fd: ::core::ffi::c_int) -> pid_t>,
}
impl Default for esp_vfs_t__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_vfs_t__bindgen_ty_34 {
    #[doc = "< tcsendbreak with context pointer"]
    pub tcsendbreak_p: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            duration: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "< tcsendbreak without context pointer"]
    pub tcsendbreak: ::core::option::Option<
        unsafe extern "C" fn(
            fd: ::core::ffi::c_int,
            duration: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for esp_vfs_t__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for esp_vfs_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Register a virtual filesystem for given path prefix.\n\n @param base_path  file path prefix associated with the filesystem.\n                   Must be a zero-terminated C string, may be empty.\n                   If not empty, must be up to ESP_VFS_PATH_MAX\n                   characters long, and at least 2 characters long.\n                   Name must start with a \"/\" and must not end with \"/\".\n                   For example, \"/data\" or \"/dev/spi\" are valid.\n                   These VFSes would then be called to handle file paths such as\n                   \"/data/myfile.txt\" or \"/dev/spi/0\".\n                   In the special case of an empty base_path, a \"fallback\"\n                   VFS is registered. Such VFS will handle paths which are not\n                   matched by any other registered VFS.\n @param vfs  Pointer to esp_vfs_t, a structure which maps syscalls to\n             the filesystem driver functions. VFS component doesn't\n             assume ownership of this pointer.\n @param ctx  If vfs->flags has ESP_VFS_FLAG_CONTEXT_PTR set, a pointer\n             which should be passed to VFS functions. Otherwise, NULL.\n\n @return  ESP_OK if successful, ESP_ERR_NO_MEM if too many VFSes are\n          registered."]
    pub fn esp_vfs_register(
        base_path: *const ::core::ffi::c_char,
        vfs: *const esp_vfs_t,
        ctx: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Special case function for registering a VFS that uses a method other than\n open() to open new file descriptors from the interval <min_fd; max_fd).\n\n This is a special-purpose function intended for registering LWIP sockets to VFS.\n\n @param vfs Pointer to esp_vfs_t. Meaning is the same as for esp_vfs_register().\n @param ctx Pointer to context structure. Meaning is the same as for esp_vfs_register().\n @param min_fd The smallest file descriptor this VFS will use.\n @param max_fd Upper boundary for file descriptors this VFS will use (the biggest file descriptor plus one).\n\n @return  ESP_OK if successful, ESP_ERR_NO_MEM if too many VFSes are\n          registered, ESP_ERR_INVALID_ARG if the file descriptor boundaries\n          are incorrect."]
    pub fn esp_vfs_register_fd_range(
        vfs: *const esp_vfs_t,
        ctx: *mut ::core::ffi::c_void,
        min_fd: ::core::ffi::c_int,
        max_fd: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Special case function for registering a VFS that uses a method other than\n open() to open new file descriptors. In comparison with\n esp_vfs_register_fd_range, this function doesn't pre-registers an interval\n of file descriptors. File descriptors can be registered later, by using\n esp_vfs_register_fd.\n\n @param vfs Pointer to esp_vfs_t. Meaning is the same as for esp_vfs_register().\n @param ctx Pointer to context structure. Meaning is the same as for esp_vfs_register().\n @param vfs_id Here will be written the VFS ID which can be passed to\n               esp_vfs_register_fd for registering file descriptors.\n\n @return  ESP_OK if successful, ESP_ERR_NO_MEM if too many VFSes are\n          registered, ESP_ERR_INVALID_ARG if the file descriptor boundaries\n          are incorrect."]
    pub fn esp_vfs_register_with_id(
        vfs: *const esp_vfs_t,
        ctx: *mut ::core::ffi::c_void,
        vfs_id: *mut esp_vfs_id_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Unregister a virtual filesystem for given path prefix\n\n @param base_path  file prefix previously used in esp_vfs_register call\n @return ESP_OK if successful, ESP_ERR_INVALID_STATE if VFS for given prefix\n         hasn't been registered"]
    pub fn esp_vfs_unregister(base_path: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " Unregister a virtual filesystem with the given index\n\n @param vfs_id  The VFS ID returned by esp_vfs_register_with_id\n @return ESP_OK if successful, ESP_ERR_INVALID_STATE if VFS for the given index\n         hasn't been registered"]
    pub fn esp_vfs_unregister_with_id(vfs_id: esp_vfs_id_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Special function for registering another file descriptor for a VFS registered\n by esp_vfs_register_with_id.\n\n @param vfs_id VFS identificator returned by esp_vfs_register_with_id.\n @param fd The registered file descriptor will be written to this address.\n\n @return  ESP_OK if the registration is successful,\n          ESP_ERR_NO_MEM if too many file descriptors are registered,\n          ESP_ERR_INVALID_ARG if the arguments are incorrect."]
    pub fn esp_vfs_register_fd(vfs_id: esp_vfs_id_t, fd: *mut ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " Special function for registering another file descriptor with given local_fd\n for a VFS registered by esp_vfs_register_with_id.\n\n @param vfs_id VFS identificator returned by esp_vfs_register_with_id.\n @param local_fd The fd in the local vfs. Passing -1 will set the local fd as the (*fd) value.\n @param permanent Whether the fd should be treated as permannet (not removed after close())\n @param fd The registered file descriptor will be written to this address.\n\n @return  ESP_OK if the registration is successful,\n          ESP_ERR_NO_MEM if too many file descriptors are registered,\n          ESP_ERR_INVALID_ARG if the arguments are incorrect."]
    pub fn esp_vfs_register_fd_with_local_fd(
        vfs_id: esp_vfs_id_t,
        local_fd: ::core::ffi::c_int,
        permanent: bool,
        fd: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Special function for unregistering a file descriptor belonging to a VFS\n registered by esp_vfs_register_with_id.\n\n @param vfs_id VFS identificator returned by esp_vfs_register_with_id.\n @param fd File descriptor which should be unregistered.\n\n @return  ESP_OK if the registration is successful,\n          ESP_ERR_INVALID_ARG if the arguments are incorrect."]
    pub fn esp_vfs_unregister_fd(vfs_id: esp_vfs_id_t, fd: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " These functions are to be used in newlib syscall table. They will be called by\n newlib when it needs to use any of the syscalls.\n/\n/**@{"]
    pub fn esp_vfs_write(
        r: *mut _reent,
        fd: ::core::ffi::c_int,
        data: *const ::core::ffi::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn esp_vfs_lseek(
        r: *mut _reent,
        fd: ::core::ffi::c_int,
        size: off_t,
        mode: ::core::ffi::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn esp_vfs_read(
        r: *mut _reent,
        fd: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn esp_vfs_open(
        r: *mut _reent,
        path: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
        mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_close(r: *mut _reent, fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_fstat(
        r: *mut _reent,
        fd: ::core::ffi::c_int,
        st: *mut stat,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_stat(
        r: *mut _reent,
        path: *const ::core::ffi::c_char,
        st: *mut stat,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_link(
        r: *mut _reent,
        n1: *const ::core::ffi::c_char,
        n2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_unlink(r: *mut _reent, path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_rename(
        r: *mut _reent,
        src: *const ::core::ffi::c_char,
        dst: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_vfs_utime(
        path: *const ::core::ffi::c_char,
        times: *const utimbuf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Synchronous I/O multiplexing which implements the functionality of POSIX select() for VFS\n @param nfds      Specifies the range of descriptors which should be checked.\n                  The first nfds descriptors will be checked in each set.\n @param readfds   If not NULL, then points to a descriptor set that on input\n                  specifies which descriptors should be checked for being\n                  ready to read, and on output indicates which descriptors\n                  are ready to read.\n @param writefds  If not NULL, then points to a descriptor set that on input\n                  specifies which descriptors should be checked for being\n                  ready to write, and on output indicates which descriptors\n                  are ready to write.\n @param errorfds  If not NULL, then points to a descriptor set that on input\n                  specifies which descriptors should be checked for error\n                  conditions, and on output indicates which descriptors\n                  have error conditions.\n @param timeout   If not NULL, then points to timeval structure which\n                  specifies the time period after which the functions should\n                  time-out and return. If it is NULL, then the function will\n                  not time-out. Note that the timeout period is rounded up to\n                  the system tick and incremented by one.\n\n @return      The number of descriptors set in the descriptor sets, or -1\n              when an error (specified by errno) have occurred."]
    pub fn esp_vfs_select(
        nfds: ::core::ffi::c_int,
        readfds: *mut fd_set,
        writefds: *mut fd_set,
        errorfds: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Notification from a VFS driver about a read/write/error condition\n\n This function is called when the VFS driver detects a read/write/error\n condition as it was requested by the previous call to start_select.\n\n @param sem semaphore structure which was passed to the driver by the start_select call"]
    pub fn esp_vfs_select_triggered(sem: esp_vfs_select_sem_t);
}
extern "C" {
    #[doc = " @brief Notification from a VFS driver about a read/write/error condition (ISR version)\n\n This function is called when the VFS driver detects a read/write/error\n condition as it was requested by the previous call to start_select.\n\n @param sem semaphore structure which was passed to the driver by the start_select call\n @param woken is set to pdTRUE if the function wakes up a task with higher priority"]
    pub fn esp_vfs_select_triggered_isr(sem: esp_vfs_select_sem_t, woken: *mut BaseType_t);
}
extern "C" {
    #[doc = " @brief Implements the VFS layer of POSIX pread()\n\n @param fd         File descriptor used for read\n @param dst        Pointer to the buffer where the output will be written\n @param size       Number of bytes to be read\n @param offset     Starting offset of the read\n\n @return           A positive return value indicates the number of bytes read. -1 is return on failure and errno is\n                   set accordingly."]
    pub fn esp_vfs_pread(
        fd: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_void,
        size: usize,
        offset: off_t,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Implements the VFS layer of POSIX pwrite()\n\n @param fd         File descriptor used for write\n @param src        Pointer to the buffer from where the output will be read\n @param size       Number of bytes to write\n @param offset     Starting offset of the write\n\n @return           A positive return value indicates the number of bytes written. -1 is return on failure and errno is\n                   set accordingly."]
    pub fn esp_vfs_pwrite(
        fd: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        size: usize,
        offset: off_t,
    ) -> isize;
}
#[doc = "!< CR + LF"]
pub const esp_line_endings_t_ESP_LINE_ENDINGS_CRLF: esp_line_endings_t = 0;
#[doc = "!< CR"]
pub const esp_line_endings_t_ESP_LINE_ENDINGS_CR: esp_line_endings_t = 1;
#[doc = "!< LF"]
pub const esp_line_endings_t_ESP_LINE_ENDINGS_LF: esp_line_endings_t = 2;
#[doc = " @brief Line ending settings"]
pub type esp_line_endings_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief add /dev/cdcacm virtual filesystem driver\n\n This function is called from startup code to enable console output"]
    pub fn esp_vfs_dev_cdcacm_register() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the line endings expected to be received\n\n This specifies the conversion between line endings received and\n newlines ('\\n', LF) passed into stdin:\n\n - ESP_LINE_ENDINGS_CRLF: convert CRLF to LF\n - ESP_LINE_ENDINGS_CR: convert CR to LF\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. reading\n\n @param mode line endings expected"]
    pub fn esp_vfs_dev_cdcacm_set_rx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief Set the line endings to sent\n\n This specifies the conversion between newlines ('\\n', LF) on stdout and line\n endings sent:\n\n - ESP_LINE_ENDINGS_CRLF: convert LF to CRLF\n - ESP_LINE_ENDINGS_CR: convert LF to CR\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. writing\n\n @param mode line endings to send"]
    pub fn esp_vfs_dev_cdcacm_set_tx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief add /dev/uart virtual filesystem driver\n\n This function is called from startup code to enable serial output"]
    pub fn esp_vfs_dev_uart_register();
}
extern "C" {
    #[doc = " @brief Set the line endings expected to be received on UART\n\n This specifies the conversion between line endings received on UART and\n newlines ('\\n', LF) passed into stdin:\n\n - ESP_LINE_ENDINGS_CRLF: convert CRLF to LF\n - ESP_LINE_ENDINGS_CR: convert CR to LF\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. reading from UART\n\n @param mode line endings expected on UART"]
    pub fn esp_vfs_dev_uart_set_rx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief Set the line endings to sent to UART\n\n This specifies the conversion between newlines ('\\n', LF) on stdout and line\n endings sent over UART:\n\n - ESP_LINE_ENDINGS_CRLF: convert LF to CRLF\n - ESP_LINE_ENDINGS_CR: convert LF to CR\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. writing to UART\n\n @param mode line endings to send to UART"]
    pub fn esp_vfs_dev_uart_set_tx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief Set the line endings expected to be received on specified UART\n\n This specifies the conversion between line endings received on UART and\n newlines ('\\n', LF) passed into stdin:\n\n - ESP_LINE_ENDINGS_CRLF: convert CRLF to LF\n - ESP_LINE_ENDINGS_CR: convert CR to LF\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. reading from UART\n\n @param uart_num the UART number\n @param mode line endings to send to UART\n @return  0 if successed, or -1\n              when an error (specified by errno) have occurred."]
    pub fn esp_vfs_dev_uart_port_set_rx_line_endings(
        uart_num: ::core::ffi::c_int,
        mode: esp_line_endings_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set the line endings to sent to specified UART\n\n This specifies the conversion between newlines ('\\n', LF) on stdout and line\n endings sent over UART:\n\n - ESP_LINE_ENDINGS_CRLF: convert LF to CRLF\n - ESP_LINE_ENDINGS_CR: convert LF to CR\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. writing to UART\n\n @param uart_num the UART number\n @param mode line endings to send to UART\n @return  0 if successed, or -1\n              when an error (specified by errno) have occurred."]
    pub fn esp_vfs_dev_uart_port_set_tx_line_endings(
        uart_num: ::core::ffi::c_int,
        mode: esp_line_endings_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief set VFS to use simple functions for reading and writing UART\n Read is non-blocking, write is busy waiting until TX FIFO has enough space.\n These functions are used by default.\n @param uart_num UART peripheral number"]
    pub fn esp_vfs_dev_uart_use_nonblocking(uart_num: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief set VFS to use UART driver for reading and writing\n @note application must configure UART driver before calling these functions\n With these functions, read and write are blocking and interrupt-driven.\n @param uart_num UART peripheral number"]
    pub fn esp_vfs_dev_uart_use_driver(uart_num: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief set VFS to use USB-SERIAL-JTAG driver for reading and writing\n @note application must configure USB-SERIAL-JTAG driver before calling these functions\n With these functions, read and write are blocking and interrupt-driven."]
    pub fn esp_vfs_usb_serial_jtag_use_driver();
}
extern "C" {
    #[doc = " @brief set VFS to use simple functions for reading and writing UART\n Read is non-blocking, write is busy waiting until TX FIFO has enough space.\n These functions are used by default."]
    pub fn esp_vfs_usb_serial_jtag_use_nonblocking();
}
extern "C" {
    #[doc = " @brief add virtual filesystem semihosting driver\n\n @param base_path VFS path to mount host directory\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if esp_vfs_semihost_register was already called for specified VFS path\n      - ESP_ERR_NO_MEM if there are no slots to register new mount point"]
    pub fn esp_vfs_semihost_register(base_path: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Un-register semihosting driver from VFS\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if semihosting driver is not registered in VFS at that path"]
    pub fn esp_vfs_semihost_unregister(base_path: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief add /dev/usbserjtag virtual filesystem driver\n\n This function is called from startup code to enable console output"]
    pub fn esp_vfs_dev_usb_serial_jtag_register() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the line endings expected to be received\n\n This specifies the conversion between line endings received and\n newlines ('\\n', LF) passed into stdin:\n\n - ESP_LINE_ENDINGS_CRLF: convert CRLF to LF\n - ESP_LINE_ENDINGS_CR: convert CR to LF\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. reading\n\n @param mode line endings expected"]
    pub fn esp_vfs_dev_usb_serial_jtag_set_rx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief Set the line endings to sent\n\n This specifies the conversion between newlines ('\\n', LF) on stdout and line\n endings sent:\n\n - ESP_LINE_ENDINGS_CRLF: convert LF to CRLF\n - ESP_LINE_ENDINGS_CR: convert LF to CR\n - ESP_LINE_ENDINGS_LF: no modification\n\n @note this function is not thread safe w.r.t. writing\n\n @param mode line endings to send"]
    pub fn esp_vfs_dev_usb_serial_jtag_set_tx_line_endings(mode: esp_line_endings_t);
}
extern "C" {
    #[doc = " @brief add uart/usb_serial_jtag/usb_otg_acmcdc virtual filesystem driver\n\n This function is called from startup code to enable serial output"]
    pub fn esp_vfs_console_register() -> esp_err_t;
}
#[doc = " @brief Eventfd vfs initialization settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_vfs_eventfd_config_t {
    #[doc = "< The maxinum number of eventfds supported"]
    pub max_fds: usize,
}
extern "C" {
    #[doc = " @brief  Registers the event vfs.\n\n @return  ESP_OK if successful, ESP_ERR_NO_MEM if too many VFSes are\n          registered."]
    pub fn esp_vfs_eventfd_register(config: *const esp_vfs_eventfd_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Unregisters the event vfs.\n\n @return ESP_OK if successful, ESP_ERR_INVALID_STATE if VFS for given prefix\n         hasn't been registered"]
    pub fn esp_vfs_eventfd_unregister() -> esp_err_t;
}
extern "C" {
    pub fn eventfd(initval: ::core::ffi::c_uint, flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " @brief Configuration structure for esp_vfs_spiffs_register"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_vfs_spiffs_conf_t {
    #[doc = "< File path prefix associated with the filesystem."]
    pub base_path: *const ::core::ffi::c_char,
    #[doc = "< Optional, label of SPIFFS partition to use. If set to NULL, first partition with subtype=spiffs will be used."]
    pub partition_label: *const ::core::ffi::c_char,
    #[doc = "< Maximum files that could be open at the same time."]
    pub max_files: usize,
    #[doc = "< If true, it will format the file system if it fails to mount."]
    pub format_if_mount_failed: bool,
}
impl Default for esp_vfs_spiffs_conf_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Register and mount SPIFFS to VFS with given path prefix.\n\n @param   conf                      Pointer to esp_vfs_spiffs_conf_t configuration structure\n\n @return\n          - ESP_OK                  if success\n          - ESP_ERR_NO_MEM          if objects could not be allocated\n          - ESP_ERR_INVALID_STATE   if already mounted or partition is encrypted\n          - ESP_ERR_NOT_FOUND       if partition for SPIFFS was not found\n          - ESP_FAIL                if mount or format fails"]
    pub fn esp_vfs_spiffs_register(conf: *const esp_vfs_spiffs_conf_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Unregister and unmount SPIFFS from VFS\n\n @param partition_label  Same label as passed to esp_vfs_spiffs_register.\n\n @return\n          - ESP_OK if successful\n          - ESP_ERR_INVALID_STATE already unregistered"]
    pub fn esp_vfs_spiffs_unregister(partition_label: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if SPIFFS is mounted\n\n @param partition_label  Optional, label of the partition to check.\n                         If not specified, first partition with subtype=spiffs is used.\n\n @return\n          - true    if mounted\n          - false   if not mounted"]
    pub fn esp_spiffs_mounted(partition_label: *const ::core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Format the SPIFFS partition\n\n @param partition_label  Same label as passed to esp_vfs_spiffs_register.\n @return\n          - ESP_OK      if successful\n          - ESP_FAIL    on error"]
    pub fn esp_spiffs_format(partition_label: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " Get information for SPIFFS\n\n @param partition_label           Same label as passed to esp_vfs_spiffs_register\n @param[out] total_bytes          Size of the file system\n @param[out] used_bytes           Current used bytes in the file system\n\n @return\n          - ESP_OK                  if success\n          - ESP_ERR_INVALID_STATE   if not mounted"]
    pub fn esp_spiffs_info(
        partition_label: *const ::core::ffi::c_char,
        total_bytes: *mut usize,
        used_bytes: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Check integrity of SPIFFS\n\n @param partition_label  Same label as passed to esp_vfs_spiffs_register\n @return\n          - ESP_OK                  if successful\n          - ESP_ERR_INVALID_STATE   if not mounted\n          - ESP_FAIL                on error"]
    pub fn esp_spiffs_check(partition_label: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Perform garbage collection in SPIFFS partition\n\n Call this function to run GC and ensure that at least the given amount of\n space is available in the partition. This function will fail with ESP_ERR_NOT_FINISHED\n if it is not possible to reclaim the requested space (that is, not enough free\n or deleted pages in the filesystem). This function will also fail if it fails to\n reclaim the requested space after CONFIG_SPIFFS_GC_MAX_RUNS number of GC iterations.\n On one GC iteration, SPIFFS will erase one logical block (4kB). Therefore the value\n of CONFIG_SPIFFS_GC_MAX_RUNS should be set at least to the maximum expected size_to_gc,\n divided by 4096. For example, if the application expects to make room for a 1MB file and\n calls esp_spiffs_gc(label, 1024 * 1024), CONFIG_SPIFFS_GC_MAX_RUNS should be set to\n at least 256.\n On the other hand, increasing CONFIG_SPIFFS_GC_MAX_RUNS value increases the maximum\n amount of time for which any SPIFFS GC or write operation may potentially block.\n\n @param partition_label  Label of the partition to be garbage-collected.\n                         The partition must be already mounted.\n @param size_to_gc       The number of bytes that the GC process should attempt\n                         to make available.\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_FINISHED if GC fails to reclaim the size given by size_to_gc\n          - ESP_ERR_INVALID_STATE if the partition is not mounted\n          - ESP_FAIL on all other errors"]
    pub fn esp_spiffs_gc(
        partition_label: *const ::core::ffi::c_char,
        size_to_gc: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure IO Pad as General Purpose IO,\n        so that it can be connected to internal Matrix,\n        then combined with one or more peripheral signals.\n\n @param iopad_num IO Pad number"]
    pub fn esp_rom_gpio_pad_select_gpio(iopad_num: u32);
}
extern "C" {
    #[doc = " @brief Enable internal pull up, and disable internal pull down.\n\n @param iopad_num IO Pad number"]
    pub fn esp_rom_gpio_pad_pullup_only(iopad_num: u32);
}
extern "C" {
    #[doc = " @brief Unhold the IO Pad.\n @note When the Pad is set to hold, the state is latched at that moment and won't get changed.\n\n @param iopad_num IP Pad number"]
    pub fn esp_rom_gpio_pad_unhold(gpio_num: u32);
}
extern "C" {
    #[doc = " @brief Set IO Pad current drive capability.\n\n @param iopad_num IO Pad number\n @param drv Numeric to indicate the capability of current drive\n      - 0: 5mA\n      - 1: 10mA\n      - 2: 20mA\n      - 3: 40mA"]
    pub fn esp_rom_gpio_pad_set_drv(iopad_num: u32, drv: u32);
}
extern "C" {
    #[doc = " @brief Combine a GPIO input with a peripheral signal, which tagged as input attribute.\n\n @note There's no limitation on the number of signals that a GPIO can combine with.\n\n @param gpio_num GPIO number, especially, `GPIO_MATRIX_CONST_ZERO_INPUT` means connect logic 0 to signal\n                                          `GPIO_MATRIX_CONST_ONE_INPUT` means connect logic 1 to signal\n @param signal_idx Peripheral signal index (tagged as input attribute)\n @param inv  Whether the GPIO input to be inverted or not"]
    pub fn esp_rom_gpio_connect_in_signal(gpio_num: u32, signal_idx: u32, inv: bool);
}
extern "C" {
    #[doc = " @brief Combine a peripheral signal which tagged as output attribute with a GPIO.\n\n @note There's no limitation on the number of signals that a GPIO can combine with.\n\n @param gpio_num GPIO number\n @param signal_idx Peripheral signal index (tagged as output attribute)\n @param out_inv Whether to signal to be inverted or not\n @param oen_inv Whether the output enable control is inverted or not"]
    pub fn esp_rom_gpio_connect_out_signal(
        gpio_num: u32,
        signal_idx: u32,
        out_inv: bool,
        oen_inv: bool,
    );
}
pub type gpio_isr_handle_t = intr_handle_t;
#[doc = " @brief GPIO interrupt handler\n\n @param arg User registered data"]
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u64,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
impl Default for gpio_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief GPIO common configuration\n\n        Configure GPIO's Mode,pull-up,PullDown,IntrType\n\n @param  pGPIOConfig Pointer to GPIO configure struct\n\n @return\n     - ESP_OK success\n     - ESP_ERR_INVALID_ARG Parameter error\n"]
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset an gpio to default state (select gpio function, enable pullup and disable input and output).\n\n @param gpio_num GPIO number.\n\n @note This function also configures the IOMUX for this pin to the GPIO\n       function, and disconnects any other peripheral output configured via GPIO\n       Matrix.\n\n @return Always return ESP_OK."]
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type\n\n @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  intr_type Interrupt type, select from gpio_int_type_t\n\n @return\n     - ESP_OK  Success\n     - ESP_ERR_INVALID_ARG Parameter error\n"]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Enable GPIO module interrupt signal\n\n @note ESP32: Please do not use the interrupt of GPIO36 and GPIO39 when using ADC or Wi-Fi and Bluetooth with sleep mode enabled.\n       Please refer to the comments of `adc1_get_raw`.\n       Please refer to Section 3.11 of <a href=\"https://espressif.com/sites/default/files/documentation/eco_and_workarounds_for_bugs_in_esp32_en.pdf\">ESP32 ECO and Workarounds for Bugs</a> for the description of this issue.\n       As a workaround, call adc_power_acquire() in the app. This will result in higher power consumption (by ~1mA),\n       but will remove the glitches on GPIO36 and GPIO39.\n\n @param  gpio_num GPIO number. If you want to enable an interrupt on e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n"]
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable GPIO module interrupt signal\n\n @note This function is allowed to be executed when Cache is disabled within ISR context, by enabling `CONFIG_GPIO_CTRL_FUNC_IN_IRAM`\n\n @param  gpio_num GPIO number. If you want to disable the interrupt of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n\n @return\n     - ESP_OK success\n     - ESP_ERR_INVALID_ARG Parameter error\n"]
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level\n\n @note This function is allowed to be executed when Cache is disabled within ISR context, by enabling `CONFIG_GPIO_CTRL_FUNC_IN_IRAM`\n\n @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  level Output level. 0: low ; 1: high\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG GPIO number error\n"]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level\n\n @warning If the pad is not configured for input (or input and output) the returned value is always 0.\n\n @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);\n\n @return\n     - 0 the GPIO input level is 0\n     - 1 the GPIO input level is 1\n"]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction\n\n Configure GPIO direction,such as output_only,input_only,output_and_input\n\n @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  mode GPIO direction\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG GPIO error\n"]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors\n\n @note ESP32: Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not.\n\n @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  pull GPIO pull up/down mode.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG : Parameter error\n"]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function.\n\n @param gpio_num GPIO number.\n\n @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR.\n          The handler will be attached to the same CPU core that this function is running on.\n\n This ISR function is called whenever any GPIO interrupt occurs. See\n the alternative gpio_install_isr_service() and\n gpio_isr_handler_add() API in order to have the driver support\n per-GPIO ISRs.\n\n @param  fn  Interrupt handler function.\n @param  arg  Parameter for handler function\n @param  intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n @param  handle Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here.\n\n \\verbatim embed:rst:leading-asterisk\n To disable or remove the ISR, pass the returned handle to the :doc:`interrupt allocation functions </api-reference/system/intr_alloc>`.\n \\endverbatim\n\n @return\n     - ESP_OK Success ;\n     - ESP_ERR_INVALID_ARG GPIO error\n     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::core::ffi::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the GPIO driver's ETS_GPIO_INTR_SOURCE ISR handler service, which allows per-pin GPIO interrupt handlers.\n\n This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.\n\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_NO_MEM No memory to install this service\n     - ESP_ERR_INVALID_STATE ISR service already installed.\n     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags\n     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(intr_alloc_flags: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin.\n\n Call this function after using gpio_install_isr_service() to\n install the driver's GPIO ISR handler service.\n\n The pin ISR handlers no longer need to be declared with IRAM_ATTR,\n unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the\n ISR in gpio_install_isr_service().\n\n This ISR handler will be called from an ISR. So there is a stack\n size limit (configurable as \"ISR stack size\" in menuconfig). This\n limit is smaller compared to a global GPIO interrupt handler due\n to the additional level of indirection.\n\n @param gpio_num GPIO number\n @param isr_handler ISR handler function for the corresponding GPIO number.\n @param args parameter for ISR handler.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized.\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized.\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPIO pad drive capability\n\n @param gpio_num GPIO number, only support output GPIOs\n @param strength Drive capability of the pad\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO pad drive capability\n\n @param gpio_num GPIO number, only support output GPIOs\n @param strength Pointer to accept drive capability of the pad\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable gpio pad hold function.\n\n When the pin is set to hold, the state is latched at that moment and will not change no matter how the internal\n signals change or how the IO MUX/GPIO configuration is modified (including input enable, output enable,\n output value, function, and drive strength values). It can be used to retain the pin state through a\n core reset and system reset triggered by watchdog time-out or Deep-sleep events.\n\n The gpio pad hold function works in both input and output modes, but must be output-capable gpios.\n If pad hold enabled:\n   in output mode: the output level of the pad will be force locked and can not be changed.\n   in input mode: input read value can still reflect the changes of the input signal.\n\n The state of the digital gpio cannot be held during Deep-sleep, and it will resume to hold at its default pin state\n when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,\n `gpio_deep_sleep_hold_en` should also be called.\n\n Power down or call `gpio_hold_dis` will disable this function.\n\n @param gpio_num GPIO number, only support output-capable GPIOs\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable gpio pad hold function.\n\n When the chip is woken up from Deep-sleep, the gpio will be set to the default mode, so, the gpio will output\n the default level if this function is called. If you don't want the level changes, the gpio should be configured to\n a known state before this function is called.\n  e.g.\n     If you hold gpio18 high during Deep-sleep, after the chip is woken up and `gpio_hold_dis` is called,\n     gpio18 will output low level(because gpio18 is input mode by default). If you don't want this behavior,\n     you should configure gpio18 as output mode and set it to hight level before calling `gpio_hold_dis`.\n\n @param gpio_num GPIO number, only support output-capable GPIOs\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable all digital gpio pads hold function during Deep-sleep.\n\n Enabling this feature makes all digital gpio pads be at the holding state during Deep-sleep. The state of each pad\n holds is its active configuration (not pad's sleep configuration!).\n\n Note that this pad hold feature only works when the chip is in Deep-sleep mode. When the chip is in active mode,\n the digital gpio state can be changed freely even you have called this function.\n\n After this API is being called, the digital gpio Deep-sleep hold feature will work during every sleep process. You\n should call `gpio_deep_sleep_hold_dis` to disable this feature."]
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    #[doc = " @brief Disable all digital gpio pads hold function during Deep-sleep."]
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    #[doc = " @brief Set pad input to a peripheral signal through the IOMUX.\n @param gpio_num GPIO number of the pad.\n @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``."]
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    #[doc = " @brief Set peripheral output to an GPIO pad through the IOMUX.\n @param gpio_num gpio_num GPIO number of the pad.\n @param func The function number of the peripheral pin to output pin.\n        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``.\n @param oen_inv True if the output enable needs to be inverted, otherwise False."]
    pub fn gpio_iomux_out(gpio_num: u8, func: ::core::ffi::c_int, oen_inv: bool);
}
extern "C" {
    #[doc = " @brief Force hold all digital and rtc gpio pads.\n\n GPIO force hold, no matter the chip in active mode or sleep modes.\n\n This function will immediately cause all pads to latch the current values of input enable, output enable,\n output value, function, and drive strength values.\n\n @warning This function will hold flash and UART pins as well. Therefore, this function, and all code run afterwards\n (till calling `gpio_force_unhold_all` to disable this feature), MUST be placed in internal RAM as holding the flash\n pins will halt SPI flash operation, and holding the UART pins will halt any UART logging."]
    pub fn gpio_force_hold_all() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Force unhold all digital and rtc gpio pads."]
    pub fn gpio_force_unhold_all() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable SLP_SEL to change GPIO status automantically in lightsleep.\n @param gpio_num GPIO number of the pad.\n\n @return\n     - ESP_OK Success\n"]
    pub fn gpio_sleep_sel_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable SLP_SEL to change GPIO status automantically in lightsleep.\n @param gpio_num GPIO number of the pad.\n\n @return\n     - ESP_OK Success"]
    pub fn gpio_sleep_sel_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction at sleep\n\n Configure GPIO direction,such as output_only,input_only,output_and_input\n\n @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  mode GPIO direction\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_sleep_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors at sleep\n\n @note ESP32: Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not.\n\n @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);\n @param  pull GPIO pull up/down mode.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG : Parameter error"]
    pub fn gpio_sleep_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO deep-sleep wake-up function.\n\n @param gpio_num GPIO number.\n\n @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used.\n\n @note Called by the SDK. User shouldn't call this directly in the APP.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_deep_sleep_wakeup_enable(
        gpio_num: gpio_num_t,
        intr_type: gpio_int_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO deep-sleep wake-up function.\n\n @param gpio_num GPIO number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_deep_sleep_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
#[doc = " Decoded values from SD card Card Specific Data register"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_csd_t {
    #[doc = "< CSD structure format"]
    pub csd_ver: ::core::ffi::c_int,
    #[doc = "< MMC version (for CID format)"]
    pub mmc_ver: ::core::ffi::c_int,
    #[doc = "< total number of sectors"]
    pub capacity: ::core::ffi::c_int,
    #[doc = "< sector size in bytes"]
    pub sector_size: ::core::ffi::c_int,
    #[doc = "< block length for reads"]
    pub read_block_len: ::core::ffi::c_int,
    #[doc = "< Card Command Class for SD"]
    pub card_command_class: ::core::ffi::c_int,
    #[doc = "< Max transfer speed"]
    pub tr_speed: ::core::ffi::c_int,
}
#[doc = " Decoded values from SD card Card IDentification register"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_cid_t {
    #[doc = "< manufacturer identification number"]
    pub mfg_id: ::core::ffi::c_int,
    #[doc = "< OEM/product identification number"]
    pub oem_id: ::core::ffi::c_int,
    #[doc = "< product name (MMC v1 has the longest)"]
    pub name: [::core::ffi::c_char; 8usize],
    #[doc = "< product revision"]
    pub revision: ::core::ffi::c_int,
    #[doc = "< product serial number"]
    pub serial: ::core::ffi::c_int,
    #[doc = "< manufacturing date"]
    pub date: ::core::ffi::c_int,
}
#[doc = " Decoded values from SD Configuration Register\n Note: When new member is added, update reserved bits accordingly"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_scr_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< reserved for manufacturer usage"]
    pub rsvd_mnf: u32,
}
impl sdmmc_scr_t {
    #[inline]
    pub fn sd_spec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sd_spec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_mem_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_erase_mem_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bus_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bus_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sd_spec: u32,
        erase_mem_state: u32,
        bus_width: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sd_spec: u32 = unsafe { ::core::mem::transmute(sd_spec) };
            sd_spec as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let erase_mem_state: u32 = unsafe { ::core::mem::transmute(erase_mem_state) };
            erase_mem_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let bus_width: u32 = unsafe { ::core::mem::transmute(bus_width) };
            bus_width as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Decoded values from SD Status Register\n Note: When new member is added, update reserved bits accordingly"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_ssr_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl sdmmc_ssr_t {
    #[inline]
    pub fn alloc_unit_kb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_alloc_unit_kb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_size_au(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_erase_size_au(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cur_bus_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cur_bus_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn discard_support(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discard_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fule_support(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fule_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_timeout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_erase_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_erase_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        alloc_unit_kb: u32,
        erase_size_au: u32,
        cur_bus_width: u32,
        discard_support: u32,
        fule_support: u32,
        erase_timeout: u32,
        erase_offset: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let alloc_unit_kb: u32 = unsafe { ::core::mem::transmute(alloc_unit_kb) };
            alloc_unit_kb as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let erase_size_au: u32 = unsafe { ::core::mem::transmute(erase_size_au) };
            erase_size_au as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let cur_bus_width: u32 = unsafe { ::core::mem::transmute(cur_bus_width) };
            cur_bus_width as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let discard_support: u32 = unsafe { ::core::mem::transmute(discard_support) };
            discard_support as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let fule_support: u32 = unsafe { ::core::mem::transmute(fule_support) };
            fule_support as u64
        });
        __bindgen_bitfield_unit.set(36usize, 6u8, {
            let erase_timeout: u32 = unsafe { ::core::mem::transmute(erase_timeout) };
            erase_timeout as u64
        });
        __bindgen_bitfield_unit.set(42usize, 2u8, {
            let erase_offset: u32 = unsafe { ::core::mem::transmute(erase_offset) };
            erase_offset as u64
        });
        __bindgen_bitfield_unit.set(44usize, 20u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Decoded values of Extended Card Specific Data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_ext_csd_t {
    #[doc = "< Extended CSD Revision"]
    pub rev: u8,
    #[doc = "< Power class used by the card"]
    pub power_class: u8,
    #[doc = "< data state on card after erase whether 0 or 1 (card vendor dependent)"]
    pub erase_mem_state: u8,
    #[doc = "< secure data management features supported by the card"]
    pub sec_feature: u8,
}
#[doc = " SD/MMC command response buffer"]
pub type sdmmc_response_t = [u32; 4usize];
#[doc = " SD SWITCH_FUNC response buffer"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sdmmc_switch_func_rsp_t {
    #[doc = "< response data"]
    pub data: [u32; 16usize],
}
#[doc = " SD/MMC command information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_command_t {
    #[doc = "< SD or MMC command index"]
    pub opcode: u32,
    #[doc = "< SD/MMC command argument"]
    pub arg: u32,
    #[doc = "< response buffer"]
    pub response: sdmmc_response_t,
    #[doc = "< buffer to send or read into"]
    pub data: *mut ::core::ffi::c_void,
    #[doc = "< length of data buffer"]
    pub datalen: usize,
    #[doc = "< block length"]
    pub blklen: usize,
    #[doc = "< see below"]
    pub flags: ::core::ffi::c_int,
    #[doc = "< error returned from transfer"]
    pub error: esp_err_t,
    #[doc = "< response timeout, in milliseconds"]
    pub timeout_ms: u32,
}
impl Default for sdmmc_command_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " SD/MMC Host description\n\n This structure defines properties of SD/MMC host and functions\n of SD/MMC host which can be used by upper layers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sdmmc_host_t {
    #[doc = "< flags defining host properties"]
    pub flags: u32,
    #[doc = "< slot number, to be passed to host functions"]
    pub slot: ::core::ffi::c_int,
    #[doc = "< max frequency supported by the host"]
    pub max_freq_khz: ::core::ffi::c_int,
    #[doc = "< I/O voltage used by the controller (voltage switching is not supported)"]
    pub io_voltage: f32,
    #[doc = "< Host function to initialize the driver"]
    pub init: ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>,
    #[doc = "< host function to set bus width"]
    pub set_bus_width: ::core::option::Option<
        unsafe extern "C" fn(slot: ::core::ffi::c_int, width: usize) -> esp_err_t,
    >,
    #[doc = "< host function to get bus width"]
    pub get_bus_width:
        ::core::option::Option<unsafe extern "C" fn(slot: ::core::ffi::c_int) -> usize>,
    #[doc = "< host function to set DDR mode"]
    pub set_bus_ddr_mode: ::core::option::Option<
        unsafe extern "C" fn(slot: ::core::ffi::c_int, ddr_enable: bool) -> esp_err_t,
    >,
    #[doc = "< host function to set card clock frequency"]
    pub set_card_clk: ::core::option::Option<
        unsafe extern "C" fn(slot: ::core::ffi::c_int, freq_khz: u32) -> esp_err_t,
    >,
    #[doc = "< host function to do a transaction"]
    pub do_transaction: ::core::option::Option<
        unsafe extern "C" fn(slot: ::core::ffi::c_int, cmdinfo: *mut sdmmc_command_t) -> esp_err_t,
    >,
    pub __bindgen_anon_1: sdmmc_host_t__bindgen_ty_1,
    #[doc = "< Host function to enable SDIO interrupt line"]
    pub io_int_enable:
        ::core::option::Option<unsafe extern "C" fn(slot: ::core::ffi::c_int) -> esp_err_t>,
    #[doc = "< Host function to wait for SDIO interrupt line to be active"]
    pub io_int_wait: ::core::option::Option<
        unsafe extern "C" fn(slot: ::core::ffi::c_int, timeout_ticks: TickType_t) -> esp_err_t,
    >,
    #[doc = "< timeout, in milliseconds, of a single command. Set to 0 to use the default value."]
    pub command_timeout_ms: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sdmmc_host_t__bindgen_ty_1 {
    #[doc = "< host function to deinitialize the driver"]
    pub deinit: ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>,
    #[doc = "< host function to deinitialize the driver, called with the `slot`"]
    pub deinit_p:
        ::core::option::Option<unsafe extern "C" fn(slot: ::core::ffi::c_int) -> esp_err_t>,
}
impl Default for sdmmc_host_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdmmc_host_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " SD/MMC card information structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sdmmc_card_t {
    #[doc = "< Host with which the card is associated"]
    pub host: sdmmc_host_t,
    #[doc = "< OCR (Operation Conditions Register) value"]
    pub ocr: u32,
    pub __bindgen_anon_1: sdmmc_card_t__bindgen_ty_1,
    #[doc = "< decoded CSD (Card-Specific Data) register value"]
    pub csd: sdmmc_csd_t,
    #[doc = "< decoded SCR (SD card Configuration Register) value"]
    pub scr: sdmmc_scr_t,
    #[doc = "< decoded SSR (SD Status Register) value"]
    pub ssr: sdmmc_ssr_t,
    #[doc = "< decoded EXT_CSD (Extended Card Specific Data) register value"]
    pub ext_csd: sdmmc_ext_csd_t,
    #[doc = "< RCA (Relative Card Address)"]
    pub rca: u16,
    #[doc = "< Maximum frequency, in kHz, supported by the card"]
    pub max_freq_khz: u16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sdmmc_card_t__bindgen_ty_1 {
    #[doc = "< decoded CID (Card IDentification) register value"]
    pub cid: sdmmc_cid_t,
    #[doc = "< raw CID of MMC card to be decoded\nafter the CSD is fetched in the data transfer mode"]
    pub raw_cid: sdmmc_response_t,
}
impl Default for sdmmc_card_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdmmc_card_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sdmmc_card_t {
    #[inline]
    pub fn is_mem(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mmc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mmc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_io_functions(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_num_io_functions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn log_bus_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log_bus_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn is_ddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_ddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_mem: u32,
        is_sdio: u32,
        is_mmc: u32,
        num_io_functions: u32,
        log_bus_width: u32,
        is_ddr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_mem: u32 = unsafe { ::core::mem::transmute(is_mem) };
            is_mem as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sdio: u32 = unsafe { ::core::mem::transmute(is_sdio) };
            is_sdio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_mmc: u32 = unsafe { ::core::mem::transmute(is_mmc) };
            is_mmc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let num_io_functions: u32 = unsafe { ::core::mem::transmute(num_io_functions) };
            num_io_functions as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let log_bus_width: u32 = unsafe { ::core::mem::transmute(log_bus_width) };
            log_bus_width as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_ddr: u32 = unsafe { ::core::mem::transmute(is_ddr) };
            is_ddr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Erase operation on SD, Trim operation on MMC"]
pub const sdmmc_erase_arg_t_SDMMC_ERASE_ARG: sdmmc_erase_arg_t = 0;
#[doc = "< Discard operation for SD/MMC"]
pub const sdmmc_erase_arg_t_SDMMC_DISCARD_ARG: sdmmc_erase_arg_t = 1;
#[doc = " SD/MMC erase command(38) arguments\n SD:\n  ERASE: Erase the write blocks, physical/hard erase.\n\n  DISCARD: Card may deallocate the discarded blocks partially or completely.\n  After discard operation the previously written data may be partially or\n  fully read by the host depending on card implementation.\n\n MMC:\n  ERASE: Does TRIM, applies erase operation to write blocks instead of Erase Group.\n\n  DISCARD: The Discard function allows the host to identify data that is no\n  longer required so that the device can erase the data if necessary during\n  background erase events. Applies to write blocks instead of Erase Group\n  After discard operation, the original data may be remained partially or\n  fully accessible to the host dependent on device.\n"]
pub type sdmmc_erase_arg_t = ::core::ffi::c_uint;
#[doc = " Handle representing an SD SPI device"]
pub type sdspi_dev_handle_t = ::core::ffi::c_int;
#[doc = " Extra configuration for SD SPI device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdspi_device_config_t {
    #[doc = "< SPI host to use, SPIx_HOST (see spi_types.h)."]
    pub host_id: spi_host_device_t,
    #[doc = "< GPIO number of CS signal"]
    pub gpio_cs: gpio_num_t,
    #[doc = "< GPIO number of card detect signal"]
    pub gpio_cd: gpio_num_t,
    #[doc = "< GPIO number of write protect signal"]
    pub gpio_wp: gpio_num_t,
    #[doc = "< GPIO number of interrupt line (input) for SDIO card."]
    pub gpio_int: gpio_num_t,
}
impl Default for sdspi_device_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize SD SPI driver\n\n @note This function is not thread safe\n\n @return\n      - ESP_OK on success\n      - other error codes may be returned in future versions"]
    pub fn sdspi_host_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attach and initialize an SD SPI device on the specific SPI bus\n\n @note This function is not thread safe\n\n @note Initialize the SPI bus by `spi_bus_initialize()` before calling this function.\n\n @note The SDIO over sdspi needs an extra interrupt line. Call ``gpio_install_isr_service()`` before this function.\n\n @param dev_config pointer to device configuration structure\n @param out_handle Output of the handle to the sdspi device.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if sdspi_host_init_device has invalid arguments\n      - ESP_ERR_NO_MEM if memory can not be allocated\n      - other errors from the underlying spi_master and gpio drivers"]
    pub fn sdspi_host_init_device(
        dev_config: *const sdspi_device_config_t,
        out_handle: *mut sdspi_dev_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove an SD SPI device\n\n @param handle Handle of the SD SPI device\n @return Always ESP_OK"]
    pub fn sdspi_host_remove_device(handle: sdspi_dev_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send command to the card and get response\n\n This function returns when command is sent and response is received,\n or data is transferred, or timeout occurs.\n\n @note This function is not thread safe w.r.t. init/deinit functions,\n       and bus width/clock speed configuration functions. Multiple tasks\n       can call sdspi_host_do_transaction as long as other sdspi_host_*\n       functions are not called.\n\n @param handle    Handle of the sdspi device\n @param cmdinfo   pointer to structure describing command and data to transfer\n @return\n      - ESP_OK on success\n      - ESP_ERR_TIMEOUT if response or data transfer has timed out\n      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed\n      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response"]
    pub fn sdspi_host_do_transaction(
        handle: sdspi_dev_handle_t,
        cmdinfo: *mut sdmmc_command_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set card clock frequency\n\n Currently only integer fractions of 40MHz clock can be used.\n For High Speed cards, 40MHz can be used.\n For Default Speed cards, 20MHz can be used.\n\n @note This function is not thread safe\n\n @param host    Handle of the sdspi device\n @param freq_khz  card clock frequency, in kHz\n @return\n      - ESP_OK on success\n      - other error codes may be returned in the future"]
    pub fn sdspi_host_set_card_clk(host: sdspi_dev_handle_t, freq_khz: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release resources allocated using sdspi_host_init\n\n @note This function is not thread safe\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if sdspi_host_init function has not been called"]
    pub fn sdspi_host_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable SDIO interrupt.\n\n @param handle    Handle of the sdspi device\n\n @return\n      - ESP_OK on success"]
    pub fn sdspi_host_io_int_enable(handle: sdspi_dev_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait for SDIO interrupt until timeout.\n\n @param handle    Handle of the sdspi device\n @param timeout_ticks Ticks to wait before timeout.\n\n @return\n      - ESP_OK on success"]
    pub fn sdspi_host_io_int_wait(
        handle: sdspi_dev_handle_t,
        timeout_ticks: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ff_memalloc(msize: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn ff_memfree(arg1: *mut ::core::ffi::c_void);
}
pub type UINT = ::core::ffi::c_uint;
pub type BYTE = ::core::ffi::c_uchar;
pub type WORD = u16;
pub type DWORD = u32;
pub type QWORD = u64;
pub type WCHAR = WORD;
pub type FSIZE_t = DWORD;
pub type LBA_t = DWORD;
pub type TCHAR = ::core::ffi::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PARTITION {
    pub pd: BYTE,
    pub pt: BYTE,
}
extern "C" {
    pub static VolToPart: [PARTITION; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FATFS {
    pub fs_type: BYTE,
    pub pdrv: BYTE,
    pub n_fats: BYTE,
    pub wflag: BYTE,
    pub fsi_flag: BYTE,
    pub id: WORD,
    pub n_rootdir: WORD,
    pub csize: WORD,
    pub ssize: WORD,
    pub sobj: SemaphoreHandle_t,
    pub last_clst: DWORD,
    pub free_clst: DWORD,
    pub n_fatent: DWORD,
    pub fsize: DWORD,
    pub volbase: LBA_t,
    pub fatbase: LBA_t,
    pub dirbase: LBA_t,
    pub database: LBA_t,
    pub winsect: LBA_t,
    pub win: [BYTE; 4096usize],
}
impl Default for FATFS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFOBJID {
    pub fs: *mut FATFS,
    pub id: WORD,
    pub attr: BYTE,
    pub stat: BYTE,
    pub sclust: DWORD,
    pub objsize: FSIZE_t,
}
impl Default for FFOBJID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIL {
    pub obj: FFOBJID,
    pub flag: BYTE,
    pub err: BYTE,
    pub fptr: FSIZE_t,
    pub clust: DWORD,
    pub sect: LBA_t,
    pub dir_sect: LBA_t,
    pub dir_ptr: *mut BYTE,
    pub buf: [BYTE; 4096usize],
}
impl Default for FIL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FF_DIR {
    pub obj: FFOBJID,
    pub dptr: DWORD,
    pub clust: DWORD,
    pub sect: LBA_t,
    pub dir: *mut BYTE,
    pub fn_: [BYTE; 12usize],
}
impl Default for FF_DIR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FILINFO {
    pub fsize: FSIZE_t,
    pub fdate: WORD,
    pub ftime: WORD,
    pub fattrib: BYTE,
    pub fname: [TCHAR; 13usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MKFS_PARM {
    pub fmt: BYTE,
    pub n_fat: BYTE,
    pub align: UINT,
    pub n_root: UINT,
    pub au_size: DWORD,
}
pub const FRESULT_FR_OK: FRESULT = 0;
pub const FRESULT_FR_DISK_ERR: FRESULT = 1;
pub const FRESULT_FR_INT_ERR: FRESULT = 2;
pub const FRESULT_FR_NOT_READY: FRESULT = 3;
pub const FRESULT_FR_NO_FILE: FRESULT = 4;
pub const FRESULT_FR_NO_PATH: FRESULT = 5;
pub const FRESULT_FR_INVALID_NAME: FRESULT = 6;
pub const FRESULT_FR_DENIED: FRESULT = 7;
pub const FRESULT_FR_EXIST: FRESULT = 8;
pub const FRESULT_FR_INVALID_OBJECT: FRESULT = 9;
pub const FRESULT_FR_WRITE_PROTECTED: FRESULT = 10;
pub const FRESULT_FR_INVALID_DRIVE: FRESULT = 11;
pub const FRESULT_FR_NOT_ENABLED: FRESULT = 12;
pub const FRESULT_FR_NO_FILESYSTEM: FRESULT = 13;
pub const FRESULT_FR_MKFS_ABORTED: FRESULT = 14;
pub const FRESULT_FR_TIMEOUT: FRESULT = 15;
pub const FRESULT_FR_LOCKED: FRESULT = 16;
pub const FRESULT_FR_NOT_ENOUGH_CORE: FRESULT = 17;
pub const FRESULT_FR_TOO_MANY_OPEN_FILES: FRESULT = 18;
pub const FRESULT_FR_INVALID_PARAMETER: FRESULT = 19;
pub type FRESULT = ::core::ffi::c_uint;
extern "C" {
    pub fn f_open(fp: *mut FIL, path: *const TCHAR, mode: BYTE) -> FRESULT;
}
extern "C" {
    pub fn f_close(fp: *mut FIL) -> FRESULT;
}
extern "C" {
    pub fn f_read(
        fp: *mut FIL,
        buff: *mut ::core::ffi::c_void,
        btr: UINT,
        br: *mut UINT,
    ) -> FRESULT;
}
extern "C" {
    pub fn f_write(
        fp: *mut FIL,
        buff: *const ::core::ffi::c_void,
        btw: UINT,
        bw: *mut UINT,
    ) -> FRESULT;
}
extern "C" {
    pub fn f_lseek(fp: *mut FIL, ofs: FSIZE_t) -> FRESULT;
}
extern "C" {
    pub fn f_truncate(fp: *mut FIL) -> FRESULT;
}
extern "C" {
    pub fn f_sync(fp: *mut FIL) -> FRESULT;
}
extern "C" {
    pub fn f_opendir(dp: *mut FF_DIR, path: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_closedir(dp: *mut FF_DIR) -> FRESULT;
}
extern "C" {
    pub fn f_readdir(dp: *mut FF_DIR, fno: *mut FILINFO) -> FRESULT;
}
extern "C" {
    pub fn f_findfirst(
        dp: *mut FF_DIR,
        fno: *mut FILINFO,
        path: *const TCHAR,
        pattern: *const TCHAR,
    ) -> FRESULT;
}
extern "C" {
    pub fn f_findnext(dp: *mut FF_DIR, fno: *mut FILINFO) -> FRESULT;
}
extern "C" {
    pub fn f_mkdir(path: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_unlink(path: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_rename(path_old: *const TCHAR, path_new: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_stat(path: *const TCHAR, fno: *mut FILINFO) -> FRESULT;
}
extern "C" {
    pub fn f_chmod(path: *const TCHAR, attr: BYTE, mask: BYTE) -> FRESULT;
}
extern "C" {
    pub fn f_utime(path: *const TCHAR, fno: *const FILINFO) -> FRESULT;
}
extern "C" {
    pub fn f_chdir(path: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_chdrive(path: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_getcwd(buff: *mut TCHAR, len: UINT) -> FRESULT;
}
extern "C" {
    pub fn f_getfree(path: *const TCHAR, nclst: *mut DWORD, fatfs: *mut *mut FATFS) -> FRESULT;
}
extern "C" {
    pub fn f_getlabel(path: *const TCHAR, label: *mut TCHAR, vsn: *mut DWORD) -> FRESULT;
}
extern "C" {
    pub fn f_setlabel(label: *const TCHAR) -> FRESULT;
}
extern "C" {
    pub fn f_forward(
        fp: *mut FIL,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *const BYTE, arg2: UINT) -> UINT>,
        btf: UINT,
        bf: *mut UINT,
    ) -> FRESULT;
}
extern "C" {
    pub fn f_expand(fp: *mut FIL, fsz: FSIZE_t, opt: BYTE) -> FRESULT;
}
extern "C" {
    pub fn f_mount(fs: *mut FATFS, path: *const TCHAR, opt: BYTE) -> FRESULT;
}
extern "C" {
    pub fn f_mkfs(
        path: *const TCHAR,
        opt: *const MKFS_PARM,
        work: *mut ::core::ffi::c_void,
        len: UINT,
    ) -> FRESULT;
}
extern "C" {
    pub fn f_fdisk(pdrv: BYTE, ptbl: *const LBA_t, work: *mut ::core::ffi::c_void) -> FRESULT;
}
extern "C" {
    pub fn f_setcp(cp: WORD) -> FRESULT;
}
extern "C" {
    pub fn f_putc(c: TCHAR, fp: *mut FIL) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn f_puts(str_: *const TCHAR, cp: *mut FIL) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn f_printf(fp: *mut FIL, str_: *const TCHAR, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn f_gets(buff: *mut TCHAR, len: ::core::ffi::c_int, fp: *mut FIL) -> *mut TCHAR;
}
extern "C" {
    pub fn get_fattime() -> DWORD;
}
extern "C" {
    pub fn ff_cre_syncobj(vol: BYTE, sobj: *mut SemaphoreHandle_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ff_req_grant(sobj: SemaphoreHandle_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ff_rel_grant(sobj: SemaphoreHandle_t);
}
extern "C" {
    pub fn ff_del_syncobj(sobj: SemaphoreHandle_t) -> ::core::ffi::c_int;
}
#[doc = "< map to data memory (Vaddr0), allows byte-aligned access, 4 MB total"]
pub const esp_partition_mmap_memory_t_ESP_PARTITION_MMAP_DATA: esp_partition_mmap_memory_t = 0;
#[doc = "< map to instruction memory (Vaddr1-3), allows only 4-byte-aligned access, 11 MB total"]
pub const esp_partition_mmap_memory_t_ESP_PARTITION_MMAP_INST: esp_partition_mmap_memory_t = 1;
#[doc = " @brief Enumeration which specifies memory space requested in an mmap call"]
pub type esp_partition_mmap_memory_t = ::core::ffi::c_uint;
#[doc = " @brief Opaque handle for memory region obtained from esp_partition_mmap."]
pub type esp_partition_mmap_handle_t = u32;
#[doc = "!< Application partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_APP: esp_partition_type_t = 0;
#[doc = "!< Data partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_DATA: esp_partition_type_t = 1;
#[doc = "!< Used to search for partitions with any type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_ANY: esp_partition_type_t = 255;
#[doc = " @brief Partition type\n\n @note Partition types with integer value 0x00-0x3F are reserved for partition types defined by ESP-IDF.\n Any other integer value 0x40-0xFE can be used by individual applications, without restriction.\n\n @internal Keep this enum in sync with PartitionDefinition class gen_esp32part.py @endinternal\n"]
pub type esp_partition_type_t = ::core::ffi::c_uint;
#[doc = "!< Factory application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_FACTORY: esp_partition_subtype_t = 0;
#[doc = "!< Base for OTA partition subtypes"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MIN: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 0"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_0: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 1"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_1: esp_partition_subtype_t = 17;
#[doc = "!< OTA partition 2"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_2: esp_partition_subtype_t = 18;
#[doc = "!< OTA partition 3"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_3: esp_partition_subtype_t = 19;
#[doc = "!< OTA partition 4"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_4: esp_partition_subtype_t = 20;
#[doc = "!< OTA partition 5"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_5: esp_partition_subtype_t = 21;
#[doc = "!< OTA partition 6"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_6: esp_partition_subtype_t = 22;
#[doc = "!< OTA partition 7"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_7: esp_partition_subtype_t = 23;
#[doc = "!< OTA partition 8"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_8: esp_partition_subtype_t = 24;
#[doc = "!< OTA partition 9"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_9: esp_partition_subtype_t = 25;
#[doc = "!< OTA partition 10"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_10: esp_partition_subtype_t = 26;
#[doc = "!< OTA partition 11"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_11: esp_partition_subtype_t = 27;
#[doc = "!< OTA partition 12"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_12: esp_partition_subtype_t = 28;
#[doc = "!< OTA partition 13"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_13: esp_partition_subtype_t = 29;
#[doc = "!< OTA partition 14"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_14: esp_partition_subtype_t = 30;
#[doc = "!< OTA partition 15"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_15: esp_partition_subtype_t = 31;
#[doc = "!< Max subtype of OTA partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MAX: esp_partition_subtype_t = 32;
#[doc = "!< Test application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_TEST: esp_partition_subtype_t = 32;
#[doc = "!< OTA selection partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_OTA: esp_partition_subtype_t = 0;
#[doc = "!< PHY init data partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_PHY: esp_partition_subtype_t = 1;
#[doc = "!< NVS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS: esp_partition_subtype_t = 2;
#[doc = "!< COREDUMP partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_COREDUMP: esp_partition_subtype_t = 3;
#[doc = "!< Partition for NVS keys"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS: esp_partition_subtype_t = 4;
#[doc = "!< Partition for emulate eFuse bits"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM: esp_partition_subtype_t = 5;
#[doc = "!< Undefined (or unspecified) data partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_UNDEFINED: esp_partition_subtype_t = 6;
#[doc = "!< ESPHTTPD partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD: esp_partition_subtype_t =
    128;
#[doc = "!< FAT partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_FAT: esp_partition_subtype_t = 129;
#[doc = "!< SPIFFS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_SPIFFS: esp_partition_subtype_t = 130;
#[doc = "!< Used to search for partitions with any subtype"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_ANY: esp_partition_subtype_t = 255;
#[doc = " @brief Partition subtype\n\n @note These ESP-IDF-defined partition subtypes apply to partitions of type ESP_PARTITION_TYPE_APP\n and ESP_PARTITION_TYPE_DATA.\n\n Application-defined partition types (0x40-0xFE) can set any numeric subtype value.\n\n @internal Keep this enum in sync with PartitionDefinition class gen_esp32part.py @endinternal"]
pub type esp_partition_subtype_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_iterator_opaque_ {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque partition iterator type"]
pub type esp_partition_iterator_t = *mut esp_partition_iterator_opaque_;
#[doc = " @brief partition information structure\n\n This is not the format in flash, that format is esp_partition_info_t.\n\n However, this is the format used by this API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_t {
    #[doc = "< SPI flash chip on which the partition resides"]
    pub flash_chip: *mut esp_flash_t,
    #[doc = "< partition type (app/data)"]
    pub type_: esp_partition_type_t,
    #[doc = "< partition subtype"]
    pub subtype: esp_partition_subtype_t,
    #[doc = "< starting address of the partition in flash"]
    pub address: u32,
    #[doc = "< size of the partition, in bytes"]
    pub size: u32,
    #[doc = "< size the erase operation should be aligned to"]
    pub erase_size: u32,
    #[doc = "< partition label, zero-terminated ASCII string"]
    pub label: [::core::ffi::c_char; 17usize],
    #[doc = "< flag is set to true if partition is encrypted"]
    pub encrypted: bool,
}
impl Default for esp_partition_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Find partition based on one or more parameters\n\n @param type Partition type, one of esp_partition_type_t values or an 8-bit unsigned integer.\n             To find all partitions, no matter the type, use ESP_PARTITION_TYPE_ANY, and set\n             subtype argument to ESP_PARTITION_SUBTYPE_ANY.\n @param subtype Partition subtype, one of esp_partition_subtype_t values or an 8-bit unsigned integer.\n                To find all partitions of given type, use ESP_PARTITION_SUBTYPE_ANY.\n @param label (optional) Partition label. Set this value if looking\n             for partition with a specific name. Pass NULL otherwise.\n\n @return iterator which can be used to enumerate all the partitions found,\n         or NULL if no partitions were found.\n         Iterator obtained through this function has to be released\n         using esp_partition_iterator_release when not used any more."]
    pub fn esp_partition_find(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const ::core::ffi::c_char,
    ) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Find first partition based on one or more parameters\n\n @param type Partition type, one of esp_partition_type_t values or an 8-bit unsigned integer.\n             To find all partitions, no matter the type, use ESP_PARTITION_TYPE_ANY, and set\n             subtype argument to ESP_PARTITION_SUBTYPE_ANY.\n @param subtype Partition subtype, one of esp_partition_subtype_t values or an 8-bit unsigned integer\n                To find all partitions of given type, use ESP_PARTITION_SUBTYPE_ANY.\n @param label (optional) Partition label. Set this value if looking\n             for partition with a specific name. Pass NULL otherwise.\n\n @return pointer to esp_partition_t structure, or NULL if no partition is found.\n         This pointer is valid for the lifetime of the application."]
    pub fn esp_partition_find_first(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const ::core::ffi::c_char,
    ) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Get esp_partition_t structure for given partition\n\n @param iterator  Iterator obtained using esp_partition_find. Must be non-NULL.\n\n @return pointer to esp_partition_t structure. This pointer is valid for the lifetime\n         of the application."]
    pub fn esp_partition_get(iterator: esp_partition_iterator_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Move partition iterator to the next partition found\n\n Any copies of the iterator will be invalid after this call.\n\n @param iterator Iterator obtained using esp_partition_find. Must be non-NULL.\n\n @return NULL if no partition was found, valid esp_partition_iterator_t otherwise."]
    pub fn esp_partition_next(iterator: esp_partition_iterator_t) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Release partition iterator\n\n @param iterator Iterator obtained using esp_partition_find.\n                 The iterator is allowed to be NULL, so it is not necessary to check its value\n                 before calling this function.\n"]
    pub fn esp_partition_iterator_release(iterator: esp_partition_iterator_t);
}
extern "C" {
    #[doc = " @brief Verify partition data\n\n Given a pointer to partition data, verify this partition exists in the partition table (all fields match.)\n\n This function is also useful to take partition data which may be in a RAM buffer and convert it to a pointer to the\n permanent partition data stored in flash.\n\n Pointers returned from this function can be compared directly to the address of any pointer returned from\n esp_partition_get(), as a test for equality.\n\n @param partition Pointer to partition data to verify. Must be non-NULL. All fields of this structure must match the\n partition table entry in flash for this function to return a successful match.\n\n @return\n - If partition not found, returns NULL.\n - If found, returns a pointer to the esp_partition_t structure in flash. This pointer is always valid for the lifetime of the application."]
    pub fn esp_partition_verify(partition: *const esp_partition_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Read data from the partition\n\n Partitions marked with an encryption flag will automatically be\n be read and decrypted via a cache mapping.\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param dst Pointer to the buffer where data should be stored.\n            Pointer must be non-NULL and buffer must be at least 'size' bytes long.\n @param src_offset Address of the data to be read, relative to the\n                   beginning of the partition.\n @param size Size of data to be read, in bytes.\n\n @return ESP_OK, if data was read successfully;\n         ESP_ERR_INVALID_ARG, if src_offset exceeds partition size;\n         ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition;\n         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_read(
        partition: *const esp_partition_t,
        src_offset: usize,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the partition\n\n Before writing data to flash, corresponding region of flash needs to be erased.\n This can be done using esp_partition_erase_range function.\n\n Partitions marked with an encryption flag will automatically be\n written via the esp_flash_write_encrypted() function. If writing to\n an encrypted partition, all write offsets and lengths must be\n multiples of 16 bytes. See the esp_flash_write_encrypted() function\n for more details. Unencrypted partitions do not have this\n restriction.\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param dst_offset Address where the data should be written, relative to the\n                   beginning of the partition.\n @param src Pointer to the source buffer.  Pointer must be non-NULL and\n            buffer must be at least 'size' bytes long.\n @param size Size of data to be written, in bytes.\n\n @note Prior to writing to flash memory, make sure it has been erased with\n       esp_partition_erase_range call.\n\n @return ESP_OK, if data was written successfully;\n         ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size;\n         ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition;\n         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_write(
        partition: *const esp_partition_t,
        dst_offset: usize,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from the partition without any transformation/decryption.\n\n @note This function is essentially the same as \\c esp_partition_read() above.\n       It just never decrypts data but returns it as is.\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param dst Pointer to the buffer where data should be stored.\n            Pointer must be non-NULL and buffer must be at least 'size' bytes long.\n @param src_offset Address of the data to be read, relative to the\n                   beginning of the partition.\n @param size Size of data to be read, in bytes.\n\n @return ESP_OK, if data was read successfully;\n         ESP_ERR_INVALID_ARG, if src_offset exceeds partition size;\n         ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition;\n         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_read_raw(
        partition: *const esp_partition_t,
        src_offset: usize,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the partition without any transformation/encryption.\n\n @note This function is essentially the same as \\c esp_partition_write() above.\n       It just never encrypts data but writes it as is.\n\n Before writing data to flash, corresponding region of flash needs to be erased.\n This can be done using esp_partition_erase_range function.\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param dst_offset Address where the data should be written, relative to the\n                   beginning of the partition.\n @param src Pointer to the source buffer.  Pointer must be non-NULL and\n            buffer must be at least 'size' bytes long.\n @param size Size of data to be written, in bytes.\n\n @note Prior to writing to flash memory, make sure it has been erased with\n       esp_partition_erase_range call.\n\n @return ESP_OK, if data was written successfully;\n         ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size;\n         ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition;\n         or one of the error codes from lower-level flash driver."]
    pub fn esp_partition_write_raw(
        partition: *const esp_partition_t,
        dst_offset: usize,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase part of the partition\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param offset Offset from the beginning of partition where erase operation\n               should start. Must be aligned to partition->erase_size.\n @param size Size of the range which should be erased, in bytes.\n                   Must be divisible by partition->erase_size.\n\n @return ESP_OK, if the range was erased successfully;\n         ESP_ERR_INVALID_ARG, if iterator or dst are NULL;\n         ESP_ERR_INVALID_SIZE, if erase would go out of bounds of the partition;\n         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_erase_range(
        partition: *const esp_partition_t,
        offset: usize,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure MMU to map partition into data memory\n\n Unlike spi_flash_mmap function, which requires a 64kB aligned base address,\n this function doesn't impose such a requirement.\n If offset results in a flash address which is not aligned to 64kB boundary,\n address will be rounded to the lower 64kB boundary, so that mapped region\n includes requested range.\n Pointer returned via out_ptr argument will be adjusted to point to the\n requested offset (not necessarily to the beginning of mmap-ed region).\n\n To release mapped memory, pass handle returned via out_handle argument to\n esp_partition_munmap function.\n\n @param partition Pointer to partition structure obtained using\n                  esp_partition_find_first or esp_partition_get.\n                  Must be non-NULL.\n @param offset Offset from the beginning of partition where mapping should start.\n @param size Size of the area to be mapped.\n @param memory  Memory space where the region should be mapped\n @param out_ptr  Output, pointer to the mapped memory region\n @param out_handle  Output, handle which should be used for esp_partition_munmap call\n\n @return ESP_OK, if successful"]
    pub fn esp_partition_mmap(
        partition: *const esp_partition_t,
        offset: usize,
        size: usize,
        memory: esp_partition_mmap_memory_t,
        out_ptr: *mut *const ::core::ffi::c_void,
        out_handle: *mut esp_partition_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release region previously obtained using esp_partition_mmap\n\n @note Calling this function will not necessarily unmap memory region.\n       Region will only be unmapped when there are no other handles which\n       reference this region. In case of partially overlapping regions\n       it is possible that memory will be unmapped partially.\n\n @param handle  Handle obtained from spi_flash_mmap"]
    pub fn esp_partition_munmap(handle: esp_partition_mmap_handle_t);
}
extern "C" {
    #[doc = " @brief Get SHA-256 digest for required partition.\n\n For apps with SHA-256 appended to the app image, the result is the appended SHA-256 value for the app image content.\n The hash is verified before returning, if app content is invalid then the function returns ESP_ERR_IMAGE_INVALID.\n For apps without SHA-256 appended to the image, the result is the SHA-256 of all bytes in the app image.\n For other partition types, the result is the SHA-256 of the entire partition.\n\n @param[in]  partition    Pointer to info for partition containing app or data. (fields: address, size and type, are required to be filled).\n @param[out] sha_256      Returned SHA-256 digest for a given partition.\n\n @return\n          - ESP_OK: In case of successful operation.\n          - ESP_ERR_INVALID_ARG: The size was 0 or the sha_256 was NULL.\n          - ESP_ERR_NO_MEM: Cannot allocate memory for sha256 operation.\n          - ESP_ERR_IMAGE_INVALID: App partition doesn't contain a valid app image.\n          - ESP_FAIL: An allocation error occurred."]
    pub fn esp_partition_get_sha256(
        partition: *const esp_partition_t,
        sha_256: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Check for the identity of two partitions by SHA-256 digest.\n\n @param[in] partition_1 Pointer to info for partition 1 containing app or data. (fields: address, size and type, are required to be filled).\n @param[in] partition_2 Pointer to info for partition 2 containing app or data. (fields: address, size and type, are required to be filled).\n\n @return\n         - True:  In case of the two firmware is equal.\n         - False: Otherwise"]
    pub fn esp_partition_check_identity(
        partition_1: *const esp_partition_t,
        partition_2: *const esp_partition_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Register a partition on an external flash chip\n\n This API allows designating certain areas of external flash chips (identified by the esp_flash_t structure)\n as partitions. This allows using them with components which access SPI flash through the esp_partition API.\n\n @param flash_chip  Pointer to the structure identifying the flash chip\n @param offset  Address in bytes, where the partition starts\n @param size  Size of the partition in bytes\n @param label  Partition name\n @param type  One of the partition types (ESP_PARTITION_TYPE_*), or an integer. Note that applications can not be booted from external flash\n              chips, so using ESP_PARTITION_TYPE_APP is not supported.\n @param subtype  One of the partition subtypes (ESP_PARTITION_SUBTYPE_*), or an integer.\n @param[out] out_partition  Output, if non-NULL, receives the pointer to the resulting esp_partition_t structure\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM if memory allocation has failed\n      - ESP_ERR_INVALID_ARG if the new partition overlaps another partition on the same flash chip\n      - ESP_ERR_INVALID_SIZE if the partition doesn't fit into the flash chip size"]
    pub fn esp_partition_register_external(
        flash_chip: *mut esp_flash_t,
        offset: usize,
        size: usize,
        label: *const ::core::ffi::c_char,
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        out_partition: *mut *const esp_partition_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the partition previously registered using esp_partition_register_external\n @param partition  pointer to the partition structure obtained from esp_partition_register_external,\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if the partition pointer is not found\n      - ESP_ERR_INVALID_ARG if the partition comes from the partition table\n      - ESP_ERR_INVALID_ARG if the partition was not registered using\n        esp_partition_register_external function."]
    pub fn esp_partition_deregister_external(partition: *const esp_partition_t) -> esp_err_t;
}
#[doc = " @brief wear levelling handle"]
pub type wl_handle_t = i32;
extern "C" {
    #[doc = " @brief Mount WL for defined partition\n\n @param partition that will be used for access\n @param out_handle handle of the WL instance\n\n @return\n       - ESP_OK, if the allocation was successfully;\n       - ESP_ERR_INVALID_ARG, if WL allocation was unsuccessful;\n       - ESP_ERR_NO_MEM, if there was no memory to allocate WL components;"]
    pub fn wl_mount(partition: *const esp_partition_t, out_handle: *mut wl_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unmount WL for defined partition\n\n @param handle WL partition handle\n\n @return\n       - ESP_OK, if the operation completed successfully;\n       - or one of error codes from lower-level flash driver."]
    pub fn wl_unmount(handle: wl_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase part of the WL storage\n\n @param handle WL handle that are related to the partition\n @param start_addr Address where erase operation should start. Must be aligned\n                   to the result of function wl_sector_size(...).\n @param size Size of the range which should be erased, in bytes.\n                   Must be divisible by result of function wl_sector_size(...)..\n\n @return\n       - ESP_OK, if the range was erased successfully;\n       - ESP_ERR_INVALID_ARG, if iterator or dst are NULL;\n       - ESP_ERR_INVALID_SIZE, if erase would go out of bounds of the partition;\n       - or one of error codes from lower-level flash driver."]
    pub fn wl_erase_range(handle: wl_handle_t, start_addr: usize, size: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the WL storage\n\n Before writing data to flash, corresponding region of flash needs to be erased.\n This can be done using wl_erase_range function.\n\n @param handle WL handle that are related to the partition\n @param dest_addr Address where the data should be written, relative to the\n                   beginning of the partition.\n @param src Pointer to the source buffer.  Pointer must be non-NULL and\n            buffer must be at least 'size' bytes long.\n @param size Size of data to be written, in bytes.\n\n @note Prior to writing to WL storage, make sure it has been erased with\n       wl_erase_range call.\n\n @return\n       - ESP_OK, if data was written successfully;\n       - ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size;\n       - ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition;\n       - or one of error codes from lower-level flash driver."]
    pub fn wl_write(
        handle: wl_handle_t,
        dest_addr: usize,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from the WL storage\n\n @param handle WL module instance that was initialized before\n @param dest Pointer to the buffer where data should be stored.\n            Pointer must be non-NULL and buffer must be at least 'size' bytes long.\n @param src_addr Address of the data to be read, relative to the\n                   beginning of the partition.\n @param size Size of data to be read, in bytes.\n\n @return\n       - ESP_OK, if data was read successfully;\n       - ESP_ERR_INVALID_ARG, if src_offset exceeds partition size;\n       - ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition;\n       - or one of error codes from lower-level flash driver."]
    pub fn wl_read(
        handle: wl_handle_t,
        src_addr: usize,
        dest: *mut ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get size of the WL storage\n\n @param handle WL module handle that was initialized before\n @return usable size, in bytes"]
    pub fn wl_size(handle: wl_handle_t) -> usize;
}
extern "C" {
    #[doc = " @brief Get sector size of the WL instance\n\n @param handle WL module handle that was initialized before\n @return sector size, in bytes"]
    pub fn wl_sector_size(handle: wl_handle_t) -> usize;
}
extern "C" {
    #[doc = " @brief Register FATFS with VFS component\n\n This function registers given FAT drive in VFS, at the specified base path.\n If only one drive is used, fat_drive argument can be an empty string.\n Refer to FATFS library documentation on how to specify FAT drive.\n This function also allocates FATFS structure which should be used for f_mount\n call.\n\n @note This function doesn't mount the drive into FATFS, it just connects\n       POSIX and C standard library IO function with FATFS. You need to mount\n       desired drive into FATFS separately.\n\n @param base_path  path prefix where FATFS should be registered\n @param fat_drive  FATFS drive specification; if only one drive is used, can be an empty string\n @param max_files  maximum number of files which can be open at the same time\n @param[out] out_fs  pointer to FATFS structure which can be used for FATFS f_mount call is returned via this argument.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_register was already called\n      - ESP_ERR_NO_MEM if not enough memory or too many VFSes already registered"]
    pub fn esp_vfs_fat_register(
        base_path: *const ::core::ffi::c_char,
        fat_drive: *const ::core::ffi::c_char,
        max_files: usize,
        out_fs: *mut *mut FATFS,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Un-register FATFS from VFS\n\n @note FATFS structure returned by esp_vfs_fat_register is destroyed after\n       this call. Make sure to call f_mount function to unmount it before\n       calling esp_vfs_fat_unregister_ctx.\n       Difference between this function and the one above is that this one\n       will release the correct drive, while the one above will release\n       the last registered one\n\n @param base_path     path prefix where FATFS is registered. This is the same\n                      used when esp_vfs_fat_register was called\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if FATFS is not registered in VFS"]
    pub fn esp_vfs_fat_unregister_path(base_path: *const ::core::ffi::c_char) -> esp_err_t;
}
#[doc = " @brief Configuration arguments for esp_vfs_fat_sdmmc_mount and esp_vfs_fat_spiflash_mount_rw_wl functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_vfs_fat_mount_config_t {
    #[doc = " If FAT partition can not be mounted, and this parameter is true,\n create partition table and format the filesystem."]
    pub format_if_mount_failed: bool,
    #[doc = "< Max number of open files"]
    pub max_files: ::core::ffi::c_int,
    #[doc = " If format_if_mount_failed is set, and mount fails, format the card\n with given allocation unit size. Must be a power of 2, between sector\n size and 128 * sector size.\n For SD cards, sector size is always 512 bytes. For wear_levelling,\n sector size is determined by CONFIG_WL_SECTOR_SIZE option.\n\n Using larger allocation unit size will result in higher read/write\n performance and higher overhead when storing small files.\n\n Setting this field to 0 will result in allocation unit set to the\n sector size."]
    pub allocation_unit_size: usize,
    #[doc = " Enables real ff_disk_status function implementation for SD cards\n (ff_sdmmc_status). Possibly slows down IO performance.\n\n Try to enable if you need to handle situations when SD cards\n are not unmounted properly before physical removal\n or you are experiencing issues with SD cards.\n\n Doesn't do anything for other memory storage media."]
    pub disk_status_check_enable: bool,
}
#[doc = " @brief Configuration arguments for esp_vfs_fat_sdmmc_mount and esp_vfs_fat_spiflash_mount_rw_wl functions"]
pub type esp_vfs_fat_sdmmc_mount_config_t = esp_vfs_fat_mount_config_t;
extern "C" {
    #[doc = " @brief Convenience function to get FAT filesystem on SD card registered in VFS\n\n This is an all-in-one function which does the following:\n - initializes SDMMC driver or SPI driver with configuration in host_config\n - initializes SD card with configuration in slot_config\n - mounts FAT partition on SD card using FATFS library, with configuration in mount_config\n - registers FATFS library with VFS, with prefix given by base_prefix variable\n\n This function is intended to make example code more compact.\n For real world applications, developers should implement the logic of\n probing SD card, locating and mounting partition, and registering FATFS in VFS,\n with proper error checking and handling of exceptional conditions.\n\n @note Use this API to mount a card through SDSPI is deprecated. Please call\n       `esp_vfs_fat_sdspi_mount()` instead for that case.\n\n @param base_path     path where partition should be registered (e.g. \"/sdcard\")\n @param host_config   Pointer to structure describing SDMMC host. When using\n                      SDMMC peripheral, this structure can be initialized using\n                      SDMMC_HOST_DEFAULT() macro. When using SPI peripheral,\n                      this structure can be initialized using SDSPI_HOST_DEFAULT()\n                      macro.\n @param slot_config   Pointer to structure with slot configuration.\n                      For SDMMC peripheral, pass a pointer to sdmmc_slot_config_t\n                      structure initialized using SDMMC_SLOT_CONFIG_DEFAULT.\n @param mount_config  pointer to structure with extra parameters for mounting FATFS\n @param[out] out_card  if not NULL, pointer to the card information structure will be returned via this argument\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called\n      - ESP_ERR_NO_MEM if memory can not be allocated\n      - ESP_FAIL if partition can not be mounted\n      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers"]
    pub fn esp_vfs_fat_sdmmc_mount(
        base_path: *const ::core::ffi::c_char,
        host_config: *const sdmmc_host_t,
        slot_config: *const ::core::ffi::c_void,
        mount_config: *const esp_vfs_fat_mount_config_t,
        out_card: *mut *mut sdmmc_card_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Convenience function to get FAT filesystem on SD card registered in VFS\n\n This is an all-in-one function which does the following:\n - initializes an SPI Master device based on the SPI Master driver with configuration in\n   slot_config, and attach it to an initialized SPI bus.\n - initializes SD card with configuration in host_config_input\n - mounts FAT partition on SD card using FATFS library, with configuration in mount_config\n - registers FATFS library with VFS, with prefix given by base_prefix variable\n\n This function is intended to make example code more compact.\n For real world applications, developers should implement the logic of\n probing SD card, locating and mounting partition, and registering FATFS in VFS,\n with proper error checking and handling of exceptional conditions.\n\n @note This function try to attach the new SD SPI device to the bus specified in host_config.\n       Make sure the SPI bus specified in `host_config->slot` have been initialized by\n       `spi_bus_initialize()` before.\n\n @param base_path     path where partition should be registered (e.g. \"/sdcard\")\n @param host_config_input Pointer to structure describing SDMMC host. This structure can be\n                          initialized using SDSPI_HOST_DEFAULT() macro.\n @param slot_config   Pointer to structure with slot configuration.\n                      For SPI peripheral, pass a pointer to sdspi_device_config_t\n                      structure initialized using SDSPI_DEVICE_CONFIG_DEFAULT().\n @param mount_config  pointer to structure with extra parameters for mounting FATFS\n @param[out] out_card If not NULL, pointer to the card information structure will be returned via\n                      this argument. It is suggested to hold this handle and use it to unmount the card later if\n                      needed. Otherwise it's not suggested to use more than one card at the same time and unmount one\n                      of them in your application.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called\n      - ESP_ERR_NO_MEM if memory can not be allocated\n      - ESP_FAIL if partition can not be mounted\n      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers"]
    pub fn esp_vfs_fat_sdspi_mount(
        base_path: *const ::core::ffi::c_char,
        host_config_input: *const sdmmc_host_t,
        slot_config: *const sdspi_device_config_t,
        mount_config: *const esp_vfs_fat_mount_config_t,
        out_card: *mut *mut sdmmc_card_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_sdmmc_mount\n\n @deprecated Use `esp_vfs_fat_sdcard_unmount()` instead.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called"]
    pub fn esp_vfs_fat_sdmmc_unmount() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unmount an SD card from the FAT filesystem and release resources acquired using\n        `esp_vfs_fat_sdmmc_mount()` or `esp_vfs_fat_sdspi_mount()`\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if the card argument is unregistered\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called"]
    pub fn esp_vfs_fat_sdcard_unmount(
        base_path: *const ::core::ffi::c_char,
        card: *mut sdmmc_card_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Convenience function to initialize FAT filesystem in SPI flash and register it in VFS\n\n This is an all-in-one function which does the following:\n\n - finds the partition with defined partition_label. Partition label should be\n   configured in the partition table.\n - initializes flash wear levelling library on top of the given partition\n - mounts FAT partition using FATFS library on top of flash wear levelling\n   library\n - registers FATFS library with VFS, with prefix given by base_prefix variable\n\n This function is intended to make example code more compact.\n\n @param base_path        path where FATFS partition should be mounted (e.g. \"/spiflash\")\n @param partition_label  label of the partition which should be used\n @param mount_config     pointer to structure with extra parameters for mounting FATFS\n @param[out] wl_handle   wear levelling driver handle\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if the partition table does not contain FATFS partition with given label\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_spiflash_mount_rw_wl was already called\n      - ESP_ERR_NO_MEM if memory can not be allocated\n      - ESP_FAIL if partition can not be mounted\n      - other error codes from wear levelling library, SPI flash driver, or FATFS drivers"]
    pub fn esp_vfs_fat_spiflash_mount_rw_wl(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
        mount_config: *const esp_vfs_fat_mount_config_t,
        wl_handle: *mut wl_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_spiflash_mount_rw_wl\n\n @param base_path  path where partition should be registered (e.g. \"/spiflash\")\n @param wl_handle  wear levelling driver handle returned by esp_vfs_fat_spiflash_mount_rw_wl\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_spiflash_mount_rw_wl hasn't been called"]
    pub fn esp_vfs_fat_spiflash_unmount_rw_wl(
        base_path: *const ::core::ffi::c_char,
        wl_handle: wl_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Convenience function to initialize read-only FAT filesystem and register it in VFS\n\n This is an all-in-one function which does the following:\n\n - finds the partition with defined partition_label. Partition label should be\n   configured in the partition table.\n - mounts FAT partition using FATFS library\n - registers FATFS library with VFS, with prefix given by base_prefix variable\n\n @note Wear levelling is not used when FAT is mounted in read-only mode using this function.\n\n @param base_path        path where FATFS partition should be mounted (e.g. \"/spiflash\")\n @param partition_label  label of the partition which should be used\n @param mount_config     pointer to structure with extra parameters for mounting FATFS\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if the partition table does not contain FATFS partition with given label\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_spiflash_mount_ro was already called for the same partition\n      - ESP_ERR_NO_MEM if memory can not be allocated\n      - ESP_FAIL if partition can not be mounted\n      - other error codes from SPI flash driver, or FATFS drivers"]
    pub fn esp_vfs_fat_spiflash_mount_ro(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
        mount_config: *const esp_vfs_fat_mount_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_spiflash_mount_ro\n\n @param base_path  path where partition should be registered (e.g. \"/spiflash\")\n @param partition_label label of partition to be unmounted\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if esp_vfs_fat_spiflash_mount_rw_wl hasn't been called"]
    pub fn esp_vfs_fat_spiflash_unmount_ro(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_vfs_fat_spiflash_mount(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
        mount_config: *const esp_vfs_fat_mount_config_t,
        wl_handle: *mut wl_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_vfs_fat_spiflash_unmount(
        base_path: *const ::core::ffi::c_char,
        wl_handle: wl_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_vfs_fat_rawflash_mount(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
        mount_config: *const esp_vfs_fat_mount_config_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_vfs_fat_rawflash_unmount(
        base_path: *const ::core::ffi::c_char,
        partition_label: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get information for FATFS partition\n\n @param base_path  Path where partition should be registered (e.g. \"/spiflash\")\n @param[out] out_total_bytes  Size of the file system\n @param[out] out_free_bytes   Current used bytes in the file system\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if partition not found\n      - ESP_FAIL if another FRESULT error (saved in errno)"]
    pub fn esp_vfs_fat_info(
        base_path: *const ::core::ffi::c_char,
        out_total_bytes: *mut u64,
        out_free_bytes: *mut u64,
    ) -> esp_err_t;
}
pub type DSTATUS = BYTE;
pub const DRESULT_RES_OK: DRESULT = 0;
pub const DRESULT_RES_ERROR: DRESULT = 1;
pub const DRESULT_RES_WRPRT: DRESULT = 2;
pub const DRESULT_RES_NOTRDY: DRESULT = 3;
pub const DRESULT_RES_PARERR: DRESULT = 4;
pub type DRESULT = ::core::ffi::c_uint;
extern "C" {
    pub fn ff_disk_initialize(pdrv: BYTE) -> DSTATUS;
}
extern "C" {
    pub fn ff_disk_status(pdrv: BYTE) -> DSTATUS;
}
extern "C" {
    pub fn ff_disk_read(pdrv: BYTE, buff: *mut BYTE, sector: LBA_t, count: UINT) -> DRESULT;
}
extern "C" {
    pub fn ff_disk_write(pdrv: BYTE, buff: *const BYTE, sector: LBA_t, count: UINT) -> DRESULT;
}
extern "C" {
    pub fn ff_disk_ioctl(pdrv: BYTE, cmd: BYTE, buff: *mut ::core::ffi::c_void) -> DRESULT;
}
#[doc = " Structure of pointers to disk IO driver functions.\n\n See FatFs documentation for details about these functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ff_diskio_impl_t {
    #[doc = "< disk initialization function"]
    pub init: ::core::option::Option<unsafe extern "C" fn(pdrv: ::core::ffi::c_uchar) -> DSTATUS>,
    #[doc = "< disk status check function"]
    pub status: ::core::option::Option<unsafe extern "C" fn(pdrv: ::core::ffi::c_uchar) -> DSTATUS>,
    #[doc = "< sector read function"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            pdrv: ::core::ffi::c_uchar,
            buff: *mut ::core::ffi::c_uchar,
            sector: u32,
            count: ::core::ffi::c_uint,
        ) -> DRESULT,
    >,
    #[doc = "< sector write function"]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            pdrv: ::core::ffi::c_uchar,
            buff: *const ::core::ffi::c_uchar,
            sector: u32,
            count: ::core::ffi::c_uint,
        ) -> DRESULT,
    >,
    #[doc = "< function to get info about disk and do some misc operations"]
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            pdrv: ::core::ffi::c_uchar,
            cmd: ::core::ffi::c_uchar,
            buff: *mut ::core::ffi::c_void,
        ) -> DRESULT,
    >,
}
extern "C" {
    #[doc = " Register or unregister diskio driver for given drive number.\n\n When FATFS library calls one of disk_xxx functions for driver number pdrv,\n corresponding function in discio_impl for given pdrv will be called.\n\n @param pdrv drive number\n @param discio_impl   pointer to ff_diskio_impl_t structure with diskio functions\n                      or NULL to unregister and free previously registered drive"]
    pub fn ff_diskio_register(pdrv: BYTE, discio_impl: *const ff_diskio_impl_t);
}
extern "C" {
    #[doc = " Get next available drive number\n\n @param   out_pdrv            pointer to the byte to set if successful\n\n @return  ESP_OK              on success\n          ESP_ERR_NOT_FOUND   if all drives are attached"]
    pub fn ff_diskio_get_drive(out_pdrv: *mut BYTE) -> esp_err_t;
}
extern "C" {
    #[doc = " Register spi flash partition\n\n @param pdrv  drive number\n @param part_handle  pointer to raw flash partition."]
    pub fn ff_diskio_register_raw_partition(
        pdrv: ::core::ffi::c_uchar,
        part_handle: *const esp_partition_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ff_diskio_get_pdrv_raw(part_handle: *const esp_partition_t) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " Probe and initialize SD/MMC card using given host\n\n @note Only SD cards (SDSC and SDHC/SDXC) are supported now.\n       Support for MMC/eMMC cards will be added later.\n\n @param host  pointer to structure defining host controller\n @param out_card  pointer to structure which will receive information\n                  about the card when the function completes\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_card_init(host: *const sdmmc_host_t, out_card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Print information about the card to a stream\n @param stream  stream obtained using fopen or fdopen\n @param card  card information structure initialized using sdmmc_card_init"]
    pub fn sdmmc_card_print_info(stream: *mut FILE, card: *const sdmmc_card_t);
}
extern "C" {
    #[doc = " Get status of SD/MMC card\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_get_status(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Write given number of sectors to SD/MMC card\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param src   pointer to data buffer to read data from; data size must be\n              equal to sector_count * card->csd.sector_size\n @param start_sector  sector where to start writing\n @param sector_count  number of sectors to write\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_write_sectors(
        card: *mut sdmmc_card_t,
        src: *const ::core::ffi::c_void,
        start_sector: usize,
        sector_count: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read given number of sectors from the SD/MMC card\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param dst   pointer to data buffer to write into; buffer size must be\n              at least sector_count * card->csd.sector_size\n @param start_sector  sector where to start reading\n @param sector_count  number of sectors to read\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_read_sectors(
        card: *mut sdmmc_card_t,
        dst: *mut ::core::ffi::c_void,
        start_sector: usize,
        sector_count: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Erase given number of sectors from the SD/MMC card\n\n @note When sdmmc_erase_sectors used with cards in SDSPI mode, it was\n observed that card requires re-init after erase operation.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param start_sector  sector where to start erase\n @param sector_count  number of sectors to erase\n @param arg  erase command (CMD38) argument\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_erase_sectors(
        card: *mut sdmmc_card_t,
        start_sector: usize,
        sector_count: usize,
        arg: sdmmc_erase_arg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if SD/MMC card supports discard\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK if supported by the card/device\n      - ESP_FAIL if not supported by the card/device"]
    pub fn sdmmc_can_discard(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if SD/MMC card supports trim\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK if supported by the card/device\n      - ESP_FAIL if not supported by the card/device"]
    pub fn sdmmc_can_trim(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if SD/MMC card supports sanitize\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK if supported by the card/device\n      - ESP_FAIL if not supported by the card/device"]
    pub fn sdmmc_mmc_can_sanitize(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Sanitize the data that was unmapped by a Discard command\n\n @note  Discard command has to precede sanitize operation. To discard, use\n        MMC_DICARD_ARG with sdmmc_erase_sectors argument\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param timeout_ms timeout value in milliseconds required to sanitize the\n                   selected range of sectors.\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_mmc_sanitize(card: *mut sdmmc_card_t, timeout_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Erase complete SD/MMC card\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_full_erase(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Read one byte from an SDIO card using IO_RW_DIRECT (CMD52)\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param reg  byte address within IO function\n @param[out] out_byte  output, receives the value read from the card\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_byte(
        card: *mut sdmmc_card_t,
        function: u32,
        reg: u32,
        out_byte: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write one byte to an SDIO card using IO_RW_DIRECT (CMD52)\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param reg  byte address within IO function\n @param in_byte  value to be written\n @param[out] out_byte  if not NULL, receives new byte value read\n                       from the card (read-after-write).\n @return\n      - ESP_OK on success\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_byte(
        card: *mut sdmmc_card_t,
        function: u32,
        reg: u32,
        in_byte: u8,
        out_byte: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read multiple bytes from an SDIO card using IO_RW_EXTENDED (CMD53)\n\n This function performs read operation using CMD53 in byte mode.\n For block mode, see sdmmc_io_read_blocks.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param addr  byte address within IO function where reading starts\n @param dst  buffer which receives the data read from card\n @param size  number of bytes to read\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_bytes(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write multiple bytes to an SDIO card using IO_RW_EXTENDED (CMD53)\n\n This function performs write operation using CMD53 in byte mode.\n For block mode, see sdmmc_io_write_blocks.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param addr  byte address within IO function where writing starts\n @param src  data to be written\n @param size  number of bytes to write\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_bytes(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read blocks of data from an SDIO card using IO_RW_EXTENDED (CMD53)\n\n This function performs read operation using CMD53 in block mode.\n For byte mode, see sdmmc_io_read_bytes.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param addr  byte address within IO function where writing starts\n @param dst  buffer which receives the data read from card\n @param size  number of bytes to read, must be divisible by the card block\n              size.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_blocks(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        dst: *mut ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write blocks of data to an SDIO card using IO_RW_EXTENDED (CMD53)\n\n This function performs write operation using CMD53 in block mode.\n For byte mode, see sdmmc_io_write_bytes.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param function  IO function number\n @param addr  byte address within IO function where writing starts\n @param src  data to be written\n @param size  number of bytes to read, must be divisible by the card block\n              size.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes\n      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_blocks(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Enable SDIO interrupt in the SDMMC host\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_SUPPORTED if the host controller does not support\n        IO interrupts"]
    pub fn sdmmc_io_enable_int(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Block until an SDIO interrupt is received\n\n Slave uses D1 line to signal interrupt condition to the host.\n This function can be used to wait for the interrupt.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param timeout_ticks  time to wait for the interrupt, in RTOS ticks\n @return\n      - ESP_OK if the interrupt is received\n      - ESP_ERR_NOT_SUPPORTED if the host controller does not support\n        IO interrupts\n      - ESP_ERR_TIMEOUT if the interrupt does not happen in timeout_ticks"]
    pub fn sdmmc_io_wait_int(card: *mut sdmmc_card_t, timeout_ticks: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Get the data of CIS region of an SDIO card.\n\n You may provide a buffer not sufficient to store all the CIS data. In this\n case, this function stores as much data into your buffer as possible. Also,\n this function will try to get and return the size required for you.\n\n @param card  pointer to card information structure previously initialized\n              using sdmmc_card_init\n @param out_buffer Output buffer of the CIS data\n @param buffer_size Size of the buffer.\n @param inout_cis_size Mandatory, pointer to a size, input and output.\n              - input: Limitation of maximum searching range, should be 0 or larger than\n                      buffer_size. The function searches for CIS_CODE_END until this range. Set to\n                      0 to search infinitely.\n              - output: The size required to store all the CIS data, if CIS_CODE_END is found.\n\n @return\n      - ESP_OK: on success\n      - ESP_ERR_INVALID_RESPONSE: if the card does not (correctly) support CIS.\n      - ESP_ERR_INVALID_SIZE: CIS_CODE_END found, but buffer_size is less than\n              required size, which is stored in the inout_cis_size then.\n      - ESP_ERR_NOT_FOUND: if the CIS_CODE_END not found. Increase input value of\n              inout_cis_size or set it to 0, if you still want to search for the end;\n              output value of inout_cis_size is invalid in this case.\n      - and other error code return from sdmmc_io_read_bytes"]
    pub fn sdmmc_io_get_cis_data(
        card: *mut sdmmc_card_t,
        out_buffer: *mut u8,
        buffer_size: usize,
        inout_cis_size: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Parse and print the CIS information of an SDIO card.\n\n @note Not all the CIS codes and all kinds of tuples are supported. If you\n see some unresolved code, you can add the parsing of these code in\n sdmmc_io.c and contribute to the IDF through the Github repository.\n\n              using sdmmc_card_init\n @param buffer Buffer to parse\n @param buffer_size Size of the buffer.\n @param fp File pointer to print to, set to NULL to print to stdout.\n\n @return\n      - ESP_OK: on success\n      - ESP_ERR_NOT_SUPPORTED: if the value from the card is not supported to be parsed.\n      - ESP_ERR_INVALID_SIZE: if the CIS size fields are not correct."]
    pub fn sdmmc_io_print_cis_info(buffer: *mut u8, buffer_size: usize, fp: *mut FILE)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable/disable SD card status checking\n\n @param pdrv   drive number\n @param enable mock ff_sdmmc_status function (return 0)"]
    pub fn ff_sdmmc_set_disk_status_check(pdrv: BYTE, enable: bool);
}
extern "C" {
    #[doc = " Register SD/MMC diskio driver\n\n @param pdrv  drive number\n @param card  pointer to sdmmc_card_t structure describing a card; card should be initialized before calling f_mount."]
    pub fn ff_diskio_register_sdmmc(pdrv: ::core::ffi::c_uchar, card: *mut sdmmc_card_t);
}
extern "C" {
    #[doc = " @brief Get the driver number corresponding to a card\n\n @param card The card to get its driver\n @return Driver number to the card"]
    pub fn ff_diskio_get_pdrv_card(card: *const sdmmc_card_t) -> BYTE;
}
extern "C" {
    #[doc = " Register spi flash partition\n\n @param pdrv  drive number\n @param flash_handle  handle of the wear levelling partition."]
    pub fn ff_diskio_register_wl_partition(
        pdrv: ::core::ffi::c_uchar,
        flash_handle: wl_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ff_diskio_get_pdrv_wl(flash_handle: wl_handle_t) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn ff_diskio_clear_pdrv_wl(flash_handle: wl_handle_t);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub un: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u32_addr: [u32_t; 4usize],
    pub u8_addr: [u8_t; 16usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " This variable is initialized by the system to contain the wildcard IPv6 address."]
    pub static in6addr_any: in6_addr;
}
#[doc = " No error, everything OK."]
pub const err_enum_t_ERR_OK: err_enum_t = 0;
#[doc = " Out of memory error."]
pub const err_enum_t_ERR_MEM: err_enum_t = -1;
#[doc = " Buffer error."]
pub const err_enum_t_ERR_BUF: err_enum_t = -2;
#[doc = " Timeout."]
pub const err_enum_t_ERR_TIMEOUT: err_enum_t = -3;
#[doc = " Routing problem."]
pub const err_enum_t_ERR_RTE: err_enum_t = -4;
#[doc = " Operation in progress"]
pub const err_enum_t_ERR_INPROGRESS: err_enum_t = -5;
#[doc = " Illegal value."]
pub const err_enum_t_ERR_VAL: err_enum_t = -6;
#[doc = " Operation would block."]
pub const err_enum_t_ERR_WOULDBLOCK: err_enum_t = -7;
#[doc = " Address in use."]
pub const err_enum_t_ERR_USE: err_enum_t = -8;
#[doc = " Already connecting."]
pub const err_enum_t_ERR_ALREADY: err_enum_t = -9;
#[doc = " Conn already established."]
pub const err_enum_t_ERR_ISCONN: err_enum_t = -10;
#[doc = " Not connected."]
pub const err_enum_t_ERR_CONN: err_enum_t = -11;
#[doc = " Low-level netif error"]
pub const err_enum_t_ERR_IF: err_enum_t = -12;
#[doc = " Connection aborted."]
pub const err_enum_t_ERR_ABRT: err_enum_t = -13;
#[doc = " Connection reset."]
pub const err_enum_t_ERR_RST: err_enum_t = -14;
#[doc = " Connection closed."]
pub const err_enum_t_ERR_CLSD: err_enum_t = -15;
#[doc = " Illegal argument."]
pub const err_enum_t_ERR_ARG: err_enum_t = -16;
#[doc = " Definitions for error constants."]
pub type err_enum_t = ::core::ffi::c_int;
pub type err_t = s8_t;
extern "C" {
    pub fn err_to_errno(err: err_t) -> ::core::ffi::c_int;
}
#[doc = " Includes spare room for transport layer header, e.g. UDP header.\n Use this if you intend to pass the pbuf to functions like udp_send()."]
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 74;
#[doc = " Includes spare room for IP header.\n Use this if you intend to pass the pbuf to functions like raw_send()."]
pub const pbuf_layer_PBUF_IP: pbuf_layer = 54;
#[doc = " Includes spare room for link layer header (ethernet header).\n Use this if you intend to pass the pbuf to functions like ethernet_output().\n @see PBUF_LINK_HLEN"]
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 14;
#[doc = " Includes spare room for additional encapsulation header before ethernet\n headers (e.g. 802.11).\n Use this if you intend to pass the pbuf to functions like netif->linkoutput().\n @see PBUF_LINK_ENCAPSULATION_HLEN"]
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 0;
#[doc = " Use this for input packets in a netif driver when calling netif->input()\n in the most common case - ethernet-layer netif driver."]
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 0;
#[doc = " @ingroup pbuf\n Enumeration of pbuf layers"]
pub type pbuf_layer = ::core::ffi::c_uint;
#[doc = " pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload\nare allocated in one piece of contiguous memory (so the first payload byte\ncan be calculated from struct pbuf).\npbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might\nchange in future versions).\nThis should be used for all OUTGOING packets (TX)."]
pub const pbuf_type_PBUF_RAM: pbuf_type = 640;
#[doc = " pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in\ntotally different memory areas. Since it points to ROM, payload does not\nhave to be copied when queued for transmission."]
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
#[doc = " pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change\nso it has to be duplicated when queued before transmitting, depending on\nwho has a 'ref' to it."]
pub const pbuf_type_PBUF_REF: pbuf_type = 65;
#[doc = " pbuf payload refers to RAM. This one comes from a pool and should be used\nfor RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct\npbuf and its payload are allocated in one piece of contiguous memory (so\nthe first payload byte can be calculated from struct pbuf).\nDon't use this for TX, if the pool becomes empty e.g. because of TCP queuing,\nyou are unable to receive TCP acks!"]
pub const pbuf_type_PBUF_POOL: pbuf_type = 386;
#[doc = " @ingroup pbuf\n Enumeration of pbuf types"]
pub type pbuf_type = ::core::ffi::c_uint;
#[doc = " Main packet buffer struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::core::ffi::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " a bit field indicating pbuf type and allocation sources\n(see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)"]
    pub type_internal: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u8_t,
    #[doc = " For incoming packets, this contains the input netif's index"]
    pub if_idx: u8_t,
}
impl Default for pbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Helper struct for const-correctness only.\n The only meaning of this one is to provide a const payload pointer\n for PBUF_ROM type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_rom {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *const ::core::ffi::c_void,
}
impl Default for pbuf_rom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Prototype for a function to free a custom pbuf"]
pub type pbuf_free_custom_fn = ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[doc = " A custom pbuf: like a pbuf, but following a function pointer to free it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_custom {
    #[doc = " The actual pbuf"]
    pub pbuf: pbuf,
    #[doc = " This function is called when pbuf_free deallocates this pbuf(_custom)"]
    pub custom_free_function: pbuf_free_custom_fn,
}
impl Default for pbuf_custom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloc_reference(
        payload: *mut ::core::ffi::c_void,
        length: u16_t,
        type_: pbuf_type,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut ::core::ffi::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_header_force(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header_force(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_free_header(q: *mut pbuf, size: u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
extern "C" {
    pub fn pbuf_clen(p: *const pbuf) -> u16_t;
}
extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *const pbuf) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial_pbuf(
        p_to: *mut pbuf,
        p_from: *const pbuf,
        copy_len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial(
        p: *const pbuf,
        dataptr: *mut ::core::ffi::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_get_contiguous(
        p: *const pbuf,
        buffer: *mut ::core::ffi::c_void,
        bufsize: usize,
        len: u16_t,
        offset: u16_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::core::ffi::c_void, len: u16_t) -> err_t;
}
extern "C" {
    pub fn pbuf_take_at(
        buf: *mut pbuf,
        dataptr: *const ::core::ffi::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_skip(in_: *mut pbuf, in_offset: u16_t, out_offset: *mut u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_clone(l: pbuf_layer, type_: pbuf_type, p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_get_at(p: *const pbuf, offset: u16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_try_get_at(p: *const pbuf, offset: u16_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pbuf_put_at(p: *mut pbuf, offset: u16_t, data: u8_t);
}
extern "C" {
    pub fn pbuf_memcmp(
        p: *const pbuf,
        offset: u16_t,
        s2: *const ::core::ffi::c_void,
        n: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_memfind(
        p: *const pbuf,
        mem: *const ::core::ffi::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_strstr(p: *const pbuf, substr: *const ::core::ffi::c_char) -> u16_t;
}
pub type mem_size_t = usize;
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mem_trim(mem: *mut ::core::ffi::c_void, size: mem_size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut ::core::ffi::c_void);
}
pub const memp_t_MEMP_RAW_PCB: memp_t = 0;
pub const memp_t_MEMP_UDP_PCB: memp_t = 1;
pub const memp_t_MEMP_TCP_PCB: memp_t = 2;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 3;
pub const memp_t_MEMP_TCP_SEG: memp_t = 4;
pub const memp_t_MEMP_FRAG_PBUF: memp_t = 5;
pub const memp_t_MEMP_NETBUF: memp_t = 6;
pub const memp_t_MEMP_NETCONN: memp_t = 7;
pub const memp_t_MEMP_TCPIP_MSG_API: memp_t = 8;
pub const memp_t_MEMP_TCPIP_MSG_INPKT: memp_t = 9;
pub const memp_t_MEMP_ARP_QUEUE: memp_t = 10;
pub const memp_t_MEMP_IGMP_GROUP: memp_t = 11;
pub const memp_t_MEMP_SYS_TIMEOUT: memp_t = 12;
pub const memp_t_MEMP_NETDB: memp_t = 13;
pub const memp_t_MEMP_ND6_QUEUE: memp_t = 14;
pub const memp_t_MEMP_MLD6_GROUP: memp_t = 15;
pub const memp_t_MEMP_PBUF: memp_t = 16;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 17;
pub const memp_t_MEMP_MAX: memp_t = 18;
#[doc = " Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end"]
pub type memp_t = ::core::ffi::c_uint;
#[doc = " Memory pool descriptor"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct memp_desc {
    #[doc = " Element size"]
    pub size: u16_t,
}
extern "C" {
    pub fn memp_init_pool(desc: *const memp_desc);
}
extern "C" {
    pub fn memp_malloc_pool(desc: *const memp_desc) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memp_free_pool(desc: *const memp_desc, mem: *mut ::core::ffi::c_void);
}
extern "C" {
    pub static memp_pools: [*const memp_desc; 18usize];
}
extern "C" {
    pub fn memp_init();
}
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut ::core::ffi::c_void);
}
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_DHCP:
    lwip_internal_netif_client_data_index = 0;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_IGMP:
    lwip_internal_netif_client_data_index = 1;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MLD6:
    lwip_internal_netif_client_data_index = 2;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MAX:
    lwip_internal_netif_client_data_index = 3;
#[doc = " @}"]
pub type lwip_internal_netif_client_data_index = ::core::ffi::c_uint;
#[doc = " Delete a filter entry"]
pub const netif_mac_filter_action_NETIF_DEL_MAC_FILTER: netif_mac_filter_action = 0;
#[doc = " Add a filter entry"]
pub const netif_mac_filter_action_NETIF_ADD_MAC_FILTER: netif_mac_filter_action = 1;
#[doc = " MAC Filter Actions, these are passed to a netif's igmp_mac_filter or\n mld_mac_filter callback function."]
pub type netif_mac_filter_action = ::core::ffi::c_uint;
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet\n @return ERR_OK if the packet was handled\n         != ERR_OK is the packet was NOT handled, in this case, the caller has\n                   to free the pbuf"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->output_ip6 functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'ethip6_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IPv6 address to which the packet shall be sent"]
pub type netif_output_ip6_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip6_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif igmp_mac_filter functions"]
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip4_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
#[doc = " Function prototype for netif mld_mac_filter functions"]
pub type netif_mld_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip6_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
pub type netif_addr_idx_t = u8_t;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " Array of IPv6 addresses for this netif."]
    pub ip6_addr: [ip_addr_t; 3usize],
    #[doc = " The state of each IPv6 address (Tentative, Preferred, etc).\n @see ip6_addr.h"]
    pub ip6_addr_state: [u8_t; 3usize],
    #[doc = " Remaining valid and preferred lifetime of each IPv6 address, in seconds.\n For valid lifetimes, the special value of IP6_ADDR_LIFE_STATIC (0)\n indicates the address is static and has no lifetimes."]
    pub ip6_addr_valid_life: [u32_t; 3usize],
    pub ip6_addr_pref_life: [u32_t; 3usize],
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually etharp_output()"]
    pub output: netif_output_fn,
    #[doc = " This function is called by ethernet_output() when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This function is called by the IPv6 module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually ethip6_output()"]
    pub output_ip6: netif_output_ip6_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device."]
    pub state: *mut ::core::ffi::c_void,
    pub client_data: [*mut ::core::ffi::c_void; 3usize],
    pub hostname: *const ::core::ffi::c_char,
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " maximum transfer unit (in bytes), updated by RA"]
    pub mtu6: u16_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " flags (@see @ref netif_flags)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [::core::ffi::c_char; 2usize],
    #[doc = " number of this interface. Used for @ref if_api and @ref netifapi_netif,\n as well as for IPv6 zones"]
    pub num: u8_t,
    #[doc = " is this netif enabled for IPv6 autoconfiguration"]
    pub ip6_autoconfig_enabled: u8_t,
    #[doc = " Number of Router Solicitation messages that remain to be sent."]
    pub rs_count: u8_t,
    #[doc = " This function could be called to add or delete an entry in the multicast\nfilter table of the ethernet MAC."]
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
    #[doc = " This function could be called to add or delete an entry in the IPv6 multicast\nfilter table of the ethernet MAC."]
    pub mld_mac_filter: netif_mld_mac_filter_fn,
    pub loop_first: *mut pbuf,
    pub loop_last: *mut pbuf,
    pub loop_cnt_current: u16_t,
    pub reschedule_poll: u8_t,
}
impl Default for netif {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
}
extern "C" {
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
}
extern "C" {
    pub fn netif_init();
}
extern "C" {
    pub fn netif_add_noaddr(
        netif: *mut netif,
        state: *mut ::core::ffi::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
        state: *mut ::core::ffi::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
    );
}
extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
extern "C" {
    pub fn netif_find(name: *const ::core::ffi::c_char) -> *mut netif;
}
extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_loop_output(netif: *mut netif, p: *mut pbuf) -> err_t;
}
extern "C" {
    pub fn netif_poll(netif: *mut netif);
}
extern "C" {
    pub fn netif_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn netif_ip6_addr_set(netif: *mut netif, addr_idx: s8_t, addr6: *const ip6_addr_t);
}
extern "C" {
    pub fn netif_ip6_addr_set_parts(
        netif: *mut netif,
        addr_idx: s8_t,
        i0: u32_t,
        i1: u32_t,
        i2: u32_t,
        i3: u32_t,
    );
}
extern "C" {
    pub fn netif_ip6_addr_set_state(netif: *mut netif, addr_idx: s8_t, state: u8_t);
}
extern "C" {
    pub fn netif_get_ip6_addr_match(netif: *mut netif, ip6addr: *const ip6_addr_t) -> s8_t;
}
extern "C" {
    pub fn netif_create_ip6_linklocal_address(netif: *mut netif, from_mac_48bit: u8_t);
}
extern "C" {
    pub fn netif_add_ip6_address(
        netif: *mut netif,
        ip6addr: *const ip6_addr_t,
        chosen_idx: *mut s8_t,
    ) -> err_t;
}
extern "C" {
    pub fn netif_name_to_index(name: *const ::core::ffi::c_char) -> u8_t;
}
extern "C" {
    pub fn netif_index_to_name(
        idx: u8_t,
        name: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn netif_get_by_index(idx: u8_t) -> *mut netif;
}
#[doc = " @ingroup netif\n Extended netif status callback (NSC) reasons flags.\n May be extended in the future!"]
pub type netif_nsc_reason_t = u16_t;
#[doc = " @ingroup netif\n Argument supplied to netif_ext_callback_fn."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union netif_ext_callback_args_t {
    pub link_changed: netif_ext_callback_args_t_link_changed_s,
    pub status_changed: netif_ext_callback_args_t_status_changed_s,
    pub ipv4_changed: netif_ext_callback_args_t_ipv4_changed_s,
    pub ipv6_set: netif_ext_callback_args_t_ipv6_set_s,
    pub ipv6_addr_state_changed: netif_ext_callback_args_t_ipv6_addr_state_changed_s,
}
#[doc = " Args to LWIP_NSC_LINK_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct netif_ext_callback_args_t_link_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[doc = " Args to LWIP_NSC_STATUS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct netif_ext_callback_args_t_status_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[doc = " Args to LWIP_NSC_IPV4_ADDRESS_CHANGED|LWIP_NSC_IPV4_GATEWAY_CHANGED|LWIP_NSC_IPV4_NETMASK_CHANGED|LWIP_NSC_IPV4_SETTINGS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv4_changed_s {
    #[doc = " Old IPv4 address"]
    pub old_address: *const ip_addr_t,
    pub old_netmask: *const ip_addr_t,
    pub old_gw: *const ip_addr_t,
}
impl Default for netif_ext_callback_args_t_ipv4_changed_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Args to LWIP_NSC_IPV6_SET callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_set_s {
    #[doc = " Index of changed IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address"]
    pub old_address: *const ip_addr_t,
}
impl Default for netif_ext_callback_args_t_ipv6_set_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Args to LWIP_NSC_IPV6_ADDR_STATE_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_addr_state_changed_s {
    #[doc = " Index of affected IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address state"]
    pub old_state: u8_t,
    #[doc = " Affected IPv6 address"]
    pub address: *const ip_addr_t,
}
impl Default for netif_ext_callback_args_t_ipv6_addr_state_changed_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for netif_ext_callback_args_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @ingroup netif\n Function used for extended netif status callbacks\n Note: When parsing reason argument, keep in mind that more reasons may be added in the future!\n @param netif netif that is affected by change\n @param reason change reason\n @param args depends on reason, see reason description"]
pub type netif_ext_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        reason: netif_nsc_reason_t,
        args: *const netif_ext_callback_args_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback {
    pub callback_fn: netif_ext_callback_fn,
    pub next: *mut netif_ext_callback,
}
impl Default for netif_ext_callback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type netif_ext_callback_t = netif_ext_callback;
extern "C" {
    pub fn netif_add_ext_callback(callback: *mut netif_ext_callback_t, fn_: netif_ext_callback_fn);
}
extern "C" {
    pub fn netif_remove_ext_callback(callback: *mut netif_ext_callback_t);
}
extern "C" {
    pub fn netif_invoke_ext_callback(
        netif: *mut netif,
        reason: netif_nsc_reason_t,
        args: *const netif_ext_callback_args_t,
    );
}
pub type sa_family_t = u8_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::core::ffi::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: u8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32_t,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub s2_len: u8_t,
    pub ss_family: sa_family_t,
    pub s2_data1: [::core::ffi::c_char; 2usize],
    pub s2_data2: [u32_t; 3usize],
    pub s2_data3: [u32_t; 3usize],
}
pub type socklen_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::core::ffi::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::core::ffi::c_int,
    pub msg_control: *mut ::core::ffi::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::core::ffi::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::core::ffi::c_int,
    pub cmsg_type: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ifreq {
    pub ifr_name: [::core::ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::core::ffi::c_int,
    pub l_linger: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::core::ffi::c_uint,
    pub ipi_addr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::core::ffi::c_uint,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lwip_socket_thread_init();
}
extern "C" {
    pub fn lwip_socket_thread_cleanup();
}
extern "C" {
    pub fn lwip_accept(
        s: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_bind(
        s: ::core::ffi::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_shutdown(s: ::core::ffi::c_int, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getpeername(
        s: ::core::ffi::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getsockname(
        s: ::core::ffi::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getsockopt(
        s: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_setsockopt(
        s: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_close(s: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_connect(
        s: ::core::ffi::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_listen(s: ::core::ffi::c_int, backlog: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_recv(
        s: ::core::ffi::c_int,
        mem: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_read(s: ::core::ffi::c_int, mem: *mut ::core::ffi::c_void, len: usize) -> isize;
}
extern "C" {
    pub fn lwip_readv(
        s: ::core::ffi::c_int,
        iov: *const iovec,
        iovcnt: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_recvfrom(
        s: ::core::ffi::c_int,
        mem: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn lwip_recvmsg(
        s: ::core::ffi::c_int,
        message: *mut msghdr,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_send(
        s: ::core::ffi::c_int,
        dataptr: *const ::core::ffi::c_void,
        size: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_sendmsg(
        s: ::core::ffi::c_int,
        message: *const msghdr,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_sendto(
        s: ::core::ffi::c_int,
        dataptr: *const ::core::ffi::c_void,
        size: usize,
        flags: ::core::ffi::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn lwip_socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_write(
        s: ::core::ffi::c_int,
        dataptr: *const ::core::ffi::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn lwip_writev(
        s: ::core::ffi::c_int,
        iov: *const iovec,
        iovcnt: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_select(
        maxfdp1: ::core::ffi::c_int,
        readset: *mut fd_set,
        writeset: *mut fd_set,
        exceptset: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_poll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_ioctl(
        s: ::core::ffi::c_int,
        cmd: ::core::ffi::c_long,
        argp: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_fcntl(
        s: ::core::ffi::c_int,
        cmd: ::core::ffi::c_int,
        val: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lwip_inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::core::ffi::c_char,
    pub h_aliases: *mut *mut ::core::ffi::c_char,
    pub h_addrtype: ::core::ffi::c_int,
    pub h_length: ::core::ffi::c_int,
    pub h_addr_list: *mut *mut ::core::ffi::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::core::ffi::c_int,
    pub ai_family: ::core::ffi::c_int,
    pub ai_socktype: ::core::ffi::c_int,
    pub ai_protocol: ::core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::core::ffi::c_char,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut h_errno: ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
}
extern "C" {
    pub fn lwip_gethostbyname_r(
        name: *const ::core::ffi::c_char,
        ret: *mut hostent,
        buf: *mut ::core::ffi::c_char,
        buflen: usize,
        result: *mut *mut hostent,
        h_errnop: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lwip_freeaddrinfo(ai: *mut addrinfo);
}
extern "C" {
    pub fn lwip_getaddrinfo(
        nodename: *const ::core::ffi::c_char,
        servname: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
}
#[doc = " Ethernet"]
pub const lwip_iana_hwtype_LWIP_IANA_HWTYPE_ETHERNET: lwip_iana_hwtype = 1;
#[doc = " @ingroup iana\n Hardware types"]
pub type lwip_iana_hwtype = ::core::ffi::c_uint;
#[doc = " SMTP"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SMTP: lwip_iana_port_number = 25;
#[doc = " DHCP server"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_DHCP_SERVER: lwip_iana_port_number = 67;
#[doc = " DHCP client"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_DHCP_CLIENT: lwip_iana_port_number = 68;
#[doc = " TFTP"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_TFTP: lwip_iana_port_number = 69;
#[doc = " HTTP"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_HTTP: lwip_iana_port_number = 80;
#[doc = " SNTP"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SNTP: lwip_iana_port_number = 123;
#[doc = " NETBIOS"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_NETBIOS: lwip_iana_port_number = 137;
#[doc = " SNMP"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SNMP: lwip_iana_port_number = 161;
#[doc = " SNMP traps"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SNMP_TRAP: lwip_iana_port_number = 162;
#[doc = " HTTPS"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_HTTPS: lwip_iana_port_number = 443;
#[doc = " SMTPS"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SMTPS: lwip_iana_port_number = 465;
#[doc = " MQTT"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_MQTT: lwip_iana_port_number = 1883;
#[doc = " MDNS"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_MDNS: lwip_iana_port_number = 5353;
#[doc = " Secure MQTT"]
pub const lwip_iana_port_number_LWIP_IANA_PORT_SECURE_MQTT: lwip_iana_port_number = 8883;
#[doc = " @ingroup iana\n Port numbers\n https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt"]
pub type lwip_iana_port_number = ::core::ffi::c_uint;
extern "C" {
    pub fn sntp_setoperatingmode(operating_mode: u8_t);
}
extern "C" {
    pub fn sntp_getoperatingmode() -> u8_t;
}
extern "C" {
    pub fn sntp_init();
}
extern "C" {
    pub fn sntp_stop();
}
extern "C" {
    pub fn sntp_enabled() -> u8_t;
}
extern "C" {
    pub fn sntp_setserver(idx: u8_t, addr: *const ip_addr_t);
}
extern "C" {
    pub fn sntp_getserver(idx: u8_t) -> *const ip_addr_t;
}
extern "C" {
    pub fn sntp_getreachability(idx: u8_t) -> u8_t;
}
extern "C" {
    pub fn sntp_setservername(idx: u8_t, server: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn sntp_getservername(idx: u8_t) -> *const ::core::ffi::c_char;
}
#[doc = "< Update system time immediately when receiving a response from the SNTP server."]
pub const sntp_sync_mode_t_SNTP_SYNC_MODE_IMMED: sntp_sync_mode_t = 0;
#[doc = "< Smooth time updating. Time error is gradually reduced using adjtime function. If the difference between SNTP response time and system time is large (more than 35 minutes) then update immediately."]
pub const sntp_sync_mode_t_SNTP_SYNC_MODE_SMOOTH: sntp_sync_mode_t = 1;
#[doc = " SNTP time update mode"]
pub type sntp_sync_mode_t = ::core::ffi::c_uint;
pub const sntp_sync_status_t_SNTP_SYNC_STATUS_RESET: sntp_sync_status_t = 0;
pub const sntp_sync_status_t_SNTP_SYNC_STATUS_COMPLETED: sntp_sync_status_t = 1;
pub const sntp_sync_status_t_SNTP_SYNC_STATUS_IN_PROGRESS: sntp_sync_status_t = 2;
#[doc = " SNTP sync status"]
pub type sntp_sync_status_t = ::core::ffi::c_uint;
pub const esp_sntp_operatingmode_t_ESP_SNTP_OPMODE_POLL: esp_sntp_operatingmode_t = 0;
pub const esp_sntp_operatingmode_t_ESP_SNTP_OPMODE_LISTENONLY: esp_sntp_operatingmode_t = 1;
#[doc = " SNTP operating modes per lwip SNTP module"]
pub type esp_sntp_operatingmode_t = ::core::ffi::c_uint;
#[doc = " @brief SNTP callback function for notifying about time sync event\n\n @param tv Time received from SNTP server."]
pub type sntp_sync_time_cb_t = ::core::option::Option<unsafe extern "C" fn(tv: *mut timeval)>;
extern "C" {
    #[doc = " @brief This function updates the system time.\n\n This is a weak-linked function. It is possible to replace all SNTP update functionality\n by placing a sntp_sync_time() function in the app firmware source.\n If the default implementation is used, calling sntp_set_sync_mode() allows\n the time synchronization mode to be changed to instant or smooth.\n If a callback function is registered via sntp_set_time_sync_notification_cb(),\n it will be called following time synchronization.\n\n @param tv Time received from SNTP server."]
    pub fn sntp_sync_time(tv: *mut timeval);
}
extern "C" {
    #[doc = " @brief Set the sync mode\n\n Modes allowed: SNTP_SYNC_MODE_IMMED and SNTP_SYNC_MODE_SMOOTH.\n @param sync_mode Sync mode."]
    pub fn sntp_set_sync_mode(sync_mode: sntp_sync_mode_t);
}
extern "C" {
    #[doc = " @brief Get set sync mode\n\n @return  SNTP_SYNC_MODE_IMMED: Update time immediately.\n          SNTP_SYNC_MODE_SMOOTH: Smooth time updating."]
    pub fn sntp_get_sync_mode() -> sntp_sync_mode_t;
}
extern "C" {
    #[doc = " @brief Get status of time sync\n\n After the update is completed, the status will be returned as SNTP_SYNC_STATUS_COMPLETED.\n After that, the status will be reset to SNTP_SYNC_STATUS_RESET.\n If the update operation is not completed yet, the status will be SNTP_SYNC_STATUS_RESET.\n If a smooth mode was chosen and the synchronization is still continuing (adjtime works), then it will be SNTP_SYNC_STATUS_IN_PROGRESS.\n\n @return  SNTP_SYNC_STATUS_RESET: Reset status.\n          SNTP_SYNC_STATUS_COMPLETED: Time is synchronized.\n          SNTP_SYNC_STATUS_IN_PROGRESS: Smooth time sync in progress."]
    pub fn sntp_get_sync_status() -> sntp_sync_status_t;
}
extern "C" {
    #[doc = " @brief Set status of time sync\n\n @param sync_status status of time sync (see sntp_sync_status_t)"]
    pub fn sntp_set_sync_status(sync_status: sntp_sync_status_t);
}
extern "C" {
    #[doc = " @brief Set a callback function for time synchronization notification\n\n @param callback a callback function"]
    pub fn sntp_set_time_sync_notification_cb(callback: sntp_sync_time_cb_t);
}
extern "C" {
    #[doc = " @brief Set the sync interval of SNTP operation\n\n Note: SNTPv4 RFC 4330 enforces a minimum sync interval of 15 seconds.\n This sync interval will be used in the next attempt update time throught SNTP.\n To apply the new sync interval call the sntp_restart() function,\n otherwise, it will be applied after the last interval expired.\n\n @param interval_ms   The sync interval in ms. It cannot be lower than 15 seconds, otherwise 15 seconds will be set."]
    pub fn sntp_set_sync_interval(interval_ms: u32);
}
extern "C" {
    #[doc = " @brief Restart SNTP\n\n @return True  - Restart\n         False - SNTP was not initialized yet"]
    pub fn sntp_restart() -> bool;
}
extern "C" {
    #[doc = " @brief Sets SNTP operating mode. The mode has to be set before init.\n\n @param operating_mode Desired operating mode"]
    pub fn esp_sntp_setoperatingmode(operating_mode: esp_sntp_operatingmode_t);
}
extern "C" {
    #[doc = " @brief Init and start SNTP service"]
    pub fn esp_sntp_init();
}
extern "C" {
    #[doc = " @brief Stops SNTP service"]
    pub fn esp_sntp_stop();
}
extern "C" {
    #[doc = " @brief Sets SNTP server address\n\n @param idx Index of the server\n @param addr IP address of the server"]
    pub fn esp_sntp_setserver(idx: u8_t, addr: *const ip_addr_t);
}
extern "C" {
    #[doc = " @brief Sets SNTP hostname\n @param idx Index of the server\n @param server Name of the server"]
    pub fn esp_sntp_setservername(idx: u8_t, server: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Gets SNTP server name\n @param idx Index of the server\n @return Name of the server"]
    pub fn esp_sntp_getservername(idx: u8_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Get SNTP server IP\n @param idx Index of the server\n @return IP address of the server"]
    pub fn esp_sntp_getserver(idx: u8_t) -> *const ip_addr_t;
}
extern "C" {
    #[doc = " @brief Checks if sntp is enabled\n @return true if sntp module is enabled"]
    pub fn esp_sntp_enabled() -> bool;
}
#[doc = " @brief Type of \"ping\" session handle"]
pub type esp_ping_handle_t = *mut ::core::ffi::c_void;
#[doc = " @brief Type of \"ping\" callback functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_ping_callbacks_t {
    #[doc = " @brief arguments for callback functions\n"]
    pub cb_args: *mut ::core::ffi::c_void,
    #[doc = " @brief Invoked by internal ping thread when received ICMP echo reply packet\n"]
    pub on_ping_success: ::core::option::Option<
        unsafe extern "C" fn(hdl: esp_ping_handle_t, args: *mut ::core::ffi::c_void),
    >,
    #[doc = " @brief Invoked by internal ping thread when receive ICMP echo reply packet timeout\n"]
    pub on_ping_timeout: ::core::option::Option<
        unsafe extern "C" fn(hdl: esp_ping_handle_t, args: *mut ::core::ffi::c_void),
    >,
    #[doc = " @brief Invoked by internal ping thread when a ping session is finished\n"]
    pub on_ping_end: ::core::option::Option<
        unsafe extern "C" fn(hdl: esp_ping_handle_t, args: *mut ::core::ffi::c_void),
    >,
}
impl Default for esp_ping_callbacks_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Type of \"ping\" configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_ping_config_t {
    #[doc = "< A \"ping\" session contains count procedures"]
    pub count: u32,
    #[doc = "< Milliseconds between each ping procedure"]
    pub interval_ms: u32,
    #[doc = "< Timeout value (in milliseconds) of each ping procedure"]
    pub timeout_ms: u32,
    #[doc = "< Size of the data next to ICMP packet header"]
    pub data_size: u32,
    #[doc = "< Type of Service, a field specified in the IP header"]
    pub tos: ::core::ffi::c_int,
    #[doc = "< Time to Live,a field specified in the IP header"]
    pub ttl: ::core::ffi::c_int,
    #[doc = "< Target IP address, either IPv4 or IPv6"]
    pub target_addr: ip_addr_t,
    #[doc = "< Stack size of internal ping task"]
    pub task_stack_size: u32,
    #[doc = "< Priority of internal ping task"]
    pub task_prio: u32,
    #[doc = "< Netif index, interface=0 means NETIF_NO_INDEX"]
    pub interface: u32,
}
impl Default for esp_ping_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Sequence number of a ping procedure"]
pub const esp_ping_profile_t_ESP_PING_PROF_SEQNO: esp_ping_profile_t = 0;
#[doc = "< Type of service of a ping procedure"]
pub const esp_ping_profile_t_ESP_PING_PROF_TOS: esp_ping_profile_t = 1;
#[doc = "< Time to live of a ping procedure"]
pub const esp_ping_profile_t_ESP_PING_PROF_TTL: esp_ping_profile_t = 2;
#[doc = "< Number of request packets sent out"]
pub const esp_ping_profile_t_ESP_PING_PROF_REQUEST: esp_ping_profile_t = 3;
#[doc = "< Number of reply packets received"]
pub const esp_ping_profile_t_ESP_PING_PROF_REPLY: esp_ping_profile_t = 4;
#[doc = "< IP address of replied target"]
pub const esp_ping_profile_t_ESP_PING_PROF_IPADDR: esp_ping_profile_t = 5;
#[doc = "< Size of received packet"]
pub const esp_ping_profile_t_ESP_PING_PROF_SIZE: esp_ping_profile_t = 6;
#[doc = "< Elapsed time between request and reply packet"]
pub const esp_ping_profile_t_ESP_PING_PROF_TIMEGAP: esp_ping_profile_t = 7;
#[doc = "< Elapsed time of the whole ping session"]
pub const esp_ping_profile_t_ESP_PING_PROF_DURATION: esp_ping_profile_t = 8;
#[doc = " @brief Profile of ping session"]
pub type esp_ping_profile_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Create a ping session\n\n @param config ping configuration\n @param cbs a bunch of callback functions invoked by internal ping task\n @param hdl_out handle of ping session\n @return\n      - ESP_ERR_INVALID_ARG: invalid parameters (e.g. configuration is null, etc)\n      - ESP_ERR_NO_MEM: out of memory\n      - ESP_FAIL: other internal error (e.g. socket error)\n      - ESP_OK: create ping session successfully, user can take the ping handle to do follow-on jobs"]
    pub fn esp_ping_new_session(
        config: *const esp_ping_config_t,
        cbs: *const esp_ping_callbacks_t,
        hdl_out: *mut esp_ping_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete a ping session\n\n @param hdl handle of ping session\n @return\n      - ESP_ERR_INVALID_ARG: invalid parameters (e.g. ping handle is null, etc)\n      - ESP_OK: delete ping session successfully"]
    pub fn esp_ping_delete_session(hdl: esp_ping_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start the ping session\n\n @param hdl handle of ping session\n @return\n      - ESP_ERR_INVALID_ARG: invalid parameters (e.g. ping handle is null, etc)\n      - ESP_OK: start ping session successfully"]
    pub fn esp_ping_start(hdl: esp_ping_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the ping session\n\n @param hdl handle of ping session\n @return\n      - ESP_ERR_INVALID_ARG: invalid parameters (e.g. ping handle is null, etc)\n      - ESP_OK: stop ping session successfully"]
    pub fn esp_ping_stop(hdl: esp_ping_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get runtime profile of ping session\n\n @param hdl handle of ping session\n @param profile type of profile\n @param data profile data\n @param size profile data size\n @return\n      - ESP_ERR_INVALID_ARG: invalid parameters (e.g. ping handle is null, etc)\n      - ESP_ERR_INVALID_SIZE: the actual profile data size doesn't match the \"size\" parameter\n      - ESP_OK: get profile successfully"]
    pub fn esp_ping_get_profile(
        hdl: esp_ping_handle_t,
        profile: esp_ping_profile_t,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_mbedtls_mem_calloc(n: usize, size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn esp_mbedtls_mem_free(ptr: *mut ::core::ffi::c_void);
}
pub type mbedtls_iso_c_forbids_empty_translation_units = ::core::ffi::c_int;
extern "C" {
    #[doc = " \\brief       Securely zeroize a buffer\n\n              The function is meant to wipe the data contained in a buffer so\n              that it can no longer be recovered even if the program memory\n              is later compromised. Call this function on sensitive data\n              stored on the stack before returning from a function, and on\n              sensitive data stored on the heap before freeing the heap\n              object.\n\n              It is extremely difficult to guarantee that calls to\n              mbedtls_platform_zeroize() are not removed by aggressive\n              compiler optimizations in a portable way. For this reason, Mbed\n              TLS provides the configuration option\n              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure\n              mbedtls_platform_zeroize() to use a suitable implementation for\n              their platform and needs\n\n \\param buf   Buffer to be zeroized\n \\param len   Length of the buffer in bytes\n"]
    pub fn mbedtls_platform_zeroize(buf: *mut ::core::ffi::c_void, len: usize);
}
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_mpi {
    pub private_s: ::core::ffi::c_int,
    pub private_n: usize,
    pub private_p: *mut mbedtls_mpi_uint,
}
impl Default for mbedtls_mpi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           Initialize an MPI context.\n\n                  This makes the MPI ready to be set or freed,\n                  but does not define a value for the MPI.\n\n \\param X         The MPI context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an MPI context.\n\n \\param X        The MPI context to be cleared. This may be \\c NULL,\n                 in which case this function is a no-op. If it is\n                 not \\c NULL, it must point to an initialized MPI."]
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Enlarge an MPI to the specified number of limbs.\n\n \\note           This function does nothing if the MPI is\n                 already large enough.\n\n \\param X        The MPI to grow. It must be initialized.\n \\param nblimbs  The target number of limbs.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: usize) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function resizes an MPI downwards, keeping at least the\n                 specified number of limbs.\n\n                 If \\c X is smaller than \\c nblimbs, it is resized up\n                 instead.\n\n \\param X        The MPI to shrink. This must point to an initialized MPI.\n \\param nblimbs  The minimum number of limbs to keep.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed\n                 (this can only happen when resizing up).\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: usize) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Make a copy of an MPI.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param Y        The source MPI. This must point to an initialized MPI.\n\n \\note           The limb-buffer in the destination MPI is enlarged\n                 if necessary to hold the value in the source MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Swap the contents of two MPIs.\n\n \\param X        The first MPI. It must be initialized.\n \\param Y        The second MPI. It must be initialized."]
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional copy of MPI which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The MPI to conditionally assign to. This must point\n                 to an initialized MPI.\n \\param Y        The MPI to be assigned from. This must point to an\n                 initialized MPI.\n \\param assign   The condition deciding whether to perform the\n                 assignment or not. Must be either 0 or 1:\n                 * \\c 1: Perform the assignment `X = Y`.\n                 * \\c 0: Keep the original value of \\p X.\n\n \\note           This function is equivalent to\n                      `if( assign ) mbedtls_mpi_copy( X, Y );`\n                 except that it avoids leaking any information about whether\n                 the assignment was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p assign is neither 0 nor 1, the result of this function\n                 is indeterminate, and the resulting value in \\p X might be\n                 neither its original value nor the value in \\p Y.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional swap which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The first MPI. This must be initialized.\n \\param Y        The second MPI. This must be initialized.\n \\param swap     The condition deciding whether to perform\n                 the swap or not. Must be either 0 or 1:\n                 * \\c 1: Swap the values of \\p X and \\p Y.\n                 * \\c 0: Keep the original values of \\p X and \\p Y.\n\n \\note           This function is equivalent to\n                      if( swap ) mbedtls_mpi_swap( X, Y );\n                 except that it avoids leaking any information about whether\n                 the swap was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p swap is neither 0 nor 1, the result of this function\n                 is indeterminate, and both \\p X and \\p Y might end up with\n                 values different to either of the original ones.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure.\n"]
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        swap: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Store integer value in MPI.\n\n \\param X        The MPI to set. This must be initialized.\n \\param z        The value to use.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a specific bit from an MPI.\n\n \\param X        The MPI to query. This must be initialized.\n \\param pos      Zero-based index of the bit to query.\n\n \\return         \\c 0 or \\c 1 on success, depending on whether bit \\c pos\n                 of \\c X is unset or set.\n \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: usize) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Modify a specific bit in an MPI.\n\n \\note           This function will grow the target MPI if necessary to set a\n                 bit to \\c 1 in a not yet existing limb. It will not grow if\n                 the bit should be set to \\c 0.\n\n \\param X        The MPI to modify. This must be initialized.\n \\param pos      Zero-based index of the bit to modify.\n \\param val      The desired value of bit \\c pos: \\c 0 or \\c 1.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_set_bit(
        X: *mut mbedtls_mpi,
        pos: usize,
        val: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits of value \\c 0 before the\n                 least significant bit of value \\c 1.\n\n \\note           This is the same as the zero-based index of\n                 the least significant bit of value \\c 1.\n\n \\param X        The MPI to query.\n\n \\return         The number of bits of value \\c 0 before the least significant\n                 bit of value \\c 1 in \\p X."]
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits up to and including the most\n                 significant bit of value \\c 1.\n\n * \\note         This is same as the one-based index of the most\n                 significant bit of value \\c 1.\n\n \\param X        The MPI to query. This must point to an initialized MPI.\n\n \\return         The number of bits up to and including the most\n                 significant bit of value \\c 1."]
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the total size of an MPI value in bytes.\n\n \\param X        The MPI to use. This must point to an initialized MPI.\n\n \\note           The value returned by this function may be less than\n                 the number of bytes used to store \\p X internally.\n                 This happens if and only if there are trailing bytes\n                 of value zero.\n\n \\return         The least number of bytes capable of storing\n                 the absolute value of \\p X."]
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from an ASCII string.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the input string.\n \\param s        Null-terminated string buffer.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: ::core::ffi::c_int,
        s: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Export an MPI to an ASCII string.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the output string.\n \\param buf      The buffer to write the string to. This must be writable\n                 buffer of length \\p buflen Bytes.\n \\param buflen   The available size in Bytes of \\p buf.\n \\param olen     The address at which to store the length of the string\n                 written, including the  final \\c NULL byte. This must\n                 not be \\c NULL.\n\n \\note           You can call this function with `buflen == 0` to obtain the\n                 minimum required buffer size in `*olen`.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \\p buf\n                 is too small to hold the value of \\p X in the desired base.\n                 In this case, `*olen` is nonetheless updated to contain the\n                 size of \\p buf required for a successful call.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Read an MPI from a line in an opened file.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the string representation used\n                 in the source line.\n \\param fin      The input file handle to use. This must not be \\c NULL.\n\n \\note           On success, this function advances the file stream\n                 to the end of the current line or to EOF.\n\n                 The function returns \\c 0 on an empty line.\n\n                 Leading whitespaces are ignored, as is a\n                 '0x' prefix for radix \\c 16.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the file read buffer\n                 is too small.\n \\return         Another negative error code on failure."]
    pub fn mbedtls_mpi_read_file(
        X: *mut mbedtls_mpi,
        radix: ::core::ffi::c_int,
        fin: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Export an MPI into an opened file.\n\n \\param p        A string prefix to emit prior to the MPI data.\n                 For example, this might be a label, or \"0x\" when\n                 printing in base \\c 16. This may be \\c NULL if no prefix\n                 is needed.\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param radix    The numeric base to be used in the emitted string.\n \\param fout     The output file handle. This may be \\c NULL, in which case\n                 the output is written to \\c stdout.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_write_file(
        p: *const ::core::ffi::c_char,
        X: *const mbedtls_mpi,
        radix: ::core::ffi::c_int,
        fout: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from unsigned big endian binary data.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p p in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Import X from unsigned binary data, little endian\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p p in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary_le(
        X: *mut mbedtls_mpi,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, big endian.\n                 Always fills the whole buffer, which will start with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, little endian.\n                 Always fills the whole buffer, which will end with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary_le(
        X: *const mbedtls_mpi,
        buf: *mut ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a left-shift on an MPI: X <<= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: usize) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a right-shift on an MPI: X >>= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: usize) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare the absolute values of two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if `|X|` is greater than `|Y|`.\n \\return         \\c -1 if `|X|` is lesser than `|Y|`.\n \\return         \\c 0 if `|X|` is equal to `|Y|`."]
    pub fn mbedtls_mpi_cmp_abs(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if \\p X is greater than \\p Y.\n \\return         \\c -1 if \\p X is lesser than \\p Y.\n \\return         \\c 0 if \\p X is equal to \\p Y."]
    pub fn mbedtls_mpi_cmp_mpi(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Check if an MPI is less than the other in constant time.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as Y.\n \\param Y        The right-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as X.\n \\param ret      The result of the comparison:\n                 \\c 1 if \\p X is less than \\p Y.\n                 \\c 0 if \\p X is greater than or equal to \\p Y.\n\n \\return         0 on success.\n \\return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of\n                 the two input MPIs is not the same."]
    pub fn mbedtls_mpi_lt_mpi_ct(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
        ret: *mut ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare an MPI with an integer.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param z        The integer value to compare \\p X to.\n\n \\return         \\c 1 if \\p X is greater than \\p z.\n \\return         \\c -1 if \\p X is lesser than \\p z.\n \\return         \\c 0 if \\p X is equal to \\p z."]
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned addition of MPIs: X = |A| + |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is greater than \\p A.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of MPIs: X = A + B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of MPIs: X = A - B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of an MPI and an integer: X = A + b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param b        The second summand.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of an MPI and an integer:\n                 X = A - b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param b        The subtrahend.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of two MPIs: X = A * B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param B        The second factor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of an MPI with an unsigned integer:\n                 X = A * b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param b        The second factor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of two MPIs:\n                 A = Q * B + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed. This must not alias A or B.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed. This must not alias A or B.\n \\param A        The dividend. This must point to an initialized MPI.\n \\param B        The divisor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of an MPI by an integer:\n                 A = Q * b + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed.  This must not alias A.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed.  This must not alias A.\n \\param A        The dividend. This must point to an initialized MPi.\n \\param b        The divisor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction. R = A mod B\n\n \\param R        The destination MPI for the residue value.\n                 This must point to an initialized MPI.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPI.\n \\param B        The base of the modular reduction.\n                 This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is negative.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction with respect to an integer.\n                 r = A mod b\n\n \\param r        The address at which to store the residue.\n                 This must not be \\c NULL.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPi.\n \\param b        The integer base of the modular reduction.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p b is negative.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a sliding-window exponentiation: X = A^E mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n                 This must not alias E or N.\n \\param A        The base of the exponentiation.\n                 This must point to an initialized MPI.\n \\param E        The exponent MPI. This must point to an initialized MPI.\n \\param N        The base for the modular reduction. This must point to an\n                 initialized MPI.\n \\param prec_RR  A helper MPI depending solely on \\p N which can be used to\n                 speed-up multiple modular exponentiations for the same value\n                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must\n                 point to an initialized MPI. If it hasn't been used after\n                 the call to mbedtls_mpi_init(), this function will compute\n                 the helper value and store it in \\p prec_RR for reuse on\n                 subsequent calls to this function. Otherwise, the function\n                 will assume that \\p prec_RR holds the helper value set by a\n                 previous call to mbedtls_mpi_exp_mod(), and reuse it.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or\n                 even, or if \\c E is negative.\n \\return         Another negative error code on different kinds of failures.\n"]
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        prec_RR: *mut mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Fill an MPI with a number of random bytes.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param size     The number of random bytes to generate.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on failure.\n\n \\note           The bytes obtained from the RNG are interpreted\n                 as a big-endian representation of an MPI; this can\n                 be relevant in applications like deterministic ECDSA."]
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Generate a random number uniformly in a range.\n\n This function generates a random number between \\p min inclusive and\n \\p N exclusive.\n\n The procedure complies with RFC 6979 §3.3 (deterministic ECDSA)\n when the RNG is a suitably parametrized instance of HMAC_DRBG\n and \\p min is \\c 1.\n\n \\note           There are `N - min` possible outputs. The lower bound\n                 \\p min can be reached, but the upper bound \\p N cannot.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param min      The minimum value to return.\n                 It must be nonnegative.\n \\param N        The upper bound of the range, exclusive.\n                 In other words, this is one plus the maximum value to return.\n                 \\p N must be strictly larger than \\p min.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p min or \\p N is invalid\n                 or if they are incompatible.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was\n                 unable to find a suitable value within a limited number\n                 of attempts. This has a negligible probability if \\p N\n                 is significantly larger than \\p min, which is the case\n                 for all usual cryptographic applications.\n \\return         Another negative error code on failure."]
    pub fn mbedtls_mpi_random(
        X: *mut mbedtls_mpi,
        min: mbedtls_mpi_sint,
        N: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the greatest common divisor: G = gcd(A, B)\n\n \\param G        The destination MPI. This must point to an initialized MPI.\n \\param A        The first operand. This must point to an initialized MPI.\n \\param B        The second operand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the modular inverse: X = A^-1 mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The MPI to calculate the modular inverse of. This must point\n                 to an initialized MPI.\n \\param N        The base of the modular inversion. This must point to an\n                 initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p N is less than\n                 or equal to one.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p has no modular inverse\n                 with respect to \\p N."]
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Miller-Rabin primality test.\n\n \\warning        If \\p X is potentially generated by an adversary, for example\n                 when validating cryptographic parameters that you didn't\n                 generate yourself and that are supposed to be prime, then\n                 \\p rounds should be at least the half of the security\n                 strength of the cryptographic algorithm. On the other hand,\n                 if \\p X is chosen uniformly or non-adversarially (as is the\n                 case when mbedtls_mpi_gen_prime calls this function), then\n                 \\p rounds can be much lower.\n\n \\param X        The MPI to check for primality.\n                 This must point to an initialized MPI.\n \\param rounds   The number of bases to perform the Miller-Rabin primality\n                 test for. The probability of returning 0 on a composite is\n                 at most 2<sup>-2*\\p rounds</sup>.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, i.e. \\p X is probably prime.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_is_prime_ext(
        X: *const mbedtls_mpi,
        rounds: ::core::ffi::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
#[doc = "< (X-1)/2 is prime too"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t =
    1;
#[doc = "< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR:
    mbedtls_mpi_gen_prime_flag_t = 2;
#[doc = " \\brief Flags for mbedtls_mpi_gen_prime()\n\n Each of these flags is a constraint on the result X returned by\n mbedtls_mpi_gen_prime()."]
pub type mbedtls_mpi_gen_prime_flag_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief          Generate a prime number.\n\n \\param X        The destination MPI to store the generated prime in.\n                 This must point to an initialized MPi.\n \\param nbits    The required size of the destination MPI in bits.\n                 This must be between \\c 3 and #MBEDTLS_MPI_MAX_BITS.\n \\param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, in which case \\p X holds a\n                 probably prime number.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between\n                 \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: usize,
        flags: ::core::ffi::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_mpi_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Lock access to RSA Accelerator (MPI/bignum operations)\n\n RSA Accelerator hardware unit can only be used by one\n consumer at a time.\n\n @note This function is non-recursive (do not call it twice from the\n same task.)\n\n @note You do not need to call this if you are using the mbedTLS bignum.h\n API or esp_mpi_xxx functions. This function is only needed if you\n want to call ROM RSA functions or access the registers directly.\n"]
    pub fn esp_mpi_acquire_hardware();
}
extern "C" {
    #[doc = " @brief Unlock access to RSA Accelerator (MPI/bignum operations)\n\n Has to be called once for each call to esp_mpi_acquire_hardware().\n\n @note You do not need to call this if you are using the mbedTLS bignum.h\n API or esp_mpi_xxx functions. This function is only needed if you\n want to call ROM RSA functions or access the registers directly."]
    pub fn esp_mpi_release_hardware();
}
extern "C" {
    pub fn esp_mpi_mul_mpi_mod(
        Z: *mut mbedtls_mpi,
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
        M: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief          Perform a sliding-window exponentiation: X = A^E mod N\n\n @param X        The destination MPI. This must point to an initialized MPI.\n @param A        The base of the exponentiation.\n                 This must point to an initialized MPI.\n @param E        The exponent MPI. This must point to an initialized MPI.\n @param N        The base for the modular reduction. This must point to an\n                 initialized MPI.\n @param _RR      A helper MPI depending solely on \\p N which can be used to\n                 speed-up multiple modular exponentiations for the same value\n                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must\n                 point to an initialized MPI.\n\n @return         \\c 0 if successful.\n @return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n @return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or\n                 even, or if \\c E is negative.\n @return         Another negative error code on different kinds of failures.\n"]
    pub fn mbedtls_mpi_exp_mod_soft(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        _RR: *mut mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
#[doc = "< Curve not defined."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
#[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
#[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
#[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
#[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
#[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
#[doc = "< Domain parameters for 256-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
#[doc = "< Domain parameters for 384-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
#[doc = "< Domain parameters for 512-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
#[doc = "< Domain parameters for Curve25519."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
#[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
#[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
#[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
#[doc = "< Domain parameters for Curve448."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator.\n\n \\note Only curves over prime fields are supported.\n\n \\warning This library does not support validation of arbitrary domain\n parameters. Therefore, only standardized domain parameters from trusted\n sources should be used. See mbedtls_ecp_group_load()."]
pub type mbedtls_ecp_group_id = ::core::ffi::c_uint;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = ::core::ffi::c_uint;
#[doc = " Curve information, for use by other modules.\n\n The fields of this structure are part of the public API and can be\n accessed directly by applications. Future versions of the library may\n add extra fields or reorder existing fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    #[doc = "< An internal identifier."]
    pub grp_id: mbedtls_ecp_group_id,
    #[doc = "< The TLS NamedCurve identifier."]
    pub tls_id: u16,
    #[doc = "< The curve size in bits."]
    pub bit_size: u16,
    #[doc = "< A human-friendly name."]
    pub name: *const ::core::ffi::c_char,
}
impl Default for mbedtls_ecp_curve_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates.\n\n \\note            All functions expect and return points satisfying\n                  the following condition: <code>Z == 0</code> or\n                  <code>Z == 1</code>. Other values of \\p Z are\n                  used only by internal functions.\n                  The point is zero, or \"at infinity\", if <code>Z == 0</code>.\n                  Otherwise, \\p X and \\p Y are its standard (affine)\n                  coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_point {
    pub private_X: mbedtls_mpi,
    pub private_Y: mbedtls_mpi,
    pub private_Z: mbedtls_mpi,
}
impl Default for mbedtls_ecp_point {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief           The ECP group structure.\n\n We consider two types of curve equations:\n <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>\n (SEC1 + RFC-4492)</li>\n <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,\n Curve448)</li></ul>\n In both cases, the generator (\\p G) for a prime-order subgroup is fixed.\n\n For Short Weierstrass, this subgroup is the whole curve, and its\n cardinality is denoted by \\p N. Our code requires that \\p N is an\n odd prime as mbedtls_ecp_mul() requires an odd number, and\n mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.\n\n For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,\n which is the quantity used in the formulas. Additionally, \\p nbits is\n not the size of \\p N but the required size for private keys.\n\n If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm.\n Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the\n range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer\n which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits\n in size, so that it may be efficiently brought in the 0..P-1 range by a few\n additions or subtractions. Therefore, it is only an approximative modular\n reduction. It must return 0 on success and non-zero on failure.\n\n \\note        Alternative implementations of the ECP module must obey the\n              following constraints.\n              * Group IDs must be distinct: if two group structures have\n                the same ID, then they must be identical.\n              * The fields \\c id, \\c P, \\c A, \\c B, \\c G, \\c N,\n                \\c pbits and \\c nbits must have the same type and semantics\n                as in the built-in implementation.\n                They must be available for reading, but direct modification\n                of these fields does not need to be supported.\n                They do not need to be at the same offset in the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_group {
    #[doc = "< An internal group identifier."]
    pub id: mbedtls_ecp_group_id,
    #[doc = "< The prime modulus of the base field."]
    pub P: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p A in the equation. For\nMontgomery curves: <code>(A + 2) / 4</code>."]
    pub A: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p B in the equation.\nFor Montgomery curves: unused."]
    pub B: mbedtls_mpi,
    #[doc = "< The generator of the subgroup used."]
    pub G: mbedtls_ecp_point,
    #[doc = "< The order of \\p G."]
    pub N: mbedtls_mpi,
    #[doc = "< The number of bits in \\p P."]
    pub pbits: usize,
    #[doc = "< For Short Weierstrass: The number of bits in \\p P.\nFor Montgomery curves: the number of bits in the\nprivate keys."]
    pub nbits: usize,
    pub private_h: ::core::ffi::c_uint,
    pub private_modp:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> ::core::ffi::c_int>,
    pub private_t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub private_t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub private_t_data: *mut ::core::ffi::c_void,
    pub private_T: *mut mbedtls_ecp_point,
    pub private_T_size: usize,
}
impl Default for mbedtls_ecp_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mbedtls_ecp_restart_ctx = ::core::ffi::c_void;
#[doc = " \\brief    The ECP key-pair structure.\n\n A generic key-pair that may be used for ECDSA and fixed ECDH, for example.\n\n \\note    Members are deliberately in the same order as in the\n          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
}
impl Default for mbedtls_ecp_keypair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mbedtls_ecp_get_type(grp: *const mbedtls_ecp_group) -> mbedtls_ecp_curve_type;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the information defined in\n                  mbedtls_ecp_curve_info() for all supported curves.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array. The last entry is 0."]
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the list of internal group\n                  identifiers of all supported curves in the order of\n                  preference.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array,\n                  terminated with MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from an internal\n                  group identifier.\n\n \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a TLS\n                  NamedCurve value.\n\n \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a\n                  human-readable name.\n\n \\param name      The human-readable name.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const ::core::ffi::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function initializes a point as zero.\n\n \\param pt        The point to initialize."]
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECP group context\n                  without loading any domain parameters.\n\n \\note            After this function is called, domain parameters\n                  for various ECP groups can be loaded through the\n                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()\n                  functions."]
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function initializes a key pair as an invalid one.\n\n \\param key       The key pair to initialize."]
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a point.\n\n \\param pt        The point to free."]
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of an ECP group.\n\n \\param grp       The group to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP group."]
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a key pair.\n\n \\param key       The key pair to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP key pair."]
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of point \\p Q into\n                  point \\p P.\n\n \\param P         The destination point. This must be initialized.\n \\param Q         The source point. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code for other kinds of failure."]
    pub fn mbedtls_ecp_copy(
        P: *mut mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of group \\p src into\n                  group \\p dst.\n\n \\param dst       The destination group. This must be initialized.\n \\param src       The source group. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a point to the point at infinity.\n\n \\param pt        The point to set. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks if a point is the point at infinity.\n\n \\param pt        The point to test. This must be initialized.\n\n \\return          \\c 1 if the point is zero.\n \\return          \\c 0 if the point is non-zero.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function compares two points.\n\n \\note            This assumes that the points are normalized. Otherwise,\n                  they may compare as \"not equal\" even if they are.\n\n \\param P         The first point to compare. This must be initialized.\n \\param Q         The second point to compare. This must be initialized.\n\n \\return          \\c 0 if the points are equal.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a non-zero point from two ASCII\n                  strings.\n\n \\param P         The destination point. This must be initialized.\n \\param radix     The numeric base of the input.\n \\param x         The first affine coordinate, as a null-terminated string.\n \\param y         The second affine coordinate, as a null-terminated string.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: ::core::ffi::c_int,
        x: *const ::core::ffi::c_char,
        y: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point into unsigned binary data.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The point to export. This must be initialized.\n \\param format    The point format. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n                  (For groups without these formats, this parameter is\n                  ignored. But it still has to be either of the above\n                  values.)\n \\param olen      The address at which to store the length of\n                  the output in Bytes. This must not be \\c NULL.\n \\param buf       The output buffer. This must be a writable buffer\n                  of length \\p buflen Bytes.\n \\param buflen    The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer\n                  is too small to hold the point.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format\n                  or the export for the given group is not implemented.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: ::core::ffi::c_int,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from unsigned binary data.\n\n \\note            This function does not check that the point actually\n                  belongs to the given group, see mbedtls_ecp_check_pubkey()\n                  for that.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The destination context to import the point to.\n                  This must be initialized.\n \\param buf       The input buffer. This must be a readable buffer\n                  of length \\p ilen Bytes.\n \\param ilen      The length of the input buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the\n                  given group is not implemented."]
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from a TLS ECPoint record.\n\n \\note            On function return, \\p *buf is updated to point immediately\n                  after the ECPoint record.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The destination point.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the buffer.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization\n                  failure.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point as a TLS ECPoint record\n                  defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to be exported. This must be initialized.\n \\param format    The point format to use. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n \\param olen      The address at which to store the length in Bytes\n                  of the data written.\n \\param buf       The target buffer. This must be a writable buffer of\n                  length \\p blen Bytes.\n \\param blen      The length of the target buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer\n                  is too small to hold the exported point.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: ::core::ffi::c_int,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        blen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context\n                  from a standardized set of domain parameters.\n\n \\note            The index should be a value of the NamedCurve enum,\n                  as defined in <em>RFC-4492: Elliptic Curve Cryptography\n                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,\n                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param id        The identifier of the domain parameter set to load.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        id: mbedtls_ecp_group_id,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context from a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts an elliptic curve group ID from a\n                  TLS ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The address at which to store the group id.\n                  This must not be \\c NULL.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group_id(
        grp: *mut mbedtls_ecp_group_id,
        buf: *mut *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve as a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to be exported.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param olen      The address at which to store the number of Bytes written.\n                  This must not be \\c NULL.\n \\param buf       The buffer to write to. This must be a writable buffer\n                  of length \\p blen Bytes.\n \\param blen      The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output\n                  buffer is too small to hold the exported group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        blen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a scalar multiplication of a point\n                  by an integer: \\p R = \\p m * \\p P.\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            To prevent timing attacks, this function\n                  executes the exact same sequence of base-field\n                  operations for any valid \\p m. It avoids any if-branch or\n                  array index depending on the value of \\p m. It also uses\n                  \\p f_rng to randomize some intermediate results.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication of a point by\n                  an integer: \\p R = \\p m * \\p P in a restartable way.\n\n \\see             mbedtls_ecp_mul()\n\n \\note            This function does the same as \\c mbedtls_ecp_mul(), but\n                  it can return early and restart according to the limit set\n                  with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            In contrast to mbedtls_ecp_mul(), this function does not\n                  guarantee a constant execution flow and timing.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q in a\n                  restartable way.\n\n \\see             \\c mbedtls_ecp_muladd()\n\n \\note            This function works the same as \\c mbedtls_ecp_muladd(),\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that a point is a valid public key\n                  on this curve.\n\n                  It only checks that the point is non-zero, has\n                  valid coordinates and lies on the curve. It does not verify\n                  that it is indeed a multiple of \\p G. This additional\n                  check is computationally more expensive, is not required\n                  by standards, and should not be necessary if the group\n                  used has a small cofactor. In particular, it is useless for\n                  the NIST groups which all have a cofactor of 1.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure, to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the point should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid public key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not\n                  a valid public key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that an \\p mbedtls_mpi is a\n                  valid private key for this curve.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the private key should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The integer to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid private key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid\n                  private key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a private key.\n\n \\param grp       The ECP group to generate a private key for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part). This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_privkey(
        grp: *const mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a keypair with a configurable base\n                  point.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param G         The base point to use. This must be initialized\n                  and belong to \\p grp. It replaces the default base\n                  point \\c grp->G used by mbedtls_ecp_gen_keypair().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP keypair.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key. This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads an elliptic curve private key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key.\n \\param buf       The buffer containing the binary representation of the\n                  key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is\n                  invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_read_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve private key.\n\n \\param key       The private key.\n \\param buf       The output buffer for containing the binary representation\n                  of the key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The total length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \\p key\nrepresentation is larger than the available space in \\p buf.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_write_key(
        key: *mut mbedtls_ecp_keypair,
        buf: *mut ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that the keypair objects\n                  \\p pub and \\p prv have the same group and the\n                  same public point, and that the private key in\n                  \\p prv is consistent with the public key.\n\n \\param pub       The keypair structure holding the public key. This\n                  must be initialized. If it contains a private key, that\n                  part is ignored.\n \\param prv       The keypair structure holding the full keypair.\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success, meaning that the keys are valid and match.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX\n                  error code on calculation failure."]
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports generic key-pair parameters.\n\n \\param key       The key pair to export from.\n \\param grp       Slot for exported ECP group.\n                  It must point to an initialized ECP group.\n \\param d         Slot for the exported secret value.\n                  It must point to an initialized mpi.\n \\param Q         Slot for the exported public value.\n                  It must point to an initialized ECP point.\n\n \\return          \\c 0 on success,\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_export(
        key: *const mbedtls_ecp_keypair,
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The ECP checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_ecp_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = "< None."]
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
#[doc = "< The MD5 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 1;
#[doc = "< The SHA-1 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 2;
#[doc = "< The SHA-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 3;
#[doc = "< The SHA-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 4;
#[doc = "< The SHA-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 5;
#[doc = "< The SHA-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 6;
#[doc = "< The RIPEMD-160 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 7;
#[doc = " \\brief     Supported message digests.\n\n \\warning   MD5 and SHA-1 are considered weak message digests and\n            their use constitutes a security risk. We recommend considering\n            stronger message digests instead.\n"]
pub type mbedtls_md_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_context_t {
    pub private_md_info: *const mbedtls_md_info_t,
    pub private_md_ctx: *mut ::core::ffi::c_void,
    pub private_hmac_ctx: *mut ::core::ffi::c_void,
}
impl Default for mbedtls_md_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           This function returns the list of digests supported by the\n                  generic digest module.\n\n \\note            The list starts with the strongest available hashes.\n\n \\return          A statically allocated array of digests. Each element\n                  in the returned list is an integer belonging to the\n                  message-digest enumeration #mbedtls_md_type_t.\n                  The last entry is 0."]
    pub fn mbedtls_md_list() -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest name.\n\n \\param md_name   The name of the digest to search for.\n\n \\return          The message-digest information associated with \\p md_name.\n \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_string(
        md_name: *const ::core::ffi::c_char,
    ) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest type.\n\n \\param md_type   The type of digest to search for.\n\n \\return          The message-digest information associated with \\p md_type.\n \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  from the given context.\n\n \\param ctx       The context from which to extract the information.\n                  This must be initialized (or \\c NULL).\n\n \\return          The message-digest information associated with \\p ctx.\n \\return          \\c NULL if \\p ctx is \\c NULL."]
    pub fn mbedtls_md_info_from_ctx(ctx: *const mbedtls_md_context_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function initializes a message-digest context without\n                  binding it to a particular message-digest algorithm.\n\n                  This function should always be called first. It prepares the\n                  context for mbedtls_md_setup() for binding it to a\n                  message-digest algorithm."]
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function clears the internal structure of \\p ctx and\n                  frees any embedded internal structure, but does not free\n                  \\p ctx itself.\n\n                  If you have called mbedtls_md_setup() on \\p ctx, you must\n                  call mbedtls_md_free() when you are no longer using the\n                  context.\n                  Calling this function if you have previously\n                  called mbedtls_md_init() and nothing else is optional.\n                  You must not call this function if you have not called\n                  mbedtls_md_init()."]
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,\n                  and allocates internal structures.\n\n                  It should be called after mbedtls_md_init() or\n                  mbedtls_md_free(). Makes it necessary to call\n                  mbedtls_md_free() later.\n\n \\param ctx       The context to set up.\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),\n                  or non-zero: HMAC is used with this context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure.\n \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clones the state of a message-digest\n                  context.\n\n \\note            You must call mbedtls_md_setup() on \\c dst before calling\n                  this function.\n\n \\note            The two contexts must have the same type,\n                  for example, both are SHA-256.\n\n \\warning         This function clones the message-digest state, not the\n                  HMAC state.\n\n \\param dst       The destination context.\n \\param src       The context to be cloned.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure."]
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest size from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The size of the message-digest output in Bytes."]
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest type from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The type of the message digest."]
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest name from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The name of the message digest."]
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief           This function starts a message-digest computation.\n\n                  You must call this function after setting up the context\n                  with mbedtls_md_setup(), and before passing data with\n                  mbedtls_md_update().\n\n \\param ctx       The generic message-digest context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing\n                  message-digest computation.\n\n                  You must call mbedtls_md_starts() before calling this\n                  function. You may call this function multiple times.\n                  Afterwards, call mbedtls_md_finish().\n\n \\param ctx       The generic message-digest context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the digest operation,\n                  and writes the result to the output buffer.\n\n                  Call this function after a call to mbedtls_md_starts(),\n                  followed by any number of calls to mbedtls_md_update().\n                  Afterwards, you may either clear the context with\n                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse\n                  the context for another digest operation with the same\n                  algorithm.\n\n \\param ctx       The generic message-digest context.\n \\param output    The buffer for the generic message-digest checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest of a buffer,\n                 with respect to a configurable message-digest algorithm\n                 in a single call.\n\n                 The result is calculated as\n                 Output = message_digest(input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param input    The buffer holding the data.\n \\param ilen     The length of the input data.\n \\param output   The generic message-digest checksum result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest checksum\n                 result of the contents of the provided file.\n\n                 The result is calculated as\n                 Output = message_digest(file contents).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param path     The input file name.\n \\param output   The generic message-digest checksum result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_FILE_IO_ERROR on an I/O error accessing\n                 the file pointed by \\p path.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \\p md_info was NULL."]
    pub fn mbedtls_md_file(
        md_info: *const mbedtls_md_info_t,
        path: *const ::core::ffi::c_char,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the HMAC key and prepares to\n                  authenticate a new message.\n\n                  Call this function after mbedtls_md_setup(), to use\n                  the MD context for an HMAC calculation, then call\n                  mbedtls_md_hmac_update() to provide the input data, and\n                  mbedtls_md_hmac_finish() to get the HMAC value.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param key       The HMAC secret key.\n \\param keylen    The length of the HMAC key in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const ::core::ffi::c_uchar,
        keylen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC\n                  computation.\n\n                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()\n                  before calling this function.\n                  You may call this function multiple times to pass the\n                  input piecewise.\n                  Afterwards, call mbedtls_md_hmac_finish().\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the HMAC operation, and writes\n                  the result to the output buffer.\n\n                  Call this function after mbedtls_md_hmac_starts() and\n                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards\n                  you may either call mbedtls_md_free() to clear the context,\n                  or call mbedtls_md_hmac_reset() to reuse the context with\n                  the same HMAC key.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param output    The generic HMAC checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function prepares to authenticate a new message with\n                  the same key as the previous HMAC operation.\n\n                  You may call this function after mbedtls_md_hmac_finish().\n                  Afterwards call mbedtls_md_hmac_update() to pass the new\n                  input.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the full generic HMAC\n                 on the input buffer with the provided key.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The HMAC result is calculated as\n                 output = generic HMAC(hmac key, input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param key      The HMAC secret key.\n \\param keylen   The length of the HMAC secret key in Bytes.\n \\param input    The buffer holding the input data.\n \\param ilen     The length of the input data.\n \\param output   The generic HMAC result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const ::core::ffi::c_uchar,
        keylen: usize,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_md_process(
        ctx: *mut mbedtls_md_context_t,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
#[doc = " \\brief   The RSA context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_rsa_context {
    pub private_ver: ::core::ffi::c_int,
    pub private_len: usize,
    pub private_N: mbedtls_mpi,
    pub private_E: mbedtls_mpi,
    pub private_D: mbedtls_mpi,
    pub private_P: mbedtls_mpi,
    pub private_Q: mbedtls_mpi,
    pub private_DP: mbedtls_mpi,
    pub private_DQ: mbedtls_mpi,
    pub private_QP: mbedtls_mpi,
    pub private_RN: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_RQ: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_padding: ::core::ffi::c_int,
    pub private_hash_id: ::core::ffi::c_int,
}
impl Default for mbedtls_rsa_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes an RSA context.\n\n \\note           This function initializes the padding and the hash\n                 identifier to respectively #MBEDTLS_RSA_PKCS_V15 and\n                 #MBEDTLS_MD_NONE. See mbedtls_rsa_set_padding() for more\n                 information about those parameters.\n\n \\param ctx      The RSA context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_rsa_init(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          This function sets padding for an already initialized RSA\n                 context.\n\n \\note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP\n                 encryption scheme and the RSASSA-PSS signature scheme.\n\n \\note           The \\p hash_id parameter is ignored when using\n                 #MBEDTLS_RSA_PKCS_V15 padding.\n\n \\note           The choice of padding mode is strictly enforced for private\n                 key operations, since there might be security concerns in\n                 mixing padding modes. For public key operations it is\n                 a default value, which can be overridden by calling specific\n                 \\c mbedtls_rsa_rsaes_xxx or \\c mbedtls_rsa_rsassa_xxx\n                 functions.\n\n \\note           The hash selected in \\p hash_id is always used for OEAP\n                 encryption. For PSS signatures, it is always used for\n                 making signatures, but can be overridden for verifying them.\n                 If set to #MBEDTLS_MD_NONE, it is always overridden.\n\n \\param ctx      The initialized RSA context to be configured.\n \\param padding  The padding mode to use. This must be either\n                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21.\n \\param hash_id  The hash identifier for PSS or OAEP, if \\p padding is\n                 #MBEDTLS_RSA_PKCS_V21. #MBEDTLS_MD_NONE is accepted by this\n                 function but may be not suitable for some operations.\n                 Ignored if \\p padding is #MBEDTLS_RSA_PKCS_V15.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_RSA_INVALID_PADDING failure:\n                 \\p padding or \\p hash_id is invalid."]
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: ::core::ffi::c_int,
        hash_id: mbedtls_md_type_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports a set of core parameters into an\n                 RSA context.\n\n \\note           This function can be called multiple times for successive\n                 imports, if the parameters are not simultaneously present.\n\n                 Any sequence of calls to this function should be followed\n                 by a call to mbedtls_rsa_complete(), which checks and\n                 completes the provided information to a ready-for-use\n                 public or private RSA key.\n\n \\note           See mbedtls_rsa_complete() for more information on which\n                 parameters are necessary to set up a private or public\n                 RSA key.\n\n \\note           The imported parameters are copied and need not be preserved\n                 for the lifetime of the RSA context being set up.\n\n \\param ctx      The initialized RSA context to store the parameters in.\n \\param N        The RSA modulus. This may be \\c NULL.\n \\param P        The first prime factor of \\p N. This may be \\c NULL.\n \\param Q        The second prime factor of \\p N. This may be \\c NULL.\n \\param D        The private exponent. This may be \\c NULL.\n \\param E        The public exponent. This may be \\c NULL.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import(
        ctx: *mut mbedtls_rsa_context,
        N: *const mbedtls_mpi,
        P: *const mbedtls_mpi,
        Q: *const mbedtls_mpi,
        D: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports core RSA parameters, in raw big-endian\n                 binary format, into an RSA context.\n\n \\note           This function can be called multiple times for successive\n                 imports, if the parameters are not simultaneously present.\n\n                 Any sequence of calls to this function should be followed\n                 by a call to mbedtls_rsa_complete(), which checks and\n                 completes the provided information to a ready-for-use\n                 public or private RSA key.\n\n \\note           See mbedtls_rsa_complete() for more information on which\n                 parameters are necessary to set up a private or public\n                 RSA key.\n\n \\note           The imported parameters are copied and need not be preserved\n                 for the lifetime of the RSA context being set up.\n\n \\param ctx      The initialized RSA context to store the parameters in.\n \\param N        The RSA modulus. This may be \\c NULL.\n \\param N_len    The Byte length of \\p N; it is ignored if \\p N == NULL.\n \\param P        The first prime factor of \\p N. This may be \\c NULL.\n \\param P_len    The Byte length of \\p P; it is ignored if \\p P == NULL.\n \\param Q        The second prime factor of \\p N. This may be \\c NULL.\n \\param Q_len    The Byte length of \\p Q; it is ignored if \\p Q == NULL.\n \\param D        The private exponent. This may be \\c NULL.\n \\param D_len    The Byte length of \\p D; it is ignored if \\p D == NULL.\n \\param E        The public exponent. This may be \\c NULL.\n \\param E_len    The Byte length of \\p E; it is ignored if \\p E == NULL.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import_raw(
        ctx: *mut mbedtls_rsa_context,
        N: *const ::core::ffi::c_uchar,
        N_len: usize,
        P: *const ::core::ffi::c_uchar,
        P_len: usize,
        Q: *const ::core::ffi::c_uchar,
        Q_len: usize,
        D: *const ::core::ffi::c_uchar,
        D_len: usize,
        E: *const ::core::ffi::c_uchar,
        E_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function completes an RSA context from\n                 a set of imported core parameters.\n\n                 To setup an RSA public key, precisely \\p N and \\p E\n                 must have been imported.\n\n                 To setup an RSA private key, sufficient information must\n                 be present for the other parameters to be derivable.\n\n                 The default implementation supports the following:\n                 <ul><li>Derive \\p P, \\p Q from \\p N, \\p D, \\p E.</li>\n                 <li>Derive \\p N, \\p D from \\p P, \\p Q, \\p E.</li></ul>\n                 Alternative implementations need not support these.\n\n                 If this function runs successfully, it guarantees that\n                 the RSA context can be used for RSA operations without\n                 the risk of failure or crash.\n\n \\warning        This function need not perform consistency checks\n                 for the imported parameters. In particular, parameters that\n                 are not needed by the implementation might be silently\n                 discarded and left unchecked. To check the consistency\n                 of the key material, see mbedtls_rsa_check_privkey().\n\n \\param ctx      The initialized RSA context holding imported parameters.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations\n                 failed.\n"]
    pub fn mbedtls_rsa_complete(ctx: *mut mbedtls_rsa_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports the core parameters of an RSA key.\n\n                 If this function runs successfully, the non-NULL buffers\n                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully\n                 written, with additional unused space filled leading by\n                 zero Bytes.\n\n                 Possible reasons for returning\n                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>\n                 <li>An alternative RSA implementation is in use, which\n                 stores the key externally, and either cannot or should\n                 not export it into RAM.</li>\n                 <li>A SW or HW implementation might not support a certain\n                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,\n                 and \\p E if the former are not part of the\n                 implementation.</li></ul>\n\n                 If the function fails due to an unsupported operation,\n                 the RSA context stays intact and remains usable.\n\n \\param ctx      The initialized RSA context.\n \\param N        The MPI to hold the RSA modulus.\n                 This may be \\c NULL if this field need not be exported.\n \\param P        The MPI to hold the first prime factor of \\p N.\n                 This may be \\c NULL if this field need not be exported.\n \\param Q        The MPI to hold the second prime factor of \\p N.\n                 This may be \\c NULL if this field need not be exported.\n \\param D        The MPI to hold the private exponent.\n                 This may be \\c NULL if this field need not be exported.\n \\param E        The MPI to hold the public exponent.\n                 This may be \\c NULL if this field need not be exported.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the\n                 requested parameters cannot be done due to missing\n                 functionality or because of security policies.\n \\return         A non-zero return code on any other failure.\n"]
    pub fn mbedtls_rsa_export(
        ctx: *const mbedtls_rsa_context,
        N: *mut mbedtls_mpi,
        P: *mut mbedtls_mpi,
        Q: *mut mbedtls_mpi,
        D: *mut mbedtls_mpi,
        E: *mut mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports core parameters of an RSA key\n                 in raw big-endian binary format.\n\n                 If this function runs successfully, the non-NULL buffers\n                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully\n                 written, with additional unused space filled leading by\n                 zero Bytes.\n\n                 Possible reasons for returning\n                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>\n                 <li>An alternative RSA implementation is in use, which\n                 stores the key externally, and either cannot or should\n                 not export it into RAM.</li>\n                 <li>A SW or HW implementation might not support a certain\n                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,\n                 and \\p E if the former are not part of the\n                 implementation.</li></ul>\n                 If the function fails due to an unsupported operation,\n                 the RSA context stays intact and remains usable.\n\n \\note           The length parameters are ignored if the corresponding\n                 buffer pointers are NULL.\n\n \\param ctx      The initialized RSA context.\n \\param N        The Byte array to store the RSA modulus,\n                 or \\c NULL if this field need not be exported.\n \\param N_len    The size of the buffer for the modulus.\n \\param P        The Byte array to hold the first prime factor of \\p N,\n                 or \\c NULL if this field need not be exported.\n \\param P_len    The size of the buffer for the first prime factor.\n \\param Q        The Byte array to hold the second prime factor of \\p N,\n                 or \\c NULL if this field need not be exported.\n \\param Q_len    The size of the buffer for the second prime factor.\n \\param D        The Byte array to hold the private exponent,\n                 or \\c NULL if this field need not be exported.\n \\param D_len    The size of the buffer for the private exponent.\n \\param E        The Byte array to hold the public exponent,\n                 or \\c NULL if this field need not be exported.\n \\param E_len    The size of the buffer for the public exponent.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the\n                 requested parameters cannot be done due to missing\n                 functionality or because of security policies.\n \\return         A non-zero return code on any other failure."]
    pub fn mbedtls_rsa_export_raw(
        ctx: *const mbedtls_rsa_context,
        N: *mut ::core::ffi::c_uchar,
        N_len: usize,
        P: *mut ::core::ffi::c_uchar,
        P_len: usize,
        Q: *mut ::core::ffi::c_uchar,
        Q_len: usize,
        D: *mut ::core::ffi::c_uchar,
        D_len: usize,
        E: *mut ::core::ffi::c_uchar,
        E_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports CRT parameters of a private RSA key.\n\n \\note           Alternative RSA implementations not using CRT-parameters\n                 internally can implement this function based on\n                 mbedtls_rsa_deduce_opt().\n\n \\param ctx      The initialized RSA context.\n \\param DP       The MPI to hold \\c D modulo `P-1`,\n                 or \\c NULL if it need not be exported.\n \\param DQ       The MPI to hold \\c D modulo `Q-1`,\n                 or \\c NULL if it need not be exported.\n \\param QP       The MPI to hold modular inverse of \\c Q modulo \\c P,\n                 or \\c NULL if it need not be exported.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure.\n"]
    pub fn mbedtls_rsa_export_crt(
        ctx: *const mbedtls_rsa_context,
        DP: *mut mbedtls_mpi,
        DQ: *mut mbedtls_mpi,
        QP: *mut mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves the length of RSA modulus in Bytes.\n\n \\param ctx      The initialized RSA context.\n\n \\return         The length of the RSA modulus in Bytes.\n"]
    pub fn mbedtls_rsa_get_len(ctx: *const mbedtls_rsa_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function generates an RSA keypair.\n\n \\note           mbedtls_rsa_init() must be called before this function,\n                 to set up the RSA context.\n\n \\param ctx      The initialized RSA context used to hold the key.\n \\param f_rng    The RNG function to be used for key generation.\n                 This is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't need a context.\n \\param nbits    The size of the public key in bits.\n \\param exponent The public exponent to use. For example, \\c 65537.\n                 This must be odd and greater than \\c 1.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        nbits: ::core::ffi::c_uint,
        exponent: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks if a context contains at least an RSA\n                 public key.\n\n                 If the function runs successfully, it is guaranteed that\n                 enough information is present to perform an RSA public key\n                 operation using mbedtls_rsa_public().\n\n \\param ctx      The initialized RSA context to check.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief      This function checks if a context contains an RSA private key\n             and perform basic consistency checks.\n\n \\note       The consistency checks performed by this function not only\n             ensure that mbedtls_rsa_private() can be called successfully\n             on the given context, but that the various parameters are\n             mutually consistent with high probability, in the sense that\n             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses.\n\n \\warning    This function should catch accidental misconfigurations\n             like swapping of parameters, but it cannot establish full\n             trust in neither the quality nor the consistency of the key\n             material that was used to setup the given RSA context:\n             <ul><li>Consistency: Imported parameters that are irrelevant\n             for the implementation might be silently dropped. If dropped,\n             the current function does not have access to them,\n             and therefore cannot check them. See mbedtls_rsa_complete().\n             If you want to check the consistency of the entire\n             content of a PKCS1-encoded RSA private key, for example, you\n             should use mbedtls_rsa_validate_params() before setting\n             up the RSA context.\n             Additionally, if the implementation performs empirical checks,\n             these checks substantiate but do not guarantee consistency.</li>\n             <li>Quality: This function is not expected to perform\n             extended quality assessments like checking that the prime\n             factors are safe. Additionally, it is the responsibility of the\n             user to ensure the trustworthiness of the source of his RSA\n             parameters, which goes beyond what is effectively checkable\n             by the library.</li></ul>\n\n \\param ctx  The initialized RSA context to check.\n\n \\return     \\c 0 on success.\n \\return     An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks a public-private RSA key pair.\n\n                 It checks each of the contexts, and makes sure they match.\n\n \\param pub      The initialized RSA context holding the public key.\n \\param prv      The initialized RSA context holding the private key.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA public key operation.\n\n \\param ctx      The initialized RSA context to use.\n \\param input    The input buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\note           This function does not handle message padding.\n\n \\note           Make sure to set \\p input[0] = 0 or ensure that\n                 input is smaller than \\p N.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA private key operation.\n\n \\note           Blinding is used if and only if a PRNG is provided.\n\n \\note           If blinding is used, both the base of exponentiation\n                 and the exponent are blinded, providing protection\n                 against some side-channel attacks.\n\n \\warning        It is deprecated and a security risk to not provide\n                 a PRNG here and thereby prevent the use of blinding.\n                 Future versions of the library may enforce the presence\n                 of a PRNG.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function, used for blinding. It is mandatory.\n \\param p_rng    The RNG context to pass to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context.\n \\param input    The input buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function adds the message padding, then performs an RSA\n                 operation.\n\n                 It is the generic wrapper for performing a PKCS#1 encryption\n                 operation.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG to use. It is used for padding generation\n                 and it is mandatory.\n \\param p_rng    The RNG context to be passed to \\p f_rng. May be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n \\param ilen     The length of the plaintext in Bytes.\n \\param input    The input data to encrypt. This must be a readable\n                 buffer of size \\p ilen Bytes. It may be \\c NULL if\n                 `ilen == 0`.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        ilen: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 encryption operation\n                 (RSAES-PKCS1-v1_5-ENCRYPT).\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function to use. It is mandatory and used for\n                 padding generation.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may\n                 be \\c NULL if \\p f_rng doesn't need a context argument.\n \\param ilen     The length of the plaintext in Bytes.\n \\param input    The input data to encrypt. This must be a readable\n                 buffer of size \\p ilen Bytes. It may be \\c NULL if\n                 `ilen == 0`.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        ilen: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP encryption\n                   operation (RSAES-OAEP-ENCRYPT).\n\n \\note             The output buffer must be as large as the size\n                   of ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\param ctx        The initialized RSA context to use.\n \\param f_rng      The RNG function to use. This is needed for padding\n                   generation and is mandatory.\n \\param p_rng      The RNG context to be passed to \\p f_rng. This may\n                   be \\c NULL if \\p f_rng doesn't need a context argument.\n \\param label      The buffer holding the custom label to use.\n                   This must be a readable buffer of length \\p label_len\n                   Bytes. It may be \\c NULL if \\p label_len is \\c 0.\n \\param label_len  The length of the label in Bytes.\n \\param ilen       The length of the plaintext buffer \\p input in Bytes.\n \\param input      The input data to encrypt. This must be a readable\n                   buffer of size \\p ilen Bytes. It may be \\c NULL if\n                   `ilen == 0`.\n \\param output     The output buffer. This must be a writable buffer\n                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                   for an 2048-bit RSA modulus.\n\n \\return           \\c 0 on success.\n \\return           An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        label: *const ::core::ffi::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA operation, then removes the\n                 message padding.\n\n                 It is the generic wrapper for performing a PKCS#1 decryption\n                 operation.\n\n \\note           The output buffer length \\c output_max_len should be\n                 as large as the size \\p ctx->len of \\p ctx->N (for example,\n                 128 Bytes if RSA-1024 is used) to be able to hold an\n                 arbitrary decrypted message. If it is not large enough to\n                 hold the decryption of the particular ciphertext provided,\n                 the function returns \\c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context.\n \\param olen     The address at which to store the length of\n                 the plaintext. This must not be \\c NULL.\n \\param input    The ciphertext buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The buffer used to hold the plaintext. This must\n                 be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        olen: *mut usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        output_max_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 decryption\n                 operation (RSAES-PKCS1-v1_5-DECRYPT).\n\n \\note           The output buffer length \\c output_max_len should be\n                 as large as the size \\p ctx->len of \\p ctx->N, for example,\n                 128 Bytes if RSA-1024 is used, to be able to hold an\n                 arbitrary decrypted message. If it is not large enough to\n                 hold the decryption of the particular ciphertext provided,\n                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context.\n \\param olen     The address at which to store the length of\n                 the plaintext. This must not be \\c NULL.\n \\param input    The ciphertext buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The buffer used to hold the plaintext. This must\n                 be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        olen: *mut usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        output_max_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP decryption\n                   operation (RSAES-OAEP-DECRYPT).\n\n \\note             The output buffer length \\c output_max_len should be\n                   as large as the size \\p ctx->len of \\p ctx->N, for\n                   example, 128 Bytes if RSA-1024 is used, to be able to\n                   hold an arbitrary decrypted message. If it is not\n                   large enough to hold the decryption of the particular\n                   ciphertext provided, the function returns\n                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx        The initialized RSA context to use.\n \\param f_rng      The RNG function. This is used for blinding and is\n                   mandatory.\n \\param p_rng      The RNG context to be passed to \\p f_rng. This may be\n                   \\c NULL if \\p f_rng doesn't need a context.\n \\param label      The buffer holding the custom label to use.\n                   This must be a readable buffer of length \\p label_len\n                   Bytes. It may be \\c NULL if \\p label_len is \\c 0.\n \\param label_len  The length of the label in Bytes.\n \\param olen       The address at which to store the length of\n                   the plaintext. This must not be \\c NULL.\n \\param input      The ciphertext buffer. This must be a readable buffer\n                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                   for an 2048-bit RSA modulus.\n \\param output     The buffer used to hold the plaintext. This must\n                   be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        label: *const ::core::ffi::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        output_max_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a private RSA operation to sign\n                 a message digest using PKCS#1.\n\n                 It is the generic wrapper for performing a PKCS#1\n                 signature.\n\n \\note           The \\p sig buffer must be as large as the size\n                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\note           For PKCS#1 v2.1 encoding, see comments on\n                 mbedtls_rsa_rsassa_pss_sign() for details on\n                 \\p md_alg and \\p hash_id.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function to use. This is mandatory and\n                 must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 signature\n                 operation (RSASSA-PKCS1-v1_5-SIGN).\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature\n                 operation (RSASSA-PSS-SIGN).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>.\n\n \\note           This function enforces that the provided salt length complies\n                 with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1 v2.2) §9.1.1\n                 step 3. The constraint is that the hash length plus the salt\n                 length plus 2 bytes must be at most the key length. If this\n                 constraint is not met, this function returns\n                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param saltlen  The length of the salt that should be used.\n                 If passed #MBEDTLS_RSA_SALT_LEN_ANY, the function will use\n                 the largest possible salt length up to the hash length,\n                 which is the largest permitted by some standards including\n                 FIPS 186-4 §5.5.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        saltlen: ::core::ffi::c_int,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature\n                 operation (RSASSA-PSS-SIGN).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>.\n\n \\note           This function always uses the maximum possible salt size,\n                 up to the length of the payload hash. This choice of salt\n                 size complies with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1\n                 v2.2) §9.1.1 step 3. Furthermore this function enforces a\n                 minimum salt size which is the hash size minus 2 bytes. If\n                 this minimum size is too large given the key size (the salt\n                 size, plus the hash size, plus 2 bytes must be no more than\n                 the key size in bytes), this function returns\n                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a public RSA operation and checks\n                 the message digest.\n\n                 This is the generic wrapper for performing a PKCS#1\n                 verification.\n\n \\note           For PKCS#1 v2.1 encoding, see comments on\n                 mbedtls_rsa_rsassa_pss_verify() about \\p md_alg and\n                 \\p hash_id.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 verification\n                 operation (RSASSA-PKCS1-v1_5-VERIFY).\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification\n                 operation (RSASSA-PSS-VERIFY).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>. If the \\c hash_id set in \\p ctx by\n                 mbedtls_rsa_set_padding() is #MBEDTLS_MD_NONE, the \\p md_alg\n                 parameter is used.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification\n                 operation (RSASSA-PSS-VERIFY).\n\n \\note           The \\p sig buffer must be as large as the size\n                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\note           The \\c hash_id set in \\p ctx by mbedtls_rsa_set_padding() is\n                 ignored.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param mgf1_hash_id      The message digest algorithm used for the\n                          verification operation and the mask generation\n                          function (MGF1). For more details on the encoding\n                          operation and the mask generation function, consult\n                          <em>RFC-3447: Public-Key Cryptography Standards\n                          (PKCS) #1 v2.1: RSA Cryptography\n                          Specifications</em>.\n \\param expected_salt_len The length of the salt used in padding. Use\n                          #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: ::core::ffi::c_int,
        sig: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function copies the components of an RSA context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The source context. This must be initialized.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure."]
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an RSA key.\n\n \\param ctx      The RSA context to free. May be \\c NULL, in which case\n                 this function is a no-op. If it is not \\c NULL, it must\n                 point to an initialized RSA context."]
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          The RSA checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_rsa_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " \\brief    The ECP key-pair structure.\n\n A generic key-pair that may be used for ECDSA and fixed ECDH, for example.\n\n \\note    Members are deliberately in the same order as in the\n          ::mbedtls_ecdsa_context structure."]
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
pub type mbedtls_ecdsa_restart_ctx = ::core::ffi::c_void;
extern "C" {
    #[doc = " \\brief          This function checks whether a given group can be used\n                 for ECDSA.\n\n \\param gid      The ECP group ID to check.\n\n \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdsa_can_do(gid: mbedtls_ecp_group_id) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            The deterministic version implemented in\n                  mbedtls_ecdsa_sign_det_ext() is usually preferred.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated\n                  as defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp       The context for the elliptic curve to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param r         The MPI context in which to store the first part\n                  the signature. This must be initialized.\n \\param s         The MPI context in which to store the second part\n                  the signature. This must be initialized.\n \\param d         The private signing key. This must be initialized.\n \\param buf       The content to be signed. This is usually the hash of\n                  the original data to be signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX\n                  or \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const ::core::ffi::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message, deterministic version.\n\n                  For more information, see <em>RFC-6979: Deterministic\n                  Usage of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param md_alg        The hash algorithm used to hash the original data.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
    pub fn mbedtls_ecdsa_sign_det_ext(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const ::core::ffi::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng_blind: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param buf       The hashed content that was signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param Q         The public key to use for verification. This must be\n                  initialized and setup.\n \\param r         The first integer of the signature.\n                  This must be initialized.\n \\param s         The second integer of the signature.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const ::core::ffi::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, serialized as defined in <em>RFC-4492:\n                  Elliptic Curve Cryptography (ECC) Cipher Suites for\n                  Transport Layer Security (TLS)</em>.\n\n \\warning         It is not thread-safe to use the same context in\n                  multiple threads.\n\n \\note            The deterministic version is used if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more\n                  information, see <em>RFC-6979: Deterministic Usage\n                  of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p blen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is used only for blinding and may be set to \\c NULL, but\n                  doing so is DEPRECATED.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hlen: usize,
        sig: *mut ::core::ffi::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_write_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_write_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p blen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is unused and may be set to \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hlen: usize,
        sig: *mut ::core::ffi::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p size Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const ::core::ffi::c_uchar,
        hlen: usize,
        sig: *const ::core::ffi::c_uchar,
        slen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature,\n                  in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_read_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_read_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p size Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const ::core::ffi::c_uchar,
        hlen: usize,
        sig: *const ::core::ffi::c_uchar,
        slen: usize,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates an ECDSA keypair on the given curve.\n\n \\see            ecp.h\n\n \\param ctx      The ECDSA context to store the keypair in.\n                 This must be initialized.\n \\param gid      The elliptic curve to use. One of the various\n                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDSA context from an EC key pair.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to setup. This must be initialized.\n \\param key       The EC key to use. This must be initialized and hold\n                  a private-public key pair or a public key. In the former\n                  case, the ECDSA context may be used for signature creation\n                  and verification after this call. In the latter case, it\n                  may be used for signature verification.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDSA context.\n\n \\param ctx       The ECDSA context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    #[doc = " \\brief           This function frees an ECDSA context.\n\n \\param ctx       The ECDSA context to free. This may be \\c NULL,\n                  in which case this function does nothing. If it\n                  is not \\c NULL, it must be initialized."]
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub const mbedtls_pk_type_t_MBEDTLS_PK_OPAQUE: mbedtls_pk_type_t = 7;
#[doc = " \\brief          Public key types"]
pub type mbedtls_pk_type_t = ::core::ffi::c_uint;
#[doc = " \\brief           Options for RSASSA-PSS signature verification.\n                  See \\c mbedtls_rsa_rsassa_pss_verify_ext()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    pub private_mgf1_hash_id: mbedtls_md_type_t,
    pub private_expected_salt_len: ::core::ffi::c_int,
}
impl Default for mbedtls_pk_rsassa_pss_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
#[doc = " \\brief           Types for interfacing with the debug module"]
pub type mbedtls_pk_debug_type = ::core::ffi::c_uint;
#[doc = " \\brief           Item to send to the debug module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub private_type: mbedtls_pk_debug_type,
    pub private_name: *const ::core::ffi::c_char,
    pub private_value: *mut ::core::ffi::c_void,
}
impl Default for mbedtls_pk_debug_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[doc = " \\brief           Public key container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_context {
    pub private_pk_info: *const mbedtls_pk_info_t,
    pub private_pk_ctx: *mut ::core::ffi::c_void,
}
impl Default for mbedtls_pk_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mbedtls_pk_restart_ctx = ::core::ffi::c_void;
#[doc = " \\brief           Types for RSA-alt abstraction"]
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        olen: *mut usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        output_max_len: usize,
    ) -> ::core::ffi::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> usize>;
extern "C" {
    #[doc = " \\brief           Return information associated with the given PK type\n\n \\param pk_type   PK type to search for.\n\n \\return          The PK info associated with the type or NULL if not found."]
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    #[doc = " \\brief           Initialize a #mbedtls_pk_context (as NONE).\n\n \\param ctx       The context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Free the components of a #mbedtls_pk_context.\n\n \\param ctx       The context to clear. It must have been initialized.\n                  If this is \\c NULL, this function does nothing.\n\n \\note            For contexts that have been set up with\n                  mbedtls_pk_setup_opaque(), this does not free the underlying\n                  PSA key and you still need to call psa_destroy_key()\n                  independently if you want to destroy that key."]
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Initialize a PK context with the information given\n                  and allocates the type-specific PK subcontext.\n\n \\param ctx       Context to initialize. It must not have been set\n                  up yet (type #MBEDTLS_PK_NONE).\n \\param info      Information to use\n\n \\return          0 on success,\n                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,\n                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure.\n\n \\note            For contexts holding an RSA-alt key, use\n                  \\c mbedtls_pk_setup_rsa_alt() instead."]
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Initialize an RSA-alt context\n\n \\param ctx       Context to initialize. It must not have been set\n                  up yet (type #MBEDTLS_PK_NONE).\n \\param key       RSA key pointer\n \\param decrypt_func  Decryption function\n \\param sign_func     Signing function\n \\param key_len_func  Function returning key length in bytes\n\n \\return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the\n                  context wasn't already initialized as RSA_ALT.\n\n \\note            This function replaces \\c mbedtls_pk_setup() for RSA-alt."]
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut ::core::ffi::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Get the size in bits of the underlying key\n\n \\param ctx       The context to query. It must have been initialized.\n\n \\return          Key size in bits, or 0 on error"]
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> usize;
}
extern "C" {
    #[doc = " \\brief           Tell if a context can do the operation given by type\n\n \\param ctx       The context to query. It must have been initialized.\n \\param type      The desired type.\n\n \\return          1 if the context can do operations on the given type.\n \\return          0 if the context cannot do the operations on the given\n                  type. This is always the case for a context that has\n                  been initialized but not set up, or that has been\n                  cleared with mbedtls_pk_free()."]
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used.\n                  This can be #MBEDTLS_MD_NONE if the signature algorithm\n                  does not rely on a hash algorithm (non-deterministic\n                  ECDSA, RSA PKCS#1 v1.5).\n                  For PKCS#1 v1.5, if \\p md_alg is #MBEDTLS_MD_NONE, then\n                  \\p hash is the DigestInfo structure used by RFC 8017\n                  &sect;9.2 steps 3&ndash;6. If \\p md_alg is a valid hash\n                  algorithm then \\p hash is the digest itself, and this\n                  function calculates the DigestInfo encoding internally.\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n\n \\return          0 on success (signature is valid),\n                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid\n                  signature in sig but its length is less than \\p siglen,\n                  or a specific error code.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n                  Use \\c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )\n                  to verify RSASSA_PSS signatures."]
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *const ::core::ffi::c_uchar,
        sig_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_verify()\n\n \\note            Performs the same job as \\c mbedtls_pk_verify(), but can\n                  return early and restart according to the limit set with\n                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC\n                  operations. For RSA, same as \\c mbedtls_pk_verify().\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length or 0 (see notes)\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n \\param rs_ctx    Restart context (NULL to disable restart)\n\n \\return          See \\c mbedtls_pk_verify(), or\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_verify_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *const ::core::ffi::c_uchar,
        sig_len: usize,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature, with options.\n                  (Includes verification of the padding depending on type.)\n\n \\param type      Signature type (inc. possible padding type) to verify\n \\param options   Pointer to type-specific options, or NULL\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length or 0 (see notes)\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n\n \\return          0 on success (signature is valid),\n                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be\n                  used for this type of signatures,\n                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid\n                  signature in sig but its length is less than \\p siglen,\n                  or a specific error code.\n\n \\note            If hash_len is 0, then the length associated with md_alg\n                  is used instead, or an error returned if it is invalid.\n\n \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0\n\n \\note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point\n                  to a mbedtls_pk_rsassa_pss_options structure,\n                  otherwise it must be NULL."]
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const ::core::ffi::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *const ::core::ffi::c_uchar,
        sig_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature, including padding if relevant.\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 on success, or a specific error code.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n                  There is no interface in the PK module to make RSASSA-PSS\n                  signatures yet.\n\n \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.\n                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *mut ::core::ffi::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature given a signature type.\n\n \\param pk_type   Signature type.\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 on success, or a specific error code.\n\n \\note            When \\p pk_type is #MBEDTLS_PK_RSASSA_PSS,\n                  see #PSA_ALG_RSA_PSS for a description of PSS options used.\n\n \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.\n                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE.\n"]
    pub fn mbedtls_pk_sign_ext(
        pk_type: mbedtls_pk_type_t,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *mut ::core::ffi::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_sign()\n\n \\note            Performs the same job as \\c mbedtls_pk_sign(), but can\n                  return early and restart according to the limit set with\n                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC\n                  operations. For RSA, same as \\c mbedtls_pk_sign().\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n \\param rs_ctx    Restart context (NULL to disable restart)\n\n \\return          See \\c mbedtls_pk_sign().\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_sign_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ::core::ffi::c_uchar,
        hash_len: usize,
        sig: *mut ::core::ffi::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Decrypt message (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param input     Input to decrypt\n \\param ilen      Input size\n \\param output    Decrypted output\n \\param olen      Decrypted message length\n \\param osize     Size of the output buffer\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n\n \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Encrypt message (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param input     Message to encrypt\n \\param ilen      Message size\n \\param output    Encrypted output\n \\param olen      Encrypted output length\n \\param osize     Size of the output buffer\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\note            \\p f_rng is used for padding generation.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n\n \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if a public-private pair of keys matches.\n\n \\param pub       Context holding a public key.\n \\param prv       Context holding a private (and public) key.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          \\c 0 on success (keys were checked and match each other).\n \\return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not\n                  be checked - in that case they may or may not match.\n \\return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid.\n \\return          Another non-zero value if the keys do not match."]
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Export debug information\n\n \\param ctx       The PK context to use. It must have been initialized.\n \\param items     Place to write debug items\n\n \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Access the type name\n\n \\param ctx       The PK context to use. It must have been initialized.\n\n \\return          Type name on success, or \"invalid PK\""]
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief           Get the key type\n\n \\param ctx       The PK context to use. It must have been initialized.\n\n \\return          Type on success.\n \\return          #MBEDTLS_PK_NONE for a context that has not been set up."]
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Parse a private key in PEM or DER format\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param key       Input buffer to parse.\n                  The buffer must contain the input exactly, with no\n                  extra trailing material. For PEM, the buffer must\n                  contain a null-terminated string.\n \\param keylen    Size of \\b key in bytes.\n                  For PEM data, this includes the terminating null byte,\n                  so \\p keylen must be equal to `strlen(key) + 1`.\n \\param pwd       Optional password for decryption.\n                  Pass \\c NULL if expecting a non-encrypted key.\n                  Pass a string of \\p pwdlen bytes if expecting an encrypted\n                  key; a non-encrypted key will also be accepted.\n                  The empty password is not supported.\n \\param pwdlen    Size of the password in bytes.\n                  Ignored if \\p pwd is \\c NULL.\n \\param f_rng     RNG function, must not be \\c NULL. Used for blinding.\n \\param p_rng     RNG parameter\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a\n                  specific key type, check the result with mbedtls_pk_can_do().\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const ::core::ffi::c_uchar,
        keylen: usize,
        pwd: *const ::core::ffi::c_uchar,
        pwdlen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Parse a public key in PEM or DER format\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param key       Input buffer to parse.\n                  The buffer must contain the input exactly, with no\n                  extra trailing material. For PEM, the buffer must\n                  contain a null-terminated string.\n \\param keylen    Size of \\b key in bytes.\n                  For PEM data, this includes the terminating null byte,\n                  so \\p keylen must be equal to `strlen(key) + 1`.\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a\n                  specific key type, check the result with mbedtls_pk_can_do().\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const ::core::ffi::c_uchar,
        keylen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Load and parse a private key\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param path      filename to read the private key from\n \\param password  Optional password to decrypt the file.\n                  Pass \\c NULL if expecting a non-encrypted key.\n                  Pass a null-terminated string if expecting an encrypted\n                  key; a non-encrypted key will also be accepted.\n                  The empty password is not supported.\n \\param f_rng     RNG function, must not be \\c NULL. Used for blinding.\n \\param p_rng     RNG parameter\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a\n                  specific key type, check the result with mbedtls_pk_can_do().\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_keyfile(
        ctx: *mut mbedtls_pk_context,
        path: *const ::core::ffi::c_char,
        password: *const ::core::ffi::c_char,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Load and parse a public key\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param path      filename to read the public key from\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If\n                  you need a specific key type, check the result with\n                  mbedtls_pk_can_do().\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_keyfile(
        ctx: *mut mbedtls_pk_context,
        path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       PK context which must contain a valid private key.\n \\param buf       buffer to write to\n \\param size      size of the buffer\n\n \\return          length of data written if successful, or a specific\n                  error code"]
    pub fn mbedtls_pk_write_key_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a SubjectPublicKeyInfo DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       PK context which must contain a valid public or private key.\n \\param buf       buffer to write to\n \\param size      size of the buffer\n\n \\return          length of data written if successful, or a specific\n                  error code"]
    pub fn mbedtls_pk_write_pubkey_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a PEM string\n\n \\param ctx       PK context which must contain a valid public or private key.\n \\param buf       Buffer to write to. The output includes a\n                  terminating null byte.\n \\param size      Size of the buffer in bytes.\n\n \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_pubkey_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 PEM string\n\n \\param ctx       PK context which must contain a valid private key.\n \\param buf       Buffer to write to. The output includes a\n                  terminating null byte.\n \\param size      Size of the buffer in bytes.\n\n \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_key_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Parse a SubjectPublicKeyInfo DER structure\n\n \\param p         the position in the ASN.1 data\n \\param end       end of the buffer\n \\param pk        The PK context to fill. It must have been initialized\n                  but not set up.\n\n \\return          0 if successful, or a specific PK error code"]
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a subjectPublicKey to ASN.1 data\n                  Note: function works backwards in data buffer\n\n \\param p         reference to current position pointer\n \\param start     start of the buffer (for bounds-checking)\n \\param key       PK context which must contain a valid public or private key.\n\n \\return          the length written or a negative error code"]
    pub fn mbedtls_pk_write_pubkey(
        p: *mut *mut ::core::ffi::c_uchar,
        start: *mut ::core::ffi::c_uchar,
        key: *const mbedtls_pk_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_pk_load_file(
        path: *const ::core::ffi::c_char,
        buf: *mut *mut ::core::ffi::c_uchar,
        n: *mut usize,
    ) -> ::core::ffi::c_int;
}
#[doc = "< Placeholder to mark the end of cipher ID lists."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
#[doc = "< The identity cipher, treated as a stream cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
#[doc = "< The AES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
#[doc = "< The DES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
#[doc = "< The Triple DES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
#[doc = "< The Camellia cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
#[doc = "< The Aria cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
#[doc = "< The ChaCha20 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
#[doc = " \\brief     Supported cipher types.\n\n \\warning   DES is considered weak cipher and its use\n            constitutes a security risk. Arm recommends considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_id_t = ::core::ffi::c_uint;
#[doc = "< Placeholder to mark the end of cipher-pair lists."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
#[doc = "< The identity stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
#[doc = "< AES cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
#[doc = "< AES cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
#[doc = "< AES cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
#[doc = "< AES cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
#[doc = "< AES cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
#[doc = "< AES cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
#[doc = "< AES cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
#[doc = "< AES cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
#[doc = "< AES cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
#[doc = "< AES cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
#[doc = "< AES cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
#[doc = "< AES cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
#[doc = "< AES cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
#[doc = "< AES cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
#[doc = "< AES cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
#[doc = "< Camellia cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
#[doc = "< Camellia cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
#[doc = "< Camellia cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
#[doc = "< Camellia cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
#[doc = "< Camellia cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
#[doc = "< Camellia cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
#[doc = "< Camellia cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
#[doc = "< Camellia cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
#[doc = "< Camellia cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
#[doc = "< Camellia cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
#[doc = "< Camellia cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
#[doc = "< Camellia cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
#[doc = "< Camellia cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
#[doc = "< Camellia cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
#[doc = "< Camellia cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
#[doc = "< DES cipher with ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
#[doc = "< DES cipher with CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
#[doc = "< DES cipher with EDE ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
#[doc = "< DES cipher with EDE CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
#[doc = "< DES cipher with EDE3 ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
#[doc = "< DES cipher with EDE3 CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
#[doc = "< AES cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
#[doc = "< AES cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
#[doc = "< AES cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
#[doc = "< AES cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
#[doc = "< AES cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
#[doc = "< AES cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
#[doc = "< Camellia cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
#[doc = "< Camellia cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
#[doc = "< Camellia cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
#[doc = "< Camellia cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    47;
#[doc = "< Camellia cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    48;
#[doc = "< Camellia cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    49;
#[doc = "< Aria cipher with 128-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
#[doc = "< Aria cipher with 192-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
#[doc = "< Aria cipher with 256-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
#[doc = "< Aria cipher with 128-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
#[doc = "< Aria cipher with 192-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
#[doc = "< Aria cipher with 256-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
#[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
#[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
#[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
#[doc = "< Aria cipher with 128-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
#[doc = "< Aria cipher with 192-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
#[doc = "< Aria cipher with 256-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
#[doc = "< Aria cipher with 128-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
#[doc = "< Aria cipher with 192-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
#[doc = "< Aria cipher with 256-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
#[doc = "< Aria cipher with 128-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
#[doc = "< Aria cipher with 192-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
#[doc = "< Aria cipher with 256-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
#[doc = "< Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
#[doc = "< Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
#[doc = "< Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
#[doc = "< AES 128-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
#[doc = "< AES 192-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
#[doc = "< AES 256-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
#[doc = "< AES 128-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
#[doc = "< AES 256-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
#[doc = "< ChaCha20 stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
#[doc = "< ChaCha20-Poly1305 AEAD cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
#[doc = "< AES cipher with 128-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
#[doc = "< AES cipher with 192-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
#[doc = "< AES cipher with 256-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
#[doc = "< AES cipher with 128-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
#[doc = "< AES cipher with 192-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
#[doc = "< AES cipher with 256-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs.\n\n \\warning   DES is considered weak cipher and its use\n            constitutes a security risk. Arm recommends considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_type_t = ::core::ffi::c_uint;
#[doc = "< None."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
#[doc = "< The ECB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
#[doc = "< The CBC cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
#[doc = "< The CFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
#[doc = "< The OFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
#[doc = "< The CTR cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
#[doc = "< The GCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
#[doc = "< The stream cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
#[doc = "< The CCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
#[doc = "< The CCM*-no-tag cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
#[doc = "< The XTS cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
#[doc = "< The ChaCha-Poly cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
#[doc = "< The SP800-38F KW mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
#[doc = "< The SP800-38F KWP mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
#[doc = " Supported cipher modes."]
pub type mbedtls_cipher_mode_t = ::core::ffi::c_uint;
#[doc = "< PKCS7 padding (default)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
#[doc = "< ISO/IEC 7816-4 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
#[doc = "< ANSI X.923 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
#[doc = "< Zero padding (not reversible)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
#[doc = "< Never pad (full blocks only)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
#[doc = " Supported cipher padding types."]
pub type mbedtls_cipher_padding_t = ::core::ffi::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
#[doc = " Type of operation."]
pub type mbedtls_operation_t = ::core::ffi::c_int;
#[doc = " Undefined key length."]
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_5 = 0;
#[doc = " Key length, in bits (including parity), for DES keys."]
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_5 = 64;
#[doc = " Key length in bits, including parity, for DES in two-key EDE."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_5 = 128;
#[doc = " Key length in bits, including parity, for DES in three-key EDE."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_5 = 192;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[doc = " Cipher information. Allows calling cipher functions\n in a generic way.\n\n \\note        The library does not support custom cipher info structures,\n              only built-in structures returned by the functions\n              mbedtls_cipher_info_from_string(),\n              mbedtls_cipher_info_from_type(),\n              mbedtls_cipher_info_from_values(),\n              mbedtls_cipher_info_from_psa()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    pub private_type: mbedtls_cipher_type_t,
    pub private_mode: mbedtls_cipher_mode_t,
    pub private_key_bitlen: ::core::ffi::c_uint,
    pub private_name: *const ::core::ffi::c_char,
    pub private_iv_size: ::core::ffi::c_uint,
    pub private_flags: ::core::ffi::c_int,
    pub private_block_size: ::core::ffi::c_uint,
    pub private_base: *const mbedtls_cipher_base_t,
}
impl Default for mbedtls_cipher_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    pub private_cipher_info: *const mbedtls_cipher_info_t,
    pub private_key_bitlen: ::core::ffi::c_int,
    pub private_operation: mbedtls_operation_t,
    pub private_add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut ::core::ffi::c_uchar, olen: usize, data_len: usize),
    >,
    pub private_get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut ::core::ffi::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> ::core::ffi::c_int,
    >,
    pub private_unprocessed_data: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_len: usize,
    pub private_iv: [::core::ffi::c_uchar; 16usize],
    pub private_iv_size: usize,
    pub private_cipher_ctx: *mut ::core::ffi::c_void,
    pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
impl Default for mbedtls_cipher_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief This function retrieves the list of ciphers supported\n        by the generic cipher module.\n\n        For any cipher identifier in the returned list, you can\n        obtain the corresponding generic cipher information structure\n        via mbedtls_cipher_info_from_type(), which can then be used\n        to prepare a cipher context via mbedtls_cipher_setup().\n\n\n \\return      A statically-allocated array of cipher identifiers\n              of type cipher_type_t. The last entry is zero."]
    pub fn mbedtls_cipher_list() -> *const ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher name.\n\n \\param cipher_name   Name of the cipher to search for. This must not be\n                      \\c NULL.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_name.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const ::core::ffi::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher type.\n\n \\param cipher_type   Type of the cipher to search for.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_type.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher ID,\n                      key size and mode.\n\n \\param cipher_id     The ID of the cipher to search for. For example,\n                      #MBEDTLS_CIPHER_ID_AES.\n \\param key_bitlen    The length of the key in bits.\n \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_id.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: ::core::ffi::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function initializes a \\p cipher_context as NONE.\n\n \\param ctx           The context to be initialized. This must not be \\c NULL."]
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function frees and clears the cipher-specific\n                      context of \\p ctx. Freeing \\p ctx itself remains the\n                      responsibility of the caller.\n\n \\param ctx           The context to be freed. If this is \\c NULL, the\n                      function has no effect, otherwise this must point to an\n                      initialized context."]
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function prepares a cipher context for\n                      use with the given cipher primitive.\n\n \\note                After calling this function, you should call\n                      mbedtls_cipher_setkey() and, if the mode uses padding,\n                      mbedtls_cipher_set_padding_mode(), then for each\n                      message to encrypt or decrypt with this key, either:\n                      - mbedtls_cipher_crypt() for one-shot processing with\n                      non-AEAD modes;\n                      - mbedtls_cipher_auth_encrypt_ext() or\n                      mbedtls_cipher_auth_decrypt_ext() for one-shot\n                      processing with AEAD modes or NIST_KW;\n                      - for multi-part processing, see the documentation of\n                      mbedtls_cipher_reset().\n\n \\param ctx           The context to prepare. This must be initialized by\n                      a call to mbedtls_cipher_init() first.\n \\param cipher_info   The cipher to use.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the\n                      cipher-specific context fails."]
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the key to use with the given context.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param key           The key to use. This must be a readable buffer of at\n                      least \\p key_bitlen Bits.\n \\param key_bitlen    The key length to use, in Bits.\n \\param operation     The operation that the key will be used for:\n                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const ::core::ffi::c_uchar,
        key_bitlen: ::core::ffi::c_int,
        operation: mbedtls_operation_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the padding mode, for cipher modes\n                      that use padding.\n\n                      The default passing mode is PKCS7 padding.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param mode          The padding mode.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE\n                      if the selected padding mode is not supported.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode\n                      does not support padding."]
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the initialization vector (IV)\n                  or nonce.\n\n \\note            Some ciphers do not use IVs nor nonce. For these\n                  ciphers, this function has no effect.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must\n                  be 12, and the initial counter value is 0.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length\n                  must be 12.\n\n \\param ctx       The generic cipher context. This must be initialized and\n                  bound to a cipher information structure.\n \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This\n                  must be a readable buffer of at least \\p iv_len Bytes.\n \\param iv_len    The IV length for ciphers with variable-size IV.\n                  This parameter is discarded by ciphers with fixed-size IV.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                  parameter-verification failure."]
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief         This function resets the cipher state.\n\n \\note          With non-AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update() one or more times\n                4. mbedtls_cipher_finish()\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\note          With AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update_ad()\n                4. mbedtls_cipher_update() one or more times\n                5. mbedtls_cipher_finish()\n                6. mbedtls_cipher_check_tag() (for decryption) or\n                mbedtls_cipher_write_tag() (for encryption).\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\param ctx     The generic cipher context. This must be bound to a key.\n\n \\return        \\c 0 on success.\n \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                parameter-verification failure."]
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function adds additional data for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param ad            The additional data to use. This must be a readable\n                      buffer of at least \\p ad_len Bytes.\n \\param ad_len        The length of \\p ad in Bytes.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher update function. It encrypts or\n                      decrypts using the given cipher context. Writes as\n                      many block-sized blocks of data as possible to output.\n                      Any data that cannot be written immediately is either\n                      added to the next block, or flushed when\n                      mbedtls_cipher_finish() is called.\n                      Exception: For MBEDTLS_MODE_ECB, expects a single block\n                      in size. For example, 16 Bytes for AES.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an\n                      unsupported mode for a cipher.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        olen: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher finalization function. If data still\n                      needs to be flushed from an incomplete block, the data\n                      contained in it is padded to the size of\n                      the last block, and written to the \\p output buffer.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param output        The buffer to write data to. This needs to be a writable\n                      buffer of at least \\p block_size Bytes.\n \\param olen          The length of the data written to the \\p output buffer.\n                      This may not be \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut ::core::ffi::c_uchar,
        olen: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized,\n                      bound to a key, and have just completed a cipher\n                      operation through mbedtls_cipher_finish() the tag for\n                      which should be written.\n \\param tag           The buffer to write the tag to. This must be a writable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to write.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function checks the tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param tag           The buffer holding the tag. This must be a readable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to check.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic all-in-one encryption/decryption function,\n                      for all ciphers except AEAD constructs.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n                      This must be a readable buffer of at least \\p iv_len\n                      Bytes.\n \\param iv_len        The IV length for ciphers with variable-size IV.\n                      This parameter is discarded by ciphers with fixed-size\n                      IV.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data in Bytes.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\note                Some ciphers do not use IVs nor nonce. For these\n                      ciphers, use \\p iv = NULL and \\p iv_len = 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        olen: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                For AEAD modes, the tag will be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      must not be \\c NULL.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen + \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen + 8\n                      (rounded up to a multiple of 8 if KWP is used);\n                      \\p ilen + 15 is always a safe value.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The desired length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_encrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                If the data is not authentic, then the output buffer\n                      is zeroed out to prevent the unauthentic plaintext being\n                      used, making this interface safer.\n\n \\note                For AEAD modes, the tag must be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data. For AEAD ciphers this\n                      must be at least \\p tag_len. For NIST_KW this must be\n                      at least \\c 8.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      may be \\c NULL if \\p output_len is \\c 0.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen - \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen - 8.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The actual length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_decrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = ::core::ffi::c_uint;
#[doc = " \\brief   This structure is used for storing ciphersuite information\n\n \\note    members are defined using integral types instead of enums\n          in order to pack structure and reduce memory usage by internal\n          \\c ciphersuite_definitions[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub private_id: ::core::ffi::c_int,
    pub private_name: *const ::core::ffi::c_char,
    pub private_cipher: u8,
    pub private_mac: u8,
    pub private_key_exchange: u8,
    pub private_flags: u8,
    pub private_min_tls_version: u16,
    pub private_max_tls_version: u16,
}
impl Default for mbedtls_ssl_ciphersuite_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const ::core::ffi::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: ::core::ffi::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_get_cipher_key_bitlen(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> usize;
}
pub type psa_status_t = i32;
#[doc = " \\brief Encoding of a key type.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_TYPE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_type_t = u16;
#[doc = " The type of PSA elliptic curve family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_ECC_FAMILY_xxx`.\n\n The curve identifier is required to create an ECC key using the\n PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_ecc_family_t = u8;
#[doc = " The type of PSA Diffie-Hellman group family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_DH_FAMILY_xxx`.\n\n The group identifier is required to create a Diffie-Hellman key using the\n PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_dh_family_t = u8;
#[doc = " \\brief Encoding of a cryptographic algorithm.\n\n Values of this type are generally constructed by macros called\n `PSA_ALG_xxx`.\n\n For algorithms that can be applied to multiple key types, this type\n does not encode the key type. For example, for symmetric ciphers\n based on a block cipher, #psa_algorithm_t encodes the block cipher\n mode and the padding mode while the block cipher itself is encoded\n via #psa_key_type_t.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_algorithm_t = u32;
#[doc = " Encoding of key lifetimes.\n\n The lifetime of a key indicates where it is stored and what system actions\n may create and destroy it.\n\n Lifetime values have the following structure:\n - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\\c lifetime)):\n   persistence level. This value indicates what device management\n   actions can cause it to be destroyed. In particular, it indicates\n   whether the key is _volatile_ or _persistent_.\n   See ::psa_key_persistence_t for more information.\n - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\\c lifetime)):\n   location indicator. This value indicates which part of the system\n   has access to the key material and can perform operations using the key.\n   See ::psa_key_location_t for more information.\n\n Volatile keys are automatically destroyed when the application instance\n terminates or on a power reset of the device. Persistent keys are\n preserved until the application explicitly destroys them or until an\n integration-specific device management event occurs (for example,\n a factory reset).\n\n Persistent keys have a key identifier of type #mbedtls_svc_key_id_t.\n This identifier remains valid throughout the lifetime of the key,\n even if the application instance that created the key terminates.\n The application can call psa_open_key() to open a persistent key that\n it created previously.\n\n The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime\n #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is\n available. Other lifetime values may be supported depending on the\n library configuration.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_LIFETIME_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_lifetime_t = u32;
#[doc = " Encoding of key persistence levels.\n\n What distinguishes different persistence levels is what device management\n events may cause keys to be destroyed. _Volatile_ keys are destroyed\n by a power reset. Persistent keys may be destroyed by events such as\n a transfer of ownership or a factory reset. What management events\n actually affect persistent keys at different levels is outside the\n scope of the PSA Cryptography specification.\n\n The PSA Cryptography specification defines the following values of\n persistence levels:\n - \\c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key.\n   A volatile key is automatically destroyed by the implementation when\n   the application instance terminates. In particular, a volatile key\n   is automatically destroyed on a power reset of the device.\n - \\c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:\n   persistent key with a default lifetime.\n - \\c 2-254: currently not supported by Mbed TLS.\n - \\c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:\n   read-only or write-once key.\n   A key with this persistence level cannot be destroyed.\n   Mbed TLS does not currently offer a way to create such keys, but\n   integrations of Mbed TLS can use it for built-in keys that the\n   application cannot modify (for example, a hardware unique key (HUK)).\n\n \\note Key persistence levels are 8-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the persistence as the lower 8 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_persistence_t = u8;
#[doc = " Encoding of key location indicators.\n\n If an integration of Mbed TLS can make calls to external\n cryptoprocessors such as secure elements, the location of a key\n indicates which secure element performs the operations on the key.\n Depending on the design of the secure element, the key\n material may be stored either in the secure element, or\n in wrapped (encrypted) form alongside the key metadata in the\n primary local storage.\n\n The PSA Cryptography API specification defines the following values of\n location indicators:\n - \\c 0: primary local storage.\n   This location is always available.\n   The primary local storage is typically the same storage area that\n   contains the key metadata.\n - \\c 1: primary secure element.\n   Integrations of Mbed TLS should support this value if there is a secure\n   element attached to the operating environment.\n   As a guideline, secure elements may provide higher resistance against\n   side channel and physical attacks than the primary local storage, but may\n   have restrictions on supported key types, sizes, policies and operations\n   and may have different performance characteristics.\n - \\c 2-0x7fffff: other locations defined by a PSA specification.\n   The PSA Cryptography API does not currently assign any meaning to these\n   locations, but future versions of that specification or other PSA\n   specifications may do so.\n - \\c 0x800000-0xffffff: vendor-defined locations.\n   No PSA specification will assign a meaning to locations in this range.\n\n \\note Key location indicators are 24-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the location as the upper 24 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_location_t = u32;
#[doc = " Encoding of identifiers of persistent keys.\n\n - Applications may freely choose key identifiers in the range\n   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX.\n - The implementation may define additional key identifiers in the range\n   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX.\n - 0 is reserved as an invalid key identifier.\n - Key identifiers outside these ranges are reserved for future use.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to how values are allocated must require careful\n       consideration to allow backward compatibility."]
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
#[doc = " \\brief Encoding of permitted usage on a key.\n\n Values of this type are generally constructed as bitwise-ors of macros\n called `PSA_KEY_USAGE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_usage_t = u32;
#[doc = " The type of a structure containing key attributes.\n\n This is an opaque structure that can represent the metadata of a key\n object. Metadata that can be stored in attributes includes:\n - The location of the key in storage, indicated by its key identifier\n   and its lifetime.\n - The key's policy, comprising usage flags and a specification of\n   the permitted algorithm(s).\n - Information about the key itself: the key type and its size.\n - Additional implementation-defined attributes.\n\n The actual key material is not considered an attribute of a key.\n Key attributes do not contain information that is generally considered\n highly confidential.\n\n An attribute structure works like a simple data structure where each function\n `psa_set_key_xxx` sets a field and the corresponding function\n `psa_get_key_xxx` retrieves the value of the corresponding field.\n However, a future version of the library  may report values that are\n equivalent to the original one, but have a different encoding. Invalid\n values may be mapped to different, also invalid values.\n\n An attribute structure may contain references to auxiliary resources,\n for example pointers to allocated memory or indirect references to\n pre-calculated values. In order to free such resources, the application\n must call psa_reset_key_attributes(). As an exception, calling\n psa_reset_key_attributes() on an attribute structure is optional if\n the structure has only been modified by the following functions\n since it was initialized or last reset with psa_reset_key_attributes():\n - psa_set_key_id()\n - psa_set_key_lifetime()\n - psa_set_key_type()\n - psa_set_key_bits()\n - psa_set_key_usage_flags()\n - psa_set_key_algorithm()\n\n Before calling any function on a key attribute structure, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   memset(&attributes, 0, sizeof(attributes));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_attributes_t attributes = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,\n   for example:\n   \\code\n   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\n   \\endcode\n - Assign the result of the function psa_key_attributes_init()\n   to the structure, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   attributes = psa_key_attributes_init();\n   \\endcode\n\n A freshly initialized attribute structure contains the following\n values:\n\n - lifetime: #PSA_KEY_LIFETIME_VOLATILE.\n - key identifier: 0 (which is not a valid key identifier).\n - type: \\c 0 (meaning that the type is unspecified).\n - key size: \\c 0 (meaning that the size is unspecified).\n - usage flags: \\c 0 (which allows no usage except exporting a public key).\n - algorithm: \\c 0 (which allows no cryptographic usage, but allows\n   exporting).\n\n A typical sequence to create a key is as follows:\n -# Create and initialize an attribute structure.\n -# If the key is persistent, call psa_set_key_id().\n    Also call psa_set_key_lifetime() to place the key in a non-default\n    location.\n -# Set the key policy with psa_set_key_usage_flags() and\n    psa_set_key_algorithm().\n -# Set the key type with psa_set_key_type().\n    Skip this step if copying an existing key with psa_copy_key().\n -# When generating a random key with psa_generate_key() or deriving a key\n    with psa_key_derivation_output_key(), set the desired key size with\n    psa_set_key_bits().\n -# Call a key creation function: psa_import_key(), psa_generate_key(),\n    psa_key_derivation_output_key() or psa_copy_key(). This function reads\n    the attribute structure, creates a key with these attributes, and\n    outputs a key identifier to the newly created key.\n -# The attribute structure is now no longer necessary.\n    You may call psa_reset_key_attributes(), although this is optional\n    with the workflow presented here because the attributes currently\n    defined in this specification do not require any additional resources\n    beyond the structure itself.\n\n A typical sequence to query a key's attributes is as follows:\n -# Call psa_get_key_attributes().\n -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that\n    you are interested in.\n -# Call psa_reset_key_attributes() to free any resources that may be\n    used by the attribute structure.\n\n Once a key has been created, it is impossible to change its attributes."]
pub type psa_key_attributes_t = psa_key_attributes_s;
#[doc = " \\brief Encoding of the step of a key derivation.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_DERIVATION_INPUT_xxx`."]
pub type psa_key_derivation_step_t = u16;
extern "C" {
    #[doc = " \\brief Library initialization.\n\n Applications must call this function before calling any other\n function in this module.\n\n Applications may call this function more than once. Once a call\n succeeds, subsequent calls are guaranteed to succeed.\n\n If the application calls other functions before calling psa_crypto_init(),\n the behavior is undefined. Implementations are encouraged to either perform\n the operation as if the library had been initialized or to return\n #PSA_ERROR_BAD_STATE or some other applicable error. In particular,\n implementations should not return a success status if the lack of\n initialization may have security implications, for example due to improper\n seeding of the random number generator.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_DATA_CORRUPT"]
    pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the attributes of a key.\n\n This function first resets the attribute structure as with\n psa_reset_key_attributes(). It then copies the attributes of\n the given key into the given attribute structure.\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\param[in] key               Identifier of the key to query.\n \\param[in,out] attributes    On success, the attributes of the key.\n                              On failure, equivalent to a\n                              freshly-initialized structure.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_get_key_attributes(
        key: mbedtls_svc_key_id_t,
        attributes: *mut psa_key_attributes_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Reset a key attribute structure to a freshly initialized state.\n\n You must initialize the attribute structure as described in the\n documentation of the type #psa_key_attributes_t before calling this\n function. Once the structure has been initialized, you may call this\n function at any time.\n\n This function frees any auxiliary resources that the structure\n may contain.\n\n \\param[in,out] attributes    The attribute structure to reset."]
    pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
    #[doc = " Remove non-essential copies of key material from memory.\n\n If the key identifier designates a volatile key, this functions does not do\n anything and returns successfully.\n\n If the key identifier designates a persistent key, then this function will\n free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and the key can still be used.\n\n \\param key Identifier of the key to purge.\n\n \\retval #PSA_SUCCESS\n         The key material will have been removed from memory if it is not\n         currently required.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid key identifier.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_purge_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Make a copy of a key.\n\n Copy key material from one location to another.\n\n This function is primarily useful to copy a key from one location\n to another, since it populates a key using the material from\n another key which may have a different lifetime.\n\n This function may be used to share a key with a different party,\n subject to implementation-defined restrictions on key sharing.\n\n The policy on the source key must have the usage flag\n #PSA_KEY_USAGE_COPY set.\n This flag is sufficient to permit the copy if the key has the lifetime\n #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT.\n Some secure elements do not provide a way to copy a key without\n making it extractable from the secure element. If a key is located\n in such a secure element, then the key must have both usage flags\n #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make\n a copy of the key outside the secure element.\n\n The resulting key may only be used in a way that conforms to\n both the policy of the original key and the policy specified in\n the \\p attributes parameter:\n - The usage flags on the resulting key are the bitwise-and of the\n   usage flags on the source policy and the usage flags in \\p attributes.\n - If both allow the same algorithm or wildcard-based\n   algorithm policy, the resulting key has the same algorithm policy.\n - If either of the policies allows an algorithm and the other policy\n   allows a wildcard-based algorithm policy that includes this algorithm,\n   the resulting key allows the same algorithm.\n - If the policies do not allow any algorithm in common, this function\n   fails with the status #PSA_ERROR_INVALID_ARGUMENT.\n\n The effect of this function on implementation-defined attributes is\n implementation-defined.\n\n \\param source_key        The key to copy. It must allow the usage\n                          #PSA_KEY_USAGE_COPY. If a private or secret key is\n                          being copied outside of a secure element it must\n                          also allow #PSA_KEY_USAGE_EXPORT.\n \\param[in] attributes    The attributes for the new key.\n                          They are used as follows:\n                          - The key type and size may be 0. If either is\n                            nonzero, it must match the corresponding\n                            attribute of the source key.\n                          - The key location (the lifetime and, for\n                            persistent keys, the key identifier) is\n                            used directly.\n                          - The policy constraints (usage flags and\n                            algorithm policy) are combined from\n                            the source key and \\p attributes so that\n                            both sets of restrictions apply, as\n                            described in the documentation of this function.\n \\param[out] target_key   On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p source_key is invalid.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The lifetime or identifier in \\p attributes are invalid, or\n         the policy constraints on the source and specified in\n         \\p attributes are incompatible, or\n         \\p attributes specifies a key type or key size\n         which does not match the attributes of the source key.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or\n         the source key is not exportable and its lifetime does not\n         allow copying it to the target's lifetime.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_copy_key(
        source_key: mbedtls_svc_key_id_t,
        attributes: *const psa_key_attributes_t,
        target_key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Destroy a key.\n\n This function destroys a key from both volatile\n memory and, if applicable, non-volatile storage. Implementations shall\n make a best effort to ensure that the key material cannot be recovered.\n\n This function also erases any metadata such as policies and frees\n resources associated with the key.\n\n If a key is currently in use in a multipart operation, then destroying the\n key will cause the multipart operation to fail.\n\n \\param key  Identifier of the key to erase. If this is \\c 0, do nothing and\n             return #PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p key was a valid identifier and the key material that it\n         referred to has been erased. Alternatively, \\p key is \\c 0.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key cannot be erased because it is\n         read-only, either due to a policy or due to physical restrictions.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p key is not a valid identifier nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n         There was a failure in communication with the cryptoprocessor.\n         The key material may still be present in the cryptoprocessor.\n \\retval #PSA_ERROR_DATA_INVALID\n         This error is typically a result of either storage corruption on a\n         cleartext storage backend, or an attempt to read data that was\n         written by an incompatible version of the library.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The storage is corrupted. Implementations shall make a best effort\n         to erase key material even in this stage, however applications\n         should be aware that it may be impossible to guarantee that the\n         key material is not recoverable in such cases.\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n         An unexpected condition which is not a storage corruption or\n         a communication failure occurred. The cryptoprocessor may have\n         been compromised.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_destroy_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Import a key in binary format.\n\n This function supports any output from psa_export_key(). Refer to the\n documentation of psa_export_public_key() for the format of public keys\n and to the documentation of psa_export_key() for the format for\n other key types.\n\n The key data determines the key size. The attributes may optionally\n specify a key size; in this case it must match the size determined\n from the key data. A key size of 0 in \\p attributes indicates that\n the key size is solely determined by the key data.\n\n Implementations must reject an attempt to import a key of size 0.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n \\param[in] attributes    The attributes for the new key.\n                          The key size is always determined from the\n                          \\p data buffer.\n                          If the key size in \\p attributes is nonzero,\n                          it must be equal to the size from \\p data.\n \\param[out] key          On success, an identifier to the newly created key.\n                          For persistent keys, this is the key identifier\n                          defined in \\p attributes.\n                          \\c 0 on failure.\n \\param[in] data    Buffer containing the key data. The content of this\n                    buffer is interpreted according to the type declared\n                    in \\p attributes.\n                    All implementations must support at least the format\n                    described in the documentation\n                    of psa_export_key() or psa_export_public_key() for\n                    the chosen type. Implementations may allow other\n                    formats, but should be conservative: implementations\n                    should err on the side of rejecting content if it\n                    may be erroneous (e.g. wrong type or truncated data).\n \\param data_length Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular persistent location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key attributes, as a whole, are invalid, or\n         the key data is not correctly formatted, or\n         the size in \\p attributes is nonzero and does not match the size\n         of the key data.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_import_key(
        attributes: *const psa_key_attributes_t,
        data: *const u8,
        data_length: usize,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a key in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an equivalent object.\n\n If the implementation of psa_import_key() supports other formats\n beyond the format specified here, the output from psa_export_key()\n must use the representation specified here, not the original\n representation.\n\n For standard key types, the output format is as follows:\n\n - For symmetric keys (including MAC keys), the format is the\n   raw bytes of the key.\n - For DES, the key data consists of 8 bytes. The parity bits must be\n   correct.\n - For Triple-DES, the format is the concatenation of the\n   two or three DES keys.\n - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format\n   is the non-encrypted DER encoding of the representation defined by\n   PKCS\\#1 (RFC 8017) as `RSAPrivateKey`, version 0.\n   ```\n   RSAPrivateKey ::= SEQUENCE {\n       version             INTEGER,  -- must be 0\n       modulus             INTEGER,  -- n\n       publicExponent      INTEGER,  -- e\n       privateExponent     INTEGER,  -- d\n       prime1              INTEGER,  -- p\n       prime2              INTEGER,  -- q\n       exponent1           INTEGER,  -- d mod (p-1)\n       exponent2           INTEGER,  -- d mod (q-1)\n       coefficient         INTEGER,  -- (inverse of q) mod p\n   }\n   ```\n - For elliptic curve key pairs (key types for which\n   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is\n   a representation of the private value as a `ceiling(m/8)`-byte string\n   where `m` is the bit size associated with the curve, i.e. the bit size\n   of the order of the curve's coordinate field. This byte string is\n   in little-endian order for Montgomery curves (curve types\n   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass\n   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`\n   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`).\n   For Weierstrass curves, this is the content of the `privateKey` field of\n   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,\n   the format is defined by RFC 7748, and output is masked according to §5.\n   For twisted Edwards curves, the private key is as defined by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For Diffie-Hellman key exchange key pairs (key types for which\n   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the\n   format is the representation of the private key `x` as a big-endian byte\n   string. The length of the byte string is the private key size in bytes\n   (leading zeroes are not stripped).\n - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is\n   true), the format is the same as for psa_export_public_key().\n\n The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.\n\n \\param key               Identifier of the key to export. It must allow the\n                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public\n                          key.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_EXPORT flag.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(\\c type, \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_export_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a public key or the public part of a key pair in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an object that is equivalent to the public key.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n For standard key types, the output format is as follows:\n - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of\n   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`.\n   ```\n   RSAPublicKey ::= SEQUENCE {\n      modulus            INTEGER,    -- n\n      publicExponent     INTEGER  }  -- e\n   ```\n - For elliptic curve keys on a twisted Edwards curve (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY\n   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined\n   by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For other elliptic curve public keys (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed\n   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.\n   Let `m` be the bit size associated with the curve, i.e. the bit size of\n   `q` for a curve over `F_q`. The representation consists of:\n      - The byte 0x04;\n      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;\n      - `y_P` as a `ceiling(m/8)`-byte string, big-endian.\n - For Diffie-Hellman key exchange public keys (key types for which\n   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),\n   the format is the representation of the public key `y = g^x mod p` as a\n   big-endian byte string. The length of the byte string is the length of the\n   base prime `p` in bytes.\n\n Exporting a public key object or the public part of a key pair is\n always permitted, regardless of the key's usage flags.\n\n \\param key               Identifier of the key to export.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key is neither a public key nor a key pair.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\\c type), \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_export_public_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message.\n\n \\note To verify the hash of a message against an\n       expected value, use psa_hash_compare() instead.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer where the hash is to be written.\n \\param hash_size         Size of the \\p hash buffer in bytes.\n \\param[out] hash_length  On success, the number of bytes\n                          that make up the hash value. This is always\n                          #PSA_HASH_LENGTH(\\p alg).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p hash_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_compute(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message and compare it with a\n reference value.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer containing the expected hash value.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p input_length or \\p hash_length do not match the hash size for \\p alg\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_compare(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart hash operations.\n\n Before calling any function on a hash operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_hash_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_hash_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,\n   for example:\n   \\code\n   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_hash_operation_init()\n   to the structure, for example:\n   \\code\n   psa_hash_operation_t operation;\n   operation = psa_hash_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
    #[doc = " Set up a multipart hash operation.\n\n The sequence of operations to calculate a hash (message digest)\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT.\n -# Call psa_hash_setup() to specify the algorithm.\n -# Call psa_hash_update() zero, one or more times, passing a fragment\n    of the message each time. The hash that is calculated is the hash\n    of the concatenation of these messages in order.\n -# To calculate the hash, call psa_hash_finish().\n    To compare the hash with an expected value, call psa_hash_verify().\n\n If an error occurs at any step after a call to psa_hash_setup(), the\n operation will need to be reset by a call to psa_hash_abort(). The\n application may call psa_hash_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_hash_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_hash_finish() or psa_hash_verify().\n - A call to psa_hash_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_hash_operation_t and not yet in use.\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a hash algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_setup(
        operation: *mut psa_hash_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart hash operation.\n\n The application must call psa_hash_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\param[in,out] operation Active hash operation.\n \\param[in] input         Buffer containing the message fragment to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_update(
        operation: *mut psa_hash_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the hash. Call psa_hash_verify() instead.\n          Beware that comparing integrity or authenticity data such as\n          hash values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the hashed data which could allow an attacker to guess\n          a valid hash and thereby bypass security controls.\n\n \\param[in,out] operation     Active hash operation.\n \\param[out] hash             Buffer where the hash is to be written.\n \\param hash_size             Size of the \\p hash buffer in bytes.\n \\param[out] hash_length      On success, the number of bytes\n                              that make up the hash value. This is always\n                              #PSA_HASH_LENGTH(\\c alg) where \\c alg is the\n                              hash algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p hash buffer is too small. You can determine a\n         sufficient buffer size by calling #PSA_HASH_LENGTH(\\c alg)\n         where \\c alg is the hash algorithm that is calculated.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_finish(
        operation: *mut psa_hash_operation_t,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message and compare it with\n an expected value.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update(). It then\n compares the calculated hash with the expected hash passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual hash and the expected hash is performed\n in constant time.\n\n \\param[in,out] operation     Active hash operation.\n \\param[in] hash              Buffer containing the expected hash value.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_verify(
        operation: *mut psa_hash_operation_t,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a hash operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_hash_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_hash_operation_t.\n\n In particular, calling psa_hash_abort() after the operation has been\n terminated by a call to psa_hash_abort(), psa_hash_finish() or\n psa_hash_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized hash operation.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Clone a hash operation.\n\n This function copies the state of an ongoing hash operation to\n a new operation object. In other words, this function is equivalent\n to calling psa_hash_setup() on \\p target_operation with the same\n algorithm that \\p source_operation was set up for, then\n psa_hash_update() on \\p target_operation with the same input that\n that was passed to \\p source_operation. After this function returns, the\n two objects are independent, i.e. subsequent calls involving one of\n the objects do not affect the other object.\n\n \\param[in] source_operation      The active hash operation to clone.\n \\param[in,out] target_operation  The operation object to set up.\n                                  It must be initialized but not active.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_BAD_STATE\n         The \\p source_operation state is not valid (it must be active), or\n         the \\p target_operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_clone(
        source_operation: *const psa_hash_operation_t,
        target_operation: *mut psa_hash_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC (message authentication code) of a message.\n\n \\note To verify the MAC of a message against an\n       expected value, use psa_mac_verify() instead.\n       Beware that comparing integrity or authenticity data such as\n       MAC values with a function such as \\c memcmp is risky\n       because the time taken by the comparison may leak information\n       about the MAC value which could allow an attacker to guess\n       a valid MAC and thereby bypass security controls.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p mac_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_compute(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC of a message and compare it with a reference value.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected value.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart MAC operations.\n\n Before calling any function on a MAC operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_mac_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_mac_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,\n   for example:\n   \\code\n   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_mac_operation_init()\n   to the structure, for example:\n   \\code\n   psa_mac_operation_t operation;\n   operation = psa_mac_operation_init();\n   \\endcode\n\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
    #[doc = " Set up a multipart MAC calculation operation.\n\n This function sets up the calculation of the MAC\n (message authentication code) of a byte string.\n To verify the MAC of a message against an\n expected value, use psa_mac_verify_setup() instead.\n\n The sequence of operations to calculate a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_sign_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_sign_finish() to finish\n    calculating the MAC value and retrieve it.\n\n If an error occurs at any step after a call to psa_mac_sign_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_sign_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_sign_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_sign_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set up a multipart MAC verification operation.\n\n This function sets up the verification of the MAC\n (message authentication code) of a byte string against an expected value.\n\n The sequence of operations to verify a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_verify_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_verify_finish() to finish\n    calculating the actual MAC of the message and verify it against\n    the expected value.\n\n If an error occurs at any step after a call to psa_mac_verify_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_verify_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_verify_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage\n                          PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c key is not compatible with \\c alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart MAC operation.\n\n The application must call psa_mac_sign_setup() or psa_mac_verify_setup()\n before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] input         Buffer containing the message fragment to add to\n                          the MAC calculation.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_update(
        operation: *mut psa_mac_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message.\n\n The application must call psa_mac_sign_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the MAC. Call psa_mac_verify_finish() instead.\n          Beware that comparing integrity or authenticity data such as\n          MAC values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the MAC value which could allow an attacker to guess\n          a valid MAC and thereby bypass security controls.\n\n \\param[in,out] operation Active MAC operation.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value. This is always\n                          #PSA_MAC_LENGTH(\\c key_type, \\c key_bits, \\c alg)\n                          where \\c key_type and \\c key_bits are the type and\n                          bit-size respectively of the key and \\c alg is the\n                          MAC algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p mac buffer is too small. You can determine a\n         sufficient buffer size by calling PSA_MAC_LENGTH().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac sign\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_sign_finish(
        operation: *mut psa_mac_operation_t,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message and compare it with\n an expected value.\n\n The application must call psa_mac_verify_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update(). It then\n compares the calculated MAC with the expected MAC passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual MAC and the expected MAC is performed\n in constant time.\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] mac           Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected MAC.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac verify\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify_finish(
        operation: *mut psa_mac_operation_t,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a MAC operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_mac_sign_setup() or psa_mac_verify_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_mac_operation_t.\n\n In particular, calling psa_mac_abort() after the operation has been\n terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or\n psa_mac_verify_finish() is safe and has no effect.\n\n \\param[in,out] operation Initialized MAC operation.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt a message using a symmetric cipher.\n\n This function encrypts a message with a random IV (initialization\n vector). Use the multipart operation interface with a\n #psa_cipher_operation_t object to provide other forms of IV.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n                              The output contains the IV followed by\n                              the ciphertext proper.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Decrypt a message using a symmetric cipher.\n\n This function decrypts a message encrypted with a symmetric cipher.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to decrypt.\n                              This consists of the IV followed by the\n                              ciphertext proper.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the plaintext is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart cipher operations.\n\n Before calling any function on a cipher operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_cipher_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,\n   for example:\n   \\code\n   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_cipher_operation_init()\n   to the structure, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   operation = psa_cipher_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart symmetric encryption operation.\n\n The sequence of operations to encrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_encrypt_setup() to specify the algorithm and key.\n -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to\n    generate or set the IV (initialization vector). You should use\n    psa_cipher_generate_iv() unless the protocol you are implementing\n    requires a specific IV value.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_encrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_encrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart symmetric decryption operation.\n\n The sequence of operations to decrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_decrypt_setup() to specify the algorithm and key.\n -# Call psa_cipher_set_iv() with the IV (initialization vector) for the\n    decryption. If the IV is prepended to the ciphertext, you can call\n    psa_cipher_update() on a buffer containing the IV followed by the\n    beginning of the message.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_decrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_decrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate an IV for a symmetric encryption operation.\n\n This function generates a random IV (initialization vector), nonce\n or initial counter value for the encryption operation as appropriate\n for the chosen algorithm, key type and key size.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] iv               Buffer where the generated IV is to be written.\n \\param iv_size               Size of the \\p iv buffer in bytes.\n \\param[out] iv_length        On success, the number of bytes of the\n                              generated IV.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p iv buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no IV set),\n         or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_generate_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *mut u8,
        iv_size: usize,
        iv_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the IV for a symmetric encryption or decryption operation.\n\n This function sets the IV (initialization vector), nonce\n or initial counter value for the encryption or decryption operation.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\note When encrypting, applications should use psa_cipher_generate_iv()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] iv                Buffer containing the IV to use.\n \\param iv_length             Size of the IV in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p iv is not acceptable for the chosen algorithm,\n         or the chosen algorithm does not use an IV.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active cipher\n         encrypt operation, with no IV set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_set_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *const u8,
        iv_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active cipher operation.\n\n Before calling this function, you must:\n 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. If the algorithm requires an IV, call psa_cipher_generate_iv()\n    (recommended when encrypting) or psa_cipher_set_iv().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_update(
        operation: *mut psa_cipher_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting or decrypting a message in a cipher operation.\n\n The application must call psa_cipher_encrypt_setup() or\n psa_cipher_decrypt_setup() before calling this function. The choice\n of setup function determines whether this function encrypts or\n decrypts its input.\n\n This function finishes the encryption or decryption of the message\n formed by concatenating the inputs passed to preceding calls to\n psa_cipher_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input size passed to this operation is not valid for\n         this particular algorithm. For example, the algorithm is a based\n         on block cipher and requires a whole number of blocks, but the\n         total input size is not a multiple of the block size.\n \\retval #PSA_ERROR_INVALID_PADDING\n         This is a decryption operation for an algorithm that includes\n         padding, and the ciphertext does not contain valid padding.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_finish(
        operation: *mut psa_cipher_operation_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a cipher operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_cipher_operation_t.\n\n In particular, calling psa_cipher_abort() after the operation has been\n terminated by a call to psa_cipher_abort() or psa_cipher_finish()\n is safe and has no effect.\n\n \\param[in,out] operation     Initialized cipher operation.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated encryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that will be authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] plaintext           Data that will be authenticated and\n                                encrypted.\n \\param plaintext_length        Size of \\p plaintext in bytes.\n \\param[out] ciphertext         Output buffer for the authenticated and\n                                encrypted data. The additional data is not\n                                part of this output. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate outputs, the\n                                authentication tag is appended to the\n                                encrypted data.\n \\param ciphertext_size         Size of the \\p ciphertext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p plaintext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p\n                                  plaintext_length) evaluates to the maximum\n                                  ciphertext size of any supported AEAD\n                                  encryption.\n \\param[out] ciphertext_length  On success, the size of the output\n                                in the \\p ciphertext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p ciphertext_size is too small.\n         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p plaintext_length) or\n         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p plaintext_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        plaintext: *const u8,
        plaintext_length: usize,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated decryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_DECRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that has been authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] ciphertext          Data that has been authenticated and\n                                encrypted. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate inputs, the buffer\n                                must contain the encrypted data followed\n                                by the authentication tag.\n \\param ciphertext_length       Size of \\p ciphertext in bytes.\n \\param[out] plaintext          Output buffer for the decrypted data.\n \\param plaintext_size          Size of the \\p plaintext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p ciphertext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p\n                                  ciphertext_length) evaluates to the maximum\n                                  plaintext size of any supported AEAD\n                                  decryption.\n \\param[out] plaintext_length   On success, the size of the output\n                                in the \\p plaintext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The ciphertext is not authentic.\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p plaintext_size is too small.\n         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p ciphertext_length) or\n         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p ciphertext_length) can be used\n         to determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        ciphertext: *const u8,
        ciphertext_length: usize,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart AEAD operations.\n\n Before calling any function on an AEAD operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_aead_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_aead_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,\n   for example:\n   \\code\n   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_aead_operation_init()\n   to the structure, for example:\n   \\code\n   psa_aead_operation_t operation;\n   operation = psa_aead_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart authenticated encryption operation.\n\n The sequence of operations to encrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_encrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to\n    generate or set the nonce. You should use\n    psa_aead_generate_nonce() unless the protocol you are implementing\n    requires a specific nonce value.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the message to encrypt each time.\n -# Call psa_aead_finish().\n\n If an error occurs at any step after a call to psa_aead_encrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_finish().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_encrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart authenticated decryption operation.\n\n The sequence of operations to decrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_decrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call psa_aead_set_nonce() with the nonce for the decryption.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the ciphertext to decrypt each time.\n -# Call psa_aead_verify().\n\n If an error occurs at any step after a call to psa_aead_decrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_verify().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_decrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate a random nonce for an authenticated encryption operation.\n\n This function generates a random nonce for the authenticated encryption\n operation with an appropriate size for the chosen algorithm, key type\n and key size.\n\n The application must call psa_aead_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] nonce            Buffer where the generated nonce is to be\n                              written.\n \\param nonce_size            Size of the \\p nonce buffer in bytes.\n \\param[out] nonce_length     On success, the number of bytes of the\n                              generated nonce.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p nonce buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active aead encrypt\n         operation, with no nonce set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_generate_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *mut u8,
        nonce_size: usize,
        nonce_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the nonce for an authenticated encryption or decryption operation.\n\n This function sets the nonce for the authenticated\n encryption or decryption operation.\n\n The application must call psa_aead_encrypt_setup() or\n psa_aead_decrypt_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note When encrypting, applications should use psa_aead_generate_nonce()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] nonce             Buffer containing the nonce to use.\n \\param nonce_length          Size of the nonce in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p nonce is not acceptable for the chosen algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no nonce\n         set), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_set_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *const u8,
        nonce_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Declare the lengths of the message and additional data for AEAD.\n\n The application must call this function before calling\n psa_aead_update_ad() or psa_aead_update() if the algorithm for\n the operation requires it. If the algorithm does not require it,\n calling this function is optional, but if this function is called\n then the implementation must enforce the lengths.\n\n You may call this function before or after setting the nonce with\n psa_aead_set_nonce() or psa_aead_generate_nonce().\n\n - For #PSA_ALG_CCM, calling this function is required.\n - For the other AEAD algorithms defined in this specification, calling\n   this function is not required.\n - For vendor-defined algorithm, refer to the vendor documentation.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param ad_length             Size of the non-encrypted additional\n                              authenticated data in bytes.\n \\param plaintext_length      Size of the plaintext to encrypt in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         At least one of the lengths is not acceptable for the chosen\n         algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and\n         psa_aead_update_ad() and psa_aead_update() must not have been\n         called yet), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_set_lengths(
        operation: *mut psa_aead_operation_t,
        ad_length: usize,
        plaintext_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Pass additional data to an active AEAD operation.\n\n Additional data is authenticated, but not encrypted.\n\n You may call this function multiple times to pass successive fragments\n of the additional data. You may not call this function after passing\n data to encrypt or decrypt with psa_aead_update().\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,\n          treat the input as untrusted and prepare to undo any action that\n          depends on the input if psa_aead_verify() returns an error status.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the fragment of\n                              additional data.\n \\param input_length          Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input length overflows the additional data length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, have lengths set if required by the algorithm, and\n         psa_aead_update() must not have been called yet), or the library\n         has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_update_ad(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active AEAD operation.\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n 3. Call psa_aead_update_ad() to pass all the additional data.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:\n          - Do not use the output in any way other than storing it in a\n            confidential location. If you take any action that depends\n            on the tentative decrypted data, this action will need to be\n            undone if the input turns out not to be valid. Furthermore,\n            if an adversary can observe that this action took place\n            (for example through timing), they may be able to use this\n            fact as an oracle to decrypt any message encrypted with the\n            same key.\n          - In particular, do not copy the output anywhere but to a\n            memory or storage space that you have exclusive access to.\n\n This function does not require the input to be aligned to any\n particular block boundary. If the implementation can only process\n a whole block at a time, it must consume all the input provided, but\n it may delay the end of the corresponding output until a subsequent\n call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()\n provides sufficient input. The amount of data that can be delayed\n in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n                              This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type,\n                                  \\c alg, \\p input_length) where\n                                  \\c key_type is the type of key and \\c alg is\n                                  the algorithm that were used to set up the\n                                  operation.\n                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p\n                                  input_length) evaluates to the maximum\n                                  output size of any supported AEAD\n                                  algorithm.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type, \\c alg, \\p input_length) or\n         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p input_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total input length overflows the plaintext length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, and have lengths set if required by the algorithm), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_update(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_encrypt_setup().\n\n This function finishes the authentication of the additional data\n formed by concatenating the inputs passed to preceding calls to\n psa_aead_update_ad() with the plaintext formed by concatenating the\n inputs passed to preceding calls to psa_aead_update().\n\n This function has two output buffers:\n - \\p ciphertext contains trailing ciphertext that was buffered from\n   preceding calls to psa_aead_update().\n - \\p tag contains the authentication tag.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] ciphertext       Buffer where the last part of the ciphertext\n                              is to be written.\n \\param ciphertext_size       Size of the \\p ciphertext buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] ciphertext_length On success, the number of bytes of\n                              returned ciphertext.\n \\param[out] tag              Buffer where the authentication tag is\n                              to be written.\n \\param tag_size              Size of the \\p tag buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\\c\n                                key_type, \\c key_bits, \\c alg) where\n                                \\c key_type and \\c key_bits are the type and\n                                bit-size of the key, and \\c alg is the\n                                algorithm that were used in the call to\n                                psa_aead_encrypt_setup().\n                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the\n                                maximum tag size of any supported AEAD\n                                algorithm.\n \\param[out] tag_length       On success, the number of bytes\n                              that make up the returned tag.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p ciphertext or \\p tag buffer is too small.\n         #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the\n         required \\p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\\c key_type,\n         \\c key_bits, \\c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to\n         determine the required \\p tag buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active encryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_finish(
        operation: *mut psa_aead_operation_t,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
        tag: *mut u8,
        tag_size: usize,
        tag_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish authenticating and decrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_decrypt_setup().\n\n This function finishes the authenticated decryption of the message\n components:\n\n -  The additional data consisting of the concatenation of the inputs\n    passed to preceding calls to psa_aead_update_ad().\n -  The ciphertext consisting of the concatenation of the inputs passed to\n    preceding calls to psa_aead_update().\n -  The tag passed to this function call.\n\n If the authentication tag is correct, this function outputs any remaining\n plaintext and reports success. If the authentication tag is not correct,\n this function returns #PSA_ERROR_INVALID_SIGNATURE.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual tag and the expected tag is performed\n in constant time.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] plaintext        Buffer where the last part of the plaintext\n                              is to be written. This is the remaining data\n                              from previous calls to psa_aead_update()\n                              that could not be processed until the end\n                              of the input.\n \\param plaintext_size        Size of the \\p plaintext buffer in bytes.\n                              This must be appropriate for the selected algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] plaintext_length On success, the number of bytes of\n                              returned plaintext.\n \\param[in] tag               Buffer containing the authentication tag.\n \\param tag_length            Size of the \\p tag buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculations were successful, but the authentication tag is\n         not correct.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p plaintext buffer is too small.\n         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the\n         required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active decryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_verify(
        operation: *mut psa_aead_operation_t,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
        tag: *const u8,
        tag_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort an AEAD operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_aead_operation_t.\n\n In particular, calling psa_aead_abort() after the operation has been\n terminated by a call to psa_aead_abort(), psa_aead_finish() or\n psa_aead_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized AEAD operation.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a message with a private key. For hash-and-sign algorithms,\n        this includes the hashing step.\n\n \\note To perform a multi-part hash-and-sign signature algorithm, first use\n       a multi-part hash operation and then pass the resulting hash to\n       psa_sign_hash(). PSA_ALG_GET_HASH(\\p alg) can be used to determine the\n       hash algorithm to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The input message to sign.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param[in]  signature_size   Size of the \\p signature buffer in bytes. This\n                              must be appropriate for the selected\n                              algorithm and key:\n                              - The required signature size is\n                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n                                where \\c key_type and \\c key_bits are the type and\n                                bit-size respectively of key.\n                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the\n                                maximum signature size of any supported\n                                signature algorithm.\n \\param[out] signature_length On success, the number of bytes that make up\n                              the returned signature value.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a message with a public key, using\n         a hash-and-sign verification algorithm.\n\n \\note To perform a multi-part hash-and-sign signature verification\n       algorithm, first use a multi-part hash operation to hash the message\n       and then pass the resulting hash to psa_verify_hash().\n       PSA_ALG_GET_HASH(\\p alg) can be used to determine the hash algorithm\n       to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. The key must allow the usage\n                              #PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The message whose signature is to be verified.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer containing the signature to verify.\n \\param[in]  signature_length Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed signature\n         is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a hash or short message with a private key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.\n \\param alg                   A signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash or message to sign.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param signature_size        Size of the \\p signature buffer in bytes.\n \\param[out] signature_length On success, the number of bytes\n                              that make up the returned signature value.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a hash or short message using a public key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must be a public key or an asymmetric key pair. The\n                          key must allow the usage\n                          #PSA_KEY_USAGE_VERIFY_HASH.\n \\param alg               A signature algorithm (PSA_ALG_XXX\n                          value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                          is true), that is compatible with\n                          the type of \\p key.\n \\param[in] hash          The hash or message whose signature is to be\n                          verified.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n \\param[in] signature     Buffer containing the signature to verify.\n \\param signature_length  Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The signature is valid.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed\n         signature is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Encrypt a short message with a public key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the encrypted message is to\n                              be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_asymmetric_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Decrypt a short message with a private key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. It must\n                              allow the usage #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the decrypted message is to\n                              be written.\n \\param output_size           Size of the \\c output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_INVALID_PADDING\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_asymmetric_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for key derivation operations.\n\n Before calling any function on a key derivation operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_derivation_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,\n   for example:\n   \\code\n   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_key_derivation_operation_init()\n   to the structure, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   operation = psa_key_derivation_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
    #[doc = " Set up a key derivation operation.\n\n A key derivation algorithm takes some inputs and uses them to generate\n a byte stream in a deterministic way.\n This byte stream can be used to produce keys and other\n cryptographic material.\n\n To derive a key:\n -# Start with an initialized object of type #psa_key_derivation_operation_t.\n -# Call psa_key_derivation_setup() to select the algorithm.\n -# Provide the inputs for the key derivation by calling\n    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()\n    as appropriate. Which inputs are needed, in what order, and whether\n    they may be keys and if so of what type depends on the algorithm.\n -# Optionally set the operation's maximum capacity with\n    psa_key_derivation_set_capacity(). You may do this before, in the middle\n    of or after providing inputs. For some algorithms, this step is mandatory\n    because the output depends on the maximum capacity.\n -# To derive a key, call psa_key_derivation_output_key().\n    To derive a byte string for a different purpose, call\n    psa_key_derivation_output_bytes().\n    Successive calls to these functions use successive output bytes\n    calculated by the key derivation algorithm.\n -# Clean up the key derivation operation object with\n    psa_key_derivation_abort().\n\n If this function returns an error, the key derivation operation object is\n not changed.\n\n If an error occurs at any step after a call to psa_key_derivation_setup(),\n the operation will need to be reset by a call to psa_key_derivation_abort().\n\n Implementations must reject an attempt to derive a key of size 0.\n\n \\param[in,out] operation       The key derivation operation object\n                                to set up. It must\n                                have been initialized but not set up yet.\n \\param alg                     The key derivation algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_DERIVATION(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c alg is not a key derivation algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_setup(
        operation: *mut psa_key_derivation_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the current capacity of a key derivation operation.\n\n The capacity of a key derivation is the maximum number of bytes that it can\n return. When you get *N* bytes of output from a key derivation operation,\n this reduces its capacity by *N*.\n\n \\param[in] operation     The operation to query.\n \\param[out] capacity     On success, the capacity of the operation.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_get_capacity(
        operation: *const psa_key_derivation_operation_t,
        capacity: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the maximum capacity of a key derivation operation.\n\n The capacity of a key derivation operation is the maximum number of bytes\n that the key derivation operation can return from this point onwards.\n\n \\param[in,out] operation The key derivation operation object to modify.\n \\param capacity          The new capacity of the operation.\n                          It must be less or equal to the operation's\n                          current capacity.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p capacity is larger than the operation's current capacity.\n         In this case, the operation object remains valid and its capacity\n         remains unchanged.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_set_capacity(
        operation: *mut psa_key_derivation_operation_t,
        capacity: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function passes direct inputs, which is usually correct for\n non-secret inputs. To pass a secret input, which should be in a key\n object, call psa_key_derivation_input_key() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] data                Input data to use.\n \\param data_length             Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow direct inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_bytes(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide a numeric input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n However, when an algorithm requires a particular order, numeric inputs\n usually come first as they tend to be configuration parameters.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function is used for inputs which are fixed-size non-negative\n integers.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] value               The value of the numeric input.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow numeric inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_integer(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        value: u64,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation in the form of a key.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function obtains input from a key object, which is usually correct for\n secret inputs or for non-secret personalization strings kept in the key\n store. To pass a non-secret parameter which is not in the key store,\n call psa_key_derivation_input_bytes() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param key                     Identifier of the key. It must have an\n                                appropriate type for step and must allow the\n                                usage #PSA_KEY_USAGE_DERIVE or\n                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)\n                                and the algorithm used by the operation.\n\n \\note Once all inputs steps are completed, the operations will allow:\n - psa_key_derivation_output_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_output_key() if the input for step\n   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD\n   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was\n   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_verify_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;\n - psa_key_derivation_verify_key() under the same conditions as\n   psa_key_derivation_verify_bytes().\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key allows neither #PSA_KEY_USAGE_DERIVE nor\n         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this\n         algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow key inputs of the given type\n         or does not allow key inputs at all.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_key(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        key: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and use the shared secret as input to a key\n derivation.\n\n A key agreement algorithm takes two inputs: a private key \\p private_key\n a public key \\p peer_key.\n The result of this function is passed as input to a key derivation.\n The output of this key derivation can be extracted by reading from the\n resulting operation to produce keys and other cryptographic material.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() with a\n                                key agreement and derivation algorithm\n                                \\c alg (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_AGREEMENT(\\c alg) is true\n                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\c alg)\n                                is false).\n                                The operation must be ready for an\n                                input of the type given by \\p step.\n \\param step                    Which step the input data is for.\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key      Public key of the peer. The peer key must be in the\n                          same format that psa_import_key() accepts for the\n                          public key type corresponding to the type of\n                          private_key. That is, this function performs the\n                          equivalent of\n                          #psa_import_key(...,\n                          `peer_key`, `peer_key_length`) where\n                          with key attributes indicating the public key\n                          type corresponding to the type of `private_key`.\n                          For example, for EC keys, this means that peer_key\n                          is interpreted as a point on the curve that the\n                          private key is on. The standard formats for public\n                          keys are documented in the documentation of\n                          psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c private_key is not compatible with \\c alg,\n         or \\p peer_key is not valid for \\c alg or not compatible with\n         \\c private_key, or \\c step does not allow an input resulting\n         from a key agreement.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this key agreement \\p step,\n         or the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_key_agreement(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Read some data from a key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm and\n return those bytes.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the requested number of bytes from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] output       Buffer where the output will be written.\n \\param output_length     Number of bytes to output.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          no output is written to the output buffer.\n                          The operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_output_bytes(
        operation: *mut psa_key_derivation_operation_t,
        output: *mut u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Derive a key from an ongoing key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm\n and uses those bytes to generate a key deterministically.\n The key's location, usage policy, type and size are taken from\n \\p attributes.\n\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads as many bytes as required from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n How much output is produced and consumed from the operation, and how\n the key is derived, depends on the key type and on the key size\n (denoted \\c bits below):\n\n - For key types for which the key is an arbitrary sequence of bytes\n   of a given size, this function is functionally equivalent to\n   calling #psa_key_derivation_output_bytes\n   and passing the resulting output to #psa_import_key.\n   However, this function has a security benefit:\n   if the implementation provides an isolation boundary then\n   the key material is not exposed outside the isolation boundary.\n   As a consequence, for these key types, this function always consumes\n   exactly (\\c bits / 8) bytes from the operation.\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_AES;\n     - #PSA_KEY_TYPE_ARIA;\n     - #PSA_KEY_TYPE_CAMELLIA;\n     - #PSA_KEY_TYPE_DERIVE;\n     - #PSA_KEY_TYPE_HMAC;\n     - #PSA_KEY_TYPE_PASSWORD_HASH.\n\n - For ECC keys on a Montgomery elliptic curve\n   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n   Montgomery curve), this function always draws a byte string whose\n   length is determined by the curve, and sets the mandatory bits\n   accordingly. That is:\n\n     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte\n       string and process it as specified in RFC 7748 &sect;5.\n     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte\n       string and process it as specified in RFC 7748 &sect;5.\n\n - For key types for which the key is represented by a single sequence of\n   \\c bits bits with constraints as to which bit sequences are acceptable,\n   this function draws a byte string of length (\\c bits / 8) bytes rounded\n   up to the nearest whole number of bytes. If the resulting byte string\n   is acceptable, it becomes the key, otherwise the drawn bytes are discarded.\n   This process is repeated until an acceptable byte string is drawn.\n   The byte string drawn from the operation is interpreted as specified\n   for the output produced by psa_export_key().\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_DES.\n       Force-set the parity bits, but discard forbidden weak keys.\n       For 2-key and 3-key triple-DES, the three keys are generated\n       successively (for example, for 3-key triple-DES,\n       if the first 8 bytes specify a weak key and the next 8 bytes do not,\n       discard the first 8 bytes, use the next 8 bytes as the first key,\n       and continue reading output from the operation to derive the other\n       two keys).\n     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\\c group)\n       where \\c group designates any Diffie-Hellman group) and\n       ECC keys on a Weierstrass elliptic curve\n       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n       Weierstrass curve).\n       For these key types, interpret the byte string as integer\n       in big-endian order. Discard it if it is not in the range\n       [0, *N* - 2] where *N* is the boundary of the private key domain\n       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,\n       or the order of the curve's base point for ECC).\n       Add 1 to the resulting integer and use this as the private key *x*.\n       This method allows compliance to NIST standards, specifically\n       the methods titled \"key-pair generation by testing candidates\"\n       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,\n       in FIPS 186-4 &sect;B.1.2 for DSA, and\n       in NIST SP 800-56A &sect;5.6.1.2.2 or\n       FIPS 186-4 &sect;B.4.2 for elliptic curve keys.\n\n - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,\n   the way in which the operation output is consumed is\n   implementation-defined.\n\n In all cases, the data that is read is discarded from the operation.\n The operation's capacity is decreased by the number of bytes read.\n\n For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,\n the input to that step must be provided with psa_key_derivation_input_key().\n Future versions of this specification may include additional restrictions\n on the derived key based on the attributes and strength of the secret key.\n\n \\param[in] attributes    The attributes for the new key.\n                          If the key type to be created is\n                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in\n                          the policy must be the same as in the current\n                          operation.\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n         There was not enough data to create the desired key.\n         Note that in this case, no output is written to the output buffer.\n         The operation's capacity is set to 0, thus subsequent calls to\n         this function will not succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The provided key attributes are not valid for the operation.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The #PSA_KEY_DERIVATION_INPUT_SECRET or\n         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a\n         key; or one of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_output_key(
        attributes: *const psa_key_attributes_t,
        operation: *mut psa_key_derivation_operation_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value in constant time.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the expected number of bytes from the\n stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to the following code:\n \\code\n psa_key_derivation_output_bytes(operation, tmp, output_length);\n if (memcmp(output, tmp, output_length) != 0)\n     return PSA_ERROR_INVALID_SIGNATURE;\n \\endcode\n except (1) it works even if the key's policy does not allow outputting the\n bytes, and (2) the comparison will be done in constant time.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected_output Buffer containing the expected derivation output.\n \\param output_length     Length of the expected output; this is also the\n                          number of bytes that will be read.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but it differs from the expected\n         output.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_verify_bytes(
        operation: *mut psa_key_derivation_operation_t,
        expected_output: *const u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value\n stored in a key object.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value, provided as key of type\n #PSA_KEY_TYPE_PASSWORD_HASH.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the number of bytes corresponding to the\n length of the expected value from the stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to exporting the key and calling\n psa_key_derivation_verify_bytes() on the result, except that it\n works even if the key cannot be exported.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH\n                          containing the expected output. Its policy must\n                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag\n                          and the permitted algorithm must match the\n                          operation. The value of this key was likely\n                          computed by a previous call to\n                          psa_key_derivation_output_key().\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but if differs from the expected\n         output.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         The key passed as the expected value does not exist.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key passed as the expected value has an invalid type.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key passed as the expected value does not allow this usage or\n         this algorithm; or one of the inputs was a key whose policy didn't\n         allow #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          the length of the expected value. In this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_verify_key(
        operation: *mut psa_key_derivation_operation_t,
        expected: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a key derivation operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_key_derivation_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_key_derivation_operation_t.\n\n In particular, it is valid to call psa_key_derivation_abort() twice, or to\n call psa_key_derivation_abort() on an operation that has not been set up.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
        -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and return the raw shared secret.\n\n \\warning The raw result of a key agreement algorithm such as finite-field\n Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should\n not be used directly as key material. It should instead be passed as\n input to a key derivation algorithm. To chain a key agreement with\n a key derivation, use psa_key_derivation_key_agreement() and other\n functions from the key derivation interface.\n\n \\param alg                     The key agreement algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\p alg)\n                                is true).\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key            Public key of the peer. It must be\n                                in the same format that psa_import_key()\n                                accepts. The standard formats for public\n                                keys are documented in the documentation\n                                of psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n \\param[out] output             Buffer where the decrypted message is to\n                                be written.\n \\param output_size             Size of the \\c output buffer in bytes.\n \\param[out] output_length      On success, the number of bytes\n                                that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n \\retval #PSA_ERROR_NOT_PERMITTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a key agreement algorithm, or\n         \\p private_key is not compatible with \\p alg,\n         or \\p peer_key is not valid for \\p alg or not compatible with\n         \\p private_key.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p output_size is too small\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported key agreement algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_raw_key_agreement(
        alg: psa_algorithm_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate random bytes.\n\n \\warning This function **can** fail! Callers MUST check the return status\n          and MUST NOT use the content of the output buffer if the return\n          status is not #PSA_SUCCESS.\n\n \\note    To generate a key, use psa_generate_key() instead.\n\n \\param[out] output       Output buffer for the generated data.\n \\param output_size       Number of bytes to generate and output.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_generate_random(output: *mut u8, output_size: usize) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate a key or key pair.\n\n The key is generated randomly.\n Its location, usage policy, type and size are taken from \\p attributes.\n\n Implementations must reject an attempt to generate a key of size 0.\n\n The following type-specific considerations apply:\n - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the public exponent is 65537.\n   The modulus is a product of two probabilistic primes\n   between 2^{n-1} and 2^n where n is the bit size specified in the\n   attributes.\n\n \\param[in] attributes    The attributes for the new key.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_generate_key(
        attributes: *const psa_key_attributes_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
#[doc = " The CMAC context structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    pub private_state: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_block: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_len: usize,
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC computation\n                      by setting the CMAC key, and preparing to authenticate\n                      the input data.\n                      It must be called with an initialized cipher context.\n\n                      Once this function has completed, data can be supplied\n                      to the CMAC computation by calling\n                      mbedtls_cipher_cmac_update().\n\n                      To start a CMAC computation using the same key as a previous\n                      CMAC computation, use mbedtls_cipher_cmac_finish().\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param ctx           The cipher context used for the CMAC operation, initialized\n                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,\n                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,\n                      or MBEDTLS_CIPHER_DES_EDE3_ECB.\n \\param key           The CMAC key.\n \\param keybits       The length of the CMAC key in bits.\n                      Must be supported by the cipher.\n\n \\return              \\c 0 on success.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_cmac_starts(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const ::core::ffi::c_uchar,
        keybits: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function feeds an input buffer into an ongoing CMAC\n                      computation.\n\n                      The CMAC computation must have previously been started\n                      by calling mbedtls_cipher_cmac_starts() or\n                      mbedtls_cipher_cmac_reset().\n\n                      Call this function as many times as needed to input the\n                      data to be authenticated.\n                      Once all of the required data has been input,\n                      call mbedtls_cipher_cmac_finish() to obtain the result\n                      of the CMAC operation.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n\n \\return             \\c 0 on success.\n \\return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                     if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function finishes an ongoing CMAC operation, and\n                      writes the result to the output buffer.\n\n                      It should be followed either by\n                      mbedtls_cipher_cmac_reset(), which starts another CMAC\n                      operation with the same key, or mbedtls_cipher_free(),\n                      which clears the cipher context.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param output        The output buffer for the CMAC checksum result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC operation with the same\n                      key as the previous one.\n\n                      It should be called after finishing the previous CMAC\n                      operation with mbedtls_cipher_cmac_finish().\n                      After calling this function,\n                      call mbedtls_cipher_cmac_update() to supply the new\n                      CMAC operation with data.\n\n \\param ctx           The cipher context used for the CMAC operation.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_reset(ctx: *mut mbedtls_cipher_context_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               This function calculates the full generic CMAC\n                      on the input buffer with the provided key.\n\n                      The function allocates the context, performs the\n                      calculation, and frees the context.\n\n                      The CMAC result is calculated as\n                      output = generic CMAC(cmac key, input buffer).\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param cipher_info   The cipher information.\n \\param key           The CMAC key.\n \\param keylen        The length of the CMAC key in bits.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the generic CMAC result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac(
        cipher_info: *const mbedtls_cipher_info_t,
        key: *const ::core::ffi::c_uchar,
        keylen: usize,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function implements the AES-CMAC-PRF-128 pseudorandom\n                  function, as defined in\n                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based\n                  Message Authentication Code-Pseudo-Random Function-128\n                  (AES-CMAC-PRF-128) Algorithm for the Internet Key\n                  Exchange Protocol (IKE).</em>\n\n \\param key       The key to use.\n \\param key_len   The key length in Bytes.\n \\param input     The buffer holding the input data.\n \\param in_len    The length of the input data in Bytes.\n \\param output    The buffer holding the generated 16 Bytes of\n                  pseudorandom output.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_aes_cmac_prf_128(
        key: *const ::core::ffi::c_uchar,
        key_len: usize,
        input: *const ::core::ffi::c_uchar,
        in_len: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The CMAC checkup routine.\n\n \\note           In case the CMAC routines are provided by an alternative\n                 implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the\n                 checkup routine will succeed even if the implementation does\n                 not support the less widely used AES-192 or 3DES primitives.\n                 The self-test requires at least AES-128 and AES-256 to be\n                 supported by the underlying implementation.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_cmac_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_ECB: esp_aes_mode_t = 0;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_CBC: esp_aes_mode_t = 1;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_OFB: esp_aes_mode_t = 2;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_CTR: esp_aes_mode_t = 3;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_CFB8: esp_aes_mode_t = 4;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_CFB128: esp_aes_mode_t = 5;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_GCM: esp_aes_mode_t = 6;
pub const esp_aes_mode_t_ESP_AES_BLOCK_MODE_MAX: esp_aes_mode_t = 7;
pub type esp_aes_mode_t = ::core::ffi::c_uint;
#[doc = " \\brief          AES context structure\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_aes_context {
    pub key_bytes: u8,
    pub key_in_hardware: u8,
    pub key: [u8; 32usize],
}
#[doc = " \\brief The AES XTS context-type definition."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_aes_xts_context {
    #[doc = "< The AES context to use for AES block\nencryption or decryption."]
    pub crypt: esp_aes_context,
    #[doc = "< The AES context used for tweak\ncomputation."]
    pub tweak: esp_aes_context,
}
extern "C" {
    #[doc = " \\brief Lock access to AES hardware unit\n\n AES hardware unit can only be used by one\n consumer at a time.\n\n esp_aes_xxx API calls automatically manage locking & unlocking of\n hardware, this function is only needed if you want to call\n ets_aes_xxx functions directly."]
    pub fn esp_aes_acquire_hardware();
}
extern "C" {
    #[doc = " \\brief Unlock access to AES hardware unit\n\n esp_aes_xxx API calls automatically manage locking & unlocking of\n hardware, this function is only needed if you want to call\n ets_aes_xxx functions directly."]
    pub fn esp_aes_release_hardware();
}
extern "C" {
    #[doc = " \\brief          Initialize AES context\n\n \\param ctx      AES context to be initialized"]
    pub fn esp_aes_init(ctx: *mut esp_aes_context);
}
extern "C" {
    #[doc = " \\brief          Clear AES context\n\n \\param ctx      AES context to be cleared"]
    pub fn esp_aes_free(ctx: *mut esp_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES XTS context.\n\n                 It must be the first API called before using\n                 the context.\n\n \\param ctx      The AES XTS context to initialize."]
    pub fn esp_aes_xts_init(ctx: *mut esp_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES XTS context.\n\n \\param ctx      The AES XTS context to clear."]
    pub fn esp_aes_xts_free(ctx: *mut esp_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          AES set key schedule (encryption or decryption)\n\n \\param ctx      AES context to be initialized\n \\param key      encryption key\n \\param keybits  must be 128, 192 or 256\n\n \\return         0 if successful, or ERR_AES_INVALID_KEY_LENGTH"]
    pub fn esp_aes_setkey(
        ctx: *mut esp_aes_context,
        key: *const ::core::ffi::c_uchar,
        keybits: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          AES-ECB block encryption/decryption\n\n \\param ctx      AES context\n \\param mode     AES_ENCRYPT or AES_DECRYPT\n \\param input    16-byte input block\n \\param output   16-byte output block\n\n \\return         0 if successful"]
    pub fn esp_aes_crypt_ecb(
        ctx: *mut esp_aes_context,
        mode: ::core::ffi::c_int,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          AES-CBC buffer encryption/decryption\n                 Length should be a multiple of the block\n                 size (16 bytes)\n\n \\note           Upon exit, the content of the IV is updated so that you can\n                 call the function same function again on the following\n                 block(s) of data and get the same result as if it was\n                 encrypted in one call. This allows a \"streaming\" usage.\n                 If on the other hand you need to retain the contents of the\n                 IV, you should either save it manually or use the cipher\n                 module instead.\n\n \\param ctx      AES context\n \\param mode     AES_ENCRYPT or AES_DECRYPT\n \\param length   length of the input data\n \\param iv       initialization vector (updated after use)\n \\param input    buffer holding the input data\n \\param output   buffer holding the output data\n\n \\return         0 if successful, or ERR_AES_INVALID_INPUT_LENGTH"]
    pub fn esp_aes_crypt_cbc(
        ctx: *mut esp_aes_context,
        mode: ::core::ffi::c_int,
        length: usize,
        iv: *mut ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          AES-CFB128 buffer encryption/decryption.\n\n Note: Due to the nature of CFB you should use the same key schedule for\n both encryption and decryption. So a context initialized with\n esp_aes_setkey_enc() for both AES_ENCRYPT and AES_DECRYPT.\n\n \\note           Upon exit, the content of the IV is updated so that you can\n                 call the function same function again on the following\n                 block(s) of data and get the same result as if it was\n                 encrypted in one call. This allows a \"streaming\" usage.\n                 If on the other hand you need to retain the contents of the\n                 IV, you should either save it manually or use the cipher\n                 module instead.\n\n \\param ctx      AES context\n \\param mode     AES_ENCRYPT or AES_DECRYPT\n \\param length   length of the input data\n \\param iv_off   offset in IV (updated after use)\n \\param iv       initialization vector (updated after use)\n \\param input    buffer holding the input data\n \\param output   buffer holding the output data\n\n \\return         0 if successful"]
    pub fn esp_aes_crypt_cfb128(
        ctx: *mut esp_aes_context,
        mode: ::core::ffi::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          AES-CFB8 buffer encryption/decryption.\n\n Note: Due to the nature of CFB you should use the same key schedule for\n both encryption and decryption. So a context initialized with\n esp_aes_setkey_enc() for both AES_ENCRYPT and AES_DECRYPT.\n\n \\note           Upon exit, the content of the IV is updated so that you can\n                 call the function same function again on the following\n                 block(s) of data and get the same result as if it was\n                 encrypted in one call. This allows a \"streaming\" usage.\n                 If on the other hand you need to retain the contents of the\n                 IV, you should either save it manually or use the cipher\n                 module instead.\n\n \\param ctx      AES context\n \\param mode     AES_ENCRYPT or AES_DECRYPT\n \\param length   length of the input data\n \\param iv       initialization vector (updated after use)\n \\param input    buffer holding the input data\n \\param output   buffer holding the output data\n\n \\return         0 if successful"]
    pub fn esp_aes_crypt_cfb8(
        ctx: *mut esp_aes_context,
        mode: ::core::ffi::c_int,
        length: usize,
        iv: *mut ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               AES-CTR buffer encryption/decryption\n\n Warning: You have to keep the maximum use of your counter in mind!\n\n Note: Due to the nature of CTR you should use the same key schedule for\n both encryption and decryption. So a context initialized with\n esp_aes_setkey_enc() for both AES_ENCRYPT and AES_DECRYPT.\n\n \\param ctx           AES context\n \\param length        The length of the data\n \\param nc_off        The offset in the current stream_block (for resuming\n                      within current cipher stream). The offset pointer to\n                      should be 0 at the start of a stream.\n \\param nonce_counter The 128-bit nonce and counter.\n \\param stream_block  The saved stream-block for resuming. Is overwritten\n                      by the function.\n \\param input         The input data stream\n \\param output        The output data stream\n\n \\return         0 if successful"]
    pub fn esp_aes_crypt_ctr(
        ctx: *mut esp_aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut ::core::ffi::c_uchar,
        stream_block: *mut ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       This function performs an AES-OFB (Output Feedback Mode)\n              encryption or decryption operation.\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param length   The length of the input data.\n \\param iv_off   The offset in IV (updated after use).\n                 It must point to a valid \\c size_t.\n \\param iv       The initialization vector (updated after use).\n                 It must be a readable and writeable buffer of \\c 16 Bytes.\n \\param input    The buffer holding the input data.\n                 It must be readable and of size \\p length Bytes.\n \\param output   The buffer holding the output data.\n                 It must be writeable and of size \\p length Bytes.\n\n \\return         \\c 0 on success."]
    pub fn esp_aes_crypt_ofb(
        ctx: *mut esp_aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for encryption and\n                 sets the encryption key.\n\n \\param ctx      The AES XTS context to which the key should be bound.\n \\param key      The encryption key. This is comprised of the XTS key1\n                 concatenated with the XTS key2.\n \\param keybits  The size of \\p key passed in bits. Valid options are:\n                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>\n                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn esp_aes_xts_setkey_enc(
        ctx: *mut esp_aes_xts_context,
        key: *const ::core::ffi::c_uchar,
        keybits: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for decryption and\n                 sets the decryption key.\n\n \\param ctx      The AES XTS context to which the key should be bound.\n \\param key      The decryption key. This is comprised of the XTS key1\n                 concatenated with the XTS key2.\n \\param keybits  The size of \\p key passed in bits. Valid options are:\n                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>\n                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn esp_aes_xts_setkey_dec(
        ctx: *mut esp_aes_xts_context,
        key: *const ::core::ffi::c_uchar,
        keybits: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block encryption function\n                  (Only exposed to allow overriding it,\n                  see AES_ENCRYPT_ALT)\n\n \\param ctx       AES context\n \\param input     Plaintext block\n \\param output    Output (ciphertext) block"]
    pub fn esp_internal_aes_encrypt(
        ctx: *mut esp_aes_context,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block decryption function\n                  (Only exposed to allow overriding it,\n                  see AES_DECRYPT_ALT)\n\n \\param ctx       AES context\n \\param input     Ciphertext block\n \\param output    Output (plaintext) block"]
    pub fn esp_internal_aes_decrypt(
        ctx: *mut esp_aes_context,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " AES-XTS buffer encryption/decryption"]
    pub fn esp_aes_crypt_xts(
        ctx: *mut esp_aes_xts_context,
        mode: ::core::ffi::c_int,
        length: usize,
        data_unit: *const ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Deprecated, see esp_aes_internal_decrypt"]
    pub fn esp_aes_decrypt(
        ctx: *mut esp_aes_context,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " Deprecated, see esp_aes_internal_encrypt"]
    pub fn esp_aes_encrypt(
        ctx: *mut esp_aes_context,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldesc_s {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub buf: *const u8,
    pub __bindgen_anon_1: lldesc_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lldesc_s__bindgen_ty_1 {
    pub empty: u32,
    pub qe: lldesc_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldesc_s__bindgen_ty_1__bindgen_ty_1 {
    pub stqe_next: *mut lldesc_s,
}
impl Default for lldesc_s__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lldesc_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lldesc_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl lldesc_s {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sosf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sosf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        length: u32,
        offset: u32,
        sosf: u32,
        eof: u32,
        owner: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let length: u32 = unsafe { ::core::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sosf: u32 = unsafe { ::core::mem::transmute(sosf) };
            sosf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let eof: u32 = unsafe { ::core::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let owner: u32 = unsafe { ::core::mem::transmute(owner) };
            owner as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lldesc_t = lldesc_s;
extern "C" {
    #[doc = " Generate a linked list pointing to a (huge) buffer in an descriptor array.\n\n The caller should ensure there is enough size to hold the array, by calling\n ``lldesc_get_required_num_constrained`` with the same max_desc_size argument.\n\n @param[out] out_desc_array Output of a descriptor array, the head should be fed to the DMA.\n @param buffer Buffer for the descriptors to point to.\n @param size Size (or length for TX) of the buffer\n @param max_desc_size Maximum length of each descriptor\n @param isrx The RX DMA may require the buffer to be word-aligned, set to true for a RX link, otherwise false."]
    pub fn lldesc_setup_link_constrained(
        out_desc_array: *mut lldesc_t,
        buffer: *const ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        max_desc_size: ::core::ffi::c_int,
        isrx: bool,
    );
}
extern "C" {
    #[doc = " @brief Get the received length of a linked list, until end of the link or eof.\n\n @param head      The head of the linked list.\n @param[out] out_next Output of the next descriptor of the EOF descriptor. Return NULL if there's no\n                 EOF. Can be set to NULL if next descriptor is not needed.\n @return The accumulation of the `len` field of all descriptors until EOF or the end of the link."]
    pub fn lldesc_get_received_len(
        head: *mut lldesc_t,
        out_next: *mut *mut lldesc_t,
    ) -> ::core::ffi::c_int;
}
pub const esp_aes_gcm_state_ESP_AES_GCM_STATE_INIT: esp_aes_gcm_state = 0;
pub const esp_aes_gcm_state_ESP_AES_GCM_STATE_START: esp_aes_gcm_state = 1;
pub const esp_aes_gcm_state_ESP_AES_GCM_STATE_UPDATE: esp_aes_gcm_state = 2;
pub const esp_aes_gcm_state_ESP_AES_GCM_STATE_FINISH: esp_aes_gcm_state = 3;
pub type esp_aes_gcm_state = ::core::ffi::c_uint;
#[doc = " \\brief          The GCM context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_gcm_context {
    #[doc = "< Initial hash value"]
    pub H: [u8; 16usize],
    #[doc = "< GHASH value."]
    pub ghash: [u8; 16usize],
    pub J0: [u8; 16usize],
    #[doc = "< Precalculated HTable low."]
    pub HL: [u64; 16usize],
    #[doc = "< Precalculated HTable high."]
    pub HH: [u64; 16usize],
    #[doc = "< J0 from first iteration."]
    pub ori_j0: [u8; 16usize],
    pub iv: *const u8,
    #[doc = "< The length of IV."]
    pub iv_len: usize,
    #[doc = "< The total length of the additional data."]
    pub aad_len: u64,
    pub data_len: usize,
    pub mode: ::core::ffi::c_int,
    #[doc = "< The additional data."]
    pub aad: *const ::core::ffi::c_uchar,
    pub aes_ctx: esp_aes_context,
    pub gcm_state: esp_aes_gcm_state,
}
impl Default for esp_gcm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified GCM context\n\n \\param ctx       The GCM context to initialize."]
    pub fn esp_aes_gcm_init(ctx: *mut esp_gcm_context);
}
extern "C" {
    #[doc = " \\brief           This function associates a GCM context with a\n                  key.\n\n \\param ctx       The GCM context to initialize.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key.\n \\param keybits   The key size in bits. Valid options are:\n                  <ul><li>128 bits</li>\n                  <li>192 bits</li>\n                  <li>256 bits</li></ul>\n\n \\return          \\c 0 on success.\n \\return          A cipher-specific error code on failure."]
    pub fn esp_aes_gcm_setkey(
        ctx: *mut esp_gcm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const ::core::ffi::c_uchar,
        keybits: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a GCM encryption or decryption\n                  operation.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or\n                  #MBEDTLS_GCM_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer of\n                  at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n\n \\return          \\c 0 on success."]
    pub fn esp_aes_gcm_starts(
        ctx: *mut esp_gcm_context,
        mode: ::core::ffi::c_int,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a GCM\n                  encryption or decryption operation.\n\n                  Call this function after mbedtls_gcm_starts() to pass\n                  the associated data. If the associated data is empty,\n                  you do not need to call this function. You may not\n                  call this function after calling mbedtls_cipher_update().\n\n \\param ctx       The GCM context. This must have been started with\n                  mbedtls_gcm_starts() and must not have yet received\n                  any input with mbedtls_gcm_update().\n \\param aad       The buffer holding the additional data, or \\c NULL\n                  if \\p aad_len is \\c 0.\n \\param aad_len   The length of the additional data. If \\c 0,\n                  \\p add may be \\c NULL.\n\n \\return          \\c 0 on success."]
    pub fn esp_aes_gcm_update_ad(
        ctx: *mut esp_gcm_context,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing GCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_gcm_finish().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: the output consists of a whole number\n                    of 16-byte blocks. If the total input length so far\n                    (not including associated data) is 16 \\* *B* + *A*\n                    with *A* < 16 then the total output length is 16 \\* *B*.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_length + 15.\n                  - If \\p input_length is a multiple of 16 for all the calls\n                    to this function during an operation, then it is\n                    correct to use \\p output_size = \\p input_length.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx           The GCM context. This must be initialized.\n \\param input         The buffer holding the input data. If \\p input_length\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_length bytes.\n \\param input_length  The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      of at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                 total input length too long,\n                 unsupported input/output buffer overlap detected,\n                 or \\p output_size too small."]
    pub fn esp_aes_gcm_update(
        ctx: *mut esp_gcm_context,
        input: *const ::core::ffi::c_uchar,
        input_length: usize,
        output: *mut ::core::ffi::c_uchar,
        output_size: usize,
        output_length: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the GCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the GCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param tag       The buffer for holding the tag. This must be a writable\n                  buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the tag to generate. This must be at least\n                  four.\n \\param output    The buffer for the final output.\n                  If \\p output_size is nonzero, this must be a writable\n                  buffer of at least \\p output_size bytes.\n \\param output_size  The size of the \\p output buffer in bytes.\n                  This must be large enough for the output that\n                  mbedtls_gcm_update() has not produced. In particular:\n                  - If mbedtls_gcm_update() produces immediate output,\n                    or if the total input size is a multiple of \\c 16,\n                    then mbedtls_gcm_finish() never produces any output,\n                    so \\p output_size can be \\c 0.\n                  - \\p output_size never needs to be more than \\c 15.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                  invalid value of \\p tag_len,\n                  or \\p output_size too small."]
    pub fn esp_aes_gcm_finish(
        ctx: *mut esp_gcm_context,
        output: *mut ::core::ffi::c_uchar,
        output_size: usize,
        output_length: *mut usize,
        tag: *mut ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clears a GCM context\n\n \\param ctx       The GCM context to clear."]
    pub fn esp_aes_gcm_free(ctx: *mut esp_gcm_context);
}
extern "C" {
    #[doc = " \\brief           This function performs GCM encryption or decryption of a buffer.\n\n \\note            For encryption, the output buffer can be the same as the\n                  input buffer. For decryption, the output buffer cannot be\n                  the same as input buffer. If the buffers overlap, the output\n                  buffer must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx       The GCM context to use for encryption or decryption.\n \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or\n                  #MBEDTLS_GCM_DECRYPT.\n \\param length    The length of the input data. This must be a multiple of\n                  16 except in the last call before mbedtls_gcm_finish().\n \\param iv        The initialization vector.\n \\param iv_len    The length of the IV.\n \\param aad       The buffer holding the additional data.\n \\param aad_len   The length of the additional data.\n \\param input     The buffer holding the input data.\n \\param output    The buffer for holding the output data.\n \\param tag_len   The length of the tag to generate.\n \\param tag       The buffer for holding the tag.\n\n \\return         \\c 0 on success."]
    pub fn esp_aes_gcm_crypt_and_tag(
        ctx: *mut esp_gcm_context,
        mode: ::core::ffi::c_int,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag_len: usize,
        tag: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a GCM authenticated decryption of a\n                  buffer.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx       The GCM context.\n \\param length    The length of the input data. This must be a multiple\n                  of 16 except in the last call before mbedtls_gcm_finish().\n \\param iv        The initialization vector.\n \\param iv_len    The length of the IV.\n \\param aad       The buffer holding the additional data.\n \\param aad_len   The length of the additional data.\n \\param tag       The buffer holding the tag.\n \\param tag_len   The length of the tag.\n \\param input     The buffer holding the input data.\n \\param output    The buffer for holding the output data.\n\n \\return         0 if successful and authenticated.\n \\return         #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match."]
    pub fn esp_aes_gcm_auth_decrypt(
        ctx: *mut esp_gcm_context,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
        tag: *const ::core::ffi::c_uchar,
        tag_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
#[doc = " \\brief          The GCM context structure."]
pub type mbedtls_gcm_context = esp_gcm_context;
extern "C" {
    #[doc = " \\brief          The GCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_gcm_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " \\brief    The CCM context-type definition. The CCM context is passed\n           to the APIs called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ccm_context {
    pub private_y: [::core::ffi::c_uchar; 16usize],
    pub private_ctr: [::core::ffi::c_uchar; 16usize],
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_plaintext_len: usize,
    pub private_add_len: usize,
    pub private_tag_len: usize,
    pub private_processed: usize,
    pub private_q: ::core::ffi::c_uchar,
    pub private_mode: ::core::ffi::c_uchar,
    pub private_state: ::core::ffi::c_int,
}
impl Default for mbedtls_ccm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified CCM context,\n                  to make references valid, and prepare the context\n                  for mbedtls_ccm_setkey() or mbedtls_ccm_free().\n\n \\param ctx       The CCM context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ccm_init(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function initializes the CCM context set in the\n                  \\p ctx parameter and sets the encryption key.\n\n \\param ctx       The CCM context to initialize. This must be an initialized\n                  context.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key. This must not be \\c NULL.\n \\param keybits   The key size in bits. This must be acceptable by the cipher.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_setkey(
        ctx: *mut mbedtls_ccm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const ::core::ffi::c_uchar,
        keybits: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   This function releases and clears the specified CCM context\n          and underlying cipher sub-context.\n\n \\param ctx       The CCM context to clear. If this is \\c NULL, the function\n                  has no effect. Otherwise, this must be initialized."]
    pub fn mbedtls_ccm_free(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. If \\p ad_len is greater than\n                  zero, \\p ad must be a readable buffer of at least that\n                  length.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than `2^16 - 2^8`.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag: *mut ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM*.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be encoded into the \\p iv passed to\n                  this function.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is no\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_star_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag: *mut ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM authenticated decryption of a\n                  buffer.\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer\n                  of at least that \\p ad_len Bytes..\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success. This indicates that the message is authentic.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag: *const ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM* authenticated decryption of a\n                  buffer.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be decoded from \\p iv and passed to\n                  this function as \\p tag_len. (\\p tag needs to be adjusted\n                  accordingly.)\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least that \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field in Bytes.\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is nos\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_star_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag: *const ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_set_lengths() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_set_lengths().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or\n                  #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or\n                  #MBEDTLS_CCM_STAR_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer\n                  of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p mode is invalid,\n                  \\p iv_len is invalid (lower than \\c 7 or greater than\n                  \\c 13)."]
    pub fn mbedtls_ccm_starts(
        ctx: *mut mbedtls_ccm_context,
        mode: ::core::ffi::c_int,
        iv: *const ::core::ffi::c_uchar,
        iv_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function declares the lengths of the message\n                  and additional data for a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_starts() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_starts().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param total_ad_len   The total length of additional data in bytes.\n                       This must be less than `2^16 - 2^8`.\n \\param plaintext_len  The length in bytes of the plaintext to encrypt or\n                       result of the decryption (thus not encompassing the\n                       additional data that are not encrypted).\n \\param tag_len   The length of the tag to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n                  For CCM*, zero is also valid.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p total_ad_len is greater than \\c 0xFF00."]
    pub fn mbedtls_ccm_set_lengths(
        ctx: *mut mbedtls_ccm_context,
        total_ad_len: usize,
        plaintext_len: usize,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the additional data. The\n                  lengths \\p ad_len of the data parts should eventually add\n                  up exactly to the total length of additional data\n                  \\c total_ad_len passed to mbedtls_ccm_set_lengths(). You\n                  may not call this function after calling\n                  mbedtls_ccm_update().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts(), the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths() and this must not have yet\n                  received any input with mbedtls_ccm_update().\n \\param ad        The buffer holding the additional data, or \\c NULL\n                  if \\p ad_len is \\c 0.\n \\param ad_len    The length of the additional data. If \\c 0,\n                  \\p ad may be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  total input length too long."]
    pub fn mbedtls_ccm_update_ad(
        ctx: *mut mbedtls_ccm_context,
        ad: *const ::core::ffi::c_uchar,
        ad_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_ccm_finish(). The lengths \\p input_len of the\n                  data parts should eventually add up exactly to the\n                  plaintext length \\c plaintext_len passed to\n                  mbedtls_ccm_set_lengths().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: except for the last part of input data,\n                    the output consists of a whole number of 16-byte blocks.\n                    If the total input length so far (not including\n                    associated data) is 16 \\* *B* + *A* with *A* < 16 then\n                    the total output length is 16 \\* *B*.\n                    For the last part of input data, the output length is\n                    equal to the input length plus the number of bytes (*A*)\n                    buffered in the previous call to the function (if any).\n                    The function uses the plaintext length\n                    \\c plaintext_len passed to mbedtls_ccm_set_lengths()\n                    to detect the last part of input data.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_len + 15.\n                  - If \\p input_len is a multiple of 16 for all the calls\n                    to this function during an operation (not necessary for\n                    the last one) then it is correct to use \\p output_size\n                    =\\p input_len.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx           The CCM context. This must have been started with\n                      mbedtls_ccm_starts() and the lengths of the message and\n                      additional data must have been declared with\n                      mbedtls_ccm_set_lengths().\n \\param input         The buffer holding the input data. If \\p input_len\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_len bytes.\n \\param input_len     The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_len    On success, \\p *output_len contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_len is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                 \\p ctx is in an invalid state,\n                 total input length too long,\n                 or \\p output_size too small."]
    pub fn mbedtls_ccm_update(
        ctx: *mut mbedtls_ccm_context,
        input: *const ::core::ffi::c_uchar,
        input_len: usize,
        output: *mut ::core::ffi::c_uchar,
        output_size: usize,
        output_len: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the CCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the CCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts() and the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths().\n \\param tag       The buffer for holding the tag. If \\p tag_len is greater\n                  than zero, this must be a writable buffer of at least \\p\n                  tag_len Bytes.\n \\param tag_len   The length of the tag. Must match the tag length passed to\n                  mbedtls_ccm_set_lengths() function.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  invalid value of \\p tag_len,\n                  the total amount of additional data passed to\n                  mbedtls_ccm_update_ad() was lower than the total length of\n                  additional data \\c total_ad_len passed to\n                  mbedtls_ccm_set_lengths(),\n                  the total amount of input data passed to\n                  mbedtls_ccm_update() was lower than the plaintext length\n                  \\c plaintext_len passed to mbedtls_ccm_set_lengths()."]
    pub fn mbedtls_ccm_finish(
        ctx: *mut mbedtls_ccm_context,
        tag: *mut ::core::ffi::c_uchar,
        tag_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The CCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_ccm_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_poly1305_context {
    pub private_r: [u32; 4usize],
    pub private_s: [u32; 4usize],
    pub private_acc: [u32; 5usize],
    pub private_queue: [u8; 16usize],
    pub private_queue_len: usize,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified Poly1305 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by a call to\n                  \\c mbedtls_poly1305_starts(), then one or more calls to\n                  \\c mbedtls_poly1305_update(), then one call to\n                  \\c mbedtls_poly1305_finish(), then finally\n                  \\c mbedtls_poly1305_free().\n\n \\param ctx       The Poly1305 context to initialize. This must\n                  not be \\c NULL."]
    pub fn mbedtls_poly1305_init(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  Poly1305 context.\n\n \\param ctx       The Poly1305 context to clear. This may be \\c NULL, in which\n                  case this function is a no-op. If it is not \\c NULL, it must\n                  point to an initialized Poly1305 context."]
    pub fn mbedtls_poly1305_free(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the one-time authentication key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param ctx       The Poly1305 context to which the key should be bound.\n                  This must be initialized.\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_starts(
        ctx: *mut mbedtls_poly1305_context,
        key: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This functions feeds an input buffer into an ongoing\n                  Poly1305 computation.\n\n                  It is called between \\c mbedtls_cipher_poly1305_starts() and\n                  \\c mbedtls_cipher_poly1305_finish().\n                  It can be called repeatedly to process a stream of data.\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_update(
        ctx: *mut mbedtls_poly1305_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates the Poly1305 Message\n                  Authentication Code (MAC).\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param mac       The buffer to where the MAC is written. This must\n                  be a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_finish(
        ctx: *mut mbedtls_poly1305_context,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function calculates the Poly1305 MAC of the input\n                  buffer with the provided key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param mac       The buffer to where the MAC is written. This must be\n                  a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_mac(
        key: *const ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           The Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_poly1305_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = "< The mode value for performing encryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
#[doc = "< The mode value for performing decryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chacha20_context {
    pub private_state: [u32; 16usize],
    pub private_keystream8: [u8; 64usize],
    pub private_keystream_bytes_used: usize,
}
impl Default for mbedtls_chacha20_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by calls to\n                  \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts(), then one or more calls to\n                  to \\c mbedtls_chacha20_update(), and finally to\n                  \\c mbedtls_chacha20_free().\n\n \\param ctx       The ChaCha20 context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_chacha20_init(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20 context.\n\n \\param ctx       The ChaCha20 context to clear. This may be \\c NULL,\n                  in which case this function is a no-op. If it is not\n                  \\c NULL, it must point to an initialized context.\n"]
    pub fn mbedtls_chacha20_free(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the encryption/decryption key.\n\n \\note            After using this function, you must also call\n                  \\c mbedtls_chacha20_starts() to set a nonce before you\n                  start encrypting/decrypting data with\n                  \\c mbedtls_chacha_update().\n\n \\param ctx       The ChaCha20 context to which the key should be bound.\n                  It must be initialized.\n \\param key       The encryption/decryption key. This must be \\c 32 Bytes\n                  in length.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL."]
    pub fn mbedtls_chacha20_setkey(
        ctx: *mut mbedtls_chacha20_context,
        key: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the nonce and initial counter value.\n\n \\note            A ChaCha20 context can be re-used with the same key by\n                  calling this function to change the nonce.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality guarantees for the\n                  messages encrypted with the same nonce and key.\n\n \\param ctx       The ChaCha20 context to which the nonce should be bound.\n                  It must be initialized and bound to a key.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is\n                  NULL."]
    pub fn mbedtls_chacha20_starts(
        ctx: *mut mbedtls_chacha20_context,
        nonce: *const ::core::ffi::c_uchar,
        counter: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\note            \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts() must be called at least once\n                  to setup the context before this function can be called.\n\n \\note            This function can be called multiple times in a row in\n                  order to encrypt of decrypt data piecewise with the same\n                  key and nonce.\n\n \\param ctx       The ChaCha20 context to use for encryption or decryption.\n                  It must be initialized and bound to a key and nonce.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_update(
        ctx: *mut mbedtls_chacha20_context,
        size: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data with ChaCha20 and\n                  the given key and nonce.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\warning         You must never use the same (key, nonce) pair more than\n                  once. This would void any confidentiality guarantees for\n                  the messages encrypted with the same nonce and key.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\param key       The encryption/decryption key.\n                  This must be \\c 32 Bytes in length.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_crypt(
        key: *const ::core::ffi::c_uchar,
        nonce: *const ::core::ffi::c_uchar,
        counter: u32,
        size: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_chacha20_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chachapoly_context {
    pub private_chacha20_ctx: mbedtls_chacha20_context,
    pub private_poly1305_ctx: mbedtls_poly1305_context,
    pub private_aad_len: u64,
    pub private_ciphertext_len: u64,
    pub private_state: ::core::ffi::c_int,
    pub private_mode: mbedtls_chachapoly_mode_t,
}
impl Default for mbedtls_chachapoly_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20-Poly1305 context.\n\n                  It must be the first API called before using\n                  the context. It must be followed by a call to\n                  \\c mbedtls_chachapoly_setkey() before any operation can be\n                  done, and to \\c mbedtls_chachapoly_free() once all\n                  operations with that context have been finished.\n\n                  In order to encrypt or decrypt full messages at once, for\n                  each message you should make a single call to\n                  \\c mbedtls_chachapoly_crypt_and_tag() or\n                  \\c mbedtls_chachapoly_auth_decrypt().\n\n                  In order to encrypt messages piecewise, for each\n                  message you should make a call to\n                  \\c mbedtls_chachapoly_starts(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update_aad(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update(), then one call to\n                  \\c mbedtls_chachapoly_finish().\n\n \\warning         Decryption with the piecewise API is discouraged! Always\n                  use \\c mbedtls_chachapoly_auth_decrypt() when possible!\n\n                  If however this is not possible because the data is too\n                  large to fit in memory, you need to:\n\n                  - call \\c mbedtls_chachapoly_starts() and (if needed)\n                  \\c mbedtls_chachapoly_update_aad() as above,\n                  - call \\c mbedtls_chachapoly_update() multiple times and\n                  ensure its output (the plaintext) is NOT used in any other\n                  way than placing it in temporary storage at this point,\n                  - call \\c mbedtls_chachapoly_finish() to compute the\n                  authentication tag and compared it in constant time to the\n                  tag received with the ciphertext.\n\n                  If the tags are not equal, you must immediately discard\n                  all previous outputs of \\c mbedtls_chachapoly_update(),\n                  otherwise you can now safely use the plaintext.\n\n \\param ctx       The ChachaPoly context to initialize. Must not be \\c NULL."]
    pub fn mbedtls_chachapoly_init(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20-Poly1305 context.\n\n \\param ctx       The ChachaPoly context to clear. This may be \\c NULL, in which\n                  case this function is a no-op."]
    pub fn mbedtls_chachapoly_free(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the ChaCha20-Poly1305\n                  symmetric encryption key.\n\n \\param ctx       The ChaCha20-Poly1305 context to which the key should be\n                  bound. This must be initialized.\n \\param key       The \\c 256 Bit (\\c 32 Bytes) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_setkey(
        ctx: *mut mbedtls_chachapoly_context,
        key: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a ChaCha20-Poly1305 encryption or\n                  decryption operation.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\note            If the context is being used for AAD only (no data to\n                  encrypt or decrypt) then \\p mode can be set to any value.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param nonce     The nonce/IV to use for the message.\n                  This must be a readable buffer of length \\c 12 Bytes.\n \\param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or\n                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning).\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_starts(
        ctx: *mut mbedtls_chachapoly_context,
        nonce: *const ::core::ffi::c_uchar,
        mode: mbedtls_chachapoly_mode_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds additional data to be authenticated\n                  into an ongoing ChaCha20-Poly1305 operation.\n\n                  The Additional Authenticated Data (AAD), also called\n                  Associated Data (AD) is only authenticated but not\n                  encrypted nor included in the encrypted output. It is\n                  usually transmitted separately from the ciphertext or\n                  computed locally by each party.\n\n \\note            This function is called before data is encrypted/decrypted.\n                  I.e. call this function to process the AAD before calling\n                  \\c mbedtls_chachapoly_update().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of AAD. It is permitted to call\n                  this function 0 times, if no AAD is used.\n\n                  This function cannot be called any more if data has\n                  been processed by \\c mbedtls_chachapoly_update(),\n                  or if the context has been finished.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param aad_len   The length in Bytes of the AAD. The length has no\n                  restrictions.\n \\param aad       Buffer containing the AAD.\n                  This pointer can be \\c NULL if `aad_len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA\n                  if \\p ctx or \\p aad are NULL.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operations has not been started or has been\n                  finished, or if the AAD has been finished."]
    pub fn mbedtls_chachapoly_update_aad(
        ctx: *mut mbedtls_chachapoly_context,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Thus function feeds data to be encrypted or decrypted\n                  into an on-going ChaCha20-Poly1305\n                  operation.\n\n                  The direction (encryption or decryption) depends on the\n                  mode that was given when calling\n                  \\c mbedtls_chachapoly_starts().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of data. It is permitted to call\n                  this function 0 times, if no data is to be encrypted\n                  or decrypted.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param len       The length (in bytes) of the data to encrypt or decrypt.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `len == 0`.\n \\param output    The buffer to where the encrypted or decrypted data is\n                  written. This must be able to hold \\p len bytes.\n                  This pointer can be \\c NULL if `len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_update(
        ctx: *mut mbedtls_chachapoly_context,
        len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finished the ChaCha20-Poly1305 operation and\n                  generates the MAC (authentication tag).\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param mac       The buffer to where the 128-bit (16 bytes) MAC is written.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_finish(
        ctx: *mut mbedtls_chachapoly_context,
        mac: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated encryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n                  This must be initialized.\n \\param length    The length (in bytes) of the data to encrypt or decrypt.\n \\param nonce     The 96-bit (12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated\n                  data (AAD). This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the encrypted or decrypted data\n                  is written. This pointer can be \\c NULL if `ilen == 0`.\n \\param tag       The buffer to where the computed 128-bit (16 bytes) MAC\n                  is written. This must not be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_encrypt_and_tag(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const ::core::ffi::c_uchar,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        tag: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated decryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n \\param length    The length (in Bytes) of the data to decrypt.\n \\param nonce     The \\c 96 Bit (\\c 12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated data (AAD).\n                  This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param tag       The buffer holding the authentication tag.\n                  This must be a readable buffer of length \\c 16 Bytes.\n \\param input     The buffer containing the data to decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the decrypted data is written.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED\n                  if the data was not authentic.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_auth_decrypt(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const ::core::ffi::c_uchar,
        aad: *const ::core::ffi::c_uchar,
        aad_len: usize,
        tag: *const ::core::ffi::c_uchar,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20-Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_chachapoly_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
#[doc = " For encrypt-decrypt functions, whether the operation is an encryption\n or a decryption."]
pub type psa_encrypt_or_decrypt_t = ::core::ffi::c_uint;
#[doc = " @brief Type defined for MD5 context\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD5Context {
    pub buf: [u32; 4usize],
    pub bits: [u32; 2usize],
    pub in_: [u8; 64usize],
}
impl Default for MD5Context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Type defined for MD5 context\n"]
pub type md5_context_t = MD5Context;
extern "C" {
    #[doc = " @brief Initialize the MD5 context\n\n @param context Context object allocated by user"]
    pub fn esp_rom_md5_init(context: *mut md5_context_t);
}
extern "C" {
    #[doc = " @brief Running MD5 algorithm over input data\n\n @param context MD5 context which has been initialized by `MD5Init`\n @param buf Input buffer\n @param len Buffer length in bytes"]
    pub fn esp_rom_md5_update(
        context: *mut md5_context_t,
        buf: *const ::core::ffi::c_void,
        len: u32,
    );
}
extern "C" {
    #[doc = " @brief Extract the MD5 result, and erase the context\n\n @param digest Where to store the 128-bit digest value\n @param context MD5 context"]
    pub fn esp_rom_md5_final(digest: *mut u8, context: *mut md5_context_t);
}
#[doc = " @brief Type defined for MD5 context\n"]
pub type mbedtls_md5_context = MD5Context;
extern "C" {
    #[doc = " \\brief          Initialize MD5 context\n\n \\param ctx      MD5 context to be initialized\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_init(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD5 context\n\n \\param ctx      MD5 context to be cleared\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_free(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD5 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_clone(dst: *mut mbedtls_md5_context, src: *const mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_starts(ctx: *mut mbedtls_md5_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer\n\n \\param ctx      MD5 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_update(
        ctx: *mut mbedtls_md5_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 final digest\n\n \\param ctx      MD5 context\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_finish(
        ctx: *mut mbedtls_md5_context,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process data block (internal use only)\n\n \\param ctx      MD5 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn esp_md5_process(
        ctx: *mut mbedtls_md5_context,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn esp_md5_starts(ctx: *mut mbedtls_md5_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5(
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " \\brief          RIPEMD-160 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ripemd160_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [::core::ffi::c_uchar; 64usize],
}
impl Default for mbedtls_ripemd160_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be initialized"]
    pub fn mbedtls_ripemd160_init(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clear RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be cleared"]
    pub fn mbedtls_ripemd160_free(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) a RIPEMD-160 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned"]
    pub fn mbedtls_ripemd160_clone(
        dst: *mut mbedtls_ripemd160_context,
        src: *const mbedtls_ripemd160_context,
    );
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_starts(ctx: *mut mbedtls_ripemd160_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process buffer\n\n \\param ctx      RIPEMD-160 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_update(
        ctx: *mut mbedtls_ripemd160_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 final digest\n\n \\param ctx      RIPEMD-160 context\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_finish(
        ctx: *mut mbedtls_ripemd160_context,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process data block (internal use only)\n\n \\param ctx      RIPEMD-160 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful"]
    pub fn mbedtls_internal_ripemd160_process(
        ctx: *mut mbedtls_ripemd160_context,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = RIPEMD-160( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160(
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_ripemd160_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = "< return successful in ets"]
pub const ETS_STATUS_ETS_OK: ETS_STATUS = 0;
#[doc = "< return failed in ets"]
pub const ETS_STATUS_ETS_FAILED: ETS_STATUS = 1;
#[doc = " @addtogroup ets_apis\n @{"]
pub type ETS_STATUS = ::core::ffi::c_uint;
#[doc = " @addtogroup ets_apis\n @{"]
pub use self::ETS_STATUS as ets_status_t;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ETSEventTag {
    #[doc = "< Event signal, in same task, different Event with different signal"]
    pub sig: ETSSignal,
    #[doc = "< Event parameter, sometimes without usage, then will be set as 0"]
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ets_idle_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief  Start the Espressif Task Scheduler, which is an infinit loop. Please do not add code after it.\n\n @param  none\n\n @return none"]
    pub fn ets_run();
}
extern "C" {
    #[doc = " @brief  Set the Idle callback, when Tasks are processed, will call the callback before CPU goto sleep.\n\n @param  ets_idle_cb_t func : The callback function.\n\n @param  void *arg : Argument of the callback.\n\n @return None"]
    pub fn ets_set_idle_cb(func: ets_idle_cb_t, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief  Init a task with processer, priority, queue to receive Event, queue length.\n\n @param  ETSTask task : The task processer.\n\n @param  uint8_t prio : Task priority, 0-31, bigger num with high priority, one priority with one task.\n\n @param  ETSEvent *queue : Queue belongs to the task, task always receives Events, Queue is circular used.\n\n @param  uint8_t qlen : Queue length.\n\n @return None"]
    pub fn ets_task(task: ETSTask, prio: u8, queue: *mut ETSEvent, qlen: u8);
}
extern "C" {
    #[doc = " @brief  Post an event to an Task.\n\n @param  uint8_t prio : Priority of the Task.\n\n @param  ETSSignal sig : Event signal.\n\n @param  ETSParam  par : Event parameter\n\n @return ETS_OK     : post successful\n @return ETS_FAILED : post failed"]
    pub fn ets_post(prio: u8, sig: ETSSignal, par: ETSParam) -> ETS_STATUS;
}
extern "C" {
    #[doc = " @addtogroup ets_apis\n @{"]
    pub static exc_cause_table: [*const ::core::ffi::c_char; 40usize];
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Entry code, code can be called in PRO CPU when booting is not completed.\n         When Pro CPU booting is completed, Pro CPU will call the Entry code if not NULL.\n\n @param  uint32_t start : the PRO Entry code address value in uint32_t\n\n @return None"]
    pub fn ets_set_user_start(start: u32);
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Startup code, code can be called when booting is not completed, or in Entry code.\n         When Entry code completed, CPU will call the Startup code if not NULL, else call ets_run.\n\n @param  uint32_t callback : the Startup code address value in uint32_t\n\n @return None     : post successful"]
    pub fn ets_set_startup_callback(callback: u32);
}
extern "C" {
    #[doc = " @brief  Set App cpu Entry code, code can be called in PRO CPU.\n         When APP booting is completed, APP CPU will call the Entry code if not NULL.\n\n @param  uint32_t start : the APP Entry code address value in uint32_t, stored in register APPCPU_CTRL_REG_D.\n\n @return None"]
    pub fn ets_set_appcpu_boot_addr(start: u32);
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf.\n         Can not print float point data format, or longlong data format.\n         So we maybe only use this in ROM.\n\n @param  const char *fmt : See printf.\n\n @param  ... : See printf.\n\n @return int : the length printed to the output device."]
    pub fn ets_printf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief  Set the uart channel of ets_printf(uart_tx_one_char).\n         ROM will set it base on the efuse and gpio setting, however, this can be changed after booting.\n\n @param  uart_no : 0 for UART0, 1 for UART1.\n\n @return None"]
    pub fn ets_set_printf_channel(uart_no: u8);
}
extern "C" {
    #[doc = " @brief Get the uart channel of ets_printf(uart_tx_one_char).\n\n @return uint8_t uart channel used by ets_printf(uart_tx_one_char)."]
    pub fn ets_get_printf_channel() -> u8;
}
extern "C" {
    #[doc = " @brief  Output a char to uart, which uart to output(which is in uart module in ROM) is not in scope of the function.\n         Can not print float point data format, or longlong data format\n\n @param  char c : char to output.\n\n @return None"]
    pub fn ets_write_char_uart(c: ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions： putc1 and putc2, both of which will be called if need ouput.\n         To install putc1, which is defaulted installed as ets_write_char_uart in none silent boot mode, as NULL in silent mode.\n\n @param  void (*)(char) p: Output function to install.\n\n @return None"]
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions： putc1 and putc2, both of which will be called if need ouput.\n         To install putc2, which is defaulted installed as NULL.\n\n @param  void (*)(char) p: Output function to install.\n\n @return None"]
    pub fn ets_install_putc2(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::core::ffi::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief  Install putc1 as ets_write_char_uart.\n         In silent boot mode(to void interfere the UART attached MCU), we can call this function, after booting ok.\n\n @param  None\n\n @return None"]
    pub fn ets_install_uart_printf();
}
#[doc = " @addtogroup ets_timer_apis\n @{"]
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    #[doc = "< timer linker"]
    pub timer_next: *mut _ETSTIMER_,
    #[doc = "< abstruct time when timer expire"]
    pub timer_expire: u32,
    #[doc = "< timer period, 0 means timer is not periodic repeated"]
    pub timer_period: u32,
    #[doc = "< timer handler"]
    pub timer_func: ETSTimerFunc,
    #[doc = "< timer handler argument"]
    pub timer_arg: *mut ::core::ffi::c_void,
}
impl Default for _ETSTIMER_ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ETSTimer = _ETSTIMER_;
extern "C" {
    #[doc = " @brief  Init ets timer, this timer range is 640 us to 429496 ms\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  None\n\n @return None"]
    pub fn ets_timer_init();
}
extern "C" {
    #[doc = " @brief  In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  None\n\n @return None"]
    pub fn ets_timer_deinit();
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  ETSTimer *timer : Timer struct pointer.\n\n @param  uint32_t tmout : Timer value in ms, range is 1 to 429496.\n\n @param  bool repeat : Timer is periodic repeated.\n\n @return None"]
    pub fn ets_timer_arm(timer: *mut ETSTimer, tmout: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  ETSTimer *timer : Timer struct pointer.\n\n @param  uint32_t tmout : Timer value in us, range is 1 to 429496729.\n\n @param  bool repeat : Timer is periodic repeated.\n\n @return None"]
    pub fn ets_timer_arm_us(ptimer: *mut ETSTimer, us: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Disarm an ets timer.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  ETSTimer *timer : Timer struct pointer.\n\n @return None"]
    pub fn ets_timer_disarm(timer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  Set timer callback and argument.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  ETSTimer *timer : Timer struct pointer.\n\n @param  ETSTimerFunc *pfunction : Timer callback.\n\n @param  void *parg : Timer callback argument.\n\n @return None"]
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief  Unset timer callback and argument to NULL.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  ETSTimer *timer : Timer struct pointer.\n\n @return None"]
    pub fn ets_timer_done(ptimer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  CPU do while loop for some time.\n         In FreeRTOS task, please call FreeRTOS apis.\n\n @param  uint32_t us : Delay time in us.\n\n @return None"]
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate.\n         Call this function when CPU frequency is changed.\n\n @param  uint32_t ticks_per_us : CPU ticks per us.\n\n @return None"]
    pub fn ets_update_cpu_frequency(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate.\n\n @note This function only sets the tick rate for the current CPU. It is located in ROM,\n       so the deep sleep stub can use it even if IRAM is not initialized yet.\n\n @param  uint32_t ticks_per_us : CPU ticks per us.\n\n @return None"]
    pub fn ets_update_cpu_frequency_rom(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Get the real CPU ticks per us to the ets.\n         This function do not return real CPU ticks per us, just the record in ets. It can be used to check with the real CPU frequency.\n\n @param  None\n\n @return uint32_t : CPU ticks per us record in ets."]
    pub fn ets_get_cpu_frequency() -> u32;
}
extern "C" {
    #[doc = " @brief  Get xtal_freq value, If value not stored in RTC_STORE5, than store.\n\n @param  None\n\n @return uint32_t : if stored in efuse(not 0)\n                         clock = ets_efuse_get_xtal_freq() * 1000000;\n                    else if analog_8M in efuse\n                         clock = ets_get_xtal_scale() * 625 / 16 * ets_efuse_get_8M_clock();\n                    else clock = 40M."]
    pub fn ets_get_xtal_freq() -> u32;
}
extern "C" {
    #[doc = " @brief  Get the apb divior by xtal frequency.\n         When any types of reset happen, the default value is 2.\n\n @param  None\n\n @return uint32_t : 1 or 2."]
    pub fn ets_get_xtal_div() -> u32;
}
extern "C" {
    #[doc = " @brief  Get apb_freq value, If value not stored in RTC_STORE5, than store.\n\n @param  None\n\n @return uint32_t : if rtc store the value (RTC_STORE5 high 16 bits and low 16 bits with same value), read from rtc register.\n                         clock = (REG_READ(RTC_STORE5) & 0xffff) << 12;\n                    else store ets_get_detected_xtal_freq() in."]
    pub fn ets_get_apb_freq() -> u32;
}
#[doc = " @addtogroup ets_intr_apis\n @{"]
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief  Attach a interrupt handler to a CPU interrupt number.\n         This function equals to _xtos_set_interrupt_handler_arg(i, func, arg).\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  int i : CPU interrupt number.\n\n @param  ets_isr_t func : Interrupt handler.\n\n @param  void *arg : argument of the handler.\n\n @return None"]
    pub fn ets_isr_attach(i: ::core::ffi::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief  Mask the interrupts which show in mask bits.\n         This function equals to _xtos_ints_off(mask).\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  uint32_t mask : BIT(i) means mask CPU interrupt number i.\n\n @return None"]
    pub fn ets_isr_mask(mask: u32);
}
extern "C" {
    #[doc = " @brief  Unmask the interrupts which show in mask bits.\n         This function equals to _xtos_ints_on(mask).\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  uint32_t mask : BIT(i) means mask CPU interrupt number i.\n\n @return None"]
    pub fn ets_isr_unmask(unmask: u32);
}
extern "C" {
    #[doc = " @brief  Lock the interrupt to level 2.\n         This function direct set the CPU registers.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  None\n\n @return None"]
    pub fn ets_intr_lock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0.\n         This function direct set the CPU registers.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  None\n\n @return None"]
    pub fn ets_intr_unlock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0, and CPU will go into power save mode(wait interrupt).\n         This function direct set the CPU registers.\n         In FreeRTOS, please call FreeRTOS apis, never call this api.\n\n @param  None\n\n @return None"]
    pub fn ets_waiti0();
}
extern "C" {
    #[doc = " @brief  Attach an CPU interrupt to a hardware source.\n         We have 4 steps to use an interrupt:\n         1.Attach hardware interrupt source to CPU.  intr_matrix_set(0, ETS_WIFI_MAC_INTR_SOURCE, ETS_WMAC_INUM);\n         2.Set interrupt handler.                    xt_set_interrupt_handler(ETS_WMAC_INUM, func, NULL);\n         3.Enable interrupt for CPU.                 xt_ints_on(1 << ETS_WMAC_INUM);\n         4.Enable interrupt in the module.\n\n @param  int cpu_no : The CPU which the interrupt number belongs.\n\n @param  uint32_t model_num : The interrupt hardware source number, please see the interrupt hardware source table.\n\n @param  uint32_t intr_num : The interrupt number CPU, please see the interrupt cpu using table.\n\n @return None"]
    pub fn intr_matrix_set(cpu_no: ::core::ffi::c_int, model_num: u32, intr_num: u32);
}
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::core::ffi::c_uint;
pub const SHA_TYPE_SHA1: SHA_TYPE = 0;
pub const SHA_TYPE_SHA2_224: SHA_TYPE = 1;
pub const SHA_TYPE_SHA2_256: SHA_TYPE = 2;
pub const SHA_TYPE_SHA_TYPE_MAX: SHA_TYPE = 3;
pub type SHA_TYPE = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAContext {
    pub start: bool,
    pub in_hardware: bool,
    pub type_: SHA_TYPE,
    pub state: [u32; 16usize],
    pub buffer: [::core::ffi::c_uchar; 128usize],
    pub total_bits: [u32; 4usize],
}
impl Default for SHAContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SHA_CTX = SHAContext;
extern "C" {
    pub fn ets_sha_enable();
}
extern "C" {
    pub fn ets_sha_disable();
}
extern "C" {
    pub fn ets_sha_init(ctx: *mut SHA_CTX, type_: SHA_TYPE) -> ets_status_t;
}
extern "C" {
    pub fn ets_sha_starts(ctx: *mut SHA_CTX, sha512_t: u16) -> ets_status_t;
}
extern "C" {
    pub fn ets_sha_get_state(ctx: *mut SHA_CTX);
}
extern "C" {
    pub fn ets_sha_process(ctx: *mut SHA_CTX, input: *const ::core::ffi::c_uchar);
}
extern "C" {
    pub fn ets_sha_update(
        ctx: *mut SHA_CTX,
        input: *const ::core::ffi::c_uchar,
        input_bytes: u32,
        update_ctx: bool,
    );
}
extern "C" {
    pub fn ets_sha_finish(ctx: *mut SHA_CTX, output: *mut ::core::ffi::c_uchar) -> ets_status_t;
}
pub use self::SHA_TYPE as esp_sha_type;
pub const esp_sha1_state_ESP_SHA1_STATE_INIT: esp_sha1_state = 0;
pub const esp_sha1_state_ESP_SHA1_STATE_IN_PROCESS: esp_sha1_state = 1;
pub type esp_sha1_state = ::core::ffi::c_uint;
#[doc = " \\brief          SHA-1 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha1_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 5usize],
    #[doc = "< data block being processed"]
    pub buffer: [::core::ffi::c_uchar; 64usize],
    #[doc = "< if first then true else false"]
    pub first_block: ::core::ffi::c_int,
    pub mode: esp_sha_type,
    pub sha_state: esp_sha1_state,
}
impl Default for mbedtls_sha1_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize.\n                 This must not be \\c NULL.\n"]
    pub fn mbedtls_sha1_init(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it is\n                 not \\c NULL, it must point to an initialized\n                 SHA-1 context.\n"]
    pub fn mbedtls_sha1_free(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param dst      The SHA-1 context to clone to. This must be initialized.\n \\param src      The SHA-1 context to clone from. This must be initialized.\n"]
    pub fn mbedtls_sha1_clone(dst: *mut mbedtls_sha1_context, src: *const mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-1 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize. This must be initialized.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_sha1_starts(ctx: *mut mbedtls_sha1_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1\n                 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_update(
        ctx: *mut mbedtls_sha1_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-1 operation, and writes\n                 the result to the output buffer.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized and\n                 have a hash operation started.\n \\param output   The SHA-1 checksum result. This must be a writable\n                 buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_finish(
        ctx: *mut mbedtls_sha1_context,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          SHA-1 process data block (internal use only).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized.\n \\param data     The data block being processed. This must be a\n                 readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_internal_sha1_process(
        ctx: *mut mbedtls_sha1_context,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-1 result is calculated as\n                 output = SHA-1(input buffer).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n \\param output   The SHA-1 checksum result.\n                 This must be a writable buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_sha1(
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-1 checkup routine.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure.\n"]
    pub fn mbedtls_sha1_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub const esp_sha256_state_ESP_SHA256_STATE_INIT: esp_sha256_state = 0;
pub const esp_sha256_state_ESP_SHA256_STATE_IN_PROCESS: esp_sha256_state = 1;
pub type esp_sha256_state = ::core::ffi::c_uint;
#[doc = " \\brief          SHA-256 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha256_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 8usize],
    #[doc = "< data block being processed"]
    pub buffer: [::core::ffi::c_uchar; 64usize],
    #[doc = "< if first then true, else false"]
    pub first_block: ::core::ffi::c_int,
    pub mode: esp_sha_type,
    pub sha_state: esp_sha256_state,
}
impl Default for mbedtls_sha256_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-256 context.\n\n \\param ctx      The SHA-256 context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_sha256_init(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-256 context.\n\n \\param ctx      The SHA-256 context to clear. This may be \\c NULL, in which\n                 case this function returns immediately. If it is not \\c NULL,\n                 it must point to an initialized SHA-256 context."]
    pub fn mbedtls_sha256_free(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-256 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha256_clone(
        dst: *mut mbedtls_sha256_context,
        src: *const mbedtls_sha256_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum\n                 calculation.\n\n \\param ctx      The context to use. This must be initialized.\n \\param is224    This determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_starts(
        ctx: *mut mbedtls_sha256_context,
        is224: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-256 checksum calculation.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_update(
        ctx: *mut mbedtls_sha256_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-256 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_finish(
        ctx: *mut mbedtls_sha256_context,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-256 computation. This function is for\n                 internal use only.\n\n \\param ctx      The SHA-256 context. This must be initialized.\n \\param data     The buffer holding one block of data. This must\n                 be a readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha256_process(
        ctx: *mut mbedtls_sha256_context,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-224 or SHA-256\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-256 result is calculated as\n                 output = SHA-256(input buffer).\n\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n \\param is224    Determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256(
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        is224: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-224 and SHA-256 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha256_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[doc = " \\brief          The SHA-512 context structure.\n\n                 The structure is used both for SHA-384 and for SHA-512\n                 checksum calculations. The choice between these two is\n                 made in the call to mbedtls_sha512_starts()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha512_context {
    pub private_total: [u64; 2usize],
    pub private_state: [u64; 8usize],
    pub private_buffer: [::core::ffi::c_uchar; 128usize],
    pub private_is384: ::core::ffi::c_int,
}
impl Default for mbedtls_sha512_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-512 context.\n\n \\param ctx      The SHA-512 context to initialize. This must\n                 not be \\c NULL."]
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-512 context.\n\n \\param ctx      The SHA-512 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it\n                 is not \\c NULL, it must point to an initialized\n                 SHA-512 context."]
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-512 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha512_clone(
        dst: *mut mbedtls_sha512_context,
        src: *const mbedtls_sha512_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum\n                 calculation.\n\n \\param ctx      The SHA-512 context to use. This must be initialized.\n \\param is384    Determines which function to use. This must be\n                 either \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           When \\c MBEDTLS_SHA384_C is not defined,\n                 \\p is384 must be \\c 0, or the function will return\n                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_starts(
        ctx: *mut mbedtls_sha512_context,
        is384: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-512 checksum calculation.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data. This must\n                 be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_update(
        ctx: *mut mbedtls_sha512_context,
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_finish(
        ctx: *mut mbedtls_sha512_context,
        output: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-512 computation.\n                 This function is for internal use only.\n\n \\param ctx      The SHA-512 context. This must be initialized.\n \\param data     The buffer holding one block of data. This\n                 must be a readable buffer of length \\c 128 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha512_process(
        ctx: *mut mbedtls_sha512_context,
        data: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-512 result is calculated as\n                 output = SHA-512(input buffer).\n\n \\param input    The buffer holding the input data. This must be\n                 a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n \\param is384    Determines which function to use. This must be either\n                 \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           When \\c MBEDTLS_SHA384_C is not defined, \\p is384 must\n                 be \\c 0, or the function will return\n                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512(
        input: *const ::core::ffi::c_uchar,
        ilen: usize,
        output: *mut ::core::ffi::c_uchar,
        is384: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-384 or SHA-512 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha512_self_test(verbose: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    pub dummy: ::core::ffi::c_uint,
    pub md5: mbedtls_md5_context,
    pub sha1: mbedtls_sha1_context,
    pub sha256: mbedtls_sha256_context,
    pub sha512: mbedtls_sha512_context,
}
impl Default for mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_psa_hash_operation_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_iv_length: u8,
    pub private_block_length: u8,
    pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    pub private_dummy: ::core::ffi::c_uint,
    pub private_cipher: mbedtls_cipher_context_t,
}
impl Default for mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_psa_cipher_operation_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
impl Default for psa_driver_hash_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
impl Default for psa_driver_cipher_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_ctx: psa_driver_hash_context_t,
}
impl Default for psa_hash_operation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_default_iv_length: u8,
    pub private_ctx: psa_driver_cipher_context_t,
}
impl Default for psa_cipher_operation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl psa_cipher_operation_s {
    #[inline]
    pub fn private_iv_required(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_required(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_iv_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_iv_required: ::core::ffi::c_uint,
        private_iv_set: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_iv_required: u32 = unsafe { ::core::mem::transmute(private_iv_required) };
            private_iv_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_iv_set: u32 = unsafe { ::core::mem::transmute(private_iv_set) };
            private_iv_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
    pub private_alg: psa_algorithm_t,
    #[doc = " The hash context."]
    pub hash_ctx: psa_hash_operation_s,
    pub private_opad: [u8; 128usize],
}
impl Default for mbedtls_psa_hmac_operation_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    pub private_dummy: ::core::ffi::c_uint,
    pub private_hmac: mbedtls_psa_hmac_operation_t,
    pub private_cmac: mbedtls_cipher_context_t,
}
impl Default for mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_psa_mac_operation_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_tag_length: u8,
    pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    pub dummy: ::core::ffi::c_uint,
    pub private_ccm: mbedtls_ccm_context,
    pub private_gcm: mbedtls_gcm_context,
}
impl Default for mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_psa_aead_operation_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl mbedtls_psa_aead_operation_t {
    #[inline]
    pub fn private_is_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_encrypt: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
impl Default for psa_driver_mac_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
impl Default for psa_driver_aead_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_mac_size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_mac_context_t,
}
impl Default for psa_mac_operation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl psa_mac_operation_s {
    #[inline]
    pub fn private_is_sign(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_sign(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_sign: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_sign: u32 = unsafe { ::core::mem::transmute(private_is_sign) };
            private_is_sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub private_ad_remaining: usize,
    pub private_body_remaining: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_aead_context_t,
}
impl Default for psa_aead_operation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl psa_aead_operation_s {
    #[inline]
    pub fn private_nonce_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_nonce_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_lengths_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_lengths_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_ad_started(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_ad_started(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_body_started(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_body_started(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_is_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_nonce_set: ::core::ffi::c_uint,
        private_lengths_set: ::core::ffi::c_uint,
        private_ad_started: ::core::ffi::c_uint,
        private_body_started: ::core::ffi::c_uint,
        private_is_encrypt: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_nonce_set: u32 = unsafe { ::core::mem::transmute(private_nonce_set) };
            private_nonce_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_lengths_set: u32 = unsafe { ::core::mem::transmute(private_lengths_set) };
            private_lengths_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_ad_started: u32 = unsafe { ::core::mem::transmute(private_ad_started) };
            private_ad_started as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let private_body_started: u32 = unsafe { ::core::mem::transmute(private_body_started) };
            private_body_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
    pub private_data: [u8; 32usize],
}
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_INIT:
    psa_tls12_prf_key_derivation_state_t = 0;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_SEED_SET:
    psa_tls12_prf_key_derivation_state_t = 1;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OTHER_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 2;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 3;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_LABEL_SET:
    psa_tls12_prf_key_derivation_state_t = 4;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OUTPUT:
    psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
    pub private_left_in_block: u8,
    pub private_block_number: u8,
    pub private_state: psa_tls12_prf_key_derivation_state_t,
    pub private_secret: *mut u8,
    pub private_secret_length: usize,
    pub private_seed: *mut u8,
    pub private_seed_length: usize,
    pub private_label: *mut u8,
    pub private_label_length: usize,
    pub private_other_secret: *mut u8,
    pub private_other_secret_length: usize,
    pub private_Ai: [u8; 64usize],
    pub private_output_block: [u8; 64usize],
}
impl Default for psa_tls12_prf_key_derivation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
    pub private_alg: psa_algorithm_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_capacity: usize,
    pub private_ctx: psa_key_derivation_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_key_derivation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
    pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
impl Default for psa_key_derivation_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for psa_key_derivation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl psa_key_derivation_s {
    #[inline]
    pub fn private_can_output_key(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_can_output_key(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_can_output_key: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_can_output_key: u32 =
                unsafe { ::core::mem::transmute(private_can_output_key) };
            private_can_output_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct psa_key_policy_s {
    pub private_usage: psa_key_usage_t,
    pub private_alg: psa_algorithm_t,
    pub private_alg2: psa_algorithm_t,
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
#[doc = " A mask of flags that can be stored in key attributes.\n\n This type is also used internally to store flags in slots. Internal\n flags are defined in library/psa_crypto_core.h. Internal flags may have\n the same value as external flags if they are properly handled during\n key creation and in psa_get_key_attributes."]
pub type psa_key_attributes_flag_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct psa_core_key_attributes_t {
    pub private_type: psa_key_type_t,
    pub private_bits: psa_key_bits_t,
    pub private_lifetime: psa_key_lifetime_t,
    pub private_id: mbedtls_svc_key_id_t,
    pub private_policy: psa_key_policy_t,
    pub private_flags: psa_key_attributes_flag_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_attributes_s {
    pub private_core: psa_core_key_attributes_t,
    pub private_domain_parameters: *mut ::core::ffi::c_void,
    pub private_domain_parameters_size: usize,
}
impl Default for psa_key_attributes_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief Set domain parameters for a key.\n\n Some key types require additional domain parameters in addition to\n the key type identifier and the key size. Use this function instead\n of psa_set_key_type() when you need to specify domain parameters.\n\n The format for the required domain parameters varies based on the key type.\n\n - For RSA keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY or #PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the domain parameter data consists of the public exponent,\n   represented as a big-endian integer with no leading zeros.\n   This information is used when generating an RSA key pair.\n   When importing a key, the public exponent is read from the imported\n   key data and the exponent recorded in the attribute structure is ignored.\n   As an exception, the public exponent 65537 is represented by an empty\n   byte string.\n - For DSA keys (#PSA_KEY_TYPE_DSA_PUBLIC_KEY or #PSA_KEY_TYPE_DSA_KEY_PAIR),\n   the `Dss-Params` format as defined by RFC 3279 &sect;2.3.2.\n   ```\n   Dss-Params ::= SEQUENCE  {\n      p       INTEGER,\n      q       INTEGER,\n      g       INTEGER\n   }\n   ```\n - For Diffie-Hellman key exchange keys\n   (#PSA_KEY_TYPE_DH_PUBLIC_KEY(#PSA_DH_FAMILY_CUSTOM) or\n   #PSA_KEY_TYPE_DH_KEY_PAIR(#PSA_DH_FAMILY_CUSTOM)), the\n   `DomainParameters` format as defined by RFC 3279 &sect;2.3.3.\n   ```\n   DomainParameters ::= SEQUENCE {\n      p               INTEGER,                    -- odd prime, p=jq +1\n      g               INTEGER,                    -- generator, g\n      q               INTEGER,                    -- factor of p-1\n      j               INTEGER OPTIONAL,           -- subgroup factor\n      validationParams ValidationParams OPTIONAL\n   }\n   ValidationParams ::= SEQUENCE {\n      seed            BIT STRING,\n      pgenCounter     INTEGER\n   }\n   ```\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in,out] attributes    Attribute structure where the specified domain\n                              parameters will be stored.\n                              If this function fails, the content of\n                              \\p attributes is not modified.\n \\param type                  Key type (a \\c PSA_KEY_TYPE_XXX value).\n \\param[in] data              Buffer containing the key domain parameters.\n                              The content of this buffer is interpreted\n                              according to \\p type as described above.\n \\param data_length           Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n \\retval #PSA_ERROR_NOT_SUPPORTED\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY"]
    pub fn psa_set_key_domain_parameters(
        attributes: *mut psa_key_attributes_t,
        type_: psa_key_type_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
extern "C" {
    #[doc = " Open a handle to an existing persistent key.\n\n Open a handle to a persistent key. A key is persistent if it was created\n with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key\n always has a nonzero key identifier, set with psa_set_key_id() when\n creating the key. Implementations may provide additional pre-provisioned\n keys that can be opened with psa_open_key(). Such keys have an application\n key identifier in the vendor range, as documented in the description of\n #psa_key_id_t.\n\n The application must eventually close the handle with psa_close_key() or\n psa_destroy_key() to release associated resources. If the application dies\n without calling one of these functions, the implementation should perform\n the equivalent of a call to psa_close_key().\n\n Some implementations permit an application to open the same key multiple\n times. If this is successful, each call to psa_open_key() will return a\n different key handle.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note Applications that rely on opening a key multiple times will not be\n portable to implementations that only permit a single key handle to be\n opened. See also :ref:\\`key-handles\\`.\n\n\n \\param key           The persistent identifier of the key.\n \\param[out] handle   On success, a handle to the key.\n\n \\retval #PSA_SUCCESS\n         Success. The application can now use the value of `*handle`\n         to access the key.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n         The implementation does not have sufficient resources to open the\n         key. This can be due to reaching an implementation limit on the\n         number of open keys, the number of open key handles, or available\n         memory.\n \\retval #PSA_ERROR_DOES_NOT_EXIST\n         There is no persistent key with key identifier \\p key.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid persistent key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The specified key exists, but the application does not have the\n         permission to access it. Note that this specification does not\n         define any way to create such a key, but it may be possible\n         through implementation-specific means.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_open_key(key: mbedtls_svc_key_id_t, handle: *mut psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Close a key handle.\n\n If the handle designates a volatile key, this will destroy the key material\n and free all associated resources, just like psa_destroy_key().\n\n If this is the last open handle to a persistent key, then closing the handle\n will free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and can be opened again later\n with a call to psa_open_key().\n\n Closing the key handle makes the handle invalid, and the key handle\n must not be used again by the application.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note If the key handle was used to set up an active\n :ref:\\`multipart operation <multipart-operations>\\`, then closing the\n key handle can cause the multipart operation to fail. Applications should\n maintain the key handle until after the multipart operation has finished.\n\n \\param handle        The key handle to close.\n                      If this is \\c 0, do nothing and return \\c PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p handle was a valid handle or \\c 0. It is now closed.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p handle is not a valid handle nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_close_key(handle: psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Library deinitialization.\n\n This function clears all data associated with the PSA layer,\n including the whole key store.\n\n This is an Mbed TLS extension."]
    pub fn mbedtls_psa_crypto_free();
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed Crypto and may change arbitrarily from version to version."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_psa_stats_s {
    pub private_volatile_slots: usize,
    pub private_persistent_slots: usize,
    pub private_external_slots: usize,
    pub private_half_filled_slots: usize,
    pub private_cache_slots: usize,
    pub private_empty_slots: usize,
    pub private_locked_slots: usize,
    pub private_max_open_internal_key_id: psa_key_id_t,
    pub private_max_open_external_key_id: psa_key_id_t,
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed Crypto and may change arbitrarily from version to version."]
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
extern "C" {
    #[doc = " \\brief Get statistics about\n resource consumption related to the PSA keystore.\n\n \\note When Mbed Crypto is built as part of a service, with isolation\n       between the application and the keystore, the service may or\n       may not expose this function."]
    pub fn mbedtls_psa_get_stats(stats: *mut mbedtls_psa_stats_t);
}
extern "C" {
    #[doc = " \\brief Inject an initial entropy seed for the random generator into\n        secure storage.\n\n This function injects data to be used as a seed for the random generator\n used by the PSA Crypto implementation. On devices that lack a trusted\n entropy source (preferably a hardware random number generator),\n the Mbed PSA Crypto implementation uses this value to seed its\n random generator.\n\n On devices without a trusted entropy source, this function must be\n called exactly once in the lifetime of the device. On devices with\n a trusted entropy source, calling this function is optional.\n In all cases, this function may only be called before calling any\n other function in the PSA Crypto API, including psa_crypto_init().\n\n When this function returns successfully, it populates a file in\n persistent storage. Once the file has been created, this function\n can no longer succeed.\n\n If any error occurs, this function does not change the system state.\n You can call this function again after correcting the reason for the\n error if possible.\n\n \\warning This function **can** fail! Callers MUST check the return status.\n\n \\warning If you use this function, you should use it as part of a\n          factory provisioning process. The value of the injected seed\n          is critical to the security of the device. It must be\n          *secret*, *unpredictable* and (statistically) *unique per device*.\n          You should be generate it randomly using a cryptographically\n          secure random generator seeded from trusted entropy sources.\n          You should transmit it securely to the device and ensure\n          that its value is not leaked or stored anywhere beyond the\n          needs of transmitting it from the point of generation to\n          the call of this function, and erase all copies of the value\n          once this function returns.\n\n This is an Mbed TLS extension.\n\n \\note This function is only available on the following platforms:\n * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled.\n   Note that you must provide compatible implementations of\n   mbedtls_nv_seed_read and mbedtls_nv_seed_write.\n * In a client-server integration of PSA Cryptography, on the client side,\n   if the server supports this feature.\n \\param[in] seed          Buffer containing the seed value to inject.\n \\param[in] seed_size     Size of the \\p seed buffer.\n                          The size of the seed in bytes must be greater\n                          or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE\n                          and the value of \\c MBEDTLS_ENTROPY_MIN_PLATFORM\n                          in `library/entropy_poll.h` in the Mbed TLS source\n                          code.\n                          It must be less or equal to\n                          #MBEDTLS_ENTROPY_MAX_SEED_SIZE.\n\n \\retval #PSA_SUCCESS\n         The seed value was injected successfully. The random generator\n         of the PSA Crypto implementation is now ready for use.\n         You may now call psa_crypto_init() and use the PSA Crypto\n         implementation.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p seed_size is out of range.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         There was a failure reading or writing from storage.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The library has already been initialized. It is no longer\n         possible to call this function."]
    pub fn mbedtls_psa_inject_entropy(seed: *const u8, seed_size: usize) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Get domain parameters for a key.\n\n Get the domain parameters for a key with this function, if any. The format\n of the domain parameters written to \\p data is specified in the\n documentation for psa_set_key_domain_parameters().\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in] attributes        The key attribute structure to query.\n \\param[out] data             On success, the key domain parameters.\n \\param data_size             Size of the \\p data buffer in bytes.\n                              The buffer is guaranteed to be large\n                              enough if its size in bytes is at least\n                              the value given by\n                              PSA_KEY_DOMAIN_PARAMETERS_SIZE().\n \\param[out] data_length      On success, the number of bytes\n                              that make up the key domain parameters data.\n\n \\retval #PSA_SUCCESS\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL"]
    pub fn psa_get_key_domain_parameters(
        attributes: *const psa_key_attributes_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Convert an ECC curve identifier from the PSA encoding to Mbed TLS.\n\n \\note This function is provided solely for the convenience of\n       Mbed TLS and may be removed at any time without notice.\n\n \\param curve         A PSA elliptic curve identifier\n                      (`PSA_ECC_FAMILY_xxx`).\n \\param bits          The bit-length of a private key on \\p curve.\n \\param bits_is_sloppy If true, \\p bits may be the bit-length rounded up\n                      to the nearest multiple of 8. This allows the caller\n                      to infer the exact curve from the length of a key\n                      which is supplied as a byte string.\n\n \\return              The corresponding Mbed TLS elliptic curve identifier\n                      (`MBEDTLS_ECP_DP_xxx`).\n \\return              #MBEDTLS_ECP_DP_NONE if \\c curve is not recognized.\n \\return              #MBEDTLS_ECP_DP_NONE if \\p bits is not\n                      correct for \\p curve."]
    pub fn mbedtls_ecc_group_of_psa(
        curve: psa_ecc_family_t,
        bits: usize,
        bits_is_sloppy: ::core::ffi::c_int,
    ) -> mbedtls_ecp_group_id;
}
#[doc = " A slot number identifying a key in a driver.\n\n Values of this type are used to identify built-in keys."]
pub type psa_drv_slot_number_t = u64;
#[doc = " \\brief Encoding of the application role of PAKE\n\n Encodes the application's role in the algorithm is being executed. For more\n information see the documentation of individual \\c PSA_PAKE_ROLE_XXX\n constants."]
pub type psa_pake_role_t = u8;
#[doc = " Encoding of input and output indicators for PAKE.\n\n Some PAKE algorithms need to exchange more data than just a single key share.\n This type is for encoding additional input and output data for such\n algorithms."]
pub type psa_pake_step_t = u8;
#[doc = " Encoding of the type of the PAKE's primitive.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional types must use an encoding in this range.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_primitive_type_t = u8;
#[doc = " \\brief Encoding of the family of the primitive associated with the PAKE.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_family_t = u8;
#[doc = " \\brief Encoding of the primitive associated with the PAKE.\n\n For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro."]
pub type psa_pake_primitive_t = u32;
#[doc = " The type of the data structure for PAKE cipher suites.\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
#[doc = " The type of the state data structure for PAKE operations.\n\n Before calling any function on a PAKE operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_pake_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_pake_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,\n   for example:\n   \\code\n   psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_pake_operation_init()\n   to the structure, for example:\n   \\code\n   psa_pake_operation_t operation;\n   operation = psa_pake_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_operation_t = psa_pake_operation_s;
extern "C" {
    #[doc = " Set the session information for a password-authenticated key exchange.\n\n The sequence of operations to set up a password-authenticated key exchange\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_pake_operation_t, e.g.\n    #PSA_PAKE_OPERATION_INIT.\n -# Call psa_pake_setup() to specify the cipher suite.\n -# Call \\c psa_pake_set_xxx() functions on the operation to complete the\n    setup. The exact sequence of \\c psa_pake_set_xxx() functions that needs\n    to be called depends on the algorithm in use.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n A typical sequence of calls to perform a password-authenticated key\n exchange:\n -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the\n    key share that needs to be sent to the peer.\n -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide\n    the key share that was received from the peer.\n -# Depending on the algorithm additional calls to psa_pake_output() and\n    psa_pake_input() might be necessary.\n -# Call psa_pake_get_implicit_key() for accessing the shared secret.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n If an error occurs at any step after a call to psa_pake_setup(),\n the operation will need to be reset by a call to psa_pake_abort(). The\n application may call psa_pake_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_pake_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A call to psa_pake_abort().\n - A successful call to psa_pake_get_implicit_key().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized but not set up yet.\n \\param[in] cipher_suite      The cipher suite to use. (A cipher suite fully\n                              characterizes a PAKE algorithm and determines\n                              the algorithm as well.)\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The algorithm in \\p cipher_suite is not a PAKE algorithm, or the\n         PAKE primitive in \\p cipher_suite is not compatible with the\n         PAKE algorithm, or the hash algorithm in \\p cipher_suite is invalid\n         or not compatible with the PAKE algorithm and primitive.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm in \\p cipher_suite is not a supported PAKE algorithm,\n         or the PAKE primitive in \\p cipher_suite is not supported or not\n         compatible with the PAKE algorithm, or the hash algorithm in\n         \\p cipher_suite is not supported or not compatible with the PAKE\n         algorithm and primitive.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_setup(
        operation: *mut psa_pake_operation_t,
        cipher_suite: *const psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the password for a password-authenticated key exchange from key ID.\n\n Call this function when the password, or a value derived from the password,\n is already present in the key store.\n\n \\param[in,out] operation     The operation object to set the password for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the password hasn't\n                              been set yet (psa_pake_set_password_key()\n                              hasn't been called yet).\n \\param password              Identifier of the key holding the password or a\n                              value derived from the password (eg. by a\n                              memory-hard function).  It must remain valid\n                              until the operation terminates. It must be of\n                              type #PSA_KEY_TYPE_PASSWORD or\n                              #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow\n                              the usage #PSA_KEY_USAGE_DERIVE.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p password is not a valid key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not\n         permit the \\p operation's algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key type for \\p password is not #PSA_KEY_TYPE_PASSWORD or\n         #PSA_KEY_TYPE_PASSWORD_HASH, or \\p password is not compatible with\n         the \\p operation's cipher suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size of \\p password is not supported with the\n         \\p operation's cipher suite.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must have been set up.), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_password_key(
        operation: *mut psa_pake_operation_t,
        password: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the user ID for a password-authenticated key exchange.\n\n Call this function to set the user ID. For PAKE algorithms that associate a\n user identifier with each side of the session you need to call\n psa_pake_set_peer() as well. For PAKE algorithms that associate a single\n user identifier with the session, call psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the user ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the user ID hasn't\n                              been set (psa_pake_set_user() hasn't been\n                              called yet).\n \\param[in] user_id           The user ID to authenticate with.\n \\param user_id_len           Size of the \\p user_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p user_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The value of \\p user_id is not supported by the implementation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_user(
        operation: *mut psa_pake_operation_t,
        user_id: *const u8,
        user_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the peer ID for a password-authenticated key exchange.\n\n Call this function in addition to psa_pake_set_user() for PAKE algorithms\n that associate a user identifier with each side of the session. For PAKE\n algorithms that associate a single user identifier with the session, call\n psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the peer ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the peer ID hasn't\n                              been set (psa_pake_set_peer() hasn't been\n                              called yet).\n \\param[in] peer_id           The peer's ID to authenticate.\n \\param peer_id_len           Size of the \\p peer_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p user_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm doesn't associate a second identity with the session.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         Calling psa_pake_set_peer() is invalid with the \\p operation's\n         algorithm, the operation state is not valid, or the library has not\n         been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_peer(
        operation: *mut psa_pake_operation_t,
        peer_id: *const u8,
        peer_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the application role for a password-authenticated key exchange.\n\n Not all PAKE algorithms need to differentiate the communicating entities.\n It is optional to call this function for PAKEs that don't require a role\n to be specified. For such PAKEs the application role parameter is ignored,\n or #PSA_PAKE_ROLE_NONE can be passed as \\c role.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to specify the\n                              application's role for. It must have been set up\n                              by psa_pake_setup() and not yet in use (neither\n                              psa_pake_output() nor psa_pake_input() has been\n                              called yet). It must be on operation for which\n                              the application's role hasn't been specified\n                              (psa_pake_set_role() hasn't been called yet).\n \\param role                  A value of type ::psa_pake_role_t indicating the\n                              application's role in the PAKE the algorithm\n                              that is being set up. For more information see\n                              the documentation of \\c PSA_PAKE_ROLE_XXX\n                              constants.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The \\p role is not a valid PAKE role in the \\p operation’s algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The \\p role for this algorithm is not supported or is not valid.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_role(
        operation: *mut psa_pake_operation_t,
        role: psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get output for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step of the algorithm for which the output is\n                             requested.\n \\param[out] output          Buffer where the output is to be written in the\n                             format appropriate for this \\p step. Refer to\n                             the documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param output_size          Size of the \\p output buffer in bytes. This must\n                             be at least #PSA_PAKE_OUTPUT_SIZE(\\p alg, \\p\n                             primitive, \\p step) where \\p alg and\n                             \\p primitive are the PAKE algorithm and primitive\n                             in the operation's cipher suite, and \\p step is\n                             the output step.\n\n \\param[out] output_length   On success, the number of bytes of the returned\n                             output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p step is not compatible with the operation's algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step is not supported with the operation's algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_output(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide input for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step for which the input is provided.\n \\param[in] input            Buffer containing the input in the format\n                             appropriate for this \\p step. Refer to the\n                             documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param input_length         Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p is not compatible with the \\p operation’s algorithm, or the\n         \\p input is not valid for the \\p operation's algorithm, cipher suite\n         or \\p step.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step p is not supported with the \\p operation's algorithm, or the\n         \\p input is not supported for the \\p operation's algorithm, cipher\n         suite or \\p step.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_input(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get implicitly confirmed shared secret from a PAKE.\n\n At this point there is a cryptographic guarantee that only the authenticated\n party who used the same password is able to compute the key. But there is no\n guarantee that the peer is the party it claims to be and was able to do so.\n\n That is, the authentication is only implicit. Since the peer is not\n authenticated yet, no action should be taken yet that assumes that the peer\n is who it claims to be. For example, do not access restricted files on the\n peer's behalf until an explicit authentication has succeeded.\n\n This function can be called after the key exchange phase of the operation\n has completed. It imports the shared secret output of the PAKE into the\n provided derivation operation. The input step\n #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key\n material in the key derivation operation.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n When this function returns successfully, \\p operation becomes inactive.\n If this function returns an error status, both \\p operation\n and \\p key_derivation operations enter an error state and must be aborted by\n calling psa_pake_abort() and psa_key_derivation_abort() respectively.\n\n \\param[in,out] operation    Active PAKE operation.\n \\param[out] output          A key derivation operation that is ready\n                             for an input step of type\n                             #PSA_KEY_DERIVATION_INPUT_SECRET.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the\n         algorithm in the \\p output key derivation operation.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         Input from a PAKE is not supported by the algorithm in the \\p output\n         key derivation operation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_STORAGE_FAILURE\n \\retval #PSA_ERROR_DATA_CORRUPT\n \\retval #PSA_ERROR_DATA_INVALID\n \\retval #PSA_ERROR_BAD_STATE\n         The PAKE operation state is not valid (it must be active, but beyond\n         that validity is specific to the algorithm), or\n         the library has not been previously initialized by psa_crypto_init(),\n         or the state of \\p output is not valid for\n         the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the\n         step is out of order or the application has done this step already\n         and it may not be repeated.\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_get_implicit_key(
        operation: *mut psa_pake_operation_t,
        output: *mut psa_key_derivation_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a PAKE operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_pake_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_pake_operation_t.\n\n In particular, calling psa_pake_abort() after the operation has been\n terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()\n is safe and has no effect.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_abort(operation: *mut psa_pake_operation_t) -> psa_status_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
    pub algorithm: psa_algorithm_t,
    pub type_: psa_pake_primitive_type_t,
    pub family: psa_pake_family_t,
    pub bits: u16,
    pub hash: psa_algorithm_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
    pub private_alg: psa_algorithm_t,
    pub private_state: ::core::ffi::c_uint,
    pub private_sequence: ::core::ffi::c_uint,
    pub private_ctx: psa_pake_operation_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
    pub dummy: u8,
}
impl Default for psa_pake_operation_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for psa_pake_operation_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_buf {
    #[doc = "< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING."]
    pub tag: ::core::ffi::c_int,
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< ASN1 data, e.g. in ASCII."]
    pub p: *mut ::core::ffi::c_uchar,
}
impl Default for mbedtls_asn1_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Container for ASN1 bit strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< Number of unused bits at the end of the string"]
    pub unused_bits: ::core::ffi::c_uchar,
    #[doc = "< Raw ASN1 data for the bit string"]
    pub p: *mut ::core::ffi::c_uchar,
}
impl Default for mbedtls_asn1_bitstring {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Container for a sequence of ASN.1 items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    #[doc = "< Buffer containing the given ASN.1 item."]
    pub buf: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence.\n\n The details of memory management for sequences are not documented and\n may change in future versions. Set this field to \\p NULL when\n initializing a structure, and do not modify it except via Mbed TLS\n library functions."]
    pub next: *mut mbedtls_asn1_sequence,
}
impl Default for mbedtls_asn1_sequence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_asn1_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence.\n\n The details of memory management for named data sequences are not\n documented and may change in future versions. Set this field to \\p NULL\n when initializing a structure, and do not modify it except via Mbed TLS\n library functions."]
    pub next: *mut mbedtls_asn1_named_data,
    pub private_next_merged: ::core::ffi::c_uchar,
}
impl Default for mbedtls_asn1_named_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief       Get the length of an ASN.1 element.\n              Updates the pointer to immediately behind the length.\n\n \\param p     On entry, \\c *p points to the first byte of the length,\n              i.e. immediately after the tag.\n              On successful completion, \\c *p points to the first byte\n              after the length, i.e. the first byte of the content.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On successful completion, \\c *len contains the length\n              read from the ASN.1 input.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element\n              would end beyond \\p end.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        len: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Get the tag and length of the element.\n              Check for the requested tag.\n              Updates the pointer to immediately behind the tag and length.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              after the length, i.e. the first byte of the content.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On successful completion, \\c *len contains the length\n              read from the ASN.1 input.\n \\param tag   The expected tag.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start\n              with the requested tag.\n \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element\n              would end beyond \\p end.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        len: *mut usize,
        tag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a boolean ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value (\\c 0 or \\c 1).\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BOOLEAN."]
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        val: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 INTEGER.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        val: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an enumerated ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 ENUMERATED.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_enum(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        val: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p is equal to \\p end.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param bs    On success, ::mbedtls_asn1_bitstring information about\n              the parsed value.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains\n              extra data after a valid BIT STRING.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its\n              value.\n              Updates the pointer to the beginning of the bit/octet string.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              of the content of the BIT STRING.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On success, \\c *len is the length of the content in bytes.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with\n              a valid BIT STRING with a nonzero number of unused bits.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        len: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\".\n              Updates the pointer to immediately behind the full sequence tag.\n\n This function allocates memory for the sequence elements. You can free\n the allocated memory with mbedtls_asn1_sequence_free().\n\n \\note        On error, this function may return a partial list in \\p cur.\n              You must set `cur->next = NULL` before calling this function!\n              Otherwise it is impossible to distinguish a previously non-null\n              pointer from a pointer to an object allocated by this function.\n\n \\note        If the sequence is empty, this function does not modify\n              \\c *cur. If the sequence is valid and non-empty, this\n              function sets `cur->buf.tag` to \\p tag. This allows\n              callers to distinguish between an empty sequence and\n              a one-element sequence.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p is equal to \\p end.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param cur   A ::mbedtls_asn1_sequence which this function fills.\n              When this function returns, \\c *cur is the head of a linked\n              list. Each node in this list is allocated with\n              mbedtls_calloc() apart from \\p cur itself, and should\n              therefore be freed with mbedtls_free().\n              The list describes the content of the sequence.\n              The head of the list (i.e. \\c *cur itself) describes the\n              first element, `*cur->next` describes the second element, etc.\n              For each element, `buf.tag == tag`, `buf.len` is the length\n              of the content of the content of the element, and `buf.p`\n              points to the first byte of the content (i.e. immediately\n              past the length of the element).\n              Note that list elements may be allocated even on error.\n \\param tag   Each element of the sequence must have this tag.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains\n              extra data after a valid SEQUENCE OF \\p tag.\n \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with\n              an ASN.1 SEQUENCE in which an element has a tag that\n              is different from \\p tag.\n \\return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 SEQUENCE."]
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Free a heap-allocated linked list presentation of\n                 an ASN.1 sequence, including the first element.\n\n There are two common ways to manage the memory used for the representation\n of a parsed ASN.1 sequence:\n - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc().\n   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of().\n   When you have finished processing the sequence,\n   call mbedtls_asn1_sequence_free() on `head`.\n - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,\n   for example on the stack. Make sure that `head->next == NULL`.\n   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of().\n   When you have finished processing the sequence,\n   call mbedtls_asn1_sequence_free() on `head->cur`,\n   then free `head` itself in the appropriate manner.\n\n \\param seq      The address of the first sequence component. This may\n                 be \\c NULL, in which case this functions returns\n                 immediately."]
    pub fn mbedtls_asn1_sequence_free(seq: *mut mbedtls_asn1_sequence);
}
extern "C" {
    #[doc = " \\brief                Traverse an ASN.1 SEQUENCE container and\n                       call a callback for each entry.\n\n This function checks that the input is a SEQUENCE of elements that\n each have a \"must\" tag, and calls a callback function on the elements\n that have a \"may\" tag.\n\n For example, to validate that the input is a SEQUENCE of `tag1` and call\n `cb` on each element, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);\n ```\n\n To validate that the input is a SEQUENCE of ANY and call `cb` on\n each element, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);\n ```\n\n To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}\n and call `cb` on each element that is an OCTET STRING, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);\n ```\n\n The callback is called on the elements with a \"may\" tag from left to\n right. If the input is not a valid SEQUENCE of elements with a \"must\" tag,\n the callback is called on the elements up to the leftmost point where\n the input is invalid.\n\n \\warning              This function is still experimental and may change\n                       at any time.\n\n \\param p              The address of the pointer to the beginning of\n                       the ASN.1 SEQUENCE header. This is updated to\n                       point to the end of the ASN.1 SEQUENCE container\n                       on a successful invocation.\n \\param end            The end of the ASN.1 SEQUENCE container.\n \\param tag_must_mask  A mask to be applied to the ASN.1 tags found within\n                       the SEQUENCE before comparing to \\p tag_must_value.\n \\param tag_must_val   The required value of each ASN.1 tag found in the\n                       SEQUENCE, after masking with \\p tag_must_mask.\n                       Mismatching tags lead to an error.\n                       For example, a value of \\c 0 for both \\p tag_must_mask\n                       and \\p tag_must_val means that every tag is allowed,\n                       while a value of \\c 0xFF for \\p tag_must_mask means\n                       that \\p tag_must_val is the only allowed tag.\n \\param tag_may_mask   A mask to be applied to the ASN.1 tags found within\n                       the SEQUENCE before comparing to \\p tag_may_value.\n \\param tag_may_val    The desired value of each ASN.1 tag found in the\n                       SEQUENCE, after masking with \\p tag_may_mask.\n                       Mismatching tags will be silently ignored.\n                       For example, a value of \\c 0 for \\p tag_may_mask and\n                       \\p tag_may_val means that any tag will be considered,\n                       while a value of \\c 0xFF for \\p tag_may_mask means\n                       that all tags with value different from \\p tag_may_val\n                       will be ignored.\n \\param cb             The callback to trigger for each component\n                       in the ASN.1 SEQUENCE that matches \\p tag_may_val.\n                       The callback function is called with the following\n                       parameters:\n                       - \\p ctx.\n                       - The tag of the current element.\n                       - A pointer to the start of the current element's\n                         content inside the input.\n                       - The length of the content of the current element.\n                       If the callback returns a non-zero value,\n                       the function stops immediately,\n                       forwarding the callback's return value.\n \\param ctx            The context to be passed to the callback \\p cb.\n\n \\return               \\c 0 if successful the entire ASN.1 SEQUENCE\n                       was traversed without parsing or callback errors.\n \\return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input\n                       contains extra data after a valid SEQUENCE\n                       of elements with an accepted tag.\n \\return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts\n                       with an ASN.1 SEQUENCE in which an element has a tag\n                       that is not accepted.\n \\return               An ASN.1 error code if the input does not start with\n                       a valid ASN.1 SEQUENCE.\n \\return               A non-zero error code forwarded from the callback\n                       \\p cb in case the latter returns a non-zero value."]
    pub fn mbedtls_asn1_traverse_sequence_of(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        tag_must_mask: ::core::ffi::c_uchar,
        tag_must_val: ::core::ffi::c_uchar,
        tag_may_mask: ::core::ffi::c_uchar,
        tag_may_val: ::core::ffi::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut ::core::ffi::c_void,
                tag: ::core::ffi::c_int,
                start: *mut ::core::ffi::c_uchar,
                len: usize,
            ) -> ::core::ffi::c_int,
        >,
        ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param X     On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 INTEGER.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int.\n \\return      An MPI error code if the parsed value is too large."]
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.\n              Updates the pointer to immediately behind the full\n              AlgorithmIdentifier.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the AlgorithmIdentifier element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param alg   The buffer to receive the OID.\n \\param params The buffer to receive the parameters.\n              This is zeroized if there are no parameters.\n\n \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no\n              params.\n              Updates the pointer to immediately behind the full\n              AlgorithmIdentifier.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the AlgorithmIdentifier element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param alg   The buffer to receive the OID.\n\n \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       Find a specific named_data entry in a sequence or list based on\n              the OID.\n\n \\param list  The list to seek through\n \\param oid   The OID to look for\n \\param len   Size of the OID\n\n \\return      NULL if not found, or a pointer to the existing entry."]
    pub fn mbedtls_asn1_find_named_data(
        list: *const mbedtls_asn1_named_data,
        oid: *const ::core::ffi::c_char,
        len: usize,
    ) -> *const mbedtls_asn1_named_data;
}
extern "C" {
    #[doc = " \\brief       Free all entries in a mbedtls_asn1_named_data list.\n\n \\param head  Pointer to the head of the list of named data entries to free.\n              This function calls mbedtls_free() on\n              `entry->oid.p` and `entry->val.p` and then on `entry`\n              for each list entry, and sets \\c *head to \\c NULL."]
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all shallow entries in a mbedtls_asn1_named_data list,\n              but do not free internal pointer targets.\n\n \\param name  Head of the list of named data entries to free.\n              This function calls mbedtls_free() on each list element."]
    pub fn mbedtls_asn1_free_named_data_list_shallow(name: *mut mbedtls_asn1_named_data);
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
#[doc = " Container for ASN1 bit strings."]
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
#[doc = " Container for a sequence of ASN.1 items"]
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[doc = " Container for date and time (precision in seconds)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_x509_time {
    #[doc = "< Date."]
    pub year: ::core::ffi::c_int,
    #[doc = "< Date."]
    pub mon: ::core::ffi::c_int,
    #[doc = "< Date."]
    pub day: ::core::ffi::c_int,
    #[doc = "< Time."]
    pub hour: ::core::ffi::c_int,
    #[doc = "< Time."]
    pub min: ::core::ffi::c_int,
    #[doc = "< Time."]
    pub sec: ::core::ffi::c_int,
}
extern "C" {
    #[doc = " \\brief          Store the certificate DN in printable form into buf;\n                 no more than size characters will be written.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param dn       The X509 name to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_dn_gets(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        dn: *const mbedtls_x509_name,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Store the certificate serial in printable form into buf;\n                 no more than size characters will be written.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param serial   The X509 serial to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_serial_gets(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        serial: *const mbedtls_x509_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time\n                 and tell if it's in the past.\n\n \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\".\n                 Hence the return value of 1 if on internal errors.\n\n \\param to       mbedtls_x509_time to check\n\n \\return         1 if the given time is in the past or an error occurred,\n                 0 otherwise."]
    pub fn mbedtls_x509_time_is_past(to: *const mbedtls_x509_time) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time\n                 and tell if it's in the future.\n\n \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\".\n                 Hence the return value of 1 if on internal errors.\n\n \\param from     mbedtls_x509_time to check\n\n \\return         1 if the given time is in the future or an error occurred,\n                 0 otherwise."]
    pub fn mbedtls_x509_time_is_future(from: *const mbedtls_x509_time) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\} addtogroup x509_module"]
    pub fn mbedtls_x509_get_name(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_rsassa_pss_params(
        params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        mgf_md: *mut mbedtls_md_type_t,
        salt_len: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        t: *mut mbedtls_x509_time,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut ::core::ffi::c_char,
        buf_size: usize,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const ::core::ffi::c_char,
        oid_len: usize,
        critical: ::core::ffi::c_int,
        val: *const ::core::ffi::c_uchar,
        val_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut ::core::ffi::c_uchar,
        start: *mut ::core::ffi::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut ::core::ffi::c_uchar,
        start: *mut ::core::ffi::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut ::core::ffi::c_uchar,
        start: *mut ::core::ffi::c_uchar,
        oid: *const ::core::ffi::c_char,
        oid_len: usize,
        sig: *mut ::core::ffi::c_uchar,
        size: usize,
    ) -> ::core::ffi::c_int;
}
#[doc = " Certificate revocation list entry.\n Contains the CA-specific serial numbers and revocation dates.\n\n Some fields of this structure are publicly readable. Do not modify\n them except via Mbed TLS library functions: the effect of modifying\n those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    #[doc = " Direct access to the whole entry inside the containing buffer."]
    pub raw: mbedtls_x509_buf,
    #[doc = " The serial number of the revoked certificate."]
    pub serial: mbedtls_x509_buf,
    #[doc = " The revocation date of this entry."]
    pub revocation_date: mbedtls_x509_time,
    #[doc = " Direct access to the list of CRL entry extensions\n (an ASN.1 constructed sequence).\n\n If there are no extensions, `entry_ext.len == 0` and\n `entry_ext.p == NULL`."]
    pub entry_ext: mbedtls_x509_buf,
    #[doc = " Next element in the linked list of entries.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl_entry,
}
impl Default for mbedtls_x509_crl_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Certificate revocation list structure.\n Every CRL may have multiple entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< CRL version (1=v1, 2=v2)"]
    pub version: ::core::ffi::c_int,
    #[doc = "< CRL signature type identifier"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER)."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    #[doc = "< The CRL entries containing the certificate revocation times for this CA."]
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub private_sig_oid2: mbedtls_x509_buf,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut ::core::ffi::c_void,
    #[doc = " Next element in the linked list of CRL.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl,
}
impl Default for mbedtls_x509_crl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          Parse a DER-encoded CRL and append it to the chained list\n\n \\param chain    points to the start of the chain\n \\param buf      buffer holding the CRL data in DER format\n \\param buflen   size of the buffer\n                 (including the terminating null byte for PEM data)\n\n \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more CRLs and append them to the chained list\n\n \\note           Multiple CRLs are accepted only if using PEM format\n\n \\param chain    points to the start of the chain\n \\param buf      buffer holding the CRL data in PEM or DER format\n \\param buflen   size of the buffer\n                 (including the terminating null byte for PEM data)\n\n \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more CRLs and append them to the chained list\n\n \\note           Multiple CRLs are accepted only if using PEM format\n\n \\param chain    points to the start of the chain\n \\param path     filename to read the CRLs from (in PEM or DER encoding)\n\n \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_file(
        chain: *mut mbedtls_x509_crl,
        path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the CRL.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param crl      The X509 CRL to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crl_info(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        prefix: *const ::core::ffi::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CRL (chain)\n\n \\param crl      CRL chain to initialize"]
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CRL data\n\n \\param crl      CRL chain to free"]
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
#[doc = " Container for an X.509 certificate. The certificate may be chained.\n\n Some fields of this structure are publicly readable. Do not modify\n them except via Mbed TLS library functions: the effect of modifying\n those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt {
    pub private_own_buffer: ::core::ffi::c_int,
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< The X.509 version. (1=v1, 2=v2, 3=v3)"]
    pub version: ::core::ffi::c_int,
    #[doc = "< Unique id for certificate issued by a specific CA."]
    pub serial: mbedtls_x509_buf,
    #[doc = "< Signature algorithm, e.g. sha1RSA"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER). Used for quick comparison."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The raw subject data (DER). Used for quick comparison."]
    pub subject_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: mbedtls_x509_name,
    #[doc = "< Start time of certificate validity."]
    pub valid_from: mbedtls_x509_time,
    #[doc = "< End time of certificate validity."]
    pub valid_to: mbedtls_x509_time,
    pub pk_raw: mbedtls_x509_buf,
    #[doc = "< Container for the public key context."]
    pub pk: mbedtls_pk_context,
    #[doc = "< Optional X.509 v2/v3 issuer unique identifier."]
    pub issuer_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v2/v3 subject unique identifier."]
    pub subject_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v3 extensions."]
    pub v3_ext: mbedtls_x509_buf,
    #[doc = "< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName and OtherName are listed)."]
    pub subject_alt_names: mbedtls_x509_sequence,
    #[doc = "< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed)."]
    pub certificate_policies: mbedtls_x509_sequence,
    pub private_ext_types: ::core::ffi::c_int,
    pub private_ca_istrue: ::core::ffi::c_int,
    pub private_max_pathlen: ::core::ffi::c_int,
    pub private_key_usage: ::core::ffi::c_uint,
    #[doc = "< Optional list of extended key usage OIDs."]
    pub ext_key_usage: mbedtls_x509_sequence,
    pub private_ns_cert_type: ::core::ffi::c_uchar,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut ::core::ffi::c_void,
    #[doc = " Next certificate in the linked list that constitutes the CA chain.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crt,
}
impl Default for mbedtls_x509_crt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " From RFC 5280 section 4.2.1.6:\n OtherName ::= SEQUENCE {\n      type-id    OBJECT IDENTIFIER,\n      value      [0] EXPLICIT ANY DEFINED BY type-id }\n\n Future versions of the library may add new fields to this structure or\n to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name {
    #[doc = "< The type id."]
    pub type_id: mbedtls_x509_buf,
    pub value: mbedtls_x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " From RFC 4108 section 5:\n HardwareModuleName ::= SEQUENCE {\n                         hwType OBJECT IDENTIFIER,\n                         hwSerialNum OCTET STRING }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_x509_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_x509_buf,
}
impl Default for mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_x509_san_other_name__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_x509_san_other_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure for holding the parsed Subject Alternative Name,\n according to type.\n\n Future versions of the library may add new fields to this structure or\n to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_subject_alternative_name {
    #[doc = "< The SAN type, value of MBEDTLS_X509_SAN_XXX."]
    pub type_: ::core::ffi::c_int,
    #[doc = "< A union of the supported SAN types"]
    pub san: mbedtls_x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    #[doc = "< The otherName supported type."]
    pub other_name: mbedtls_x509_san_other_name,
    #[doc = "< The buffer for the un constructed types. Only dnsName currently supported"]
    pub unstructured_name: mbedtls_x509_buf,
}
impl Default for mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_x509_subject_alternative_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Security profile for certificate verification.\n\n All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().\n\n The fields of this structure are part of the public API and can be\n manipulated directly by applications. Future versions of the library may\n add extra fields or reorder existing fields.\n\n You can create custom profiles by starting from a copy of\n an existing profile, such as mbedtls_x509_crt_profile_default or\n mbedtls_x509_ctr_profile_none and then tune it to your needs.\n\n For example to allow SHA-224 in addition to the default:\n\n  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;\n  my_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );\n\n Or to allow only RSA-3072+ with SHA-256:\n\n  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_none;\n  my_profile.allowed_mds = MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 );\n  my_profile.allowed_pks = MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_RSA );\n  my_profile.rsa_min_bitlen = 3072;"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    #[doc = "< MDs for signatures"]
    pub allowed_mds: u32,
    #[doc = "< PK algs for public keys;\n   this applies to all certificates\n   in the provided chain."]
    pub allowed_pks: u32,
    #[doc = "< Elliptic curves for ECDSA"]
    pub allowed_curves: u32,
    #[doc = "< Minimum size for RSA keys"]
    pub rsa_min_bitlen: u32,
}
#[doc = " Container for writing a certificate (CRT)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub private_version: ::core::ffi::c_int,
    pub private_serial: mbedtls_mpi,
    pub private_subject_key: *mut mbedtls_pk_context,
    pub private_issuer_key: *mut mbedtls_pk_context,
    pub private_subject: *mut mbedtls_asn1_named_data,
    pub private_issuer: *mut mbedtls_asn1_named_data,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_not_before: [::core::ffi::c_char; 16usize],
    pub private_not_after: [::core::ffi::c_char; 16usize],
    pub private_extensions: *mut mbedtls_asn1_named_data,
}
impl Default for mbedtls_x509write_cert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Item in a verification chain: cert and flags for it"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain_item {
    pub private_crt: *mut mbedtls_x509_crt,
    pub private_flags: u32,
}
impl Default for mbedtls_x509_crt_verify_chain_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Verification chain as built by \\c mbedtls_crt_verify_chain()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain {
    pub private_items: [mbedtls_x509_crt_verify_chain_item; 10usize],
    pub private_len: ::core::ffi::c_uint,
}
impl Default for mbedtls_x509_crt_verify_chain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mbedtls_x509_crt_restart_ctx = ::core::ffi::c_void;
extern "C" {
    #[doc = " Default security profile. Should provide a good balance between security\n and compatibility with current deployments.\n\n This profile permits:\n - SHA2 hashes with at least 256 bits: SHA-256, SHA-384, SHA-512.\n - Elliptic curves with 255 bits and above except secp256k1.\n - RSA with 2048 bits and above.\n\n New minor versions of Mbed TLS may extend this profile, for example if\n new algorithms are added to the library. New minor versions of Mbed TLS will\n not reduce this profile unless serious security concerns require it."]
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Expected next default profile. Recommended for new deployments.\n Currently targets a 128-bit security level, except for allowing RSA-2048.\n This profile may change at any time."]
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " NSA Suite B profile."]
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Empty profile that allows nothing. Useful as a basis for constructing\n custom profiles."]
    pub static mbedtls_x509_crt_profile_none: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it\n                 to the end of the provided chained list.\n\n \\param chain    The pointer to the start of the CRT chain to attach to.\n                 When parsing the first CRT in a chain, this should point\n                 to an instance of ::mbedtls_x509_crt initialized through\n                 mbedtls_x509_crt_init().\n \\param buf      The buffer holding the DER encoded certificate.\n \\param buflen   The size in Bytes of \\p buf.\n\n \\note           This function makes an internal copy of the CRT buffer\n                 \\p buf. In particular, \\p buf may be destroyed or reused\n                 after this call returns. To avoid duplicating the CRT\n                 buffer (at the cost of stricter lifetime constraints),\n                 use mbedtls_x509_crt_parse_der_nocopy() instead.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
#[doc = " \\brief          The type of certificate extension callbacks.\n\n                 Callbacks of this type are passed to and used by the\n                 mbedtls_x509_crt_parse_der_with_ext_cb() routine when\n                 it encounters either an unsupported extension or a\n                 \"certificate policies\" extension containing any\n                 unsupported certificate policies.\n                 Future versions of the library may invoke the callback\n                 in other cases, if and when the need arises.\n\n \\param p_ctx    An opaque context passed to the callback.\n \\param crt      The certificate being parsed.\n \\param oid      The OID of the extension.\n \\param critical Whether the extension is critical.\n \\param p        Pointer to the start of the extension value\n                 (the content of the OCTET STRING).\n \\param end      End of extension value.\n\n \\note           The callback must fail and return a negative error code\n                 if it can not parse or does not support the extension.\n                 When the callback fails to parse a critical extension\n                 mbedtls_x509_crt_parse_der_with_ext_cb() also fails.\n                 When the callback fails to parse a non critical extension\n                 mbedtls_x509_crt_parse_der_with_ext_cb() simply skips\n                 the extension and continues parsing.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
pub type mbedtls_x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::core::ffi::c_void,
        crt: *const mbedtls_x509_crt,
        oid: *const mbedtls_x509_buf,
        critical: ::core::ffi::c_int,
        p: *const ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " \\brief            Parse a single DER formatted certificate and add it\n                   to the end of the provided chained list.\n\n \\param chain      The pointer to the start of the CRT chain to attach to.\n                   When parsing the first CRT in a chain, this should point\n                   to an instance of ::mbedtls_x509_crt initialized through\n                   mbedtls_x509_crt_init().\n \\param buf        The buffer holding the DER encoded certificate.\n \\param buflen     The size in Bytes of \\p buf.\n \\param make_copy  When not zero this function makes an internal copy of the\n                   CRT buffer \\p buf. In particular, \\p buf may be destroyed\n                   or reused after this call returns.\n                   When zero this function avoids duplicating the CRT buffer\n                   by taking temporary ownership thereof until the CRT\n                   is destroyed (like mbedtls_x509_crt_parse_der_nocopy())\n \\param cb         A callback invoked for every unsupported certificate\n                   extension.\n \\param p_ctx      An opaque context passed to the callback.\n\n \\note             This call is functionally equivalent to\n                   mbedtls_x509_crt_parse_der(), and/or\n                   mbedtls_x509_crt_parse_der_nocopy()\n                   but it calls the callback with every unsupported\n                   certificate extension and additionally the\n                   \"certificate policies\" extension if it contains any\n                   unsupported certificate policies.\n                   The callback must return a negative error code if it\n                   does not know how to handle such an extension.\n                   When the callback fails to parse a critical extension\n                   mbedtls_x509_crt_parse_der_with_ext_cb() also fails.\n                   When the callback fails to parse a non critical extension\n                   mbedtls_x509_crt_parse_der_with_ext_cb() simply skips\n                   the extension and continues parsing.\n                   Future versions of the library may invoke the callback\n                   in other cases, if and when the need arises.\n\n \\return           \\c 0 if successful.\n \\return           A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_with_ext_cb(
        chain: *mut mbedtls_x509_crt,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
        make_copy: ::core::ffi::c_int,
        cb: mbedtls_x509_crt_ext_cb_t,
        p_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it\n                 to the end of the provided chained list. This is a\n                 variant of mbedtls_x509_crt_parse_der() which takes\n                 temporary ownership of the CRT buffer until the CRT\n                 is destroyed.\n\n \\param chain    The pointer to the start of the CRT chain to attach to.\n                 When parsing the first CRT in a chain, this should point\n                 to an instance of ::mbedtls_x509_crt initialized through\n                 mbedtls_x509_crt_init().\n \\param buf      The address of the readable buffer holding the DER encoded\n                 certificate to use. On success, this buffer must be\n                 retained and not be changed for the lifetime of the\n                 CRT chain \\p chain, that is, until \\p chain is destroyed\n                 through a call to mbedtls_x509_crt_free().\n \\param buflen   The size in Bytes of \\p buf.\n\n \\note           This call is functionally equivalent to\n                 mbedtls_x509_crt_parse_der(), but it avoids creating a\n                 copy of the input buffer at the cost of stronger lifetime\n                 constraints. This is useful in constrained environments\n                 where duplication of the CRT cannot be tolerated.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_nocopy(
        chain: *mut mbedtls_x509_crt,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one DER-encoded or one or more concatenated PEM-encoded\n                 certificates and add them to the chained list.\n\n                 For CRTs in PEM encoding, the function parses permissively:\n                 if at least one certificate can be parsed, the function\n                 returns the number of certificates for which parsing failed\n                 (hence \\c 0 if all certificates were parsed successfully).\n                 If no certificate could be parsed, the function returns\n                 the first (negative) error encountered during parsing.\n\n                 PEM encoded certificates may be interleaved by other data\n                 such as human readable descriptions of their content, as\n                 long as the certificates are enclosed in the PEM specific\n                 '-----{BEGIN/END} CERTIFICATE-----' delimiters.\n\n \\param chain    The chain to which to add the parsed certificates.\n \\param buf      The buffer holding the certificate data in PEM or DER format.\n                 For certificates in PEM encoding, this may be a concatenation\n                 of multiple certificates; for DER encoding, the buffer must\n                 comprise exactly one certificate.\n \\param buflen   The size of \\p buf, including the terminating \\c NULL byte\n                 in case of PEM encoded data.\n\n \\return         \\c 0 if all certificates were parsed successfully.\n \\return         The (positive) number of certificates that couldn't\n                 be parsed if parsing was partly successful (see above).\n \\return         A negative X509 or PEM error code otherwise.\n"]
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more certificates and add them\n                 to the chained list. Parses permissively. If some\n                 certificates can be parsed, the result is the number\n                 of failed certificates it encountered. If none complete\n                 correctly, the first error is returned.\n\n \\param chain    points to the start of the chain\n \\param path     filename to read the certificates from\n\n \\return         0 if all certificates parsed successfully, a positive number\n                 if partly successful or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse_file(
        chain: *mut mbedtls_x509_crt,
        path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more certificate files from a path and add them\n                 to the chained list. Parses permissively. If some\n                 certificates can be parsed, the result is the number\n                 of failed certificates it encountered. If none complete\n                 correctly, the first error is returned.\n\n \\param chain    points to the start of the chain\n \\param path     directory / folder to read the certificate files from\n\n \\return         0 if all certificates parsed successfully, a positive number\n                 if partly successful or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse_path(
        chain: *mut mbedtls_x509_crt,
        path: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          This function parses an item in the SubjectAlternativeNames\n                 extension.\n\n \\param san_buf  The buffer holding the raw data item of the subject\n                 alternative name.\n \\param san      The target structure to populate with the parsed presentation\n                 of the subject alternative name encoded in \\p san_raw.\n\n \\note           Only \"dnsName\" and \"otherName\" of type hardware_module_name\n                 as defined in RFC 4180 is supported.\n\n \\note           This function should be called on a single raw data of\n                 subject alternative name. For example, after successful\n                 certificate parsing, one must iterate on every item in the\n                 \\p crt->subject_alt_names sequence, and pass it to\n                 this function.\n\n \\warning        The target structure contains pointers to the raw data of the\n                 parsed certificate, and its lifetime is restricted by the\n                 lifetime of the certificate.\n\n \\return         \\c 0 on success\n \\return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported\n                 SAN type.\n \\return         Another negative value for any other failure."]
    pub fn mbedtls_x509_parse_subject_alt_name(
        san_buf: *const mbedtls_x509_buf,
        san: *mut mbedtls_x509_subject_alternative_name,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the\n                 certificate.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param crt      The X509 certificate to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_info(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        prefix: *const ::core::ffi::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the\n                 verification status of a certificate.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param flags    Verification flags created by mbedtls_x509_crt_verify()\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut ::core::ffi::c_char,
        size: usize,
        prefix: *const ::core::ffi::c_char,
        flags: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates.\n\n                 The verify callback is a user-supplied callback that\n                 can clear / modify / add flags for a certificate. If set,\n                 the verification callback is called for each\n                 certificate in the chain (from the trust-ca down to the\n                 presented crt). The parameters for the callback are:\n                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,\n                 int *flags). With the flags representing current flags for\n                 that specific certificate and the certificate depth from\n                 the bottom (Peer cert depth = 0).\n\n                 All flags left after returning from the callback\n                 are also returned to the application. The function should\n                 return 0 for anything (including invalid certificates)\n                 other than fatal error, as a non-zero return code\n                 immediately aborts the verification process. For fatal\n                 errors, a specific error code should be used (different\n                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n                 can be used if no better code is available.\n\n \\note           In case verification failed, the results can be displayed\n                 using \\c mbedtls_x509_crt_verify_info()\n\n \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the\n                 default security profile.\n\n \\note           It is your responsibility to provide up-to-date CRLs for\n                 all trusted CAs. If no CRL is provided for the CA that was\n                 used to sign the certificate, CRL verification is skipped\n                 silently, that is *without* setting any flag.\n\n \\note           The \\c trust_ca list can contain two types of certificates:\n                 (1) those of trusted root CAs, so that certificates\n                 chaining up to those CAs will be trusted, and (2)\n                 self-signed end-entity certificates to be trusted (for\n                 specific peers you know) - in that case, the self-signed\n                 certificate doesn't need to have the CA bit set.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param cn       The expected Common Name. This will be checked to be\n                 present in the certificate's subjectAltNames extension or,\n                 if this extension is absent, as a CN component in its\n                 Subject name. Currently only DNS names are supported. This\n                 may be \\c NULL if the CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n\n \\return         \\c 0 if the chain is valid with respect to the\n                 passed CN, CAs, CRLs and security profile.\n \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the\n                 certificate chain verification failed. In this case,\n                 \\c *flags will have one or more\n                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX\n                 flags set.\n \\return         Another negative error code in case of a fatal error\n                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const ::core::ffi::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ::core::ffi::c_int,
                arg4: *mut u32,
            ) -> ::core::ffi::c_int,
        >,
        p_vrfy: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates with respect to\n                 a configurable security profile.\n\n \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit\n                 security profile.\n\n \\note           The restrictions on keys (RSA minimum size, allowed curves\n                 for ECDSA) apply to all certificates: trusted root,\n                 intermediate CAs if any, and end entity certificate.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param profile  The security profile to use for the verification.\n \\param cn       The expected Common Name. This may be \\c NULL if the\n                 CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n\n \\return         \\c 0 if the chain is valid with respect to the\n                 passed CN, CAs, CRLs and security profile.\n \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the\n                 certificate chain verification failed. In this case,\n                 \\c *flags will have one or more\n                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX\n                 flags set.\n \\return         Another negative error code in case of a fatal error\n                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const ::core::ffi::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ::core::ffi::c_int,
                arg4: *mut u32,
            ) -> ::core::ffi::c_int,
        >,
        p_vrfy: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Restartable version of \\c mbedtls_crt_verify_with_profile()\n\n \\note           Performs the same job as \\c mbedtls_crt_verify_with_profile()\n                 but can return early and restart according to the limit\n                 set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param profile  The security profile to use for the verification.\n \\param cn       The expected Common Name. This may be \\c NULL if the\n                 CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n \\param rs_ctx   The restart context to use. This may be set to \\c NULL\n                 to disable restartable ECC.\n\n \\return         See \\c mbedtls_crt_verify_with_profile(), or\n \\return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                 operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_x509_crt_verify_restartable(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const ::core::ffi::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ::core::ffi::c_int,
                arg4: *mut u32,
            ) -> ::core::ffi::c_int,
        >,
        p_vrfy: *mut ::core::ffi::c_void,
        rs_ctx: *mut mbedtls_x509_crt_restart_ctx,
    ) -> ::core::ffi::c_int;
}
#[doc = " \\brief               The type of trusted certificate callbacks.\n\n                      Callbacks of this type are passed to and used by the CRT\n                      verification routine mbedtls_x509_crt_verify_with_ca_cb()\n                      when looking for trusted signers of a given certificate.\n\n                      On success, the callback returns a list of trusted\n                      certificates to be considered as potential signers\n                      for the input certificate.\n\n \\param p_ctx         An opaque context passed to the callback.\n \\param child         The certificate for which to search a potential signer.\n                      This will point to a readable certificate.\n \\param candidate_cas The address at which to store the address of the first\n                      entry in the generated linked list of candidate signers.\n                      This will not be \\c NULL.\n\n \\note                The callback must only return a non-zero value on a\n                      fatal error. If, in contrast, the search for a potential\n                      signer completes without a single candidate, the\n                      callback must return \\c 0 and set \\c *candidate_cas\n                      to \\c NULL.\n\n \\return              \\c 0 on success. In this case, \\c *candidate_cas points\n                      to a heap-allocated linked list of instances of\n                      ::mbedtls_x509_crt, and ownership of this list is passed\n                      to the caller.\n \\return              A negative error code on failure."]
pub type mbedtls_x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::core::ffi::c_void,
        child: *const mbedtls_x509_crt,
        candidate_cas: *mut *mut mbedtls_x509_crt,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " \\brief          Check usage of certificate against keyUsage extension.\n\n \\param crt      Leaf certificate used.\n \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT\n                 before using the certificate to perform an RSA key\n                 exchange).\n\n \\note           Except for decipherOnly and encipherOnly, a bit set in the\n                 usage argument means this bit MUST be set in the\n                 certificate. For decipherOnly and encipherOnly, it means\n                 that bit MAY be set.\n\n \\return         0 is these uses of the certificate are allowed,\n                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension\n                 is present but does not match the usage argument.\n\n \\note           You should only call this function on leaf certificates, on\n                 (intermediate) CAs the keyUsage extension is automatically\n                 checked by \\c mbedtls_x509_crt_verify()."]
    pub fn mbedtls_x509_crt_check_key_usage(
        crt: *const mbedtls_x509_crt,
        usage: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Check usage of certificate against extendedKeyUsage.\n\n \\param crt       Leaf certificate used.\n \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or\n                  MBEDTLS_OID_CLIENT_AUTH).\n \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).\n\n \\return          0 if this use of the certificate is allowed,\n                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.\n\n \\note            Usually only makes sense on leaf certificates."]
    pub fn mbedtls_x509_crt_check_extended_key_usage(
        crt: *const mbedtls_x509_crt,
        usage_oid: *const ::core::ffi::c_char,
        usage_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate revocation status\n\n \\param crt      a certificate to be verified\n \\param crl      the CRL to verify against\n\n \\return         1 if the certificate is revoked, 0 otherwise\n"]
    pub fn mbedtls_x509_crt_is_revoked(
        crt: *const mbedtls_x509_crt,
        crl: *const mbedtls_x509_crl,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a certificate (chain)\n\n \\param crt      Certificate chain to initialize"]
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Unallocate all certificate data\n\n \\param crt      Certificate chain to free"]
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief           Initialize a CRT writing context\n\n \\param ctx       CRT context to initialize"]
    pub fn mbedtls_x509write_crt_init(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Set the version for a Certificate\n                  Default: MBEDTLS_X509_CRT_VERSION_3\n\n \\param ctx       CRT context to use\n \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or\n                                  MBEDTLS_X509_CRT_VERSION_3)"]
    pub fn mbedtls_x509write_crt_set_version(
        ctx: *mut mbedtls_x509write_cert,
        version: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate.\n\n \\param ctx       CRT context to use\n \\param serial    serial number to set\n\n \\return          0 if successful"]
    pub fn mbedtls_x509write_crt_set_serial(
        ctx: *mut mbedtls_x509write_cert,
        serial: *const mbedtls_mpi,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the validity period for a Certificate\n                  Timestamps should be in string format for UTC timezone\n                  i.e. \"YYYYMMDDhhmmss\"\n                  e.g. \"20131231235959\" for December 31st 2013\n                       at 23:59:59\n\n \\param ctx       CRT context to use\n \\param not_before    not_before timestamp\n \\param not_after     not_after timestamp\n\n \\return          0 if timestamp was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_validity(
        ctx: *mut mbedtls_x509write_cert,
        not_before: *const ::core::ffi::c_char,
        not_after: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the issuer name for a Certificate\n                  Issuer names should contain a comma-separated list\n                  of OID types and values:\n                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\"\n\n \\param ctx           CRT context to use\n \\param issuer_name   issuer name to set\n\n \\return          0 if issuer name was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_issuer_name(
        ctx: *mut mbedtls_x509write_cert,
        issuer_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a Certificate\n                  Subject names should contain a comma-separated list\n                  of OID types and values:\n                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\"\n\n \\param ctx           CRT context to use\n \\param subject_name  subject name to set\n\n \\return          0 if subject name was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_subject_name(
        ctx: *mut mbedtls_x509write_cert,
        subject_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject public key for the certificate\n\n \\param ctx       CRT context to use\n \\param key       public key to include"]
    pub fn mbedtls_x509write_crt_set_subject_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the issuer key used for signing the certificate\n\n \\param ctx       CRT context to use\n \\param key       private key to sign with"]
    pub fn mbedtls_x509write_crt_set_issuer_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature\n                  (e.g. MBEDTLS_MD_SHA1)\n\n \\param ctx       CRT context to use\n \\param md_alg    MD algorithm to use"]
    pub fn mbedtls_x509write_crt_set_md_alg(
        ctx: *mut mbedtls_x509write_cert,
        md_alg: mbedtls_md_type_t,
    );
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the\n                  CRT\n\n \\param ctx       CRT context to use\n \\param oid       OID of the extension\n \\param oid_len   length of the OID\n \\param critical  if the extension is critical (per the RFC's definition)\n \\param val       value of the extension OCTET STRING\n \\param val_len   length of the value data\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_extension(
        ctx: *mut mbedtls_x509write_cert,
        oid: *const ::core::ffi::c_char,
        oid_len: usize,
        critical: ::core::ffi::c_int,
        val: *const ::core::ffi::c_uchar,
        val_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the basicConstraints extension for a CRT\n\n \\param ctx       CRT context to use\n \\param is_ca     is this a CA certificate\n \\param max_pathlen   maximum length of certificate chains below this\n                      certificate (only for CA certificates, -1 is\n                      unlimited)\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_basic_constraints(
        ctx: *mut mbedtls_x509write_cert,
        is_ca: ::core::ffi::c_int,
        max_pathlen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subjectKeyIdentifier extension for a CRT\n                  Requires that mbedtls_x509write_crt_set_subject_key() has been\n                  called before\n\n \\param ctx       CRT context to use\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_subject_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the authorityKeyIdentifier extension for a CRT\n                  Requires that mbedtls_x509write_crt_set_issuer_key() has been\n                  called before\n\n \\param ctx       CRT context to use\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_authority_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags\n                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)\n\n \\param ctx       CRT context to use\n \\param key_usage key usage flags to set\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        key_usage: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Extended Key Usage Extension\n                  (e.g. MBEDTLS_OID_SERVER_AUTH)\n\n \\param ctx       CRT context to use\n \\param exts      extended key usage extensions to set, a sequence of\n                  MBEDTLS_ASN1_OID objects\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ext_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        exts: *const mbedtls_asn1_sequence,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags\n                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)\n\n \\param ctx           CRT context to use\n \\param ns_cert_type  Netscape Cert Type flags to set\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ns_cert_type(
        ctx: *mut mbedtls_x509write_cert,
        ns_cert_type: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CRT write context\n\n \\param ctx       CRT context to free"]
    pub fn mbedtls_x509write_crt_free(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       certificate to write away\n \\param buf       buffer to write to\n \\param size      size of the buffer\n \\param f_rng     RNG function. This must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          length of data written if successful, or a specific\n                  error code\n\n \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_der(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 PEM string\n\n \\param ctx       certificate to write away\n \\param buf       buffer to write to\n \\param size      size of the buffer\n \\param f_rng     RNG function. This must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 if successful, or a specific error code\n\n \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_pem(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut ::core::ffi::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
#[doc = "< Our key."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
#[doc = "< The key of the peer."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
#[doc = " Defines the source of the imported EC key."]
pub type mbedtls_ecdh_side = ::core::ffi::c_uint;
#[doc = "< Implementation not defined."]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_NONE: mbedtls_ecdh_variant = 0;
#[doc = "< The default Mbed TLS implementation"]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0: mbedtls_ecdh_variant = 1;
#[doc = " Defines the ECDH implementation used.\n\n Later versions of the library may add new variants, therefore users should\n not make any assumptions about them."]
pub type mbedtls_ecdh_variant = ::core::ffi::c_uint;
#[doc = " The context used by the default ECDH implementation.\n\n Later versions might change the structure of this context, therefore users\n should not make any assumptions about the structure of\n mbedtls_ecdh_context_mbed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdh_context_mbed {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
    pub private_Qp: mbedtls_ecp_point,
    pub private_z: mbedtls_mpi,
}
impl Default for mbedtls_ecdh_context_mbed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\warning         Performing multiple operations concurrently on the same\n                  ECDSA context is not supported; objects of this type\n                  should not be shared between multiple threads.\n \\brief           The ECDH context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context {
    pub private_point_format: u8,
    pub private_grp_id: mbedtls_ecp_group_id,
    pub private_var: mbedtls_ecdh_variant,
    pub private_ctx: mbedtls_ecdh_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ecdh_context__bindgen_ty_1 {
    pub private_mbed_ecdh: mbedtls_ecdh_context_mbed,
}
impl Default for mbedtls_ecdh_context__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mbedtls_ecdh_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief          Check whether a given group can be used for ECDH.\n\n \\param gid      The ECP group ID to check.\n\n \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdh_can_do(gid: mbedtls_ecp_group_id) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECDH keypair on an elliptic\n                  curve.\n\n                  This function performs the first of two core computations\n                  implemented during the ECDH key exchange. The second core\n                  computation is performed by mbedtls_ecdh_compute_shared().\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use. This must be initialized and have\n                  domain parameters loaded, for example through\n                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().\n \\param d         The destination MPI (private key).\n                  This must be initialized.\n \\param Q         The destination point (public key).\n                  This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or\n                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the shared secret.\n\n                  This function performs the second of two core computations\n                  implemented during the ECDH key exchange. The first core\n                  computation is performed by mbedtls_ecdh_gen_public().\n\n \\see             ecp.h\n\n \\note            If \\p f_rng is not NULL, it is used to implement\n                  countermeasures against side-channel attacks.\n                  For more information, see mbedtls_ecp_mul().\n\n \\param grp       The ECP group to use. This must be initialized and have\n                  domain parameters loaded, for example through\n                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().\n \\param z         The destination MPI (shared secret).\n                  This must be initialized.\n \\param Q         The public key from another party.\n                  This must be initialized.\n \\param d         Our secret exponent (private key).\n                  This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't need a\n                  context argument.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or\n                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDH context.\n\n \\param ctx       The ECDH context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function sets up the ECDH context with the information\n                  given.\n\n                  This function should be called after mbedtls_ecdh_init() but\n                  before mbedtls_ecdh_make_params(). There is no need to call\n                  this function before mbedtls_ecdh_read_params().\n\n                  This is the first function used by a TLS server for ECDHE\n                  ciphersuites.\n\n \\param ctx       The ECDH context to set up. This must be initialized.\n \\param grp_id    The group id of the group to set up the context for.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_ecdh_setup(
        ctx: *mut mbedtls_ecdh_context,
        grp_id: mbedtls_ecp_group_id,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function frees a context.\n\n \\param ctx       The context to free. This may be \\c NULL, in which\n                  case this function does nothing. If it is not \\c NULL,\n                  it must point to an initialized ECDH context."]
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function generates an EC key pair and exports its\n                  in the format used in a TLS ServerKeyExchange handshake\n                  message.\n\n                  This is the second function used by a TLS server for ECDHE\n                  ciphersuites. (It is called after mbedtls_ecdh_setup().)\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and bound to a group, for example via mbedtls_ecdh_setup().\n \\param olen      The address at which to store the number of Bytes written.\n \\param buf       The destination buffer. This must be a writable buffer of\n                  length \\p blen Bytes.\n \\param blen      The length of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function parses the ECDHE parameters in a\n                  TLS ServerKeyExchange handshake message.\n\n \\note            In a TLS handshake, this is the how the client\n                  sets up its ECDHE context from the server's public\n                  ECDHE key material.\n\n \\see             ecp.h\n\n \\param ctx       The ECDHE context to use. This must be initialized.\n \\param buf       On input, \\c *buf must be the start of the input buffer.\n                  On output, \\c *buf is updated to point to the end of the\n                  data that has been read. On success, this is the first byte\n                  past the end of the ServerKeyExchange parameters.\n                  On error, this is the point at which an error has been\n                  detected, which is usually not useful except to debug\n                  failures.\n \\param end       The end of the input buffer.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure.\n"]
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDH context from an EC key.\n\n                  It is used by clients and servers in place of the\n                  ServerKeyEchange for static ECDH, and imports ECDH\n                  parameters from the EC key information of a certificate.\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to set up. This must be initialized.\n \\param key       The EC key to use. This must be initialized.\n \\param side      Defines the source of the key. Possible values are:\n                  - #MBEDTLS_ECDH_OURS: The key is ours.\n                  - #MBEDTLS_ECDH_THEIRS: The key is that of the peer.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure.\n"]
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and exports it\n                  as a TLS ClientKeyExchange payload.\n\n                  This is the second function used by a TLS client for ECDH(E)\n                  ciphersuites.\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and bound to a group, the latter usually by\n                  mbedtls_ecdh_read_params().\n \\param olen      The address at which to store the number of Bytes written.\n                  This must not be \\c NULL.\n \\param buf       The destination buffer. This must be a writable buffer\n                  of length \\p blen Bytes.\n \\param blen      The size of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief       This function parses and processes the ECDHE payload of a\n              TLS ClientKeyExchange message.\n\n              This is the third function used by a TLS server for ECDH(E)\n              ciphersuites. (It is called after mbedtls_ecdh_setup() and\n              mbedtls_ecdh_make_params().)\n\n \\see         ecp.h\n\n \\param ctx   The ECDH context to use. This must be initialized\n              and bound to a group, for example via mbedtls_ecdh_setup().\n \\param buf   The pointer to the ClientKeyExchange payload. This must\n              be a readable buffer of length \\p blen Bytes.\n \\param blen  The length of the input buffer \\p buf in Bytes.\n\n \\return      \\c 0 on success.\n \\return      An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const ::core::ffi::c_uchar,
        blen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           This function derives and exports the shared secret.\n\n                  This is the last function used by both TLS client\n                  and servers.\n\n \\note            If \\p f_rng is not NULL, it is used to implement\n                  countermeasures against side-channel attacks.\n                  For more information, see mbedtls_ecp_mul().\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and have its own private key generated and the peer's\n                  public key imported.\n \\param olen      The address at which to store the total number of\n                  Bytes written on success. This must not be \\c NULL.\n \\param buf       The buffer to write the generated shared key to. This\n                  must be a writable buffer of size \\p blen Bytes.\n \\param blen      The length of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context. This may be \\c NULL if \\p f_rng\n                  doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut ::core::ffi::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
pub type mbedtls_time_t = time_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [::core::ffi::c_uchar; 48usize],
    pub _pms_ecdh: [::core::ffi::c_uchar; 66usize],
}
impl Default for mbedtls_ssl_premaster_secret {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_NEW_SESSION_TICKET: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_RETRY_REQUEST: mbedtls_ssl_states = 18;
pub const mbedtls_ssl_states_MBEDTLS_SSL_ENCRYPTED_EXTENSIONS: mbedtls_ssl_states = 19;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY: mbedtls_ssl_states = 20;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED: mbedtls_ssl_states = 21;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO: mbedtls_ssl_states =
    22;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO: mbedtls_ssl_states = 23;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST: mbedtls_ssl_states =
    24;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 25;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET: mbedtls_ssl_states = 26;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH: mbedtls_ssl_states = 27;
pub type mbedtls_ssl_states = ::core::ffi::c_uint;
#[doc = " \\brief          Callback type: send data on the network.\n\n \\note           That callback may be either blocking or non-blocking.\n\n \\param ctx      Context for the send callback (typically a file descriptor)\n \\param buf      Buffer holding the data to send\n \\param len      Length of the data to send\n\n \\return         The callback must return the number of bytes sent if any,\n                 or a non-zero error code.\n                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE\n                 must be returned when the operation would block.\n\n \\note           The callback is allowed to send fewer bytes than requested.\n                 It must always return the number of bytes actually sent."]
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        buf: *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network.\n\n \\note           That callback may be either blocking or non-blocking.\n\n \\param ctx      Context for the receive callback (typically a file\n                 descriptor)\n \\param buf      Buffer to write the received data to\n \\param len      Length of the receive buffer\n\n \\returns        If data has been received, the positive number of bytes received.\n \\returns        \\c 0 if the connection has been closed.\n \\returns        If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ\n                 must be returned when the operation would block.\n \\returns        Another negative error code on other kinds of failures.\n\n \\note           The callback may receive fewer bytes than the length of the\n                 buffer. It must always return the number of bytes actually\n                 received and written to the buffer."]
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        buf: *mut ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network, with timeout\n\n \\note           That callback must block until data is received, or the\n                 timeout delay expires, or the operation is interrupted by a\n                 signal.\n\n \\param ctx      Context for the receive callback (typically a file descriptor)\n \\param buf      Buffer to write the received data to\n \\param len      Length of the receive buffer\n \\param timeout  Maximum number of milliseconds to wait for data\n                 0 means no timeout (potentially waiting forever)\n\n \\return         The callback must return the number of bytes received,\n                 or a non-zero error code:\n                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,\n                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.\n\n \\note           The callback may receive fewer bytes than the length of the\n                 buffer. It must always return the number of bytes actually\n                 received and written to the buffer."]
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        buf: *mut ::core::ffi::c_uchar,
        len: usize,
        timeout: u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief          Callback type: set a pair of timers/delays to watch\n\n \\param ctx      Context pointer\n \\param int_ms   Intermediate delay in milliseconds\n \\param fin_ms   Final delay in milliseconds\n                 0 cancels the current timer.\n\n \\note           This callback must at least store the necessary information\n                 for the associated \\c mbedtls_ssl_get_timer_t callback to\n                 return correct information.\n\n \\note           If using an event-driven style of programming, an event must\n                 be generated when the final delay is passed. The event must\n                 cause a call to \\c mbedtls_ssl_handshake() with the proper\n                 SSL context to be scheduled. Care must be taken to ensure\n                 that at most one such call happens at a time.\n\n \\note           Only one timer at a time must be running. Calling this\n                 function while a timer is running must cancel it. Cancelled\n                 timers must not generate any event."]
pub type mbedtls_ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, int_ms: u32, fin_ms: u32),
>;
#[doc = " \\brief          Callback type: get status of timers/delays\n\n \\param ctx      Context pointer\n\n \\return         This callback must return:\n                 -1 if cancelled (fin_ms == 0),\n                  0 if none of the delays have passed,\n                  1 if only the intermediate delay has passed,\n                  2 if the final delay has passed."]
pub type mbedtls_ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_sig_hash_set_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[doc = " \\brief          Callback type: server-side session cache getter\n\n                 The session cache is logically a key value store, with\n                 keys being session IDs and values being instances of\n                 mbedtls_ssl_session.\n\n                 This callback retrieves an entry in this key-value store.\n\n \\param data            The address of the session cache structure to query.\n \\param session_id      The buffer holding the session ID to query.\n \\param session_id_len  The length of \\p session_id in Bytes.\n \\param session         The address of the session structure to populate.\n                        It is initialized with mbdtls_ssl_session_init(),\n                        and the callback must always leave it in a state\n                        where it can safely be freed via\n                        mbedtls_ssl_session_free() independent of the\n                        return code of this function.\n\n \\return                \\c 0 on success\n \\return                A non-zero return value on failure.\n"]
pub type mbedtls_ssl_cache_get_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::core::ffi::c_void,
        session_id: *const ::core::ffi::c_uchar,
        session_id_len: usize,
        session: *mut mbedtls_ssl_session,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief          Callback type: server-side session cache setter\n\n                 The session cache is logically a key value store, with\n                 keys being session IDs and values being instances of\n                 mbedtls_ssl_session.\n\n                 This callback sets an entry in this key-value store.\n\n \\param data            The address of the session cache structure to modify.\n \\param session_id      The buffer holding the session ID to query.\n \\param session_id_len  The length of \\p session_id in Bytes.\n \\param session         The address of the session to be stored in the\n                        session cache.\n\n \\return                \\c 0 on success\n \\return                A non-zero return value on failure."]
pub type mbedtls_ssl_cache_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::core::ffi::c_void,
        session_id: *const ::core::ffi::c_uchar,
        session_id_len: usize,
        session: *const mbedtls_ssl_session,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_tls13_application_secrets {
    pub client_application_traffic_secret_N: [::core::ffi::c_uchar; 64usize],
    pub server_application_traffic_secret_N: [::core::ffi::c_uchar; 64usize],
    pub exporter_master_secret: [::core::ffi::c_uchar; 64usize],
    pub resumption_master_secret: [::core::ffi::c_uchar; 64usize],
}
impl Default for mbedtls_ssl_tls13_application_secrets {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Context not in use or version not yet negotiated."]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_UNKNOWN: mbedtls_ssl_protocol_version =
    0;
#[doc = "< (D)TLS 1.2"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_2: mbedtls_ssl_protocol_version =
    771;
#[doc = "< (D)TLS 1.3"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_3: mbedtls_ssl_protocol_version =
    772;
#[doc = " Human-friendly representation of the (D)TLS protocol version."]
pub type mbedtls_ssl_protocol_version = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_session {
    pub private_mfl_code: ::core::ffi::c_uchar,
    pub private_exported: ::core::ffi::c_uchar,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_start: mbedtls_time_t,
    pub private_ciphersuite: ::core::ffi::c_int,
    pub private_id_len: usize,
    pub private_id: [::core::ffi::c_uchar; 32usize],
    pub private_master: [::core::ffi::c_uchar; 48usize],
    pub private_peer_cert: *mut mbedtls_x509_crt,
    pub private_verify_result: u32,
    pub private_ticket: *mut ::core::ffi::c_uchar,
    pub private_ticket_len: usize,
    pub private_ticket_lifetime: u32,
    pub private_encrypt_then_mac: ::core::ffi::c_int,
}
impl Default for mbedtls_ssl_session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_NONE: mbedtls_tls_prf_types = 0;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA384: mbedtls_tls_prf_types = 1;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA256: mbedtls_tls_prf_types = 2;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA384: mbedtls_tls_prf_types = 3;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA256: mbedtls_tls_prf_types = 4;
pub type mbedtls_tls_prf_types = ::core::ffi::c_uint;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET:
    mbedtls_ssl_key_export_type = 0;
pub type mbedtls_ssl_key_export_type = ::core::ffi::c_uint;
#[doc = " \\brief           Callback type: Export key alongside random values for\n                                 session identification, and PRF for\n                                 implementation of TLS key exporters.\n\n \\param p_expkey   Context for the callback.\n \\param type       The type of the key that is being exported.\n \\param secret     The address of the buffer holding the secret\n                   that's being exporterd.\n \\param secret_len The length of \\p secret in bytes.\n \\param client_random The client random bytes.\n \\param server_random The server random bytes.\n \\param tls_prf_type The identifier for the PRF used in the handshake\n                     to which the key belongs."]
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut ::core::ffi::c_void,
        type_: mbedtls_ssl_key_export_type,
        secret: *const ::core::ffi::c_uchar,
        secret_len: usize,
        client_random: *const ::core::ffi::c_uchar,
        server_random: *const ::core::ffi::c_uchar,
        tls_prf_type: mbedtls_tls_prf_types,
    ),
>;
#[doc = " \\brief           Callback type: generic handshake callback\n\n \\note            Callbacks may use user_data funcs to set/get app user data.\n                  See \\c mbedtls_ssl_get_user_data_p()\n                      \\c mbedtls_ssl_get_user_data_n()\n                      \\c mbedtls_ssl_conf_get_user_data_p()\n                      \\c mbedtls_ssl_conf_get_user_data_n()\n\n \\param ssl       \\c mbedtls_ssl_context on which the callback is run\n\n \\return          The return value of the callback is 0 if successful,\n                  or a specific MBEDTLS_ERR_XXX code, which will cause\n                  the handshake to be aborted."]
pub type mbedtls_ssl_hs_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_user_data_t {
    pub n: usize,
    pub p: *mut ::core::ffi::c_void,
}
impl Default for mbedtls_ssl_user_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " SSL/TLS configuration to be shared between mbedtls_ssl_context structures."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_config {
    pub private_max_tls_version: mbedtls_ssl_protocol_version,
    pub private_min_tls_version: mbedtls_ssl_protocol_version,
    pub private_endpoint: u8,
    pub private_transport: u8,
    pub private_authmode: u8,
    pub private_allow_legacy_renegotiation: u8,
    pub private_mfl_code: u8,
    pub private_encrypt_then_mac: u8,
    pub private_extended_ms: u8,
    pub private_disable_renegotiation: u8,
    pub private_session_tickets: u8,
    pub private_cert_req_ca_list: u8,
    pub private_respect_cli_pref: u8,
    pub private_ciphersuite_list: *const ::core::ffi::c_int,
    pub private_f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: ::core::ffi::c_int,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
            arg5: *const ::core::ffi::c_char,
        ),
    >,
    pub private_p_dbg: *mut ::core::ffi::c_void,
    pub private_f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_uchar,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub private_p_rng: *mut ::core::ffi::c_void,
    pub private_f_get_cache: mbedtls_ssl_cache_get_t,
    pub private_f_set_cache: mbedtls_ssl_cache_set_t,
    pub private_p_cache: *mut ::core::ffi::c_void,
    pub private_f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const ::core::ffi::c_uchar,
            arg4: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub private_p_sni: *mut ::core::ffi::c_void,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: ::core::ffi::c_int,
            arg4: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub private_p_vrfy: *mut ::core::ffi::c_void,
    pub private_f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *const mbedtls_ssl_session,
            arg3: *mut ::core::ffi::c_uchar,
            arg4: *const ::core::ffi::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub private_f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut mbedtls_ssl_session,
            arg3: *mut ::core::ffi::c_uchar,
            arg4: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub private_p_ticket: *mut ::core::ffi::c_void,
    pub private_cert_profile: *const mbedtls_x509_crt_profile,
    pub private_key_cert: *mut mbedtls_ssl_key_cert,
    pub private_ca_chain: *mut mbedtls_x509_crt,
    pub private_ca_crl: *mut mbedtls_x509_crl,
    pub private_sig_algs: *const u16,
    pub private_group_list: *const u16,
    pub private_alpn_list: *mut *const ::core::ffi::c_char,
    pub private_read_timeout: u32,
    pub private_renego_max_records: ::core::ffi::c_int,
    pub private_renego_period: [::core::ffi::c_uchar; 8usize],
    pub private_badmac_limit: ::core::ffi::c_uint,
    pub private_user_data: mbedtls_ssl_user_data_t,
    pub private_f_cert_cb: mbedtls_ssl_hs_cb_t,
    pub private_dn_hints: *const mbedtls_x509_crt,
}
impl Default for mbedtls_ssl_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_context {
    pub private_conf: *const mbedtls_ssl_config,
    pub private_state: ::core::ffi::c_int,
    pub private_renego_status: ::core::ffi::c_int,
    pub private_renego_records_seen: ::core::ffi::c_int,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_badmac_seen: ::core::ffi::c_uint,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: ::core::ffi::c_int,
            arg4: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub private_p_vrfy: *mut ::core::ffi::c_void,
    pub private_f_send: mbedtls_ssl_send_t,
    pub private_f_recv: mbedtls_ssl_recv_t,
    pub private_f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    pub private_p_bio: *mut ::core::ffi::c_void,
    pub private_session_in: *mut mbedtls_ssl_session,
    pub private_session_out: *mut mbedtls_ssl_session,
    pub private_session: *mut mbedtls_ssl_session,
    pub private_session_negotiate: *mut mbedtls_ssl_session,
    pub private_handshake: *mut mbedtls_ssl_handshake_params,
    pub private_transform_in: *mut mbedtls_ssl_transform,
    pub private_transform_out: *mut mbedtls_ssl_transform,
    pub private_transform: *mut mbedtls_ssl_transform,
    pub private_transform_negotiate: *mut mbedtls_ssl_transform,
    pub private_p_timer: *mut ::core::ffi::c_void,
    pub private_f_set_timer: mbedtls_ssl_set_timer_t,
    pub private_f_get_timer: mbedtls_ssl_get_timer_t,
    pub private_in_buf: *mut ::core::ffi::c_uchar,
    pub private_in_ctr: *mut ::core::ffi::c_uchar,
    pub private_in_hdr: *mut ::core::ffi::c_uchar,
    pub private_in_len: *mut ::core::ffi::c_uchar,
    pub private_in_iv: *mut ::core::ffi::c_uchar,
    pub private_in_msg: *mut ::core::ffi::c_uchar,
    pub private_in_offt: *mut ::core::ffi::c_uchar,
    pub private_in_msgtype: ::core::ffi::c_int,
    pub private_in_msglen: usize,
    pub private_in_left: usize,
    pub private_in_hslen: usize,
    pub private_nb_zero: ::core::ffi::c_int,
    pub private_keep_current_message: ::core::ffi::c_int,
    pub private_send_alert: ::core::ffi::c_uchar,
    pub private_alert_type: ::core::ffi::c_uchar,
    pub private_alert_reason: ::core::ffi::c_int,
    pub private_out_buf: *mut ::core::ffi::c_uchar,
    pub private_out_ctr: *mut ::core::ffi::c_uchar,
    pub private_out_hdr: *mut ::core::ffi::c_uchar,
    pub private_out_len: *mut ::core::ffi::c_uchar,
    pub private_out_iv: *mut ::core::ffi::c_uchar,
    pub private_out_msg: *mut ::core::ffi::c_uchar,
    pub private_out_msgtype: ::core::ffi::c_int,
    pub private_out_msglen: usize,
    pub private_out_left: usize,
    pub private_cur_out_ctr: [::core::ffi::c_uchar; 8usize],
    pub private_hostname: *mut ::core::ffi::c_char,
    pub private_alpn_chosen: *const ::core::ffi::c_char,
    pub private_secure_renegotiation: ::core::ffi::c_int,
    pub private_verify_data_len: usize,
    pub private_own_verify_data: [::core::ffi::c_char; 12usize],
    pub private_peer_verify_data: [::core::ffi::c_char; 12usize],
    pub private_f_export_keys: mbedtls_ssl_export_keys_t,
    pub private_p_export_keys: *mut ::core::ffi::c_void,
    pub private_user_data: mbedtls_ssl_user_data_t,
}
impl Default for mbedtls_ssl_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \\brief               Return the name of the ciphersuite associated with the\n                      given ID\n\n \\param ciphersuite_id SSL ciphersuite ID\n\n \\return              a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite_name(
        ciphersuite_id: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief               Return the ID of the ciphersuite associated with the\n                      given name\n\n \\param ciphersuite_name SSL ciphersuite name\n\n \\return              the ID with the ciphersuite or 0 if not found"]
    pub fn mbedtls_ssl_get_ciphersuite_id(
        ciphersuite_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL context\n                 Just makes the context ready for mbedtls_ssl_setup() or\n                 mbedtls_ssl_free()\n\n \\param ssl      SSL context"]
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Set up an SSL context for use\n\n \\note           No copy of the configuration context is made, it can be\n                 shared by many mbedtls_ssl_context structures.\n\n \\warning        The conf structure will be accessed during the session.\n                 It must not be modified or freed as long as the session\n                 is active.\n\n \\warning        This function must be called exactly once per context.\n                 Calling mbedtls_ssl_setup again is not supported, even\n                 if no session is active.\n\n \\param ssl      SSL context\n \\param conf     SSL configuration to use\n\n \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if\n                 memory allocation failed"]
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Reset an already initialized SSL context for re-use\n                 while retaining application-set variables, function\n                 pointers and data.\n\n \\param ssl      SSL context\n \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED or\nMBEDTLS_ERR_SSL_HW_ACCEL_FAILED"]
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the current endpoint type\n\n \\param conf     SSL configuration\n \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    pub fn mbedtls_ssl_conf_endpoint(conf: *mut mbedtls_ssl_config, endpoint: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " \\brief           Set the transport type (TLS or DTLS).\n                  Default: TLS\n\n \\note            For DTLS, you must either provide a recv callback that\n                  doesn't block, or one that handles timeouts, see\n                  \\c mbedtls_ssl_set_bio(). You also need to provide timer\n                  callbacks with \\c mbedtls_ssl_set_timer_cb().\n\n \\param conf      SSL configuration\n \\param transport transport type:\n                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,\n                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS."]
    pub fn mbedtls_ssl_conf_transport(conf: *mut mbedtls_ssl_config, transport: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the certificate verification mode\n                 Default: NONE on server, REQUIRED on client\n\n \\param conf     SSL configuration\n \\param authmode can be:\n\n  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked\n                        (default on server)\n                        (insecure on client)\n\n  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the\n                        handshake continues even if verification failed;\n                        mbedtls_ssl_get_verify_result() can be called after the\n                        handshake is complete.\n\n  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,\n                        handshake is aborted if verification failed.\n                        (default on client)\n\n \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.\n With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at\n the right time(s), which may not be obvious, while REQUIRED always perform\n the verification as soon as possible. For example, REQUIRED was protecting\n against the \"triple handshake\" attack even before it was found."]
    pub fn mbedtls_ssl_conf_authmode(conf: *mut mbedtls_ssl_config, authmode: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the verification callback (Optional).\n\n                 If set, the provided verify callback is called for each\n                 certificate in the peer's CRT chain, including the trusted\n                 root. For more information, please see the documentation of\n                 \\c mbedtls_x509_crt_verify().\n\n \\note           For per context callbacks and contexts, please use\n                 mbedtls_ssl_set_verify() instead.\n\n \\param conf     The SSL configuration to use.\n \\param f_vrfy   The verification callback to use during CRT verification.\n \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ::core::ffi::c_int,
                arg4: *mut u32,
            ) -> ::core::ffi::c_int,
        >,
        p_vrfy: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the random number generator callback\n\n \\param conf     SSL configuration\n \\param f_rng    RNG function (mandatory)\n \\param p_rng    RNG parameter"]
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the debug callback\n\n                 The callback has the following argument:\n                 void *           opaque context for the callback\n                 int              debug level\n                 const char *     file name\n                 int              line number\n                 const char *     message\n\n \\param conf     SSL configuration\n \\param f_dbg    debug function\n \\param p_dbg    debug parameter"]
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: ::core::ffi::c_int,
                arg3: *const ::core::ffi::c_char,
                arg4: ::core::ffi::c_int,
                arg5: *const ::core::ffi::c_char,
            ),
        >,
        p_dbg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the underlying BIO callbacks for write, read and\n                 read-with-timeout.\n\n \\param ssl      SSL context\n \\param p_bio    parameter (context) shared by BIO callbacks\n \\param f_send   write callback\n \\param f_recv   read callback\n \\param f_recv_timeout blocking read callback with timeout.\n\n \\note           One of f_recv or f_recv_timeout can be NULL, in which case\n                 the other is used. If both are non-NULL, f_recv_timeout is\n                 used and f_recv is ignored (as if it were NULL).\n\n \\note           The two most common use cases are:\n                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL\n                 - blocking I/O, f_recv == NULL, f_recv_timeout != NULL\n\n \\note           For DTLS, you need to provide either a non-NULL\n                 f_recv_timeout callback, or a f_recv that doesn't block.\n\n \\note           See the documentations of \\c mbedtls_ssl_send_t,\n                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for\n                 the conventions those callbacks must follow.\n\n \\note           On some platforms, net_sockets.c provides\n                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and\n                 \\c mbedtls_net_recv_timeout() that are suitable to be used\n                 here."]
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut ::core::ffi::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    #[doc = " \\brief          Set a connection-specific verification callback (optional).\n\n                 If set, the provided verify callback is called for each\n                 certificate in the peer's CRT chain, including the trusted\n                 root. For more information, please see the documentation of\n                 \\c mbedtls_x509_crt_verify().\n\n \\note           This call is analogous to mbedtls_ssl_conf_verify() but\n                 binds the verification callback and context to an SSL context\n                 as opposed to an SSL configuration.\n                 If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()\n                 are both used, mbedtls_ssl_set_verify() takes precedence.\n\n \\param ssl      The SSL context to use.\n \\param f_vrfy   The verification callback to use during CRT verification.\n \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_set_verify(
        ssl: *mut mbedtls_ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ::core::ffi::c_int,
                arg4: *mut u32,
            ) -> ::core::ffi::c_int,
        >,
        p_vrfy: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the timeout period for mbedtls_ssl_read()\n                 (Default: no timeout.)\n\n \\param conf     SSL configuration context\n \\param timeout  Timeout value in milliseconds.\n                 Use 0 for no timeout (default).\n\n \\note           With blocking I/O, this will only work if a non-NULL\n                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio().\n                 With non-blocking I/O, this will only work if timer\n                 callbacks were set with \\c mbedtls_ssl_set_timer_cb().\n\n \\note           With non-blocking I/O, you may also skip this function\n                 altogether and handle timeouts at the application layer."]
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    #[doc = " \\brief          Check whether a buffer contains a valid and authentic record\n                 that has not been seen before. (DTLS only).\n\n                 This function does not change the user-visible state\n                 of the SSL context. Its sole purpose is to provide\n                 an indication of the legitimacy of an incoming record.\n\n                 This can be useful e.g. in distributed server environments\n                 using the DTLS Connection ID feature, in which connections\n                 might need to be passed between service instances on a change\n                 of peer address, but where such disruptive operations should\n                 only happen after the validity of incoming records has been\n                 confirmed.\n\n \\param ssl      The SSL context to use.\n \\param buf      The address of the buffer holding the record to be checked.\n                 This must be a read/write buffer of length \\p buflen Bytes.\n \\param buflen   The length of \\p buf in Bytes.\n\n \\note           This routine only checks whether the provided buffer begins\n                 with a valid and authentic record that has not been seen\n                 before, but does not check potential data following the\n                 initial record. In particular, it is possible to pass DTLS\n                 datagrams containing multiple records, in which case only\n                 the first record is checked.\n\n \\note           This function modifies the input buffer \\p buf. If you need\n                 to preserve the original record, you have to maintain a copy.\n\n \\return         \\c 0 if the record is valid and authentic and has not been\n                 seen before.\n \\return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed\n                 successfully but the record was found to be not authentic.\n \\return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed\n                 successfully but the record was found to be invalid for\n                 a reason different from authenticity checking.\n \\return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed\n                 successfully but the record was found to be unexpected\n                 in the state of the SSL context, including replayed records.\n \\return         Another negative error code on different kinds of failure.\n                 In this case, the SSL context becomes unusable and needs\n                 to be freed or reset before reuse."]
    pub fn mbedtls_ssl_check_record(
        ssl: *const mbedtls_ssl_context,
        buf: *mut ::core::ffi::c_uchar,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the timer callbacks (Mandatory for DTLS.)\n\n \\param ssl      SSL context\n \\param p_timer  parameter (context) shared by timer callbacks\n \\param f_set_timer   set timer callback\n \\param f_get_timer   get timer callback. Must return:\n\n \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and\n                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of\n                 callbacks must follow.\n\n \\note           On some platforms, timing.c provides\n                 \\c mbedtls_timing_set_delay() and\n                 \\c mbedtls_timing_get_delay() that are suitable for using\n                 here, except if using an event-driven style.\n\n \\note           See also the \"DTLS tutorial\" article in our knowledge base.\n                 https://mbed-tls.readthedocs.io/en/latest/kb/how-to/dtls-tutorial"]
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut ::core::ffi::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
#[doc = " \\brief           Callback type: generate and write session ticket\n\n \\note            This describes what a callback implementation should do.\n                  This callback should generate an encrypted and\n                  authenticated ticket for the session and write it to the\n                  output buffer. Here, ticket means the opaque ticket part\n                  of the NewSessionTicket structure of RFC 5077.\n\n \\param p_ticket  Context for the callback\n \\param session   SSL session to be written in the ticket\n \\param start     Start of the output buffer\n \\param end       End of the output buffer\n \\param tlen      On exit, holds the length written\n \\param lifetime  On exit, holds the lifetime of the ticket in seconds\n\n \\return          0 if successful, or\n                  a specific MBEDTLS_ERR_XXX code."]
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ::core::ffi::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief           Callback type: parse and load session ticket\n\n \\note            This describes what a callback implementation should do.\n                  This callback should parse a session ticket as generated\n                  by the corresponding mbedtls_ssl_ticket_write_t function,\n                  and, if the ticket is authentic and valid, load the\n                  session.\n\n \\note            The implementation is allowed to modify the first len\n                  bytes of the input buffer, eg to use it as a temporary\n                  area for the decrypted ticket contents.\n\n \\param p_ticket  Context for the callback\n \\param session   SSL session to be loaded\n \\param buf       Start of the buffer containing the ticket\n \\param len       Length of the ticket.\n\n \\return          0 if successful, or\n                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or\n                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or\n                  any other non-zero code for other failures."]
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ::core::ffi::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " \\brief           Configure SSL session ticket callbacks (server only).\n                  (Default: none.)\n\n \\note            On server, session tickets are enabled by providing\n                  non-NULL callbacks.\n\n \\note            On client, use \\c mbedtls_ssl_conf_session_tickets().\n\n \\param conf      SSL configuration context\n \\param f_ticket_write    Callback for writing a ticket\n \\param f_ticket_parse    Callback for parsing a ticket\n \\param p_ticket          Context shared by the two callbacks"]
    pub fn mbedtls_ssl_conf_session_tickets_cb(
        conf: *mut mbedtls_ssl_config,
        f_ticket_write: mbedtls_ssl_ticket_write_t,
        f_ticket_parse: mbedtls_ssl_ticket_parse_t,
        p_ticket: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief   Configure a key export callback.\n          (Default: none.)\n\n          This API can be used for two purposes:\n          - Debugging: Use this API to e.g. generate an NSSKeylog\n            file and use it to inspect encrypted traffic in tools\n            such as Wireshark.\n          - Application-specific export: Use this API to implement\n            key exporters, e.g. for EAP-TLS or DTLS-SRTP.\n\n\n \\param ssl            The SSL context to which the export\n                       callback should be attached.\n \\param f_export_keys  The callback for the key export.\n \\param p_export_keys  The opaque context pointer to be passed to the\n                       callback \\p f_export_keys."]
    pub fn mbedtls_ssl_set_export_keys_cb(
        ssl: *mut mbedtls_ssl_context,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut ::core::ffi::c_void,
    );
}
#[doc = " \\brief          Callback type: generate a cookie\n\n \\param ctx      Context for the callback\n \\param p        Buffer to write to,\n                 must be updated to point right after the cookie\n \\param end      Pointer to one past the end of the output buffer\n \\param info     Client ID info that was passed to\n                 \\c mbedtls_ssl_set_client_transport_id()\n \\param ilen     Length of info in bytes\n\n \\return         The callback must return 0 on success,\n                 or a negative error code."]
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        p: *mut *mut ::core::ffi::c_uchar,
        end: *mut ::core::ffi::c_uchar,
        info: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief          Callback type: verify a cookie\n\n \\param ctx      Context for the callback\n \\param cookie   Cookie to verify\n \\param clen     Length of cookie\n \\param info     Client ID info that was passed to\n                 \\c mbedtls_ssl_set_client_transport_id()\n \\param ilen     Length of info in bytes\n\n \\return         The callback must return 0 if cookie is valid,\n                 or a negative error code."]
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        cookie: *const ::core::ffi::c_uchar,
        clen: usize,
        info: *const ::core::ffi::c_uchar,
        ilen: usize,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " \\brief          Set a limit on the number of records with a bad MAC\n                 before terminating the connection.\n                 (DTLS only, no effect on TLS.)\n                 Default: 0 (disabled).\n\n \\param conf     SSL configuration\n \\param limit    Limit, or 0 to disable.\n\n \\note           If the limit is N, then the connection is terminated when\n                 the Nth non-authentic record is seen.\n\n \\note           Records with an invalid header are not counted, only the\n                 ones going through the authentication-decryption phase.\n\n \\note           This is a security trade-off related to the fact that it's\n                 often relatively easy for an active attacker to inject UDP\n                 datagrams. On one hand, setting a low limit here makes it\n                 easier for such an attacker to forcibly terminated a\n                 connection. On the other hand, a high limit or no limit\n                 might make us waste resources checking authentication on\n                 many bogus packets."]
    pub fn mbedtls_ssl_conf_dtls_badmac_limit(
        conf: *mut mbedtls_ssl_config,
        limit: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set the session cache callbacks (server-side only)\n                 If not set, no session resuming is done (except if session\n                 tickets are enabled too).\n\n                 The session cache has the responsibility to check for stale\n                 entries based on timeout. See RFC 5246 for recommendations.\n\n                 Warning: session.peer_cert is cleared by the SSL/TLS layer on\n                 connection shutdown, so do not cache the pointer! Either set\n                 it to NULL or make a full copy of the certificate.\n\n                 The get callback is called once during the initial handshake\n                 to enable session resuming. The get function has the\n                 following parameters: (void *parameter, mbedtls_ssl_session *session)\n                 If a valid entry is found, it should fill the master of\n                 the session object with the cached values and return 0,\n                 return 1 otherwise. Optionally peer_cert can be set as well\n                 if it is properly present in cache entry.\n\n                 The set callback is called once during the initial handshake\n                 to enable session resuming after the entire handshake has\n                 been finished. The set function has the following parameters:\n                 (void *parameter, const mbedtls_ssl_session *session). The function\n                 should create a cache entry for future retrieval based on\n                 the data in the session structure and should keep in mind\n                 that the mbedtls_ssl_session object presented (and all its referenced\n                 data) is cleared by the SSL/TLS layer when the connection is\n                 terminated. It is recommended to add metadata to determine if\n                 an entry is still valid in the future. Return 0 if\n                 successfully cached, return 1 otherwise.\n\n \\param conf           SSL configuration\n \\param p_cache        parameter (context) for both callbacks\n \\param f_get_cache    session get callback\n \\param f_set_cache    session set callback"]
    pub fn mbedtls_ssl_conf_session_cache(
        conf: *mut mbedtls_ssl_config,
        p_cache: *mut ::core::ffi::c_void,
        f_get_cache: mbedtls_ssl_cache_get_t,
        f_set_cache: mbedtls_ssl_cache_set_t,
    );
}
extern "C" {
    #[doc = " \\brief          Load a session for session resumption.\n\n                 Sessions loaded through this call will be considered\n                 for session resumption in the next handshake.\n\n \\note           Even if this call succeeds, it is not guaranteed that\n                 the next handshake will indeed be shortened through the\n                 use of session resumption: The server is always free\n                 to reject any attempt for resumption and fall back to\n                 a full handshake.\n\n \\note           This function can handle a variety of mechanisms for session\n                 resumption: For TLS 1.2, both session ID-based resumption and\n                 ticket-based resumption will be considered. For TLS 1.3,\n                 once implemented, sessions equate to tickets, and loading\n                 one or more sessions via this call will lead to their\n                 corresponding tickets being advertised as resumption PSKs\n                 by the client.\n\n \\note           Calling this function multiple times will only be useful\n                 once TLS 1.3 is supported. For TLS 1.2 connections, this\n                 function should be called at most once.\n\n \\param ssl      The SSL context representing the connection which should\n                 be attempted to be setup using session resumption. This\n                 must be initialized via mbedtls_ssl_init() and bound to\n                 an SSL configuration via mbedtls_ssl_setup(), but\n                 the handshake must not yet have been started.\n \\param session  The session to be considered for session resumption.\n                 This must be a session previously exported via\n                 mbedtls_ssl_get_session(), and potentially serialized and\n                 deserialized through mbedtls_ssl_session_save() and\n                 mbedtls_ssl_session_load() in the meantime.\n\n \\return         \\c 0 if successful.\n \\return         \\c MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if the session\n                 could not be loaded because of an implementation limitation.\n                 This error is non-fatal, and has no observable effect on\n                 the SSL context or the session that was attempted to be loaded.\n \\return         Another negative error code on other kinds of failure.\n\n \\sa             mbedtls_ssl_get_session()\n \\sa             mbedtls_ssl_session_load()"]
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized session data into a session structure.\n                 On client, this can be used for loading saved sessions\n                 before resuming them with mbedtls_ssl_set_session().\n                 On server, this can be used for alternative implementations\n                 of session cache or session tickets.\n\n \\warning        If a peer certificate chain is associated with the session,\n                 the serialized state will only contain the peer's\n                 end-entity certificate and the result of the chain\n                 verification (unless verification was disabled), but not\n                 the rest of the chain.\n\n \\see            mbedtls_ssl_session_save()\n \\see            mbedtls_ssl_set_session()\n\n \\param session  The session structure to be populated. It must have been\n                 initialised with mbedtls_ssl_session_init() but not\n                 populated yet.\n \\param buf      The buffer holding the serialized session data. It must be a\n                 readable buffer of at least \\p len bytes.\n \\param len      The size of the serialized data in bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.\n \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data\n                 was generated in a different version or configuration of\n                 Mbed TLS.\n \\return         Another negative value for other kinds of errors (for\n                 example, unsupported features in the embedded certificate)."]
    pub fn mbedtls_ssl_session_load(
        session: *mut mbedtls_ssl_session,
        buf: *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Save session structure as serialized data in a buffer.\n                 On client, this can be used for saving session data,\n                 potentially in non-volatile storage, for resuming later.\n                 On server, this can be used for alternative implementations\n                 of session cache or session tickets.\n\n \\see            mbedtls_ssl_session_load()\n\n \\param session  The session structure to be saved.\n \\param buf      The buffer to write the serialized data to. It must be a\n                 writeable buffer of at least \\p len bytes, or may be \\c\n                 NULL if \\p len is \\c 0.\n \\param buf_len  The number of bytes available for writing in \\p buf.\n \\param olen     The size in bytes of the data that has been or would have\n                 been written. It must point to a valid \\c size_t.\n\n \\note           \\p olen is updated to the correct value regardless of\n                 whether \\p buf_len was large enough. This makes it possible\n                 to determine the necessary size by calling this function\n                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    pub fn mbedtls_ssl_session_save(
        session: *const mbedtls_ssl_session,
        buf: *mut ::core::ffi::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the preference\n                      order. First in the list has the highest preference.\n\n                      For TLS 1.2, the notion of ciphersuite determines both\n                      the key exchange mechanism and the suite of symmetric\n                      algorithms to be used during and after the handshake.\n\n                      For TLS 1.3 (in development), the notion of ciphersuite\n                      only determines the suite of symmetric algorithms to be\n                      used during and after the handshake, while key exchange\n                      mechanisms are configured separately.\n\n                      In Mbed TLS, ciphersuites for both TLS 1.2 and TLS 1.3\n                      are configured via this function. For users of TLS 1.3,\n                      there will be separate API for the configuration of key\n                      exchange mechanisms.\n\n                      The list of ciphersuites passed to this function may\n                      contain a mixture of TLS 1.2 and TLS 1.3 ciphersuite\n                      identifiers. This is useful if negotiation of TLS 1.3\n                      should be attempted, but a fallback to TLS 1.2 would\n                      be tolerated.\n\n \\note                By default, the server chooses its preferred\n                      ciphersuite among those that the client supports. If\n                      mbedtls_ssl_conf_preference_order() is called to prefer\n                      the client's preferences, the server instead chooses\n                      the client's preferred ciphersuite among those that\n                      the server supports.\n\n \\warning             The ciphersuites array \\p ciphersuites is not copied.\n                      It must remain valid for the lifetime of the SSL\n                      configuration \\p conf.\n\n \\param conf          The SSL configuration to modify.\n \\param ciphersuites  A 0-terminated list of IANA identifiers of supported\n                      ciphersuites, accessible through \\c MBEDTLS_TLS_XXX\n                      and \\c MBEDTLS_TLS1_3_XXX macros defined in\n                      ssl_ciphersuites.h."]
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the X.509 security profile used for verification\n\n \\note           The restrictions are enforced for all certificates in the\n                 chain. However, signatures in the handshake are not covered\n                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes().\n\n \\param conf     SSL configuration\n \\param profile  Profile to use"]
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate\n\n \\note           See \\c mbedtls_x509_crt_verify() for notes regarding the\n                 parameters ca_chain (maps to trust_ca for that function)\n                 and ca_crl.\n\n \\param conf     SSL configuration\n \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set own certificate chain and private key\n\n \\note           own_cert should contain in order from the bottom up your\n                 certificate chain. The top certificate (self-signed)\n                 can be omitted.\n\n \\note           On server, this function can be called multiple times to\n                 provision more than one cert/key pair (eg one ECDSA, one\n                 RSA with SHA-256, one RSA with SHA-1). An adequate\n                 certificate will be selected according to the client's\n                 advertised capabilities. In case multiple certificates are\n                 adequate, preference is given to the one set by the first\n                 call to this function, then second, etc.\n\n \\note           On client, only the first call has any effect. That is,\n                 only one client certificate can be provisioned. The\n                 server's preferences in its CertificateRequest message will\n                 be ignored and our only cert will be sent regardless of\n                 whether it matches those preferences - the server can then\n                 decide what it wants to do with it.\n\n \\note           The provided \\p pk_key needs to match the public key in the\n                 first certificate in \\p own_cert, or all handshakes using\n                 that certificate will fail. It is your responsibility\n                 to ensure that; this function will not perform any check.\n                 You may use mbedtls_pk_check_pair() in order to perform\n                 this check yourself, but be aware that this function can\n                 be computationally expensive on some key types.\n\n \\param conf     SSL configuration\n \\param own_cert own public certificate chain\n \\param pk_key   own private key\n\n \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the allowed groups in order of preference.\n\n                 On server: This only affects the choice of key agreement mechanism\n\n                 On client: this affects the list of groups offered for any\n                 use. The server can override our preference order.\n\n                 Both sides: limits the set of groups accepted for use in\n                 key sharing.\n\n \\note           This function replaces the deprecated mbedtls_ssl_conf_curves(),\n                 which only allows ECP curves to be configured.\n\n \\note           The most recent invocation of either mbedtls_ssl_conf_curves()\n                 or mbedtls_ssl_conf_groups() nullifies all previous invocations\n                 of both.\n\n \\note           This list should be ordered by decreasing preference\n                 (preferred group first).\n\n \\note           When this function is not called, a default list is used,\n                 consisting of all supported curves at 255 bits and above,\n                 and all supported finite fields at 2048 bits and above.\n                 The order favors groups with the lowest resource usage.\n\n \\note           New minor versions of Mbed TLS will not remove items\n                 from the default list unless serious security concerns require it.\n                 New minor versions of Mbed TLS may change the order in\n                 keeping with the general principle of favoring the lowest\n                 resource usage.\n\n \\param conf     SSL configuration\n \\param groups   List of allowed groups ordered by preference, terminated by 0.\n                 Must contain valid IANA NamedGroup IDs (provided via either an integer\n                 or using MBEDTLS_TLS1_3_NAMED_GROUP_XXX macros)."]
    pub fn mbedtls_ssl_conf_groups(conf: *mut mbedtls_ssl_config, groups: *const u16);
}
extern "C" {
    #[doc = " \\brief          Configure allowed signature algorithms for use in TLS 1.3\n\n \\param conf     The SSL configuration to use.\n \\param sig_algs List of allowed IANA values for TLS 1.3 signature algorithms,\n                 terminated by \\c MBEDTLS_TLS1_3_SIG_NONE. The list must remain\n                 available throughout the lifetime of the conf object. Supported\n                 values are available as \\c MBEDTLS_TLS1_3_SIG_XXXX"]
    pub fn mbedtls_ssl_conf_sig_algs(conf: *mut mbedtls_ssl_config, sig_algs: *const u16);
}
extern "C" {
    #[doc = " \\brief          Set or reset the hostname to check against the received\n                 server certificate. It sets the ServerName TLS extension,\n                 too, if that extension is enabled. (client-side only)\n\n \\param ssl      SSL context\n \\param hostname the server hostname, may be NULL to clear hostname\n\n \\note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN.\n\n \\return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on\n                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on\n                 too long input hostname.\n\n                 Hostname set to the one provided on success (cleared\n                 when NULL). On allocation failure hostname is cleared.\n                 On too long input failure, old hostname is unchanged."]
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Retrieve SNI extension value for the current handshake.\n                 Available in \\p f_cert_cb of \\c mbedtls_ssl_conf_cert_cb(),\n                 this is the same value passed to \\p f_sni callback of\n                 \\c mbedtls_ssl_conf_sni() and may be used instead of\n                 \\c mbedtls_ssl_conf_sni().\n\n \\param ssl      SSL context\n \\param name_len pointer into which to store length of returned value.\n                 0 if SNI extension is not present or not yet processed.\n\n \\return         const pointer to SNI extension value.\n                 - value is valid only when called in \\p f_cert_cb\n                   registered with \\c mbedtls_ssl_conf_cert_cb().\n                 - value is NULL if SNI extension is not present.\n                 - value is not '\\0'-terminated.  Use \\c name_len for len.\n                 - value must not be freed."]
    pub fn mbedtls_ssl_get_hs_sni(
        ssl: *mut mbedtls_ssl_context,
        name_len: *mut usize,
    ) -> *const ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\brief          Set own certificate and key for the current handshake\n\n \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\note           Passing null \\c own_cert clears the certificate list for\n                 the current handshake.\n\n \\param ssl      SSL context\n \\param own_cert own public certificate chain\n \\param pk_key   own private key\n\n \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate for the\n                 current handshake\n\n \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set DN hints sent to client in CertificateRequest message\n\n \\note           Same as \\c mbedtls_ssl_conf_dn_hints() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param crt      crt chain whose subject DNs are issuer DNs of client certs\n                 from which the client should select client peer certificate."]
    pub fn mbedtls_ssl_set_hs_dn_hints(ssl: *mut mbedtls_ssl_context, crt: *const mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Set authmode for the current handshake.\n\n \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or\n                 MBEDTLS_SSL_VERIFY_REQUIRED"]
    pub fn mbedtls_ssl_set_hs_authmode(ssl: *mut mbedtls_ssl_context, authmode: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " \\brief          Set server side ServerName TLS extension callback\n                 (optional, server-side only).\n\n                 If set, the ServerName callback is called whenever the\n                 server receives a ServerName TLS extension from the client\n                 during a handshake. The ServerName callback has the\n                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,\n                 const unsigned char *hostname, size_t len). If a suitable\n                 certificate is found, the callback must set the\n                 certificate(s) and key(s) to use with \\c\n                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),\n                 and may optionally adjust the CA and associated CRL with \\c\n                 mbedtls_ssl_set_hs_ca_chain() as well as the client\n                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),\n                 then must return 0. If no matching name is found, the\n                 callback may return non-zero to abort the handshake.\n\n \\param conf     SSL configuration\n \\param f_sni    verification function\n \\param p_sni    verification parameter"]
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const ::core::ffi::c_uchar,
                arg4: usize,
            ) -> ::core::ffi::c_int,
        >,
        p_sni: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the supported Application Layer Protocols.\n\n \\param conf     SSL configuration\n \\param protos   Pointer to a NULL-terminated list of supported protocols,\n                 in decreasing preference order. The pointer to the list is\n                 recorded by the library for later reference as required, so\n                 the lifetime of the table must be at least as long as the\n                 lifetime of the SSL configuration structure.\n\n \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA."]
    pub fn mbedtls_ssl_conf_alpn_protocols(
        conf: *mut mbedtls_ssl_config,
        protos: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Get the name of the negotiated Application Layer Protocol.\n                 This function should be called after the handshake is\n                 completed.\n\n \\param ssl      SSL context\n\n \\return         Protocol name, or NULL if no protocol was negotiated."]
    pub fn mbedtls_ssl_get_alpn_protocol(
        ssl: *const mbedtls_ssl_context,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief           Enable or disable Encrypt-then-MAC\n                  (Default: MBEDTLS_SSL_ETM_ENABLED)\n\n \\note            This should always be enabled, it is a security\n                  improvement, and should not cause any interoperability\n                  issue (used only if the peer supports it too).\n\n \\param conf      SSL configuration\n \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED"]
    pub fn mbedtls_ssl_conf_encrypt_then_mac(
        conf: *mut mbedtls_ssl_config,
        etm: ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " \\brief           Enable or disable Extended Master Secret negotiation.\n                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)\n\n \\note            This should always be enabled, it is a security fix to the\n                  protocol, and should not cause any interoperability issue\n                  (used only if the peer supports it too).\n\n \\param conf      SSL configuration\n \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED"]
    pub fn mbedtls_ssl_conf_extended_master_secret(
        conf: *mut mbedtls_ssl_config,
        ems: ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Whether to send a list of acceptable CAs in\n                 CertificateRequest messages.\n                 (Default: do send)\n\n \\param conf     SSL configuration\n \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or\n                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED"]
    pub fn mbedtls_ssl_conf_cert_req_ca_list(
        conf: *mut mbedtls_ssl_config,
        cert_req_ca_list: ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set the maximum fragment length to emit and/or negotiate.\n                 (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and\n                 #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)\n                 (Server: set maximum fragment length to emit,\n                 usually negotiated by the client during handshake)\n                 (Client: set maximum fragment length to emit *and*\n                 negotiate with the server during handshake)\n                 (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)\n\n \\note           On the client side, the maximum fragment length extension\n                 *will not* be used, unless the maximum fragment length has\n                 been set via this function to a value different than\n                 #MBEDTLS_SSL_MAX_FRAG_LEN_NONE.\n\n \\note           With TLS, this currently only affects ApplicationData (sent\n                 with \\c mbedtls_ssl_read()), not handshake messages.\n                 With DTLS, this affects both ApplicationData and handshake.\n\n \\note           This sets the maximum length for a record's payload,\n                 excluding record overhead that will be added to it, see\n                 \\c mbedtls_ssl_get_record_expansion().\n\n \\note           For DTLS, it is also possible to set a limit for the total\n                 size of datagrams passed to the transport layer, including\n                 record overhead, see \\c mbedtls_ssl_set_mtu().\n\n \\param conf     SSL configuration\n \\param mfl_code Code for maximum fragment length (allowed values:\n                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,\n                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)\n\n \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA"]
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Pick the ciphersuites order according to the second parameter\n                 in the SSL Server module (MBEDTLS_SSL_SRV_C).\n                 (Default, if never called: MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER)\n\n \\param conf     SSL configuration\n \\param order    Server or client (MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER\n                                or MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT)"]
    pub fn mbedtls_ssl_conf_preference_order(
        conf: *mut mbedtls_ssl_config,
        order: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enable / Disable session tickets (client only).\n                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)\n\n \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb().\n\n \\param conf     SSL configuration\n \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or\n                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)"]
    pub fn mbedtls_ssl_conf_session_tickets(
        conf: *mut mbedtls_ssl_config,
        use_tickets: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enable / Disable renegotiation support for connection when\n                 initiated by peer\n                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n\n \\warning        It is recommended to always disable renegotiation unless you\n                 know you need it and you know what you're doing. In the\n                 past, there have been several issues associated with\n                 renegotiation or a poor understanding of its properties.\n\n \\note           Server-side, enabling renegotiation also makes the server\n                 susceptible to a resource DoS by a malicious client.\n\n \\param conf    SSL configuration\n \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or\n                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    pub fn mbedtls_ssl_conf_renegotiation(
        conf: *mut mbedtls_ssl_config,
        renegotiation: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Prevent or allow legacy renegotiation.\n                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)\n\n                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to\n                 be established even if the peer does not support\n                 secure renegotiation, but does not allow renegotiation\n                 to take place if not secure.\n                 (Interoperable and secure option)\n\n                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations\n                 with non-upgraded peers. Allowing legacy renegotiation\n                 makes the connection vulnerable to specific man in the\n                 middle attacks. (See RFC 5746)\n                 (Most interoperable and least secure option)\n\n                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections\n                 if peer does not support secure renegotiation. Results\n                 in interoperability issues with non-upgraded peers\n                 that do not support renegotiation altogether.\n                 (Most secure option, interoperability issues)\n\n \\param conf     SSL configuration\n \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,\n                                        SSL_ALLOW_LEGACY_RENEGOTIATION or\n                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)"]
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enforce renegotiation requests.\n                 (Default: enforced, max_records = 16)\n\n                 When we request a renegotiation, the peer can comply or\n                 ignore the request. This function allows us to decide\n                 whether to enforce our renegotiation requests by closing\n                 the connection if the peer doesn't comply.\n\n                 However, records could already be in transit from the peer\n                 when the request is emitted. In order to increase\n                 reliability, we can accept a number of records before the\n                 expected handshake records.\n\n                 The optimal value is highly dependent on the specific usage\n                 scenario.\n\n \\note           With DTLS and server-initiated renegotiation, the\n                 HelloRequest is retransmitted every time mbedtls_ssl_read() times\n                 out or receives Application Data, until:\n                 - max_records records have beens seen, if it is >= 0, or\n                 - the number of retransmits that would happen during an\n                 actual handshake has been reached.\n                 Please remember the request might be lost a few times\n                 if you consider setting max_records to a really low value.\n\n \\warning        On client, the grace period can only happen during\n                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()\n                 which always behave as if max_record was 0. The reason is,\n                 if we receive application data from the server, we need a\n                 place to write it, which only happens during mbedtls_ssl_read().\n\n \\param conf     SSL configuration\n \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to\n                 enforce renegotiation, or a non-negative value to enforce\n                 it but allow for a grace period of max_records records."]
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set record counter threshold for periodic renegotiation.\n                 (Default: 2^48 - 1)\n\n                 Renegotiation is automatically triggered when a record\n                 counter (outgoing or incoming) crosses the defined\n                 threshold. The default value is meant to prevent the\n                 connection from being closed when the counter is about to\n                 reached its maximal value (it is not allowed to wrap).\n\n                 Lower values can be used to enforce policies such as \"keys\n                 must be refreshed every N packets with cipher X\".\n\n                 The renegotiation period can be disabled by setting\n                 conf->disable_renegotiation to\n                 MBEDTLS_SSL_RENEGOTIATION_DISABLED.\n\n \\note           When the configured transport is\n                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation\n                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,\n                 the maximum renegotiation period is 2^64 - 1.\n\n \\param conf     SSL configuration\n \\param period   The threshold value: a big-endian 64-bit number."]
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Check if there is data already read from the\n                 underlying transport but not yet processed.\n\n \\param ssl      SSL context\n\n \\return         0 if nothing's pending, 1 otherwise.\n\n \\note           This is different in purpose and behaviour from\n                 \\c mbedtls_ssl_get_bytes_avail in that it considers\n                 any kind of unprocessed data, not only unread\n                 application data. If \\c mbedtls_ssl_get_bytes\n                 returns a non-zero value, this function will\n                 also signal pending data, but the converse does\n                 not hold. For example, in DTLS there might be\n                 further records waiting to be processed from\n                 the current underlying transport's datagram.\n\n \\note           If this function returns 1 (data pending), this\n                 does not imply that a subsequent call to\n                 \\c mbedtls_ssl_read will provide any data;\n                 e.g., the unprocessed data might turn out\n                 to be an alert or a handshake message.\n\n \\note           This function is useful in the following situation:\n                 If the SSL/TLS module successfully returns from an\n                 operation - e.g. a handshake or an application record\n                 read - and you're awaiting incoming data next, you\n                 must not immediately idle on the underlying transport\n                 to have data ready, but you need to check the value\n                 of this function first. The reason is that the desired\n                 data might already be read but not yet processed.\n                 If, in contrast, a previous call to the SSL/TLS module\n                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary\n                 to call this function, as the latter error code entails\n                 that all internal data has been processed.\n"]
    pub fn mbedtls_ssl_check_pending(ssl: *const mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of application data bytes\n                 remaining to be read from the current record.\n\n \\param ssl      SSL context\n\n \\return         How many bytes are available in the application\n                 data record read buffer.\n\n \\note           When working over a datagram transport, this is\n                 useful to detect the current datagram's boundary\n                 in case \\c mbedtls_ssl_read has written the maximal\n                 amount of data fitting into the input buffer.\n"]
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the result of the certificate verification\n\n \\param ssl      The SSL context to use.\n\n \\return         \\c 0 if the certificate verification was successful.\n \\return         \\c -1u if the result is not available. This may happen\n                 e.g. if the handshake aborts early, or a verification\n                 callback returned a fatal error.\n \\return         A bitwise combination of \\c MBEDTLS_X509_BADCERT_XXX\n                 and \\c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h."]
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    #[doc = " \\brief          Return the id of the current ciphersuite\n\n \\param ssl      SSL context\n\n \\return         a ciphersuite id"]
    pub fn mbedtls_ssl_get_ciphersuite_id_from_ssl(
        ssl: *const mbedtls_ssl_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the name of the current ciphersuite\n\n \\param ssl      SSL context\n\n \\return         a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite(
        ssl: *const mbedtls_ssl_context,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the current TLS version\n\n \\param ssl      SSL context\n\n \\return         a string containing the TLS version"]
    pub fn mbedtls_ssl_get_version(ssl: *const mbedtls_ssl_context) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the (maximum) number of bytes added by the record\n                 layer: header + encryption/MAC overhead (inc. padding)\n\n \\param ssl      SSL context\n\n \\return         Current maximum record expansion in bytes"]
    pub fn mbedtls_ssl_get_record_expansion(ssl: *const mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum outgoing record payload in bytes.\n\n \\note           The logic to determine the maximum outgoing record payload is\n                 version-specific. It takes into account various factors, such as\n                 the mbedtls_config.h setting \\c MBEDTLS_SSL_OUT_CONTENT_LEN, extensions\n                 such as the max fragment length or record size limit extension if\n                 used, and for DTLS the path MTU as configured and current\n                 record expansion.\n\n \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if\n                 called with a larger length value.\n                 With TLS, \\c mbedtls_ssl_write() will fragment the input if\n                 necessary and return the number of bytes written; it is up\n                 to the caller to call \\c mbedtls_ssl_write() again in\n                 order to send the remaining bytes if any.\n\n \\sa             mbedtls_ssl_get_max_out_record_payload()\n \\sa             mbedtls_ssl_get_record_expansion()\n\n \\param ssl      SSL context\n\n \\return         Current maximum payload for an outgoing record,\n                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_out_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum incoming record payload in bytes.\n\n \\note           The logic to determine the maximum outgoing record payload is\n                 version-specific. It takes into account various factors, such as\n                 the mbedtls_config.h setting \\c MBEDTLS_SSL_IN_CONTENT_LEN, extensions\n                 such as the max fragment length extension or record size limit\n                 extension if used, and the current record expansion.\n\n \\sa             mbedtls_ssl_set_mtu()\n \\sa             mbedtls_ssl_get_max_in_record_payload()\n \\sa             mbedtls_ssl_get_record_expansion()\n\n \\param ssl      SSL context\n\n \\return         Current maximum payload for an outgoing record,\n                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_in_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the peer certificate from the current connection.\n\n \\param  ssl     The SSL context to use. This must be initialized and setup.\n\n \\return         The current peer certificate, if available.\n                 The returned certificate is owned by the SSL context and\n                 is valid only until the next call to the SSL API.\n \\return         \\c NULL if no peer certificate is available. This might\n                 be because the chosen ciphersuite doesn't use CRTs\n                 (PSK-based ciphersuites, for example), or because\n                 #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,\n                 allowing the stack to free the peer's CRT to save memory.\n\n \\note           For one-time inspection of the peer's certificate during\n                 the handshake, consider registering an X.509 CRT verification\n                 callback through mbedtls_ssl_conf_verify() instead of calling\n                 this function. Using mbedtls_ssl_conf_verify() also comes at\n                 the benefit of allowing you to influence the verification\n                 process, for example by masking expected and tolerated\n                 verification failures.\n\n \\warning        You must not use the pointer returned by this function\n                 after any further call to the SSL API, including\n                 mbedtls_ssl_read() and mbedtls_ssl_write(); this is\n                 because the pointer might change during renegotiation,\n                 which happens transparently to the user.\n                 If you want to use the certificate across API calls,\n                 you must make a copy."]
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    #[doc = " \\brief          Export a session in order to resume it later.\n\n \\param ssl      The SSL context representing the connection for which to\n                 to export a session structure for later resumption.\n \\param session  The target structure in which to store the exported session.\n                 This must have been initialized with mbedtls_ssl_init_session()\n                 but otherwise be unused.\n\n \\note           This function can handle a variety of mechanisms for session\n                 resumption: For TLS 1.2, both session ID-based resumption and\n                 ticket-based resumption will be considered. For TLS 1.3,\n                 once implemented, sessions equate to tickets, and calling\n                 this function multiple times will export the available\n                 tickets one a time until no further tickets are available,\n                 in which case MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE will\n                 be returned.\n\n \\note           Calling this function multiple times will only be useful\n                 once TLS 1.3 is supported. For TLS 1.2 connections, this\n                 function should be called at most once.\n\n \\return         \\c 0 if successful. In this case, \\p session can be used for\n                 session resumption by passing it to mbedtls_ssl_set_session(),\n                 and serialized for storage via mbedtls_ssl_session_save().\n \\return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no further session\n                 is available for export.\n                 This error is a non-fatal, and has no observable effect on\n                 the SSL context or the destination session.\n \\return         Another negative error code on other kinds of failure.\n\n \\sa             mbedtls_ssl_set_session()\n \\sa             mbedtls_ssl_session_save()"]
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform the SSL handshake\n\n \\param ssl      SSL context\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use\n                 and the client did not demonstrate reachability yet - in\n                 this case you must stop using the context (see below).\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           If DTLS is in use, then you may choose to handle\n                 #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging\n                 purposes, as it is an expected return value rather than an\n                 actual error, but you still need to reset/free the context.\n\n \\note           Remarks regarding event-driven DTLS:\n                 If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram\n                 from the underlying transport layer is currently being processed,\n                 and it is safe to idle until the timer or the underlying transport\n                 signal a new event. This is not true for a successful handshake,\n                 in which case the datagram of the underlying transport that is\n                 currently being processed might or might not contain further\n                 DTLS records."]
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a single step of the SSL handshake\n\n \\note           The state of the context (ssl->state) will be at\n                 the next state after this function returns \\c 0. Do not\n                 call this function if mbedtls_ssl_is_handshake_over()\n                 returns \\c 1.\n\n \\warning        Whilst in the past you may have used direct access to the\n                 context state (ssl->state) in order to ascertain when to\n                 stop calling this function and although you can still do\n                 so with something like ssl->MBEDTLS_PRIVATE(state) or by\n                 defining MBEDTLS_ALLOW_PRIVATE_ACCESS, this is now\n                 considered deprecated and could be broken in any future\n                 release. If you still find you have good reason for such\n                 direct access, then please do contact the team to explain\n                 this (raise an issue or post to the mailing list), so that\n                 we can add a solution to your problem that will be\n                 guaranteed to work in the future.\n\n \\param ssl      SSL context\n\n \\return         See mbedtls_ssl_handshake().\n\n \\warning        If this function returns something other than \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using\n                 the SSL context for reading or writing, and either free it\n                 or call \\c mbedtls_ssl_session_reset() on it before\n                 re-using it for a new connection; the current connection\n                 must be closed."]
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Initiate an SSL renegotiation on the running connection.\n                 Client: perform the renegotiation right now.\n                 Server: request renegotiation, which will be performed\n                 during the next call to mbedtls_ssl_read() if honored by\n                 client.\n\n \\param ssl      SSL context\n\n \\return         0 if successful, or any mbedtls_ssl_handshake() return\n                 value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't\n                 happen during a renegotiation.\n\n \\warning        If this function returns something other than \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using\n                 the SSL context for reading or writing, and either free it\n                 or call \\c mbedtls_ssl_session_reset() on it before\n                 re-using it for a new connection; the current connection\n                 must be closed.\n"]
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' application data bytes\n\n \\param ssl      SSL context\n \\param buf      buffer that will hold the data\n \\param len      maximum number of bytes to read\n\n \\return         The (positive) number of bytes read if successful.\n \\return         \\c 0 if the read end of the underlying transport was closed\n                 without sending a CloseNotify beforehand, which might happen\n                 because of various reasons (internal error of an underlying\n                 stack, non-conformant peer not sending a CloseNotify and\n                 such) - in this case you must stop using the context\n                 (see below).\n \\return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying\n                 transport is still functional, but the peer has\n                 acknowledged to not send anything anymore.\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server\n                 side of a DTLS connection and the client is initiating a\n                 new connection using the same source port. See below.\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 a positive value,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CLIENT_RECONNECT,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT\n                 (which can only happen server-side), it means that a client\n                 is initiating a new connection using the same source port.\n                 You can either treat that as a connection close and wait\n                 for the client to resend a ClientHello, or directly\n                 continue with \\c mbedtls_ssl_handshake() with the same\n                 context (as it has been reset internally). Either way, you\n                 must make sure this is seen by the application as a new\n                 connection: application state, if any, should be reset, and\n                 most importantly the identity of the client must be checked\n                 again. WARNING: not validating the identity of the client\n                 again, or not transmitting the new identity to the\n                 application layer, would allow authentication bypass!\n\n \\note           Remarks regarding event-driven DTLS:\n                 - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram\n                   from the underlying transport layer is currently being processed,\n                   and it is safe to idle until the timer or the underlying transport\n                   signal a new event.\n                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was\n                   initially available on the underlying transport, as this data may have\n                   been only e.g. duplicated messages or a renegotiation request.\n                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even\n                   when reacting to an incoming-data event from the underlying transport.\n                 - On success, the datagram of the underlying transport that is currently\n                   being processed may contain further DTLS records. You should call\n                   \\c mbedtls_ssl_check_pending to check for remaining records.\n"]
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Try to write exactly 'len' application data bytes\n\n \\warning        This function will do partial writes in some cases. If the\n                 return value is non-negative but less than length, the\n                 function must be called again with updated arguments:\n                 buf + ret, len - ret (if ret is the return value) until\n                 it returns a value equal to the last 'len' argument.\n\n \\param ssl      SSL context\n \\param buf      buffer holding the data\n \\param len      how many bytes must be written\n\n \\return         The (non-negative) number of bytes actually written if\n                 successful (may be less than \\p len).\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 a non-negative value,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,\n                 it must be called later with the *same* arguments,\n                 until it returns a value greater than or equal to 0. When\n                 the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be\n                 some partial data in the output buffer, however this is not\n                 yet sent.\n\n \\note           If the requested length is greater than the maximum\n                 fragment length (either the built-in limit or the one set\n                 or negotiated with the peer), then:\n                 - with TLS, less bytes than requested are written.\n                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.\n                 \\c mbedtls_ssl_get_max_out_record_payload() may be used to\n                 query the active maximum fragment length.\n\n \\note           Attempting to write 0 bytes will result in an empty TLS\n                 application record being sent."]
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const ::core::ffi::c_uchar,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief           Send an alert message\n\n \\param ssl       SSL context\n \\param level     The alert level of the message\n                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)\n \\param message   The alert message (SSL_ALERT_MSG_*)\n\n \\return          0 if successful, or a specific SSL error code.\n\n \\note           If this function returns something other than 0 or\n                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using\n                 the SSL context for reading or writing, and either free it or\n                 call \\c mbedtls_ssl_session_reset() on it before re-using it\n                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: ::core::ffi::c_uchar,
        message: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Notify the peer that the connection is being closed\n\n \\param ssl      SSL context\n\n \\return          0 if successful, or a specific SSL error code.\n\n \\note           If this function returns something other than 0 or\n                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using\n                 the SSL context for reading or writing, and either free it or\n                 call \\c mbedtls_ssl_session_reset() on it before re-using it\n                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL context and clear memory\n\n \\param ssl      SSL context"]
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL configuration context\n                 Just makes the context ready for\n                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().\n\n \\note           You need to call mbedtls_ssl_config_defaults() unless you\n                 manually set all of the relevant fields yourself.\n\n \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Load reasonable default SSL configuration values.\n                 (You need to call mbedtls_ssl_config_init() first.)\n\n \\param conf     SSL configuration context\n \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or\n                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS\n \\param preset   a MBEDTLS_SSL_PRESET_XXX value\n\n \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS.\n\n \\return         0 if successful, or\n                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error."]
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: ::core::ffi::c_int,
        transport: ::core::ffi::c_int,
        preset: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief          Free an SSL configuration context\n\n \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Initialize SSL session structure\n\n \\param session  SSL session"]
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL session including the\n                 peer certificate and clear memory\n\n \\note           A session object can be freed even if the SSL context\n                 that was used to retrieve the session is still in use.\n\n \\param session  SSL session"]
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          TLS-PRF function for key derivation.\n\n \\param prf      The tls_prf type function type to be used.\n \\param secret   Secret for the key derivation function.\n \\param slen     Length of the secret.\n \\param label    String label for the key derivation function,\n                 terminated with null character.\n \\param random   Random bytes.\n \\param rlen     Length of the random bytes buffer.\n \\param dstbuf   The buffer holding the derived key.\n \\param dlen     Length of the output buffer.\n\n \\return         0 on success. An SSL specific error on failure."]
    pub fn mbedtls_ssl_tls_prf(
        prf: mbedtls_tls_prf_types,
        secret: *const ::core::ffi::c_uchar,
        slen: usize,
        label: *const ::core::ffi::c_char,
        random: *const ::core::ffi::c_uchar,
        rlen: usize,
        dstbuf: *mut ::core::ffi::c_uchar,
        dlen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Attach and enable use of a bundle for certificate verification\n\n Attach and enable use of a bundle for certificate verification through a verification callback.\n If no specific bundle has been set through esp_crt_bundle_set() it will default to the\n bundle defined in menuconfig and embedded in the binary.\n\n @param[in]  conf      The config struct for the SSL connection.\n\n @return\n             - ESP_OK  if adding certificates was successful.\n             - Other   if an error occured or an action must be taken by the calling process."]
    pub fn esp_crt_bundle_attach(conf: *mut ::core::ffi::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Disable and dealloc the certification bundle\n\n Removes the certificate verification callback and deallocates used resources\n\n @param[in]  conf      The config struct for the SSL connection."]
    pub fn esp_crt_bundle_detach(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " @brief      Set the default certificate bundle used for verification\n\n Overrides the default certificate bundle only in case of successful initialization. In most use cases the bundle should be\n set through menuconfig. The bundle needs to be sorted by subject name since binary search is\n used to find certificates.\n\n @param[in]  x509_bundle     A pointer to the certificate bundle.\n\n @param[in]  bundle_size     Size of the certificate bundle in bytes.\n\n @return\n             - ESP_OK  if adding certificates was successful.\n             - Other   if an error occured or an action must be taken by the calling process."]
    pub fn esp_crt_bundle_set(x509_bundle: *const u8, bundle_size: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " \\brief Translate a mbed TLS error code into a string representation,\n        Result is truncated if necessary and always includes a terminating\n        null byte.\n\n \\param errnum    error code\n \\param buffer    buffer to place representation in\n \\param buflen    length of the buffer"]
    pub fn mbedtls_strerror(
        errnum: ::core::ffi::c_int,
        buffer: *mut ::core::ffi::c_char,
        buflen: usize,
    );
}
extern "C" {
    #[doc = " \\brief Translate the high-level part of an Mbed TLS error code into a string\n        representation.\n\n This function returns a const pointer to an un-modifiable string. The caller\n must not try to modify the string. It is intended to be used mostly for\n logging purposes.\n\n \\param error_code    error code\n\n \\return The string representation of the error code, or \\c NULL if the error\n         code is unknown."]
    pub fn mbedtls_high_level_strerr(error_code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\brief Translate the low-level part of an Mbed TLS error code into a string\n        representation.\n\n This function returns a const pointer to an un-modifiable string. The caller\n must not try to modify the string. It is intended to be used mostly for\n logging purposes.\n\n \\param error_code    error code\n\n \\return The string representation of the error code, or \\c NULL if the error\n         code is unknown."]
    pub fn mbedtls_low_level_strerr(error_code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_UNKNOWN: esp_tls_error_type_t = 0;
#[doc = "< System error -- errno"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_SYSTEM: esp_tls_error_type_t = 1;
#[doc = "< Error code from mbedTLS library"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_MBEDTLS: esp_tls_error_type_t = 2;
#[doc = "< Certificate flags defined in mbedTLS"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_MBEDTLS_CERT_FLAGS: esp_tls_error_type_t = 3;
#[doc = "< ESP-IDF error type -- esp_err_t"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_ESP: esp_tls_error_type_t = 4;
#[doc = "< Error code from wolfSSL library"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_WOLFSSL: esp_tls_error_type_t = 5;
#[doc = "< Certificate flags defined in wolfSSL"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_WOLFSSL_CERT_FLAGS: esp_tls_error_type_t = 6;
#[doc = "< Last err type -- invalid entry"]
pub const esp_tls_error_type_t_ESP_TLS_ERR_TYPE_MAX: esp_tls_error_type_t = 7;
#[doc = " Definition of different types/sources of error codes reported\n from different components"]
pub type esp_tls_error_type_t = ::core::ffi::c_uint;
pub type esp_tls_error_handle_t = *mut esp_tls_last_error;
#[doc = "  @brief Error structure containing relevant errors in case tls error occurred"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_tls_last_error {
    #[doc = "< error code (based on ESP_ERR_ESP_TLS_BASE) of the last occurred error"]
    pub last_error: esp_err_t,
    #[doc = "< esp_tls error code from last esp_tls failed api"]
    pub esp_tls_error_code: ::core::ffi::c_int,
    #[doc = "< last certification verification flags"]
    pub esp_tls_flags: ::core::ffi::c_int,
}
#[doc = "  @brief Error structure containing relevant errors in case tls error occurred"]
pub type esp_tls_last_error_t = esp_tls_last_error;
pub const esp_tls_conn_state_ESP_TLS_INIT: esp_tls_conn_state = 0;
pub const esp_tls_conn_state_ESP_TLS_CONNECTING: esp_tls_conn_state = 1;
pub const esp_tls_conn_state_ESP_TLS_HANDSHAKE: esp_tls_conn_state = 2;
pub const esp_tls_conn_state_ESP_TLS_FAIL: esp_tls_conn_state = 3;
pub const esp_tls_conn_state_ESP_TLS_DONE: esp_tls_conn_state = 4;
#[doc = "  @brief ESP-TLS Connection State"]
pub type esp_tls_conn_state = ::core::ffi::c_uint;
#[doc = "  @brief ESP-TLS Connection State"]
pub use self::esp_tls_conn_state as esp_tls_conn_state_t;
pub const esp_tls_role_ESP_TLS_CLIENT: esp_tls_role = 0;
pub const esp_tls_role_ESP_TLS_SERVER: esp_tls_role = 1;
pub type esp_tls_role = ::core::ffi::c_uint;
pub use self::esp_tls_role as esp_tls_role_t;
#[doc = "  @brief ESP-TLS preshared key and hint structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psk_key_hint {
    #[doc = "< key in PSK authentication mode in binary format"]
    pub key: *const u8,
    #[doc = "< length of the key"]
    pub key_size: usize,
    #[doc = "< hint in PSK authentication mode in string format"]
    pub hint: *const ::core::ffi::c_char,
}
impl Default for psk_key_hint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @brief ESP-TLS preshared key and hint structure"]
pub type psk_hint_key_t = psk_key_hint;
#[doc = "  @brief Keep alive parameters structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tls_keep_alive_cfg {
    #[doc = "< Enable keep-alive timeout"]
    pub keep_alive_enable: bool,
    #[doc = "< Keep-alive idle time (second)"]
    pub keep_alive_idle: ::core::ffi::c_int,
    #[doc = "< Keep-alive interval time (second)"]
    pub keep_alive_interval: ::core::ffi::c_int,
    #[doc = "< Keep-alive packet retry send count"]
    pub keep_alive_count: ::core::ffi::c_int,
}
#[doc = "  @brief Keep alive parameters structure"]
pub type tls_keep_alive_cfg_t = tls_keep_alive_cfg;
#[doc = " @brief      ESP-TLS configuration parameters\n\n @note       Note about format of certificates:\n             - This structure includes certificates of a Certificate Authority, of client or server as well\n             as private keys, which may be of PEM or DER format. In case of PEM format, the buffer must be\n             NULL terminated (with NULL character included in certificate size).\n             - Certificate Authority's certificate may be a chain of certificates in case of PEM format,\n             but could be only one certificate in case of DER format\n             - Variables names of certificates and private key buffers and sizes are defined as unions providing\n             backward compatibility for legacy *_pem_buf and *_pem_bytes names which suggested only PEM format\n             was supported. It is encouraged to use generic names such as cacert_buf and cacert_bytes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_tls_cfg {
    #[doc = "< Application protocols required for HTTP2.\nIf HTTP2/ALPN support is required, a list\nof protocols that should be negotiated.\nThe format is length followed by protocol\nname.\nFor the most common cases the following is ok:\nconst char **alpn_protos = { \"h2\", NULL };\n- where 'h2' is the protocol name"]
    pub alpn_protos: *mut *const ::core::ffi::c_char,
    pub __bindgen_anon_1: esp_tls_cfg__bindgen_ty_1,
    pub __bindgen_anon_2: esp_tls_cfg__bindgen_ty_2,
    pub __bindgen_anon_3: esp_tls_cfg__bindgen_ty_3,
    pub __bindgen_anon_4: esp_tls_cfg__bindgen_ty_4,
    pub __bindgen_anon_5: esp_tls_cfg__bindgen_ty_5,
    pub __bindgen_anon_6: esp_tls_cfg__bindgen_ty_6,
    #[doc = "< Client key decryption password string"]
    pub clientkey_password: *const ::core::ffi::c_uchar,
    #[doc = "< String length of the password pointed to by\nclientkey_password"]
    pub clientkey_password_len: ::core::ffi::c_uint,
    #[doc = "< Configure non-blocking mode. If set to true the\nunderneath socket will be configured in non\nblocking mode after tls session is established"]
    pub non_block: bool,
    #[doc = "< Enable this option to use secure element or\natecc608a chip ( Integrated with ESP32-WROOM-32SE )"]
    pub use_secure_element: bool,
    #[doc = "< Network timeout in milliseconds.\nNote: If this value is not set, by default the timeout is\nset to 10 seconds. If you wish that the session should wait\nindefinitely then please use a larger value e.g., INT32_MAX"]
    pub timeout_ms: ::core::ffi::c_int,
    #[doc = "< Use a global ca_store for all the connections in which\nthis bool is set."]
    pub use_global_ca_store: bool,
    #[doc = "< If non-NULL, server certificate CN must match this name.\nIf NULL, server certificate CN must match hostname."]
    pub common_name: *const ::core::ffi::c_char,
    #[doc = "< Skip any validation of server certificate CN field"]
    pub skip_common_name: bool,
    #[doc = "< Enable TCP keep-alive timeout for SSL connection"]
    pub keep_alive_cfg: *mut tls_keep_alive_cfg_t,
    #[doc = "< Pointer to PSK hint and key. if not NULL (and certificates are NULL)\nthen PSK authentication is enabled with configured setup.\nImportant note: the pointer must be valid for connection"]
    pub psk_hint_key: *const psk_hint_key_t,
    pub crt_bundle_attach:
        ::core::option::Option<unsafe extern "C" fn(conf: *mut ::core::ffi::c_void) -> esp_err_t>,
    #[doc = "< Pointer for digital signature peripheral context"]
    pub ds_data: *mut ::core::ffi::c_void,
    #[doc = "< Use non-TLS connection: When set to true, the esp-tls uses\nplain TCP transport rather then TLS/SSL connection.\nNote, that it is possible to connect using a plain tcp transport\ndirectly with esp_tls_plain_tcp_connect() API"]
    pub is_plain_tcp: bool,
    #[doc = "< The name of interface for data to go through. Use the default interface without setting"]
    pub if_name: *mut ifreq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_1 {
    #[doc = "< Certificate Authority's certificate in a buffer.\nFormat may be PEM or DER, depending on mbedtls-support\nThis buffer should be NULL terminated in case of PEM"]
    pub cacert_buf: *const ::core::ffi::c_uchar,
    #[doc = "< CA certificate buffer legacy name"]
    pub cacert_pem_buf: *const ::core::ffi::c_uchar,
}
impl Default for esp_tls_cfg__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_2 {
    #[doc = "< Size of Certificate Authority certificate\npointed to by cacert_buf\n(including NULL-terminator in case of PEM format)"]
    pub cacert_bytes: ::core::ffi::c_uint,
    #[doc = "< Size of Certificate Authority certificate legacy name"]
    pub cacert_pem_bytes: ::core::ffi::c_uint,
}
impl Default for esp_tls_cfg__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_3 {
    #[doc = "< Client certificate in a buffer\nFormat may be PEM or DER, depending on mbedtls-support\nThis buffer should be NULL terminated in case of PEM"]
    pub clientcert_buf: *const ::core::ffi::c_uchar,
    #[doc = "< Client certificate legacy name"]
    pub clientcert_pem_buf: *const ::core::ffi::c_uchar,
}
impl Default for esp_tls_cfg__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_4 {
    #[doc = "< Size of client certificate pointed to by\nclientcert_pem_buf\n(including NULL-terminator in case of PEM format)"]
    pub clientcert_bytes: ::core::ffi::c_uint,
    #[doc = "< Size of client certificate legacy name"]
    pub clientcert_pem_bytes: ::core::ffi::c_uint,
}
impl Default for esp_tls_cfg__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_5 {
    #[doc = "< Client key in a buffer\nFormat may be PEM or DER, depending on mbedtls-support\nThis buffer should be NULL terminated in case of PEM"]
    pub clientkey_buf: *const ::core::ffi::c_uchar,
    #[doc = "< Client key legacy name"]
    pub clientkey_pem_buf: *const ::core::ffi::c_uchar,
}
impl Default for esp_tls_cfg__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_tls_cfg__bindgen_ty_6 {
    #[doc = "< Size of client key pointed to by\nclientkey_pem_buf\n(including NULL-terminator in case of PEM format)"]
    pub clientkey_bytes: ::core::ffi::c_uint,
    #[doc = "< Size of client key legacy name"]
    pub clientkey_pem_bytes: ::core::ffi::c_uint,
}
impl Default for esp_tls_cfg__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for esp_tls_cfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief      ESP-TLS configuration parameters\n\n @note       Note about format of certificates:\n             - This structure includes certificates of a Certificate Authority, of client or server as well\n             as private keys, which may be of PEM or DER format. In case of PEM format, the buffer must be\n             NULL terminated (with NULL character included in certificate size).\n             - Certificate Authority's certificate may be a chain of certificates in case of PEM format,\n             but could be only one certificate in case of DER format\n             - Variables names of certificates and private key buffers and sizes are defined as unions providing\n             backward compatibility for legacy *_pem_buf and *_pem_bytes names which suggested only PEM format\n             was supported. It is encouraged to use generic names such as cacert_buf and cacert_bytes."]
pub type esp_tls_cfg_t = esp_tls_cfg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_tls {
    _unused: [u8; 0],
}
pub type esp_tls_t = esp_tls;
extern "C" {
    #[doc = " @brief      Create TLS connection\n\n This function allocates and initializes esp-tls structure handle.\n\n @return      tls     Pointer to esp-tls as esp-tls handle if successfully initialized,\n                      NULL if allocation error"]
    pub fn esp_tls_init() -> *mut esp_tls_t;
}
extern "C" {
    #[doc = " @brief      Create a new blocking TLS/SSL connection with a given \"HTTP\" url\n\n Note: This API is present for backward compatibility reasons. Alternative function\n with the same functionality is `esp_tls_conn_http_new_sync` (and its asynchronous version\n `esp_tls_conn_http_new_async`)\n\n @param[in]  url  url of host.\n @param[in]  cfg  TLS configuration as esp_tls_cfg_t. If you wish to open\n                  non-TLS connection, keep this NULL. For TLS connection,\n                  a pass pointer to 'esp_tls_cfg_t'. At a minimum, this\n                  structure should be zero-initialized.\n @return pointer to esp_tls_t, or NULL if connection couldn't be opened."]
    pub fn esp_tls_conn_http_new(
        url: *const ::core::ffi::c_char,
        cfg: *const esp_tls_cfg_t,
    ) -> *mut esp_tls_t;
}
extern "C" {
    #[doc = " @brief      Create a new blocking TLS/SSL connection\n\n This function establishes a TLS/SSL connection with the specified host in blocking manner.\n\n @param[in]  hostname  Hostname of the host.\n @param[in]  hostlen   Length of hostname.\n @param[in]  port      Port number of the host.\n @param[in]  cfg       TLS configuration as esp_tls_cfg_t. If you wish to open\n                       non-TLS connection, keep this NULL. For TLS connection,\n                       a pass pointer to esp_tls_cfg_t. At a minimum, this\n                       structure should be zero-initialized.\n @param[in]  tls       Pointer to esp-tls as esp-tls handle.\n\n @return\n             - -1      If connection establishment fails.\n             -  1      If connection establishment is successful.\n             -  0      If connection state is in progress."]
    pub fn esp_tls_conn_new_sync(
        hostname: *const ::core::ffi::c_char,
        hostlen: ::core::ffi::c_int,
        port: ::core::ffi::c_int,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Create a new blocking TLS/SSL connection with a given \"HTTP\" url\n\n The behaviour is same as esp_tls_conn_new_sync() API. However this API accepts host's url.\n\n @param[in]  url       url of host.\n @param[in]  cfg       TLS configuration as esp_tls_cfg_t. If you wish to open\n                       non-TLS connection, keep this NULL. For TLS connection,\n                       a pass pointer to 'esp_tls_cfg_t'. At a minimum, this\n                       structure should be zero-initialized.\n @param[in]  tls       Pointer to esp-tls as esp-tls handle.\n\n @return\n             - -1      If connection establishment fails.\n             -  1      If connection establishment is successful.\n             -  0      If connection state is in progress."]
    pub fn esp_tls_conn_http_new_sync(
        url: *const ::core::ffi::c_char,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Create a new non-blocking TLS/SSL connection\n\n This function initiates a non-blocking TLS/SSL connection with the specified host, but due to\n its non-blocking nature, it doesn't wait for the connection to get established.\n\n @param[in]  hostname  Hostname of the host.\n @param[in]  hostlen   Length of hostname.\n @param[in]  port      Port number of the host.\n @param[in]  cfg       TLS configuration as esp_tls_cfg_t. `non_block` member of\n                       this structure should be set to be true.\n @param[in]  tls       pointer to esp-tls as esp-tls handle.\n\n @return\n             - -1      If connection establishment fails.\n             -  0      If connection establishment is in progress.\n             -  1      If connection establishment is successful."]
    pub fn esp_tls_conn_new_async(
        hostname: *const ::core::ffi::c_char,
        hostlen: ::core::ffi::c_int,
        port: ::core::ffi::c_int,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Create a new non-blocking TLS/SSL connection with a given \"HTTP\" url\n\n The behaviour is same as esp_tls_conn_new_async() API. However this API accepts host's url.\n\n @param[in]  url     url of host.\n @param[in]  cfg     TLS configuration as esp_tls_cfg_t.\n @param[in]  tls     pointer to esp-tls as esp-tls handle.\n\n @return\n             - -1     If connection establishment fails.\n             -  0     If connection establishment is in progress.\n             -  1     If connection establishment is successful."]
    pub fn esp_tls_conn_http_new_async(
        url: *const ::core::ffi::c_char,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Write from buffer 'data' into specified tls connection.\n\n @param[in]  tls      pointer to esp-tls as esp-tls handle.\n @param[in]  data     Buffer from which data will be written.\n @param[in]  datalen  Length of data buffer.\n\n @return\n             - >=0  if write operation was successful, the return value is the number\n                   of bytes actually written to the TLS/SSL connection.\n             - <0  if write operation was not successful, because either an\n                   error occured or an action must be taken by the calling process.\n             - ESP_TLS_ERR_SSL_WANT_READ/\n               ESP_TLS_ERR_SSL_WANT_WRITE.\n                  if the handshake is incomplete and waiting for data to be available for reading.\n                  In this case this functions needs to be called again when the underlying transport is ready for operation."]
    pub fn esp_tls_conn_write(
        tls: *mut esp_tls_t,
        data: *const ::core::ffi::c_void,
        datalen: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief      Read from specified tls connection into the buffer 'data'.\n\n @param[in]  tls      pointer to esp-tls as esp-tls handle.\n @param[in]  data     Buffer to hold read data.\n @param[in]  datalen  Length of data buffer.\n\n @return\n             - >0  if read operation was successful, the return value is the number\n                   of bytes actually read from the TLS/SSL connection.\n             -  0  if read operation was not successful. The underlying\n                   connection was closed.\n             - <0  if read operation was not successful, because either an\n                   error occured or an action must be taken by the calling process."]
    pub fn esp_tls_conn_read(
        tls: *mut esp_tls_t,
        data: *mut ::core::ffi::c_void,
        datalen: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief      Close the TLS/SSL connection and free any allocated resources.\n\n This function should be called to close each tls connection opened with\n esp_tls_conn_new_sync() (or esp_tls_conn_http_new_sync()) and\n esp_tls_conn_new_async() (or esp_tls_conn_http_new_async()) APIs.\n\n @param[in]  tls  pointer to esp-tls as esp-tls handle.\n\n @return    - 0 on success\n            - -1 if socket error or an invalid argument"]
    pub fn esp_tls_conn_destroy(tls: *mut esp_tls_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Return the number of application data bytes remaining to be\n             read from the current record\n\n This API is a wrapper over mbedtls's mbedtls_ssl_get_bytes_avail() API.\n\n @param[in]  tls  pointer to esp-tls as esp-tls handle.\n\n @return\n            - -1  in case of invalid arg\n            - bytes available in the application data\n              record read buffer"]
    pub fn esp_tls_get_bytes_avail(tls: *mut esp_tls_t) -> isize;
}
extern "C" {
    #[doc = " @brief       Returns the connection socket file descriptor from esp_tls session\n\n @param[in]   tls          handle to esp_tls context\n\n @param[out]  sockfd       int pointer to sockfd value.\n\n @return     - ESP_OK on success and value of sockfd will be updated with socket file descriptor for connection\n             - ESP_ERR_INVALID_ARG if (tls == NULL || sockfd == NULL)"]
    pub fn esp_tls_get_conn_sockfd(
        tls: *mut esp_tls_t,
        sockfd: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Returns the ssl context\n\n @param[in]   tls          handle to esp_tls context\n\n\n @return     - ssl_ctx pointer to ssl context of underlying TLS layer on success\n             - NULL  in case of error"]
    pub fn esp_tls_get_ssl_context(tls: *mut esp_tls_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief      Create a global CA store, initially empty.\n\n This function should be called if the application wants to use the same CA store for multiple connections.\n This function initialises the global CA store which can be then set by calling esp_tls_set_global_ca_store().\n To be effective, this function must be called before any call to esp_tls_set_global_ca_store().\n\n @return\n             - ESP_OK             if creating global CA store was successful.\n             - ESP_ERR_NO_MEM     if an error occured when allocating the mbedTLS resources."]
    pub fn esp_tls_init_global_ca_store() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set the global CA store with the buffer provided in pem format.\n\n This function should be called if the application wants to set the global CA store for\n multiple connections i.e. to add the certificates in the provided buffer to the certificate chain.\n This function implicitly calls esp_tls_init_global_ca_store() if it has not already been called.\n The application must call this function before calling esp_tls_conn_new().\n\n @param[in]  cacert_pem_buf    Buffer which has certificates in pem format. This buffer\n                               is used for creating a global CA store, which can be used\n                               by other tls connections.\n @param[in]  cacert_pem_bytes  Length of the buffer.\n\n @return\n             - ESP_OK  if adding certificates was successful.\n             - Other   if an error occured or an action must be taken by the calling process."]
    pub fn esp_tls_set_global_ca_store(
        cacert_pem_buf: *const ::core::ffi::c_uchar,
        cacert_pem_bytes: ::core::ffi::c_uint,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Free the global CA store currently being used.\n\n The memory being used by the global CA store to store all the parsed certificates is\n freed up. The application can call this API if it no longer needs the global CA store."]
    pub fn esp_tls_free_global_ca_store();
}
extern "C" {
    #[doc = " @brief      Returns last error in esp_tls with detailed mbedtls related error codes.\n             The error information is cleared internally upon return\n\n @param[in]  h              esp-tls error handle.\n @param[out] esp_tls_code   last error code returned from mbedtls api (set to zero if none)\n                            This pointer could be NULL if caller does not care about esp_tls_code\n @param[out] esp_tls_flags  last certification verification flags (set to zero if none)\n                            This pointer could be NULL if caller does not care about esp_tls_code\n\n @return\n            - ESP_ERR_INVALID_STATE if invalid parameters\n            - ESP_OK (0) if no error occurred\n            - specific error code (based on ESP_ERR_ESP_TLS_BASE) otherwise"]
    pub fn esp_tls_get_and_clear_last_error(
        h: esp_tls_error_handle_t,
        esp_tls_code: *mut ::core::ffi::c_int,
        esp_tls_flags: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Returns the last error captured in esp_tls of a specific type\n             The error information is cleared internally upon return\n\n @param[in]  h              esp-tls error handle.\n @param[in]  err_type       specific error type\n @param[out] error_code     last error code returned from mbedtls api (set to zero if none)\n                            This pointer could be NULL if caller does not care about esp_tls_code\n @return\n            - ESP_ERR_INVALID_STATE if invalid parameters\n            - ESP_OK if a valid error returned and was cleared"]
    pub fn esp_tls_get_and_clear_error_type(
        h: esp_tls_error_handle_t,
        err_type: esp_tls_error_type_t,
        error_code: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Returns the ESP-TLS error_handle\n\n @param[in]   tls             handle to esp_tls context\n\n @param[out]  error_handle    pointer to the error handle.\n\n @return\n             - ESP_OK             on success and error_handle will be updated with the ESP-TLS error handle.\n\n             - ESP_ERR_INVALID_ARG if (tls == NULL || error_handle == NULL)"]
    pub fn esp_tls_get_error_handle(
        tls: *mut esp_tls_t,
        error_handle: *mut esp_tls_error_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the pointer to the global CA store currently being used.\n\n The application must first call esp_tls_set_global_ca_store(). Then the same\n CA store could be used by the application for APIs other than esp_tls.\n\n @note       Modifying the pointer might cause a failure in verifying the certificates.\n\n @return\n             - Pointer to the global CA store currently being used    if successful.\n             - NULL                                                   if there is no global CA store set."]
    pub fn esp_tls_get_global_ca_store() -> *mut mbedtls_x509_crt;
}
extern "C" {
    #[doc = " @brief Creates a plain TCP connection, returning a valid socket fd on success or an error handle\n\n @param[in]  host      Hostname of the host.\n @param[in]  hostlen   Length of hostname.\n @param[in]  port      Port number of the host.\n @param[in]  cfg       ESP-TLS configuration as esp_tls_cfg_t.\n @param[out] error_handle ESP-TLS error handle holding potential errors occurred during connection\n @param[out] sockfd    Socket descriptor if successfully connected on TCP layer\n @return     ESP_OK   on success\n             ESP_ERR_INVALID_ARG if invalid output parameters\n             ESP-TLS based error codes on failure"]
    pub fn esp_tls_plain_tcp_connect(
        host: *const ::core::ffi::c_char,
        hostlen: ::core::ffi::c_int,
        port: ::core::ffi::c_int,
        cfg: *const esp_tls_cfg_t,
        error_handle: esp_tls_error_handle_t,
        sockfd: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[doc = "< Monitor the first boot. In bootloader this state is changed to ESP_OTA_IMG_PENDING_VERIFY."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_NEW: esp_ota_img_states_t = 0;
#[doc = "< First boot for this app was. If while the second boot this state is then it will be changed to ABORTED."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_PENDING_VERIFY: esp_ota_img_states_t = 1;
#[doc = "< App was confirmed as workable. App can boot and work without limits."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_VALID: esp_ota_img_states_t = 2;
#[doc = "< App was confirmed as non-workable. This app will not selected to boot at all."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_INVALID: esp_ota_img_states_t = 3;
#[doc = "< App could not confirm the workable or non-workable. In bootloader IMG_PENDING_VERIFY state will be changed to IMG_ABORTED. This app will not selected to boot at all."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_ABORTED: esp_ota_img_states_t = 4;
#[doc = "< Undefined. App can boot and work without limits."]
pub const esp_ota_img_states_t_ESP_OTA_IMG_UNDEFINED: esp_ota_img_states_t = 4294967295;
#[doc = " OTA_DATA states for checking operability of the app."]
pub type esp_ota_img_states_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_ota_select_entry_t {
    pub ota_seq: u32,
    pub seq_label: [u8; 20usize],
    pub ota_state: u32,
    pub crc: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_partition_pos_t {
    pub offset: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_partition_info_t {
    pub magic: u16,
    pub type_: u8,
    pub subtype: u8,
    pub pos: esp_partition_pos_t,
    pub label: [u8; 16usize],
    pub flags: u32,
}
extern "C" {
    pub fn esp_partition_table_verify(
        partition_table: *const esp_partition_info_t,
        log_errors: bool,
        num_partitions: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Check whether the region on the main flash is safe to write.\n\n @param addr Start address of the region\n @param size Size of the region\n\n @return true if the region is safe to write, otherwise false."]
    pub fn esp_partition_main_flash_region_safe(addr: usize, size: usize) -> bool;
}
#[doc = "< chip ID: ESP32"]
pub const esp_chip_id_t_ESP_CHIP_ID_ESP32: esp_chip_id_t = 0;
#[doc = "< chip ID: ESP32-S2"]
pub const esp_chip_id_t_ESP_CHIP_ID_ESP32S2: esp_chip_id_t = 2;
#[doc = "< chip ID: ESP32-C3"]
pub const esp_chip_id_t_ESP_CHIP_ID_ESP32C3: esp_chip_id_t = 5;
#[doc = "< chip ID: ESP32-S3"]
pub const esp_chip_id_t_ESP_CHIP_ID_ESP32S3: esp_chip_id_t = 9;
#[doc = "< chip ID: ESP32-C2"]
pub const esp_chip_id_t_ESP_CHIP_ID_ESP32C2: esp_chip_id_t = 12;
#[doc = "< Invalid chip ID (we defined it to make sure the esp_chip_id_t is 2 bytes size)"]
pub const esp_chip_id_t_ESP_CHIP_ID_INVALID: esp_chip_id_t = 65535;
#[doc = " @brief ESP chip ID\n"]
pub type esp_chip_id_t = ::core::ffi::c_ushort;
#[doc = "< SPI mode QIO"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_QIO: esp_image_spi_mode_t = 0;
#[doc = "< SPI mode QOUT"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_QOUT: esp_image_spi_mode_t = 1;
#[doc = "< SPI mode DIO"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_DIO: esp_image_spi_mode_t = 2;
#[doc = "< SPI mode DOUT"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_DOUT: esp_image_spi_mode_t = 3;
#[doc = "< SPI mode FAST_READ"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_FAST_READ: esp_image_spi_mode_t = 4;
#[doc = "< SPI mode SLOW_READ"]
pub const esp_image_spi_mode_t_ESP_IMAGE_SPI_MODE_SLOW_READ: esp_image_spi_mode_t = 5;
#[doc = " @brief SPI flash mode, used in esp_image_header_t"]
pub type esp_image_spi_mode_t = ::core::ffi::c_uint;
#[doc = "< The SPI flash clock frequency is divided by 2 of the clock source"]
pub const esp_image_spi_freq_t_ESP_IMAGE_SPI_SPEED_DIV_2: esp_image_spi_freq_t = 0;
#[doc = "< The SPI flash clock frequency is divided by 3 of the clock source"]
pub const esp_image_spi_freq_t_ESP_IMAGE_SPI_SPEED_DIV_3: esp_image_spi_freq_t = 1;
#[doc = "< The SPI flash clock frequency is divided by 4 of the clock source"]
pub const esp_image_spi_freq_t_ESP_IMAGE_SPI_SPEED_DIV_4: esp_image_spi_freq_t = 2;
#[doc = "< The SPI flash clock frequency equals to the clock source"]
pub const esp_image_spi_freq_t_ESP_IMAGE_SPI_SPEED_DIV_1: esp_image_spi_freq_t = 15;
#[doc = " @brief SPI flash clock division factor."]
pub type esp_image_spi_freq_t = ::core::ffi::c_uint;
#[doc = "< SPI flash size 1 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_1MB: esp_image_flash_size_t = 0;
#[doc = "< SPI flash size 2 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_2MB: esp_image_flash_size_t = 1;
#[doc = "< SPI flash size 4 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_4MB: esp_image_flash_size_t = 2;
#[doc = "< SPI flash size 8 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_8MB: esp_image_flash_size_t = 3;
#[doc = "< SPI flash size 16 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_16MB: esp_image_flash_size_t = 4;
#[doc = "< SPI flash size 32 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_32MB: esp_image_flash_size_t = 5;
#[doc = "< SPI flash size 64 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_64MB: esp_image_flash_size_t = 6;
#[doc = "< SPI flash size 128 MB"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_128MB: esp_image_flash_size_t = 7;
#[doc = "< SPI flash size MAX"]
pub const esp_image_flash_size_t_ESP_IMAGE_FLASH_SIZE_MAX: esp_image_flash_size_t = 8;
#[doc = " @brief Supported SPI flash sizes"]
pub type esp_image_flash_size_t = ::core::ffi::c_uint;
#[doc = " @brief Main header of binary image"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct esp_image_header_t {
    #[doc = "< Magic word ESP_IMAGE_HEADER_MAGIC"]
    pub magic: u8,
    #[doc = "< Count of memory segments"]
    pub segment_count: u8,
    #[doc = "< flash read mode (esp_image_spi_mode_t as uint8_t)"]
    pub spi_mode: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Entry address"]
    pub entry_addr: u32,
    #[doc = "< WP pin when SPI pins set via efuse (read by ROM bootloader,\n the IDF bootloader uses software to configure the WP\n pin and sets this field to 0xEE=disabled)"]
    pub wp_pin: u8,
    #[doc = "< Drive settings for the SPI flash pins (read by ROM bootloader)"]
    pub spi_pin_drv: [u8; 3usize],
    #[doc = "< Chip identification number"]
    pub chip_id: esp_chip_id_t,
    #[doc = "< Minimal chip revision supported by image\n After the Major and Minor revision eFuses were introduced into the chips, this field is no longer used.\n But for compatibility reasons, we keep this field and the data in it.\n Use min_chip_rev_full instead.\n The software interprets this as a Major version for most of the chips and as a Minor version for the ESP32-C3."]
    pub min_chip_rev: u8,
    #[doc = "< Minimal chip revision supported by image, in format: major * 100 + minor"]
    pub min_chip_rev_full: u16,
    #[doc = "< Maximal chip revision supported by image, in format: major * 100 + minor"]
    pub max_chip_rev_full: u16,
    #[doc = "< Reserved bytes in additional header space, currently unused"]
    pub reserved: [u8; 4usize],
    #[doc = "< If 1, a SHA256 digest \"simple hash\" (of the entire image) is appended after the checksum.\n Included in image length. This digest\n is separate to secure boot and only used for detecting corruption.\n For secure boot signed images, the signature\n is appended after this (and the simple hash is included in the signed data)."]
    pub hash_appended: u8,
}
impl Default for esp_image_header_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl esp_image_header_t {
    #[inline]
    pub fn spi_speed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_spi_speed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn spi_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_spi_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(spi_speed: u8, spi_size: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let spi_speed: u8 = unsafe { ::core::mem::transmute(spi_speed) };
            spi_speed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let spi_size: u8 = unsafe { ::core::mem::transmute(spi_size) };
            spi_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Header of binary image segment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_image_segment_header_t {
    #[doc = "< Address of segment"]
    pub load_addr: u32,
    #[doc = "< Length of data"]
    pub data_len: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_image_metadata_t {
    pub start_addr: u32,
    pub image: esp_image_header_t,
    pub segments: [esp_image_segment_header_t; 16usize],
    pub segment_data: [u32; 16usize],
    pub image_len: u32,
    pub image_digest: [u8; 32usize],
}
impl Default for esp_image_metadata_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const esp_image_load_mode_t_ESP_IMAGE_VERIFY: esp_image_load_mode_t = 0;
pub const esp_image_load_mode_t_ESP_IMAGE_VERIFY_SILENT: esp_image_load_mode_t = 1;
pub type esp_image_load_mode_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_retain_mem_t {
    #[doc = "< Partition of application which worked before goes to the deep sleep."]
    pub partition: esp_partition_pos_t,
    #[doc = "< Reboot counter. Reset only when power is off."]
    pub reboot_counter: u16,
    #[doc = "< Reserve"]
    pub reserve: u16,
    #[doc = "< Check sum crc32"]
    pub crc: u32,
}
extern "C" {
    #[doc = " @brief Verify an app image.\n\n If encryption is enabled, data will be transparently decrypted.\n\n @param mode Mode of operation (verify, silent verify, or load).\n @param part Partition to load the app from.\n @param[inout] data Pointer to the image metadata structure which is be filled in by this function.\n                    'start_addr' member should be set (to the start address of the image.)\n                    Other fields will all be initialised by this function.\n\n Image validation checks:\n - Magic byte.\n - Partition smaller than 16MB.\n - All segments & image fit in partition.\n - 8 bit image checksum is valid.\n - SHA-256 of image is valid (if image has this appended).\n - (Signature) if signature verification is enabled.\n\n @return\n - ESP_OK if verify or load was successful\n - ESP_ERR_IMAGE_FLASH_FAIL if a SPI flash error occurs\n - ESP_ERR_IMAGE_INVALID if the image appears invalid.\n - ESP_ERR_INVALID_ARG if the partition or data pointers are invalid."]
    pub fn esp_image_verify(
        mode: esp_image_load_mode_t,
        part: *const esp_partition_pos_t,
        data: *mut esp_image_metadata_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get metadata of app\n\n If encryption is enabled, data will be transparently decrypted.\n\n @param part Partition to load the app from.\n @param[out] metadata Pointer to the image metadata structure which is be filled in by this function.\n                      Fields will all be initialised by this function.\n\n @return\n - ESP_OK if filling of metadata was successful"]
    pub fn esp_image_get_metadata(
        part: *const esp_partition_pos_t,
        metadata: *mut esp_image_metadata_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Verify and load an app image (available only in space of bootloader).\n\n If encryption is enabled, data will be transparently decrypted.\n\n @param part Partition to load the app from.\n @param[inout] data Pointer to the image metadata structure which is be filled in by this function.\n                    'start_addr' member should be set (to the start address of the image.)\n                    Other fields will all be initialised by this function.\n\n Image validation checks:\n - Magic byte.\n - Partition smaller than 16MB.\n - All segments & image fit in partition.\n - 8 bit image checksum is valid.\n - SHA-256 of image is valid (if image has this appended).\n - (Signature) if signature verification is enabled.\n\n @return\n - ESP_OK if verify or load was successful\n - ESP_ERR_IMAGE_FLASH_FAIL if a SPI flash error occurs\n - ESP_ERR_IMAGE_INVALID if the image appears invalid.\n - ESP_ERR_INVALID_ARG if the partition or data pointers are invalid."]
    pub fn bootloader_load_image(
        part: *const esp_partition_pos_t,
        data: *mut esp_image_metadata_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Load an app image without verification (available only in space of bootloader).\n\n If encryption is enabled, data will be transparently decrypted.\n\n @param part Partition to load the app from.\n @param[inout] data Pointer to the image metadata structure which is be filled in by this function.\n                    'start_addr' member should be set (to the start address of the image.)\n                    Other fields will all be initialised by this function.\n\n @return\n - ESP_OK if verify or load was successful\n - ESP_ERR_IMAGE_FLASH_FAIL if a SPI flash error occurs\n - ESP_ERR_IMAGE_INVALID if the image appears invalid.\n - ESP_ERR_INVALID_ARG if the partition or data pointers are invalid."]
    pub fn bootloader_load_image_no_verify(
        part: *const esp_partition_pos_t,
        data: *mut esp_image_metadata_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Verify the bootloader image.\n\n @param[out] If result is ESP_OK and this pointer is non-NULL, it\n will be set to the length of the bootloader image.\n\n @return As per esp_image_load_metadata()."]
    pub fn esp_image_verify_bootloader(length: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Verify the bootloader image.\n\n @param[out] Metadata for the image. Only valid if result is ESP_OK.\n\n @return As per esp_image_load_metadata()."]
    pub fn esp_image_verify_bootloader_data(data: *mut esp_image_metadata_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the flash size of the image\n\n @param app_flash_size The value configured in the image header\n @return Actual size, in bytes."]
    pub fn esp_image_get_flash_size(app_flash_size: esp_image_flash_size_t) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_image_flash_mapping_t {
    pub drom_addr: u32,
    pub drom_load_addr: u32,
    pub drom_size: u32,
    pub irom_addr: u32,
    pub irom_load_addr: u32,
    pub irom_size: u32,
}
#[doc = "< The long hold GPIO"]
pub const esp_comm_gpio_hold_t_GPIO_LONG_HOLD: esp_comm_gpio_hold_t = 1;
#[doc = "< The short hold GPIO"]
pub const esp_comm_gpio_hold_t_GPIO_SHORT_HOLD: esp_comm_gpio_hold_t = -1;
#[doc = "< If the GPIO input is not low"]
pub const esp_comm_gpio_hold_t_GPIO_NOT_HOLD: esp_comm_gpio_hold_t = 0;
pub type esp_comm_gpio_hold_t = ::core::ffi::c_int;
pub const esp_image_type_ESP_IMAGE_BOOTLOADER: esp_image_type = 0;
pub const esp_image_type_ESP_IMAGE_APPLICATION: esp_image_type = 1;
pub type esp_image_type = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Calculate crc for the OTA data select.\n\n @param[in] s The OTA data select.\n @return    Returns crc value."]
    pub fn bootloader_common_ota_select_crc(s: *const esp_ota_select_entry_t) -> u32;
}
extern "C" {
    #[doc = " @brief Verifies the validity of the OTA data select\n\n @param[in] s The OTA data select.\n @return    Returns true on valid, false otherwise."]
    pub fn bootloader_common_ota_select_valid(s: *const esp_ota_select_entry_t) -> bool;
}
extern "C" {
    #[doc = " @brief Returns true if OTADATA is not marked as bootable partition.\n\n @param[in] s The OTA data select.\n @return    Returns true if OTADATA invalid, false otherwise."]
    pub fn bootloader_common_ota_select_invalid(s: *const esp_ota_select_entry_t) -> bool;
}
extern "C" {
    #[doc = " @brief Check if a GPIO input is held low for a long period, short period, or not\n at all.\n\n This function will configure the specified GPIO as an input with internal pull-up enabled.\n\n If the GPIO input is held low continuously for delay_sec period then it is a long hold.\n If the GPIO input is held low for less period then it is a short hold.\n\n @param[in] num_pin Number of the GPIO input.\n @param[in] delay_sec Input must be driven low for at least this long, continuously.\n @return esp_comm_gpio_hold_t Type of low level hold detected, if any."]
    pub fn bootloader_common_check_long_hold_gpio(
        num_pin: u32,
        delay_sec: u32,
    ) -> esp_comm_gpio_hold_t;
}
extern "C" {
    #[doc = " @brief Check if a GPIO input is held low or high for a long period, short period, or not\n at all.\n\n This function will configure the specified GPIO as an input with internal pull-up enabled.\n\n If the GPIO input is held at 'level' continuously for delay_sec period then it is a long hold.\n If the GPIO input is held at 'level' for less period then it is a short hold.\n\n @param[in] num_pin Number of the GPIO input.\n @param[in] delay_sec Input must be driven to 'level' for at least this long, continuously.\n @param[in] level Input pin level to trigger on hold\n @return esp_comm_gpio_hold_t Type of hold detected, if any."]
    pub fn bootloader_common_check_long_hold_gpio_level(
        num_pin: u32,
        delay_sec: u32,
        level: bool,
    ) -> esp_comm_gpio_hold_t;
}
extern "C" {
    #[doc = " @brief Erase the partition data that is specified in the transferred list.\n\n @param[in] list_erase String containing a list of cleared partitions. Like this \"nvs, phy\". The string must be null-terminal.\n @param[in] ota_data_erase If true then the OTA data partition will be cleared (if there is it in partition table).\n @return    Returns true on success, false otherwise."]
    pub fn bootloader_common_erase_part_type_data(
        list_erase: *const ::core::ffi::c_char,
        ota_data_erase: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Determines if the list contains the label\n\n @param[in] list  A string of names delimited by commas or spaces. Like this \"nvs, phy, data\". The string must be null-terminated.\n @param[in] label The substring that will be searched in the list.\n @return    Returns true if the list contains the label, false otherwise."]
    pub fn bootloader_common_label_search(
        list: *const ::core::ffi::c_char,
        label: *mut ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Configure default SPI pin modes and drive strengths\n\n @param drv GPIO drive level (determined by clock frequency)"]
    pub fn bootloader_configure_spi_pins(drv: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Calculates a sha-256 for a given partition or returns a appended digest.\n\n This function can be used to return the SHA-256 digest of application, bootloader and data partitions.\n For apps with SHA-256 appended to the app image, the result is the appended SHA-256 value for the app image content.\n The hash is verified before returning, if app content is invalid then the function returns ESP_ERR_IMAGE_INVALID.\n For apps without SHA-256 appended to the image, the result is the SHA-256 of all bytes in the app image.\n For other partition types, the result is the SHA-256 of the entire partition.\n\n @param[in]  address      Address of partition.\n @param[in]  size         Size of partition.\n @param[in]  type         Type of partition. For applications the type is 0, otherwise type is data.\n @param[out] out_sha_256  Returned SHA-256 digest for a given partition.\n\n @return\n          - ESP_OK: In case of successful operation.\n          - ESP_ERR_INVALID_ARG: The size was 0 or the sha_256 was NULL.\n          - ESP_ERR_NO_MEM: Cannot allocate memory for sha256 operation.\n          - ESP_ERR_IMAGE_INVALID: App partition doesn't contain a valid app image.\n          - ESP_FAIL: An allocation error occurred."]
    pub fn bootloader_common_get_sha256_of_partition(
        address: u32,
        size: u32,
        type_: ::core::ffi::c_int,
        out_sha_256: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns the number of active otadata.\n\n @param[in] two_otadata Pointer on array from two otadata structures.\n\n @return The number of active otadata (0 or 1).\n        - -1: If it does not have active otadata."]
    pub fn bootloader_common_get_active_otadata(
        two_otadata: *mut esp_ota_select_entry_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Returns the number of active otadata.\n\n @param[in] two_otadata       Pointer on array from two otadata structures.\n @param[in] valid_two_otadata Pointer on array from two bools. True means select.\n @param[in] max               True - will select the maximum ota_seq number, otherwise the minimum.\n\n @return The number of active otadata (0 or 1).\n        - -1: If it does not have active otadata."]
    pub fn bootloader_common_select_otadata(
        two_otadata: *const esp_ota_select_entry_t,
        valid_two_otadata: *mut bool,
        max: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get chip package\n\n @return Chip package number"]
    pub fn bootloader_common_get_chip_ver_pkg() -> u32;
}
extern "C" {
    #[doc = " @brief Check if the image (bootloader and application) has valid chip ID and revision\n\n @param[in] img_hdr: image header\n @param[in] type: image type, bootloader or application\n @return\n      - ESP_OK: image and chip are matched well\n      - ESP_FAIL: image doesn't match to the chip"]
    pub fn bootloader_common_check_chip_validity(
        img_hdr: *const esp_image_header_t,
        type_: esp_image_type,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure VDDSDIO, call this API to rise VDDSDIO to 1.9V when VDDSDIO regulator is enabled as 1.8V mode."]
    pub fn bootloader_common_vddsdio_configure();
}
extern "C" {
    #[doc = " @brief Enable an entropy source for RNG if RF subsystem is disabled\n\n @warning This function is not safe to use if any other subsystem is accessing the RF subsystem or\n          the ADC at the same time!\n\n The exact internal entropy source mechanism depends on the chip in use but\n all SoCs use the SAR ADC to continuously mix random bits (an internal\n noise reading) into the HWRNG. Consult the SoC Technical Reference\n Manual for more information.\n\n Can also be called from app code, if true random numbers are required without initialized RF subsystem.\n This might be the case in early startup code of the application when the RF subsystem has not\n started yet or if the RF subsystem should not be enabled for power saving.\n\n Consult ESP-IDF Programming Guide \"Random Number Generation\" section for\n details."]
    pub fn bootloader_random_enable();
}
extern "C" {
    #[doc = " @brief Disable entropy source for RNG\n\n Disables internal entropy source. Must be called after\n bootloader_random_enable() and before RF subsystem features, ADC, or\n I2S (ESP32 only) are initialized.\n\n Consult the ESP-IDF Programming Guide \"Random Number Generation\"\n section for details."]
    pub fn bootloader_random_disable();
}
extern "C" {
    #[doc = " @brief Fill buffer with 'length' random bytes\n\n @note If this function is being called from app code only, and never\n from the bootloader, then it's better to call esp_fill_random().\n\n @param buffer Pointer to buffer\n @param length This many bytes of random data will be copied to buffer"]
    pub fn bootloader_fill_random(buffer: *mut ::core::ffi::c_void, length: usize);
}
#[doc = " @brief Description about application."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_app_desc_t {
    #[doc = "< Magic word ESP_APP_DESC_MAGIC_WORD"]
    pub magic_word: u32,
    #[doc = "< Secure version"]
    pub secure_version: u32,
    #[doc = "< reserv1"]
    pub reserv1: [u32; 2usize],
    #[doc = "< Application version"]
    pub version: [::core::ffi::c_char; 32usize],
    #[doc = "< Project name"]
    pub project_name: [::core::ffi::c_char; 32usize],
    #[doc = "< Compile time"]
    pub time: [::core::ffi::c_char; 16usize],
    #[doc = "< Compile date"]
    pub date: [::core::ffi::c_char; 16usize],
    #[doc = "< Version IDF"]
    pub idf_ver: [::core::ffi::c_char; 32usize],
    #[doc = "< sha256 of elf file"]
    pub app_elf_sha256: [u8; 32usize],
    #[doc = "< reserv2"]
    pub reserv2: [u32; 20usize],
}
extern "C" {
    #[doc = " @brief   Return esp_app_desc structure. This structure includes app version.\n\n Return description for running app.\n @return Pointer to esp_app_desc structure."]
    pub fn esp_app_get_description() -> *const esp_app_desc_t;
}
extern "C" {
    #[doc = " @brief   Fill the provided buffer with SHA256 of the ELF file, formatted as hexadecimal, null-terminated.\n If the buffer size is not sufficient to fit the entire SHA256 in hex plus a null terminator,\n the largest possible number of bytes will be written followed by a null.\n @param dst   Destination buffer\n @param size  Size of the buffer\n @return      Number of bytes written to dst (including null terminator)"]
    pub fn esp_app_get_elf_sha256(dst: *mut ::core::ffi::c_char, size: usize)
        -> ::core::ffi::c_int;
}
#[doc = " @brief Opaque handle for an application OTA update\n\n esp_ota_begin() returns a handle which is then used for subsequent\n calls to esp_ota_write() and esp_ota_end()."]
pub type esp_ota_handle_t = u32;
extern "C" {
    #[doc = " @brief   Return esp_app_desc structure. This structure includes app version.\n\n @note This API is present for backward compatibility reasons. Alternative function\n with the same functionality is `esp_app_get_description`\n\n Return description for running app.\n @return Pointer to esp_app_desc structure."]
    pub fn esp_ota_get_app_description() -> *const esp_app_desc_t;
}
extern "C" {
    #[doc = " @brief   Fill the provided buffer with SHA256 of the ELF file, formatted as hexadecimal, null-terminated.\n If the buffer size is not sufficient to fit the entire SHA256 in hex plus a null terminator,\n the largest possible number of bytes will be written followed by a null.\n\n @note This API is present for backward compatibility reasons. Alternative function\n with the same functionality is `esp_app_get_elf_sha256`\n\n @param dst   Destination buffer\n @param size  Size of the buffer\n @return      Number of bytes written to dst (including null terminator)"]
    pub fn esp_ota_get_app_elf_sha256(
        dst: *mut ::core::ffi::c_char,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Commence an OTA update writing to the specified partition.\n\n The specified partition is erased to the specified image size.\n\n If image size is not yet known, pass OTA_SIZE_UNKNOWN which will\n cause the entire partition to be erased.\n\n On success, this function allocates memory that remains in use\n until esp_ota_end() is called with the returned handle.\n\n Note: If the rollback option is enabled and the running application has the ESP_OTA_IMG_PENDING_VERIFY state then\n it will lead to the ESP_ERR_OTA_ROLLBACK_INVALID_STATE error. Confirm the running app before to run download a new app,\n use esp_ota_mark_app_valid_cancel_rollback() function for it (this should be done as early as possible when you first download a new application).\n\n @param partition Pointer to info for partition which will receive the OTA update. Required.\n @param image_size Size of new OTA app image. Partition will be erased in order to receive this size of image. If 0 or OTA_SIZE_UNKNOWN, the entire partition is erased.\n @param out_handle On success, returns a handle which should be used for subsequent esp_ota_write() and esp_ota_end() calls.\n\n @return\n    - ESP_OK: OTA operation commenced successfully.\n    - ESP_ERR_INVALID_ARG: partition or out_handle arguments were NULL, or partition doesn't point to an OTA app partition.\n    - ESP_ERR_NO_MEM: Cannot allocate memory for OTA operation.\n    - ESP_ERR_OTA_PARTITION_CONFLICT: Partition holds the currently running firmware, cannot update in place.\n    - ESP_ERR_NOT_FOUND: Partition argument not found in partition table.\n    - ESP_ERR_OTA_SELECT_INFO_INVALID: The OTA data partition contains invalid data.\n    - ESP_ERR_INVALID_SIZE: Partition doesn't fit in configured flash size.\n    - ESP_ERR_FLASH_OP_TIMEOUT or ESP_ERR_FLASH_OP_FAIL: Flash write failed.\n    - ESP_ERR_OTA_ROLLBACK_INVALID_STATE: If the running app has not confirmed state. Before performing an update, the application must be valid."]
    pub fn esp_ota_begin(
        partition: *const esp_partition_t,
        image_size: usize,
        out_handle: *mut esp_ota_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Write OTA update data to partition\n\n This function can be called multiple times as\n data is received during the OTA operation. Data is written\n sequentially to the partition.\n\n @param handle  Handle obtained from esp_ota_begin\n @param data    Data buffer to write\n @param size    Size of data buffer in bytes.\n\n @return\n    - ESP_OK: Data was written to flash successfully.\n    - ESP_ERR_INVALID_ARG: handle is invalid.\n    - ESP_ERR_OTA_VALIDATE_FAILED: First byte of image contains invalid app image magic byte.\n    - ESP_ERR_FLASH_OP_TIMEOUT or ESP_ERR_FLASH_OP_FAIL: Flash write failed.\n    - ESP_ERR_OTA_SELECT_INFO_INVALID: OTA data partition has invalid contents"]
    pub fn esp_ota_write(
        handle: esp_ota_handle_t,
        data: *const ::core::ffi::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Write OTA update data to partition at an offset\n\n This function can write data in non-contiguous manner.\n If flash encryption is enabled, data should be 16 bytes aligned.\n\n @param handle  Handle obtained from esp_ota_begin\n @param data    Data buffer to write\n @param size    Size of data buffer in bytes\n @param offset  Offset in flash partition\n\n @note While performing OTA, if the packets arrive out of order, esp_ota_write_with_offset() can be used to write data in non-contiguous manner.\n       Use of esp_ota_write_with_offset() in combination with esp_ota_write() is not recommended.\n\n @return\n    - ESP_OK: Data was written to flash successfully.\n    - ESP_ERR_INVALID_ARG: handle is invalid.\n    - ESP_ERR_OTA_VALIDATE_FAILED: First byte of image contains invalid app image magic byte.\n    - ESP_ERR_FLASH_OP_TIMEOUT or ESP_ERR_FLASH_OP_FAIL: Flash write failed.\n    - ESP_ERR_OTA_SELECT_INFO_INVALID: OTA data partition has invalid contents"]
    pub fn esp_ota_write_with_offset(
        handle: esp_ota_handle_t,
        data: *const ::core::ffi::c_void,
        size: usize,
        offset: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Finish OTA update and validate newly written app image.\n\n @param handle  Handle obtained from esp_ota_begin().\n\n @note After calling esp_ota_end(), the handle is no longer valid and any memory associated with it is freed (regardless of result).\n\n @return\n    - ESP_OK: Newly written OTA app image is valid.\n    - ESP_ERR_NOT_FOUND: OTA handle was not found.\n    - ESP_ERR_INVALID_ARG: Handle was never written to.\n    - ESP_ERR_OTA_VALIDATE_FAILED: OTA image is invalid (either not a valid app image, or - if secure boot is enabled - signature failed to verify.)\n    - ESP_ERR_INVALID_STATE: If flash encryption is enabled, this result indicates an internal error writing the final encrypted bytes to flash."]
    pub fn esp_ota_end(handle: esp_ota_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Abort OTA update, free the handle and memory associated with it.\n\n @param handle obtained from esp_ota_begin().\n\n @return\n    - ESP_OK: Handle and its associated memory is freed successfully.\n    - ESP_ERR_NOT_FOUND: OTA handle was not found."]
    pub fn esp_ota_abort(handle: esp_ota_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure OTA data for a new boot partition\n\n @note If this function returns ESP_OK, calling esp_restart() will boot the newly configured app partition.\n\n @param partition Pointer to info for partition containing app image to boot.\n\n @return\n    - ESP_OK: OTA data updated, next reboot will use specified partition.\n    - ESP_ERR_INVALID_ARG: partition argument was NULL or didn't point to a valid OTA partition of type \"app\".\n    - ESP_ERR_OTA_VALIDATE_FAILED: Partition contained invalid app image. Also returned if secure boot is enabled and signature validation failed.\n    - ESP_ERR_NOT_FOUND: OTA data partition not found.\n    - ESP_ERR_FLASH_OP_TIMEOUT or ESP_ERR_FLASH_OP_FAIL: Flash erase or write failed."]
    pub fn esp_ota_set_boot_partition(partition: *const esp_partition_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get partition info of currently configured boot app\n\n If esp_ota_set_boot_partition() has been called, the partition which was set by that function will be returned.\n\n If esp_ota_set_boot_partition() has not been called, the result is usually the same as esp_ota_get_running_partition().\n The two results are not equal if the configured boot partition does not contain a valid app (meaning that the running partition\n will be an app that the bootloader chose via fallback).\n\n If the OTA data partition is not present or not valid then the result is the first app partition found in the\n partition table. In priority order, this means: the factory app, the first OTA app slot, or the test app partition.\n\n Note that there is no guarantee the returned partition is a valid app. Use esp_image_verify(ESP_IMAGE_VERIFY, ...) to verify if the\n returned partition contains a bootable image.\n\n @return Pointer to info for partition structure, or NULL if partition table is invalid or a flash read operation failed. Any returned pointer is valid for the lifetime of the application."]
    pub fn esp_ota_get_boot_partition() -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Get partition info of currently running app\n\n This function is different to esp_ota_get_boot_partition() in that\n it ignores any change of selected boot partition caused by\n esp_ota_set_boot_partition(). Only the app whose code is currently\n running will have its partition information returned.\n\n The partition returned by this function may also differ from esp_ota_get_boot_partition() if the configured boot\n partition is somehow invalid, and the bootloader fell back to a different app partition at boot.\n\n @return Pointer to info for partition structure, or NULL if no partition is found or flash read operation failed. Returned pointer is valid for the lifetime of the application."]
    pub fn esp_ota_get_running_partition() -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Return the next OTA app partition which should be written with a new firmware.\n\n Call this function to find an OTA app partition which can be passed to esp_ota_begin().\n\n Finds next partition round-robin, starting from the current running partition.\n\n @param start_from If set, treat this partition info as describing the current running partition. Can be NULL, in which case esp_ota_get_running_partition() is used to find the currently running partition. The result of this function is never the same as this argument.\n\n @return Pointer to info for partition which should be updated next. NULL result indicates invalid OTA data partition, or that no eligible OTA app slot partition was found.\n"]
    pub fn esp_ota_get_next_update_partition(
        start_from: *const esp_partition_t,
    ) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Returns esp_app_desc structure for app partition. This structure includes app version.\n\n Returns a description for the requested app partition.\n @param[in] partition     Pointer to app partition. (only app partition)\n @param[out] app_desc     Structure of info about app.\n @return\n  - ESP_OK                Successful.\n  - ESP_ERR_NOT_FOUND     app_desc structure is not found. Magic word is incorrect.\n  - ESP_ERR_NOT_SUPPORTED Partition is not application.\n  - ESP_ERR_INVALID_ARG   Arguments is NULL or if partition's offset exceeds partition size.\n  - ESP_ERR_INVALID_SIZE  Read would go out of bounds of the partition.\n  - or one of error codes from lower-level flash driver."]
    pub fn esp_ota_get_partition_description(
        partition: *const esp_partition_t,
        app_desc: *mut esp_app_desc_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns number of ota partitions provided in partition table.\n\n @return\n  - Number of OTA partitions"]
    pub fn esp_ota_get_app_partition_count() -> u8;
}
extern "C" {
    #[doc = " @brief This function is called to indicate that the running app is working well.\n\n @return\n  - ESP_OK: if successful."]
    pub fn esp_ota_mark_app_valid_cancel_rollback() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief This function is called to roll back to the previously workable app with reboot.\n\n If rollback is successful then device will reset else API will return with error code.\n Checks applications on a flash drive that can be booted in case of rollback.\n If the flash does not have at least one app (except the running app) then rollback is not possible.\n @return\n  - ESP_FAIL: if not successful.\n  - ESP_ERR_OTA_ROLLBACK_FAILED: The rollback is not possible due to flash does not have any apps."]
    pub fn esp_ota_mark_app_invalid_rollback_and_reboot() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns last partition with invalid state (ESP_OTA_IMG_INVALID or ESP_OTA_IMG_ABORTED).\n\n @return partition."]
    pub fn esp_ota_get_last_invalid_partition() -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Returns state for given partition.\n\n @param[in] partition  Pointer to partition.\n @param[out] ota_state state of partition (if this partition has a record in otadata).\n @return\n        - ESP_OK:                 Successful.\n        - ESP_ERR_INVALID_ARG:    partition or ota_state arguments were NULL.\n        - ESP_ERR_NOT_SUPPORTED:  partition is not ota.\n        - ESP_ERR_NOT_FOUND:      Partition table does not have otadata or state was not found for given partition."]
    pub fn esp_ota_get_state_partition(
        partition: *const esp_partition_t,
        ota_state: *mut esp_ota_img_states_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase previous boot app partition and corresponding otadata select for this partition.\n\n When current app is marked to as valid then you can erase previous app partition.\n @return\n        - ESP_OK:   Successful, otherwise ESP_ERR."]
    pub fn esp_ota_erase_last_boot_app_partition() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Checks applications on the slots which can be booted in case of rollback.\n\n These applications should be valid (marked in otadata as not UNDEFINED, INVALID or ABORTED and crc is good) and be able booted,\n and secure_version of app >= secure_version of efuse (if anti-rollback is enabled).\n\n @return\n        - True: Returns true if the slots have at least one app (except the running app).\n        - False: The rollback is not possible."]
    pub fn esp_ota_check_rollback_is_possible() -> bool;
}
extern "C" {
    pub fn lwip_if_indextoname(
        ifindex: ::core::ffi::c_uint,
        ifname: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn lwip_if_nametoindex(ifname: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn if_nametoindex(ifname: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn if_indextoname(
        ifindex: ::core::ffi::c_uint,
        ifname: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client {
    _unused: [u8; 0],
}
pub type esp_http_client_handle_t = *mut esp_http_client;
pub type esp_http_client_event_handle_t = *mut esp_http_client_event;
#[doc = "< This event occurs when there are any errors during execution"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ERROR: esp_http_client_event_id_t = 0;
#[doc = "< Once the HTTP has been connected to the server, no data exchange has been performed"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_CONNECTED: esp_http_client_event_id_t = 1;
#[doc = "< After sending all the headers to the server"]
pub const esp_http_client_event_id_t_HTTP_EVENT_HEADERS_SENT: esp_http_client_event_id_t = 2;
#[doc = "< This header has been kept for backward compatability\nand will be deprecated in future versions esp-idf"]
pub const esp_http_client_event_id_t_HTTP_EVENT_HEADER_SENT: esp_http_client_event_id_t = 2;
#[doc = "< Occurs when receiving each header sent from the server"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_HEADER: esp_http_client_event_id_t = 3;
#[doc = "< Occurs when receiving data from the server, possibly multiple portions of the packet"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_DATA: esp_http_client_event_id_t = 4;
#[doc = "< Occurs when finish a HTTP session"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_FINISH: esp_http_client_event_id_t = 5;
#[doc = "< The connection has been disconnected"]
pub const esp_http_client_event_id_t_HTTP_EVENT_DISCONNECTED: esp_http_client_event_id_t = 6;
#[doc = "< Intercepting HTTP redirects to handle them manually"]
pub const esp_http_client_event_id_t_HTTP_EVENT_REDIRECT: esp_http_client_event_id_t = 7;
#[doc = " @brief   HTTP Client events id"]
pub type esp_http_client_event_id_t = ::core::ffi::c_uint;
#[doc = " @brief      HTTP Client events data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client_event {
    #[doc = "< event_id, to know the cause of the event"]
    pub event_id: esp_http_client_event_id_t,
    #[doc = "< esp_http_client_handle_t context"]
    pub client: esp_http_client_handle_t,
    #[doc = "< data of the event"]
    pub data: *mut ::core::ffi::c_void,
    #[doc = "< data length of data"]
    pub data_len: ::core::ffi::c_int,
    #[doc = "< user_data context, from esp_http_client_config_t user_data"]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = "< For HTTP_EVENT_ON_HEADER event_id, it's store current http header key"]
    pub header_key: *mut ::core::ffi::c_char,
    #[doc = "< For HTTP_EVENT_ON_HEADER event_id, it's store current http header value"]
    pub header_value: *mut ::core::ffi::c_char,
}
impl Default for esp_http_client_event {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief      HTTP Client events data"]
pub type esp_http_client_event_t = esp_http_client_event;
#[doc = "< Unknown"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_UNKNOWN: esp_http_client_transport_t = 0;
#[doc = "< Transport over tcp"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_OVER_TCP: esp_http_client_transport_t = 1;
#[doc = "< Transport over ssl"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_OVER_SSL: esp_http_client_transport_t = 2;
#[doc = " @brief      HTTP Client transport"]
pub type esp_http_client_transport_t = ::core::ffi::c_uint;
pub type http_event_handle_cb =
    ::core::option::Option<unsafe extern "C" fn(evt: *mut esp_http_client_event_t) -> esp_err_t>;
#[doc = "< HTTP GET Method"]
pub const esp_http_client_method_t_HTTP_METHOD_GET: esp_http_client_method_t = 0;
#[doc = "< HTTP POST Method"]
pub const esp_http_client_method_t_HTTP_METHOD_POST: esp_http_client_method_t = 1;
#[doc = "< HTTP PUT Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PUT: esp_http_client_method_t = 2;
#[doc = "< HTTP PATCH Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PATCH: esp_http_client_method_t = 3;
#[doc = "< HTTP DELETE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_DELETE: esp_http_client_method_t = 4;
#[doc = "< HTTP HEAD Method"]
pub const esp_http_client_method_t_HTTP_METHOD_HEAD: esp_http_client_method_t = 5;
#[doc = "< HTTP NOTIFY Method"]
pub const esp_http_client_method_t_HTTP_METHOD_NOTIFY: esp_http_client_method_t = 6;
#[doc = "< HTTP SUBSCRIBE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_SUBSCRIBE: esp_http_client_method_t = 7;
#[doc = "< HTTP UNSUBSCRIBE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_UNSUBSCRIBE: esp_http_client_method_t = 8;
#[doc = "< HTTP OPTIONS Method"]
pub const esp_http_client_method_t_HTTP_METHOD_OPTIONS: esp_http_client_method_t = 9;
#[doc = "< HTTP COPY Method"]
pub const esp_http_client_method_t_HTTP_METHOD_COPY: esp_http_client_method_t = 10;
#[doc = "< HTTP MOVE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_MOVE: esp_http_client_method_t = 11;
#[doc = "< HTTP LOCK Method"]
pub const esp_http_client_method_t_HTTP_METHOD_LOCK: esp_http_client_method_t = 12;
#[doc = "< HTTP UNLOCK Method"]
pub const esp_http_client_method_t_HTTP_METHOD_UNLOCK: esp_http_client_method_t = 13;
#[doc = "< HTTP PROPFIND Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PROPFIND: esp_http_client_method_t = 14;
#[doc = "< HTTP PROPPATCH Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PROPPATCH: esp_http_client_method_t = 15;
#[doc = "< HTTP MKCOL Method"]
pub const esp_http_client_method_t_HTTP_METHOD_MKCOL: esp_http_client_method_t = 16;
pub const esp_http_client_method_t_HTTP_METHOD_MAX: esp_http_client_method_t = 17;
#[doc = " @brief HTTP method"]
pub type esp_http_client_method_t = ::core::ffi::c_uint;
#[doc = "< No authention"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_NONE: esp_http_client_auth_type_t = 0;
#[doc = "< HTTP Basic authentication"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_BASIC: esp_http_client_auth_type_t = 1;
#[doc = "< HTTP Disgest authentication"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_DIGEST: esp_http_client_auth_type_t = 2;
#[doc = " @brief HTTP Authentication type"]
pub type esp_http_client_auth_type_t = ::core::ffi::c_uint;
#[doc = " @brief HTTP configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client_config_t {
    #[doc = "< HTTP URL, the information on the URL is most important, it overrides the other fields below, if any"]
    pub url: *const ::core::ffi::c_char,
    #[doc = "< Domain or IP as string"]
    pub host: *const ::core::ffi::c_char,
    #[doc = "< Port to connect, default depend on esp_http_client_transport_t (80 or 443)"]
    pub port: ::core::ffi::c_int,
    #[doc = "< Using for Http authentication"]
    pub username: *const ::core::ffi::c_char,
    #[doc = "< Using for Http authentication"]
    pub password: *const ::core::ffi::c_char,
    #[doc = "< Http authentication type, see `esp_http_client_auth_type_t`"]
    pub auth_type: esp_http_client_auth_type_t,
    #[doc = "< HTTP Path, if not set, default is `/`"]
    pub path: *const ::core::ffi::c_char,
    #[doc = "< HTTP query"]
    pub query: *const ::core::ffi::c_char,
    #[doc = "< SSL server certification, PEM format as string, if the client requires to verify server"]
    pub cert_pem: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by cert_pem. May be 0 for null-terminated pem"]
    pub cert_len: usize,
    #[doc = "< SSL client certification, PEM format as string, if the server requires to verify client"]
    pub client_cert_pem: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by client_cert_pem. May be 0 for null-terminated pem"]
    pub client_cert_len: usize,
    #[doc = "< SSL client key, PEM format as string, if the server requires to verify client"]
    pub client_key_pem: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by client_key_pem. May be 0 for null-terminated pem"]
    pub client_key_len: usize,
    #[doc = "< Client key decryption password string"]
    pub client_key_password: *const ::core::ffi::c_char,
    #[doc = "< String length of the password pointed to by client_key_password"]
    pub client_key_password_len: usize,
    #[doc = "< The User Agent string to send with HTTP requests"]
    pub user_agent: *const ::core::ffi::c_char,
    #[doc = "< HTTP Method"]
    pub method: esp_http_client_method_t,
    #[doc = "< Network timeout in milliseconds"]
    pub timeout_ms: ::core::ffi::c_int,
    #[doc = "< Disable HTTP automatic redirects"]
    pub disable_auto_redirect: bool,
    #[doc = "< Max number of redirections on receiving HTTP redirect status code, using default value if zero"]
    pub max_redirection_count: ::core::ffi::c_int,
    #[doc = "< Max connection retries on receiving HTTP unauthorized status code, using default value if zero. Disables authorization retry if -1"]
    pub max_authorization_retries: ::core::ffi::c_int,
    #[doc = "< HTTP Event Handle"]
    pub event_handler: http_event_handle_cb,
    #[doc = "< HTTP transport type, see `esp_http_client_transport_t`"]
    pub transport_type: esp_http_client_transport_t,
    #[doc = "< HTTP receive buffer size"]
    pub buffer_size: ::core::ffi::c_int,
    #[doc = "< HTTP transmit buffer size"]
    pub buffer_size_tx: ::core::ffi::c_int,
    #[doc = "< HTTP user_data context"]
    pub user_data: *mut ::core::ffi::c_void,
    #[doc = "< Set asynchronous mode, only supported with HTTPS for now"]
    pub is_async: bool,
    #[doc = "< Use a global ca_store for all the connections in which this bool is set."]
    pub use_global_ca_store: bool,
    #[doc = "< Skip any validation of server certificate CN field"]
    pub skip_cert_common_name_check: bool,
    #[doc = "< Function pointer to esp_crt_bundle_attach. Enables the use of certification\nbundle for server verification, must be enabled in menuconfig"]
    pub crt_bundle_attach:
        ::core::option::Option<unsafe extern "C" fn(conf: *mut ::core::ffi::c_void) -> esp_err_t>,
    #[doc = "< Enable keep-alive timeout"]
    pub keep_alive_enable: bool,
    #[doc = "< Keep-alive idle time. Default is 5 (second)"]
    pub keep_alive_idle: ::core::ffi::c_int,
    #[doc = "< Keep-alive interval time. Default is 5 (second)"]
    pub keep_alive_interval: ::core::ffi::c_int,
    #[doc = "< Keep-alive packet retry send count. Default is 3 counts"]
    pub keep_alive_count: ::core::ffi::c_int,
    #[doc = "< The name of interface for data to go through. Use the default interface without setting"]
    pub if_name: *mut ifreq,
}
impl Default for esp_http_client_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const HttpStatus_Code_HttpStatus_Ok: HttpStatus_Code = 200;
pub const HttpStatus_Code_HttpStatus_MultipleChoices: HttpStatus_Code = 300;
pub const HttpStatus_Code_HttpStatus_MovedPermanently: HttpStatus_Code = 301;
pub const HttpStatus_Code_HttpStatus_Found: HttpStatus_Code = 302;
pub const HttpStatus_Code_HttpStatus_SeeOther: HttpStatus_Code = 303;
pub const HttpStatus_Code_HttpStatus_TemporaryRedirect: HttpStatus_Code = 307;
pub const HttpStatus_Code_HttpStatus_PermanentRedirect: HttpStatus_Code = 308;
pub const HttpStatus_Code_HttpStatus_BadRequest: HttpStatus_Code = 400;
pub const HttpStatus_Code_HttpStatus_Unauthorized: HttpStatus_Code = 401;
pub const HttpStatus_Code_HttpStatus_Forbidden: HttpStatus_Code = 403;
pub const HttpStatus_Code_HttpStatus_NotFound: HttpStatus_Code = 404;
pub const HttpStatus_Code_HttpStatus_InternalError: HttpStatus_Code = 500;
#[doc = " Enum for the HTTP status codes."]
pub type HttpStatus_Code = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief      Start a HTTP session\n             This function must be the first function to call,\n             and it returns a esp_http_client_handle_t that you must use as input to other functions in the interface.\n             This call MUST have a corresponding call to esp_http_client_cleanup when the operation is complete.\n\n @param[in]  config   The configurations, see `http_client_config_t`\n\n @return\n     - `esp_http_client_handle_t`\n     - NULL if any errors"]
    pub fn esp_http_client_init(
        config: *const esp_http_client_config_t,
    ) -> esp_http_client_handle_t;
}
extern "C" {
    #[doc = " @brief      Invoke this function after `esp_http_client_init` and all the options calls are made, and will perform the\n             transfer as described in the options. It must be called with the same esp_http_client_handle_t as input as the esp_http_client_init call returned.\n             esp_http_client_perform performs the entire request in either blocking or non-blocking manner. By default, the API performs request in a blocking manner and returns when done,\n             or if it failed, and in non-blocking manner, it returns if EAGAIN/EWOULDBLOCK or EINPROGRESS is encountered, or if it failed. And in case of non-blocking request,\n             the user may call this API multiple times unless request & response is complete or there is a failure. To enable non-blocking esp_http_client_perform(), `is_async` member of esp_http_client_config_t\n             must be set while making a call to esp_http_client_init() API.\n             You can do any amount of calls to esp_http_client_perform while using the same esp_http_client_handle_t. The underlying connection may be kept open if the server allows it.\n             If you intend to transfer more than one file, you are even encouraged to do so.\n             esp_http_client will then attempt to re-use the same connection for the following transfers, thus making the operations faster, less CPU intense and using less network resources.\n             Just note that you will have to use `esp_http_client_set_**` between the invokes to set options for the following esp_http_client_perform.\n\n @note       You must never call this function simultaneously from two places using the same client handle.\n             Let the function return first before invoking it another time.\n             If you want parallel transfers, you must use several esp_http_client_handle_t.\n             This function include `esp_http_client_open` -> `esp_http_client_write` -> `esp_http_client_fetch_headers` -> `esp_http_client_read` (and option) `esp_http_client_close`.\n\n @param      client  The esp_http_client handle\n\n @return\n  - ESP_OK on successful\n  - ESP_FAIL on error"]
    pub fn esp_http_client_perform(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set URL for client, when performing this behavior, the options in the URL will replace the old ones\n\n @param[in]  client  The esp_http_client handle\n @param[in]  url     The url\n\n @return\n  - ESP_OK\n  - ESP_FAIL"]
    pub fn esp_http_client_set_url(
        client: esp_http_client_handle_t,
        url: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set post data, this function must be called before `esp_http_client_perform`.\n             Note: The data parameter passed to this function is a pointer and this function will not copy the data\n\n @param[in]  client  The esp_http_client handle\n @param[in]  data    post data pointer\n @param[in]  len     post length\n\n @return\n  - ESP_OK\n  - ESP_FAIL"]
    pub fn esp_http_client_set_post_field(
        client: esp_http_client_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get current post field information\n\n @param[in]  client  The client\n @param[out] data    Point to post data pointer\n\n @return     Size of post data"]
    pub fn esp_http_client_get_post_field(
        client: esp_http_client_handle_t,
        data: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set http request header, this function must be called after esp_http_client_init and before any\n             perform function\n\n @param[in]  client  The esp_http_client handle\n @param[in]  key     The header key\n @param[in]  value   The header value\n\n @return\n  - ESP_OK\n  - ESP_FAIL"]
    pub fn esp_http_client_set_header(
        client: esp_http_client_handle_t,
        key: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get http request header.\n             The value parameter will be set to NULL if there is no header which is same as\n             the key specified, otherwise the address of header value will be assigned to value parameter.\n             This function must be called after `esp_http_client_init`.\n\n @param[in]  client  The esp_http_client handle\n @param[in]  key     The header key\n @param[out] value   The header value\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_http_client_get_header(
        client: esp_http_client_handle_t,
        key: *const ::core::ffi::c_char,
        value: *mut *mut ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get http request username.\n             The address of username buffer will be assigned to value parameter.\n             This function must be called after `esp_http_client_init`.\n\n @param[in]  client  The esp_http_client handle\n @param[out] value   The username value\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_get_username(
        client: esp_http_client_handle_t,
        value: *mut *mut ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set http request username.\n             The value of username parameter will be assigned to username buffer.\n             If the username parameter is NULL then username buffer will be freed.\n\n @param[in]  client    The esp_http_client handle\n @param[in]  username  The username value\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_set_username(
        client: esp_http_client_handle_t,
        username: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get http request password.\n             The address of password buffer will be assigned to value parameter.\n             This function must be called after `esp_http_client_init`.\n\n @param[in]  client  The esp_http_client handle\n @param[out] value   The password value\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_get_password(
        client: esp_http_client_handle_t,
        value: *mut *mut ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set http request password.\n             The value of password parameter will be assigned to password buffer.\n             If the password parameter is NULL then password buffer will be freed.\n\n @param[in]  client    The esp_http_client handle\n @param[in]  password  The password value\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_set_password(
        client: esp_http_client_handle_t,
        password: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set http request auth_type.\n\n @param[in]  client    The esp_http_client handle\n @param[in]  auth_type The esp_http_client auth type\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_set_authtype(
        client: esp_http_client_handle_t,
        auth_type: esp_http_client_auth_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get HTTP client session errno\n\n @param[in]  client  The esp_http_client handle\n\n @return\n         - (-1) if invalid argument\n         - errno"]
    pub fn esp_http_client_get_errno(client: esp_http_client_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set http request method\n\n @param[in]  client  The esp_http_client handle\n @param[in]  method  The method\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_set_method(
        client: esp_http_client_handle_t,
        method: esp_http_client_method_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set http request timeout\n\n @param[in]  client      The esp_http_client handle\n @param[in]  timeout_ms  The timeout value\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_http_client_set_timeout_ms(
        client: esp_http_client_handle_t,
        timeout_ms: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Delete http request header\n\n @param[in]  client  The esp_http_client handle\n @param[in]  key     The key\n\n @return\n  - ESP_OK\n  - ESP_FAIL"]
    pub fn esp_http_client_delete_header(
        client: esp_http_client_handle_t,
        key: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      This function will be open the connection, write all header strings and return\n\n @param[in]  client     The esp_http_client handle\n @param[in]  write_len  HTTP Content length need to write to the server\n\n @return\n  - ESP_OK\n  - ESP_FAIL"]
    pub fn esp_http_client_open(
        client: esp_http_client_handle_t,
        write_len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     This function will write data to the HTTP connection previously opened by esp_http_client_open()\n\n @param[in]  client  The esp_http_client handle\n @param      buffer  The buffer\n @param[in]  len     This value must not be larger than the write_len parameter provided to esp_http_client_open()\n\n @return\n     - (-1) if any errors\n     - Length of data written"]
    pub fn esp_http_client_write(
        client: esp_http_client_handle_t,
        buffer: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      This function need to call after esp_http_client_open, it will read from http stream, process all receive headers\n\n @param[in]  client  The esp_http_client handle\n\n @return\n     - (0) if stream doesn't contain content-length header, or chunked encoding (checked by `esp_http_client_is_chunked` response)\n     - (-1: ESP_FAIL) if any errors\n     - (-ESP_ERR_HTTP_EAGAIN = -0x7007) if call is timed-out before any data was ready\n     - Download data length defined by content-length header"]
    pub fn esp_http_client_fetch_headers(client: esp_http_client_handle_t) -> i64;
}
extern "C" {
    #[doc = " @brief      Check response data is chunked\n\n @param[in]  client  The esp_http_client handle\n\n @return     true or false"]
    pub fn esp_http_client_is_chunked_response(client: esp_http_client_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief      Read data from http stream\n\n @param[in]  client  The esp_http_client handle\n @param      buffer  The buffer\n @param[in]  len     The length\n\n @return\n     - (-1) if any errors\n     - Length of data was read\n\n @note  (-ESP_ERR_HTTP_EAGAIN = -0x7007) is returned when call is timed-out before any data was ready"]
    pub fn esp_http_client_read(
        client: esp_http_client_handle_t,
        buffer: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get http response status code, the valid value if this function invoke after `esp_http_client_perform`\n\n @param[in]  client  The esp_http_client handle\n\n @return     Status code"]
    pub fn esp_http_client_get_status_code(client: esp_http_client_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get http response content length (from header Content-Length)\n             the valid value if this function invoke after `esp_http_client_perform`\n\n @param[in]  client  The esp_http_client handle\n\n @return\n     - (-1) Chunked transfer\n     - Content-Length value as bytes"]
    pub fn esp_http_client_get_content_length(client: esp_http_client_handle_t) -> i64;
}
extern "C" {
    #[doc = " @brief      Close http connection, still kept all http request resources\n\n @param[in]  client  The esp_http_client handle\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_http_client_close(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      This function must be the last function to call for an session.\n             It is the opposite of the esp_http_client_init function and must be called with the same handle as input that a esp_http_client_init call returned.\n             This might close all connections this handle has used and possibly has kept open until now.\n             Don't call this function if you intend to transfer more files, re-using handles is a key to good performance with esp_http_client.\n\n @param[in]  client  The esp_http_client handle\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_http_client_cleanup(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get transport type\n\n @param[in]  client   The esp_http_client handle\n\n @return\n     - HTTP_TRANSPORT_UNKNOWN\n     - HTTP_TRANSPORT_OVER_TCP\n     - HTTP_TRANSPORT_OVER_SSL"]
    pub fn esp_http_client_get_transport_type(
        client: esp_http_client_handle_t,
    ) -> esp_http_client_transport_t;
}
extern "C" {
    #[doc = " @brief      Set redirection URL.\n             When received the 30x code from the server, the client stores the redirect URL provided by the server.\n             This function will set the current URL to redirect to enable client to execute the redirection request.\n             When `disable_auto_redirect` is set, the client will not call this function but the event `HTTP_EVENT_REDIRECT` will be dispatched giving the user contol over the redirection event.\n\n @param[in]  client  The esp_http_client handle\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_http_client_set_redirection(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      On receiving HTTP Status code 401, this API can be invoked to add authorization\n             information.\n\n @note       There is a possibility of receiving body message with redirection status codes, thus make sure\n             to flush off body data after calling this API.\n\n @param[in]  client   The esp_http_client handle"]
    pub fn esp_http_client_add_auth(client: esp_http_client_handle_t);
}
extern "C" {
    #[doc = " @brief      Checks if entire data in the response has been read without any error.\n\n @param[in]  client   The esp_http_client handle\n\n @return\n     - true\n     - false"]
    pub fn esp_http_client_is_complete_data_received(client: esp_http_client_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief      Helper API to read larger data chunks\n             This is a helper API which internally calls `esp_http_client_read` multiple times till the end of data is reached or till the buffer gets full.\n\n @param[in]  client   The esp_http_client handle\n @param      buffer   The buffer\n @param[in]  len      The buffer length\n\n @return\n     - Length of data was read"]
    pub fn esp_http_client_read_response(
        client: esp_http_client_handle_t,
        buffer: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Process all remaining response data\n              This uses an internal buffer to repeatedly receive, parse, and discard response data until complete data is processed.\n              As no additional user-supplied buffer is required, this may be preferrable to `esp_http_client_read_response` in situations where the content of the response may be ignored.\n\n @param[in]  client  The esp_http_client handle\n @param      len     Length of data discarded\n\n @return\n     - ESP_OK                 If successful, len will have discarded length\n     - ESP_FAIL               If failed to read response\n     - ESP_ERR_INVALID_ARG    If the client is NULL"]
    pub fn esp_http_client_flush_response(
        client: esp_http_client_handle_t,
        len: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief          Get URL from client\n\n @param[in]      client   The esp_http_client handle\n @param[inout]   url      The buffer to store URL\n @param[in]      len      The buffer length\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_http_client_get_url(
        client: esp_http_client_handle_t,
        url: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief          Get Chunk-Length from client\n\n @param[in]      client   The esp_http_client handle\n @param[out]     len      Variable to store length\n\n @return\n     - ESP_OK                 If successful, len will have length of current chunk\n     - ESP_FAIL               If the server is not a chunked server\n     - ESP_ERR_INVALID_ARG    If the client or len are NULL"]
    pub fn esp_http_client_get_chunk_length(
        client: esp_http_client_handle_t,
        len: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[doc = "  @brief Keep alive parameters structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_transport_keepalive {
    #[doc = "< Enable keep-alive timeout"]
    pub keep_alive_enable: bool,
    #[doc = "< Keep-alive idle time (second)"]
    pub keep_alive_idle: ::core::ffi::c_int,
    #[doc = "< Keep-alive interval time (second)"]
    pub keep_alive_interval: ::core::ffi::c_int,
    #[doc = "< Keep-alive packet retry send count"]
    pub keep_alive_count: ::core::ffi::c_int,
}
#[doc = "  @brief Keep alive parameters structure"]
pub type esp_transport_keep_alive_t = esp_transport_keepalive;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_transport_list_t {
    _unused: [u8; 0],
}
pub type esp_transport_list_handle_t = *mut esp_transport_list_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_transport_item_t {
    _unused: [u8; 0],
}
pub type esp_transport_handle_t = *mut esp_transport_item_t;
pub type connect_func = ::core::option::Option<
    unsafe extern "C" fn(
        t: esp_transport_handle_t,
        host: *const ::core::ffi::c_char,
        port: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type io_func = ::core::option::Option<
    unsafe extern "C" fn(
        t: esp_transport_handle_t,
        buffer: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type io_read_func = ::core::option::Option<
    unsafe extern "C" fn(
        t: esp_transport_handle_t,
        buffer: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type trans_func =
    ::core::option::Option<unsafe extern "C" fn(t: esp_transport_handle_t) -> ::core::ffi::c_int>;
pub type poll_func = ::core::option::Option<
    unsafe extern "C" fn(
        t: esp_transport_handle_t,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type connect_async_func = ::core::option::Option<
    unsafe extern "C" fn(
        t: esp_transport_handle_t,
        host: *const ::core::ffi::c_char,
        port: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type payload_transfer_func = ::core::option::Option<
    unsafe extern "C" fn(arg1: esp_transport_handle_t) -> esp_transport_handle_t,
>;
pub const esp_tcp_transport_err_t_ERR_TCP_TRANSPORT_NO_MEM: esp_tcp_transport_err_t = -3;
pub const esp_tcp_transport_err_t_ERR_TCP_TRANSPORT_CONNECTION_FAILED: esp_tcp_transport_err_t = -2;
pub const esp_tcp_transport_err_t_ERR_TCP_TRANSPORT_CONNECTION_CLOSED_BY_FIN:
    esp_tcp_transport_err_t = -1;
pub const esp_tcp_transport_err_t_ERR_TCP_TRANSPORT_CONNECTION_TIMEOUT: esp_tcp_transport_err_t = 0;
#[doc = " @brief Error types for TCP connection issues not covered in socket's errno"]
pub type esp_tcp_transport_err_t = ::core::ffi::c_int;
extern "C" {
    #[doc = " @brief      Create transport list\n\n @return     A handle can hold all transports"]
    pub fn esp_transport_list_init() -> esp_transport_list_handle_t;
}
extern "C" {
    #[doc = " @brief      Cleanup and free all transports, include itself,\n             this function will invoke esp_transport_destroy of every transport have added this the list\n\n @param[in]  list  The list\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_transport_list_destroy(list: esp_transport_list_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Add a transport to the list, and define a scheme to indentify this transport in the list\n\n @param[in]  list    The list\n @param[in]  t       The Transport\n @param[in]  scheme  The scheme\n\n @return\n     - ESP_OK"]
    pub fn esp_transport_list_add(
        list: esp_transport_list_handle_t,
        t: esp_transport_handle_t,
        scheme: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      This function will remove all transport from the list,\n             invoke esp_transport_destroy of every transport have added this the list\n\n @param[in]  list  The list\n\n @return\n     - ESP_OK\n     - ESP_ERR_INVALID_ARG"]
    pub fn esp_transport_list_clean(list: esp_transport_list_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the transport by scheme, which has been defined when calling function `esp_transport_list_add`\n\n @param[in]  list  The list\n @param[in]  tag   The tag\n\n @return     The transport handle"]
    pub fn esp_transport_list_get_transport(
        list: esp_transport_list_handle_t,
        scheme: *const ::core::ffi::c_char,
    ) -> esp_transport_handle_t;
}
extern "C" {
    #[doc = " @brief      Initialize a transport handle object\n\n @return     The transport handle"]
    pub fn esp_transport_init() -> esp_transport_handle_t;
}
extern "C" {
    #[doc = " @brief      Cleanup and free memory the transport\n\n @param[in]  t     The transport handle\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_transport_destroy(t: esp_transport_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get default port number used by this transport\n\n @param[in]  t     The transport handle\n\n @return     the port number"]
    pub fn esp_transport_get_default_port(t: esp_transport_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set default port number that can be used by this transport\n\n @param[in]  t     The transport handle\n @param[in]  port  The port number\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_transport_set_default_port(
        t: esp_transport_handle_t,
        port: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Transport connection function, to make a connection to server\n\n @param      t           The transport handle\n @param[in]  host        Hostname\n @param[in]  port        Port\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n - 0 in case of successful connection\n - (-1) if there are any errors, should check errno"]
    pub fn esp_transport_connect(
        t: esp_transport_handle_t,
        host: *const ::core::ffi::c_char,
        port: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Non-blocking transport connection function, to make a connection to server\n\n @param      t           The transport handle\n @param[in]  host        Hostname\n @param[in]  port        Port\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n             - -1      If connection establishment fails.\n             -  0      If connection establishment is in progress.\n             -  1      If connection establishment is successful.\n"]
    pub fn esp_transport_connect_async(
        t: esp_transport_handle_t,
        host: *const ::core::ffi::c_char,
        port: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Transport read function\n\n @param      t           The transport handle\n @param      buffer      The buffer\n @param[in]  len         The length\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n  - Number of bytes was read\n  - 0    Read timed-out\n  - (<0) For other errors\n\n @note: Please refer to the enum `esp_tcp_transport_err_t` for all the possible return values\n"]
    pub fn esp_transport_read(
        t: esp_transport_handle_t,
        buffer: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Poll the transport until readable or timeout\n\n @param[in]  t           The transport handle\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n     - 0      Timeout\n     - (-1)   If there are any errors, should check errno\n     - other  The transport can read"]
    pub fn esp_transport_poll_read(
        t: esp_transport_handle_t,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Transport write function\n\n @param      t           The transport handle\n @param      buffer      The buffer\n @param[in]  len         The length\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n  - Number of bytes was written\n  - (-1) if there are any errors, should check errno"]
    pub fn esp_transport_write(
        t: esp_transport_handle_t,
        buffer: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Poll the transport until writeable or timeout\n\n @param[in]  t           The transport handle\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates wait forever)\n\n @return\n     - 0      Timeout\n     - (-1)   If there are any errors, should check errno\n     - other  The transport can write"]
    pub fn esp_transport_poll_write(
        t: esp_transport_handle_t,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Transport close\n\n @param      t     The transport handle\n\n @return\n - 0 if ok\n - (-1) if there are any errors, should check errno"]
    pub fn esp_transport_close(t: esp_transport_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Get user data context of this transport\n\n @param[in]  t        The transport handle\n\n @return     The user data context"]
    pub fn esp_transport_get_context_data(t: esp_transport_handle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief      Get transport handle of underlying protocol\n             which can access this protocol payload directly\n             (used for receiving longer msg multiple times)\n\n @param[in]  t        The transport handle\n\n @return     Payload transport handle"]
    pub fn esp_transport_get_payload_transport_handle(
        t: esp_transport_handle_t,
    ) -> esp_transport_handle_t;
}
extern "C" {
    #[doc = " @brief      Set the user context data for this transport\n\n @param[in]  t        The transport handle\n @param      data     The user data context\n\n @return\n     - ESP_OK"]
    pub fn esp_transport_set_context_data(
        t: esp_transport_handle_t,
        data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set transport functions for the transport handle\n\n @param[in]  t            The transport handle\n @param[in]  _connect     The connect function pointer\n @param[in]  _read        The read function pointer\n @param[in]  _write       The write function pointer\n @param[in]  _close       The close function pointer\n @param[in]  _poll_read   The poll read function pointer\n @param[in]  _poll_write  The poll write function pointer\n @param[in]  _destroy     The destroy function pointer\n\n @return\n     - ESP_OK"]
    pub fn esp_transport_set_func(
        t: esp_transport_handle_t,
        _connect: connect_func,
        _read: io_read_func,
        _write: io_func,
        _close: trans_func,
        _poll_read: poll_func,
        _poll_write: poll_func,
        _destroy: trans_func,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set transport functions for the transport handle\n\n @param[in]  t                    The transport handle\n @param[in]  _connect_async_func  The connect_async function pointer\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_transport_set_async_connect_func(
        t: esp_transport_handle_t,
        _connect_async_func: connect_async_func,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set parent transport function to the handle\n\n @param[in]  t                    The transport handle\n @param[in]  _parent_transport    The underlying transport getter pointer\n\n @return\n     - ESP_OK\n     - ESP_FAIL"]
    pub fn esp_transport_set_parent_transport_func(
        t: esp_transport_handle_t,
        _parent_transport: payload_transfer_func,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Returns esp_tls error handle.\n             Warning: The returned pointer is valid only as long as esp_transport_handle_t exists. Once transport\n             handle gets destroyed, this value (esp_tls_error_handle_t) is freed automatically.\n\n @param[in]  A transport handle\n\n @return\n            - valid pointer of esp_error_handle_t\n            - NULL if invalid transport handle"]
    pub fn esp_transport_get_error_handle(t: esp_transport_handle_t) -> esp_tls_error_handle_t;
}
extern "C" {
    #[doc = " @brief      Get and clear last captured socket errno\n\n Socket errno is internally stored whenever any of public facing API\n for reading, writing, polling or connection fails returning negative return code.\n The error code corresponds to the `SO_ERROR` value retrieved from the underlying\n transport socket using `getsockopt()` API. After reading the captured errno,\n the internal value is cleared to 0.\n\n @param[in] t The transport handle\n\n @return\n   - >=0 Last captured socket errno\n   - -1  Invalid transport handle or invalid transport's internal error storage"]
    pub fn esp_transport_get_errno(t: esp_transport_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Translates the TCP transport error codes to esp_err_t error codes\n\n @param[in] error TCP Transport specific error code\n\n @return Corresponding esp_err_t based error code"]
    pub fn esp_transport_translate_error(error: esp_tcp_transport_err_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Create new SSL transport, the transport handle must be release esp_transport_destroy callback\n\n @return      the allocated esp_transport_handle_t, or NULL if the handle can not be allocated"]
    pub fn esp_transport_ssl_init() -> esp_transport_handle_t;
}
extern "C" {
    #[doc = " @brief      Set SSL certificate data (as PEM format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The pem data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_cert_data(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set SSL certificate data (as DER format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The der data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_cert_data_der(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Enable the use of certification bundle for server verfication for\n             an SSL connection.\n             It must be first enabled in menuconfig.\n\n @param      t    ssl transport\n @param[in]  crt_bundle_attach    Function pointer to esp_crt_bundle_attach"]
    pub fn esp_transport_ssl_crt_bundle_attach(
        t: esp_transport_handle_t,
        crt_bundle_attach: ::core::option::Option<
            unsafe extern "C" fn(conf: *mut ::core::ffi::c_void) -> esp_err_t,
        >,
    );
}
extern "C" {
    #[doc = " @brief      Enable global CA store for SSL connection\n\n @param      t    ssl transport"]
    pub fn esp_transport_ssl_enable_global_ca_store(t: esp_transport_handle_t);
}
extern "C" {
    #[doc = " @brief      Set SSL client certificate data for mutual authentication (as PEM format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The pem data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_client_cert_data(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set SSL client certificate data for mutual authentication (as DER format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The der data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_client_cert_data_der(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set SSL client key data for mutual authentication (as PEM format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The pem data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_client_key_data(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set SSL client key password if the key is password protected. The configured\n             password is passed to the underlying TLS stack to decrypt the client key\n\n @param      t     ssl transport\n @param[in]  password  Pointer to the password\n @param[in]  password_len   Password length"]
    pub fn esp_transport_ssl_set_client_key_password(
        t: esp_transport_handle_t,
        password: *const ::core::ffi::c_char,
        password_len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set SSL client key data for mutual authentication (as DER format).\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t     ssl transport\n @param[in]  data  The der data\n @param[in]  len   The length"]
    pub fn esp_transport_ssl_set_client_key_data_der(
        t: esp_transport_handle_t,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Set the list of supported application protocols to be used with ALPN.\n             Note that, this function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n\n @param      t            ssl transport\n @param[in]  alpn_porot   The list of ALPN protocols, the last entry must be NULL"]
    pub fn esp_transport_ssl_set_alpn_protocol(
        t: esp_transport_handle_t,
        alpn_protos: *mut *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief      Skip validation of certificate's common name field\n\n @note       Skipping CN validation is not recommended\n\n @param      t     ssl transport"]
    pub fn esp_transport_ssl_skip_common_name_check(t: esp_transport_handle_t);
}
extern "C" {
    #[doc = " @brief      Set the ssl context to use secure element (atecc608a) for client(device) private key and certificate\n\n @note       Recommended to be used with ESP32-WROOM-32SE (which has inbuilt ATECC608A a.k.a Secure Element)\n\n @param      t     ssl transport"]
    pub fn esp_transport_ssl_use_secure_element(t: esp_transport_handle_t);
}
extern "C" {
    #[doc = " @brief      Set the ds_data handle in ssl context.(used for the digital signature operation)\n\n @param      t        ssl transport\n             ds_data  the handle for ds data params"]
    pub fn esp_transport_ssl_set_ds_data(
        t: esp_transport_handle_t,
        ds_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief      Set PSK key and hint for PSK server/client verification in esp-tls component.\n             Important notes:\n             - This function stores the pointer to data, rather than making a copy.\n             So this data must remain valid until after the connection is cleaned up\n             - ESP_TLS_PSK_VERIFICATION config option must be enabled in menuconfig\n             - certificate verification takes priority so it must not be configured\n             to enable PSK method.\n\n @param      t             ssl transport\n @param[in]  psk_hint_key  psk key and hint structure defined in esp_tls.h"]
    pub fn esp_transport_ssl_set_psk_key_hint(
        t: esp_transport_handle_t,
        psk_hint_key: *const psk_hint_key_t,
    );
}
extern "C" {
    #[doc = " @brief      Set keep-alive status in current ssl context\n\n @param[in]  t               ssl transport\n @param[in]  keep_alive_cfg  The handle for keep-alive configuration"]
    pub fn esp_transport_ssl_set_keep_alive(
        t: esp_transport_handle_t,
        keep_alive_cfg: *mut esp_transport_keep_alive_t,
    );
}
extern "C" {
    #[doc = " @brief      Set name of interface that socket can be binded on\n             So the data can transport on this interface\n\n @param[in]  t        The transport handle\n @param[in]  if_name  The interface name"]
    pub fn esp_transport_ssl_set_interface_name(t: esp_transport_handle_t, if_name: *mut ifreq);
}
extern "C" {
    #[doc = " @brief      Set TCP keep-alive configuration\n\n @param[in]  t               The transport handle\n @param[in]  keep_alive_cfg  The keep-alive config\n"]
    pub fn esp_transport_tcp_set_keep_alive(
        t: esp_transport_handle_t,
        keep_alive_cfg: *mut esp_transport_keep_alive_t,
    );
}
extern "C" {
    #[doc = " @brief      Set name of interface that socket can be binded on\n             So the data can transport on this interface\n\n @param[in]  t        The transport handle\n @param[in]  if_name  The interface name"]
    pub fn esp_transport_tcp_set_interface_name(t: esp_transport_handle_t, if_name: *mut ifreq);
}
extern "C" {
    #[doc = " @brief      Create TCP transport, the transport handle must be release esp_transport_destroy callback\n\n @return  the allocated esp_transport_handle_t, or NULL if the handle can not be allocated"]
    pub fn esp_transport_tcp_init() -> esp_transport_handle_t;
}
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_CONT: ws_transport_opcodes = 0;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_TEXT: ws_transport_opcodes = 1;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_BINARY: ws_transport_opcodes = 2;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_CLOSE: ws_transport_opcodes = 8;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_PING: ws_transport_opcodes = 9;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_PONG: ws_transport_opcodes = 10;
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_FIN: ws_transport_opcodes = 128;
#[doc = "< not a valid opcode to indicate no message previously received\n from the API esp_transport_ws_get_read_opcode()"]
pub const ws_transport_opcodes_WS_TRANSPORT_OPCODES_NONE: ws_transport_opcodes = 256;
pub type ws_transport_opcodes = ::core::ffi::c_uint;
pub use self::ws_transport_opcodes as ws_transport_opcodes_t;
#[doc = " WS transport configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_transport_ws_config_t {
    #[doc = "< HTTP path to update protocol to websocket"]
    pub ws_path: *const ::core::ffi::c_char,
    #[doc = "< WS subprotocol"]
    pub sub_protocol: *const ::core::ffi::c_char,
    #[doc = "< WS user agent"]
    pub user_agent: *const ::core::ffi::c_char,
    #[doc = "< WS additional headers"]
    pub headers: *const ::core::ffi::c_char,
    #[doc = "< HTTP authorization header"]
    pub auth: *const ::core::ffi::c_char,
    #[doc = "< If true, control frames are passed to the reader\n   If false, only user frames are propagated, control frames are handled\n   automatically during read operations"]
    pub propagate_control_frames: bool,
}
impl Default for esp_transport_ws_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief      Create web socket transport\n\n @return\n  - transport\n  - NULL"]
    pub fn esp_transport_ws_init(parent_handle: esp_transport_handle_t) -> esp_transport_handle_t;
}
extern "C" {
    #[doc = " @brief       Set HTTP path to update protocol to websocket\n\n @param t     websocket transport handle\n @param path  The HTTP Path"]
    pub fn esp_transport_ws_set_path(t: esp_transport_handle_t, path: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief               Set websocket sub protocol header\n\n @param t             websocket transport handle\n @param sub_protocol  Sub protocol string\n\n @return\n      - ESP_OK on success\n      - One of the error codes"]
    pub fn esp_transport_ws_set_subprotocol(
        t: esp_transport_handle_t,
        sub_protocol: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief               Set websocket user-agent header\n\n @param t             websocket transport handle\n @param sub_protocol  user-agent string\n\n @return\n      - ESP_OK on success\n      - One of the error codes"]
    pub fn esp_transport_ws_set_user_agent(
        t: esp_transport_handle_t,
        user_agent: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief               Set websocket additional headers\n\n @param t             websocket transport handle\n @param sub_protocol  additional header strings each terminated with \\r\\n\n\n @return\n      - ESP_OK on success\n      - One of the error codes"]
    pub fn esp_transport_ws_set_headers(
        t: esp_transport_handle_t,
        headers: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief               Set websocket authorization headers\n\n @param t             websocket transport handle\n @param sub_protocol  The HTTP authorization header string, set NULL to clear the old value\n\n @return\n      - ESP_OK on success\n      - One of the error codes"]
    pub fn esp_transport_ws_set_auth(
        t: esp_transport_handle_t,
        auth: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief               Set websocket transport parameters\n\n @param t             websocket transport handle\n @param config        pointer to websocket config structure\n\n @return\n      - ESP_OK on success\n      - One of the error codes"]
    pub fn esp_transport_ws_set_config(
        t: esp_transport_handle_t,
        config: *const esp_transport_ws_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief               Sends websocket raw message with custom opcode and payload\n\n Note that generic esp_transport_write for ws handle sends\n binary massages by default if size is > 0 and\n ping message if message size is set to 0.\n This API is provided to support explicit messages with arbitrary opcode,\n should it be PING, PONG or TEXT message with arbitrary data.\n\n @param[in]  t           Websocket transport handle\n @param[in]  opcode      ws operation code\n @param[in]  buffer      The buffer\n @param[in]  len         The length\n @param[in]  timeout_ms  The timeout milliseconds (-1 indicates block forever)\n\n @return\n  - Number of bytes was written\n  - (-1) if there are any errors, should check errno"]
    pub fn esp_transport_ws_send_raw(
        t: esp_transport_handle_t,
        opcode: ws_transport_opcodes_t,
        b: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief               Returns websocket fin flag for last received data\n\n @param t             websocket transport handle\n\n @return\n      - Fin flag as a boolean"]
    pub fn esp_transport_ws_get_fin_flag(t: esp_transport_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief               Returns the HTTP status code of the websocket handshake\n\n This API should be called after the connection atempt otherwise its result is meaningless\n\n @param t             websocket transport handle\n\n @return\n      -Response status code\n      -1 on failure"]
    pub fn esp_transport_ws_get_upgrade_request_status(
        t: esp_transport_handle_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief               Returns websocket op-code for last received data\n\n @param t             websocket transport handle\n\n @return\n      - Received op-code as enum"]
    pub fn esp_transport_ws_get_read_opcode(t: esp_transport_handle_t) -> ws_transport_opcodes_t;
}
extern "C" {
    #[doc = " @brief               Returns payload length of the last received data\n\n @param t             websocket transport handle\n\n @return\n      - Number of bytes in the payload"]
    pub fn esp_transport_ws_get_read_payload_len(t: esp_transport_handle_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief               Polls the active connection for termination\n\n This API is typically used by the client to wait for clean connection closure\n by websocket server\n\n @param t             Websocket transport handle\n @param[in] timeout_ms The timeout milliseconds\n\n @return\n      0 - no activity on read and error socket descriptor within timeout\n      1 - Success: either connection terminated by FIN or the most common RST err codes\n      -1 - Failure: Unexpected error code or socket is normally readable"]
    pub fn esp_transport_ws_poll_connection_closed(
        t: esp_transport_handle_t,
        timeout_ms: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type http_data_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut http_parser,
        at: *const ::core::ffi::c_char,
        length: usize,
    ) -> ::core::ffi::c_int,
>;
pub type http_cb =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut http_parser) -> ::core::ffi::c_int>;
pub const http_method_HTTP_DELETE: http_method = 0;
pub const http_method_HTTP_GET: http_method = 1;
pub const http_method_HTTP_HEAD: http_method = 2;
pub const http_method_HTTP_POST: http_method = 3;
pub const http_method_HTTP_PUT: http_method = 4;
pub const http_method_HTTP_CONNECT: http_method = 5;
pub const http_method_HTTP_OPTIONS: http_method = 6;
pub const http_method_HTTP_TRACE: http_method = 7;
pub const http_method_HTTP_COPY: http_method = 8;
pub const http_method_HTTP_LOCK: http_method = 9;
pub const http_method_HTTP_MKCOL: http_method = 10;
pub const http_method_HTTP_MOVE: http_method = 11;
pub const http_method_HTTP_PROPFIND: http_method = 12;
pub const http_method_HTTP_PROPPATCH: http_method = 13;
pub const http_method_HTTP_SEARCH: http_method = 14;
pub const http_method_HTTP_UNLOCK: http_method = 15;
pub const http_method_HTTP_BIND: http_method = 16;
pub const http_method_HTTP_REBIND: http_method = 17;
pub const http_method_HTTP_UNBIND: http_method = 18;
pub const http_method_HTTP_ACL: http_method = 19;
pub const http_method_HTTP_REPORT: http_method = 20;
pub const http_method_HTTP_MKACTIVITY: http_method = 21;
pub const http_method_HTTP_CHECKOUT: http_method = 22;
pub const http_method_HTTP_MERGE: http_method = 23;
pub const http_method_HTTP_MSEARCH: http_method = 24;
pub const http_method_HTTP_NOTIFY: http_method = 25;
pub const http_method_HTTP_SUBSCRIBE: http_method = 26;
pub const http_method_HTTP_UNSUBSCRIBE: http_method = 27;
pub const http_method_HTTP_PATCH: http_method = 28;
pub const http_method_HTTP_PURGE: http_method = 29;
pub const http_method_HTTP_MKCALENDAR: http_method = 30;
pub const http_method_HTTP_LINK: http_method = 31;
pub const http_method_HTTP_UNLINK: http_method = 32;
pub type http_method = ::core::ffi::c_uint;
pub const http_parser_type_HTTP_REQUEST: http_parser_type = 0;
pub const http_parser_type_HTTP_RESPONSE: http_parser_type = 1;
pub const http_parser_type_HTTP_BOTH: http_parser_type = 2;
pub type http_parser_type = ::core::ffi::c_uint;
pub const flags_F_CHUNKED: flags = 1;
pub const flags_F_CONNECTION_KEEP_ALIVE: flags = 2;
pub const flags_F_CONNECTION_CLOSE: flags = 4;
pub const flags_F_CONNECTION_UPGRADE: flags = 8;
pub const flags_F_TRAILING: flags = 16;
pub const flags_F_UPGRADE: flags = 32;
pub const flags_F_SKIPBODY: flags = 64;
pub const flags_F_CONTENTLENGTH: flags = 128;
pub type flags = ::core::ffi::c_uint;
pub const http_errno_HPE_OK: http_errno = 0;
pub const http_errno_HPE_CB_message_begin: http_errno = 1;
pub const http_errno_HPE_CB_url: http_errno = 2;
pub const http_errno_HPE_CB_header_field: http_errno = 3;
pub const http_errno_HPE_CB_header_value: http_errno = 4;
pub const http_errno_HPE_CB_headers_complete: http_errno = 5;
pub const http_errno_HPE_CB_body: http_errno = 6;
pub const http_errno_HPE_CB_message_complete: http_errno = 7;
pub const http_errno_HPE_CB_status: http_errno = 8;
pub const http_errno_HPE_CB_chunk_header: http_errno = 9;
pub const http_errno_HPE_CB_chunk_complete: http_errno = 10;
pub const http_errno_HPE_INVALID_EOF_STATE: http_errno = 11;
pub const http_errno_HPE_HEADER_OVERFLOW: http_errno = 12;
pub const http_errno_HPE_CLOSED_CONNECTION: http_errno = 13;
pub const http_errno_HPE_INVALID_VERSION: http_errno = 14;
pub const http_errno_HPE_INVALID_STATUS: http_errno = 15;
pub const http_errno_HPE_INVALID_METHOD: http_errno = 16;
pub const http_errno_HPE_INVALID_URL: http_errno = 17;
pub const http_errno_HPE_INVALID_HOST: http_errno = 18;
pub const http_errno_HPE_INVALID_PORT: http_errno = 19;
pub const http_errno_HPE_INVALID_PATH: http_errno = 20;
pub const http_errno_HPE_INVALID_QUERY_STRING: http_errno = 21;
pub const http_errno_HPE_INVALID_FRAGMENT: http_errno = 22;
pub const http_errno_HPE_LF_EXPECTED: http_errno = 23;
pub const http_errno_HPE_INVALID_HEADER_TOKEN: http_errno = 24;
pub const http_errno_HPE_INVALID_CONTENT_LENGTH: http_errno = 25;
pub const http_errno_HPE_UNEXPECTED_CONTENT_LENGTH: http_errno = 26;
pub const http_errno_HPE_INVALID_CHUNK_SIZE: http_errno = 27;
pub const http_errno_HPE_INVALID_CONSTANT: http_errno = 28;
pub const http_errno_HPE_INVALID_INTERNAL_STATE: http_errno = 29;
pub const http_errno_HPE_STRICT: http_errno = 30;
pub const http_errno_HPE_PAUSED: http_errno = 31;
pub const http_errno_HPE_UNKNOWN: http_errno = 32;
pub type http_errno = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_parser {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub nread: u32,
    pub content_length: u64,
    #[doc = " READ-ONLY"]
    pub http_major: ::core::ffi::c_ushort,
    pub http_minor: ::core::ffi::c_ushort,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " PUBLIC"]
    pub data: *mut ::core::ffi::c_void,
}
impl Default for http_parser {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl http_parser {
    #[inline]
    pub fn type_(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn header_state(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_header_state(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn lenient_http_headers(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lenient_http_headers(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
        state: ::core::ffi::c_uint,
        header_state: ::core::ffi::c_uint,
        index: ::core::ffi::c_uint,
        lenient_http_headers: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(10usize, 7u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(17usize, 7u8, {
            let header_state: u32 = unsafe { ::core::mem::transmute(header_state) };
            header_state as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let index: u32 = unsafe { ::core::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lenient_http_headers: u32 = unsafe { ::core::mem::transmute(lenient_http_headers) };
            lenient_http_headers as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn status_code(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_status_code(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn method(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_method(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn http_errno(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_http_errno(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn upgrade(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upgrade(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        status_code: ::core::ffi::c_uint,
        method: ::core::ffi::c_uint,
        http_errno: ::core::ffi::c_uint,
        upgrade: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let status_code: u32 = unsafe { ::core::mem::transmute(status_code) };
            status_code as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let method: u32 = unsafe { ::core::mem::transmute(method) };
            method as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let http_errno: u32 = unsafe { ::core::mem::transmute(http_errno) };
            http_errno as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let upgrade: u32 = unsafe { ::core::mem::transmute(upgrade) };
            upgrade as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct http_parser_settings {
    pub on_message_begin: http_cb,
    pub on_url: http_data_cb,
    pub on_status: http_data_cb,
    pub on_header_field: http_data_cb,
    pub on_header_value: http_data_cb,
    pub on_headers_complete: http_cb,
    pub on_body: http_data_cb,
    pub on_message_complete: http_cb,
    pub on_chunk_header: http_cb,
    pub on_chunk_complete: http_cb,
}
pub const http_parser_url_fields_UF_SCHEMA: http_parser_url_fields = 0;
pub const http_parser_url_fields_UF_HOST: http_parser_url_fields = 1;
pub const http_parser_url_fields_UF_PORT: http_parser_url_fields = 2;
pub const http_parser_url_fields_UF_PATH: http_parser_url_fields = 3;
pub const http_parser_url_fields_UF_QUERY: http_parser_url_fields = 4;
pub const http_parser_url_fields_UF_FRAGMENT: http_parser_url_fields = 5;
pub const http_parser_url_fields_UF_USERINFO: http_parser_url_fields = 6;
pub const http_parser_url_fields_UF_MAX: http_parser_url_fields = 7;
pub type http_parser_url_fields = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct http_parser_url {
    pub field_set: u16,
    pub port: u16,
    pub field_data: [http_parser_url__bindgen_ty_1; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct http_parser_url__bindgen_ty_1 {
    pub off: u16,
    pub len: u16,
}
extern "C" {
    pub fn http_parser_version() -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn http_parser_init(parser: *mut http_parser, type_: http_parser_type);
}
extern "C" {
    pub fn http_parser_settings_init(settings: *mut http_parser_settings);
}
extern "C" {
    pub fn http_parser_execute(
        parser: *mut http_parser,
        settings: *const http_parser_settings,
        data: *const ::core::ffi::c_char,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn http_should_keep_alive(parser: *const http_parser) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn http_method_str(m: http_method) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn http_errno_name(err: http_errno) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn http_errno_description(err: http_errno) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn http_parser_url_init(u: *mut http_parser_url);
}
extern "C" {
    pub fn http_parser_parse_url(
        buf: *const ::core::ffi::c_char,
        buflen: usize,
        is_connect: ::core::ffi::c_int,
        u: *mut http_parser_url,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn http_parser_pause(parser: *mut http_parser, paused: ::core::ffi::c_int);
}
extern "C" {
    pub fn http_body_is_final(parser: *const http_parser) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut ESP_HTTP_SERVER_EVENT: esp_event_base_t;
}
#[doc = "< This event occurs when there are any errors during execution"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_ERROR: esp_http_server_event_id_t = 0;
#[doc = "< This event occurs when HTTP Server is started"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_START: esp_http_server_event_id_t = 1;
#[doc = "< Once the HTTP Server has been connected to the client, no data exchange has been performed"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_ON_CONNECTED: esp_http_server_event_id_t = 2;
#[doc = "< Occurs when receiving each header sent from the client"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_ON_HEADER: esp_http_server_event_id_t = 3;
#[doc = "< After sending all the headers to the client"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_HEADERS_SENT: esp_http_server_event_id_t = 4;
#[doc = "< Occurs when receiving data from the client"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_ON_DATA: esp_http_server_event_id_t = 5;
#[doc = "< Occurs when an ESP HTTP server session is finished"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_SENT_DATA: esp_http_server_event_id_t = 6;
#[doc = "< The connection has been disconnected"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_DISCONNECTED: esp_http_server_event_id_t = 7;
#[doc = "< This event occurs when HTTP Server is stopped"]
pub const esp_http_server_event_id_t_HTTP_SERVER_EVENT_STOP: esp_http_server_event_id_t = 8;
#[doc = " @brief   HTTP Server events id"]
pub type esp_http_server_event_id_t = ::core::ffi::c_uint;
#[doc = " Argument structure for HTTP_SERVER_EVENT_ON_DATA and HTTP_SERVER_EVENT_SENT_DATA event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_http_server_event_data {
    #[doc = "< Session socket file descriptor"]
    pub fd: ::core::ffi::c_int,
    #[doc = "< Data length"]
    pub data_len: ::core::ffi::c_int,
}
#[doc = " @brief   HTTP Server Instance Handle\n\n Every instance of the server will have a unique handle."]
pub type httpd_handle_t = *mut ::core::ffi::c_void;
#[doc = " @brief   HTTP Method Type wrapper over \"enum http_method\"\n          available in \"http_parser\" library"]
pub use self::http_method as httpd_method_t;
#[doc = " @brief  Prototype for freeing context data (if any)\n @param[in] ctx   object to free"]
pub type httpd_free_ctx_fn_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " @brief  Function prototype for opening a session.\n\n Called immediately after the socket was opened to set up the send/recv functions and\n other parameters of the socket.\n\n @param[in] hd       server instance\n @param[in] sockfd   session socket file descriptor\n @return\n  - ESP_OK   : On success\n  - Any value other than ESP_OK will signal the server to close the socket immediately"]
pub type httpd_open_func_t = ::core::option::Option<
    unsafe extern "C" fn(hd: httpd_handle_t, sockfd: ::core::ffi::c_int) -> esp_err_t,
>;
#[doc = " @brief  Function prototype for closing a session.\n\n @note   It's possible that the socket descriptor is invalid at this point, the function\n         is called for all terminated sessions. Ensure proper handling of return codes.\n\n @param[in] hd   server instance\n @param[in] sockfd   session socket file descriptor"]
pub type httpd_close_func_t =
    ::core::option::Option<unsafe extern "C" fn(hd: httpd_handle_t, sockfd: ::core::ffi::c_int)>;
#[doc = " @brief  Function prototype for URI matching.\n\n @param[in] reference_uri   URI/template with respect to which the other URI is matched\n @param[in] uri_to_match    URI/template being matched to the reference URI/template\n @param[in] match_upto      For specifying the actual length of `uri_to_match` up to\n                            which the matching algorithm is to be applied (The maximum\n                            value is `strlen(uri_to_match)`, independent of the length\n                            of `reference_uri`)\n @return true on match"]
pub type httpd_uri_match_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        reference_uri: *const ::core::ffi::c_char,
        uri_to_match: *const ::core::ffi::c_char,
        match_upto: usize,
    ) -> bool,
>;
#[doc = " @brief   HTTP Server Configuration Structure\n\n @note    Use HTTPD_DEFAULT_CONFIG() to initialize the configuration\n          to a default value and then modify only those fields that are\n          specifically determined by the use case."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct httpd_config {
    #[doc = "< Priority of FreeRTOS task which runs the server"]
    pub task_priority: ::core::ffi::c_uint,
    #[doc = "< The maximum stack size allowed for the server task"]
    pub stack_size: usize,
    #[doc = "< The core the HTTP server task will run on"]
    pub core_id: BaseType_t,
    #[doc = " TCP Port number for receiving and transmitting HTTP traffic"]
    pub server_port: u16,
    #[doc = " UDP Port number for asynchronously exchanging control signals\n between various components of the server"]
    pub ctrl_port: u16,
    #[doc = "< Max number of sockets/clients connected at any time"]
    pub max_open_sockets: u16,
    #[doc = "< Maximum allowed uri handlers"]
    pub max_uri_handlers: u16,
    #[doc = "< Maximum allowed additional headers in HTTP response"]
    pub max_resp_headers: u16,
    #[doc = "< Number of backlog connections"]
    pub backlog_conn: u16,
    #[doc = "< Purge \"Least Recently Used\" connection"]
    pub lru_purge_enable: bool,
    #[doc = "< Timeout for recv function (in seconds)"]
    pub recv_wait_timeout: u16,
    #[doc = "< Timeout for send function (in seconds)"]
    pub send_wait_timeout: u16,
    #[doc = " Global user context.\n\n This field can be used to store arbitrary user data within the server context.\n The value can be retrieved using the server handle, available e.g. in the httpd_req_t struct.\n\n When shutting down, the server frees up the user context by\n calling free() on the global_user_ctx field. If you wish to use a custom\n function for freeing the global user context, please specify that here."]
    pub global_user_ctx: *mut ::core::ffi::c_void,
    #[doc = " Free function for global user context"]
    pub global_user_ctx_free_fn: httpd_free_ctx_fn_t,
    #[doc = " Global transport context.\n\n Similar to global_user_ctx, but used for session encoding or encryption (e.g. to hold the SSL context).\n It will be freed using free(), unless global_transport_ctx_free_fn is specified."]
    pub global_transport_ctx: *mut ::core::ffi::c_void,
    #[doc = " Free function for global transport context"]
    pub global_transport_ctx_free_fn: httpd_free_ctx_fn_t,
    #[doc = "< bool to enable/disable linger"]
    pub enable_so_linger: bool,
    #[doc = "< linger timeout (in seconds)"]
    pub linger_timeout: ::core::ffi::c_int,
    #[doc = "< Enable keep-alive timeout"]
    pub keep_alive_enable: bool,
    #[doc = "< Keep-alive idle time. Default is 5 (second)"]
    pub keep_alive_idle: ::core::ffi::c_int,
    #[doc = "< Keep-alive interval time. Default is 5 (second)"]
    pub keep_alive_interval: ::core::ffi::c_int,
    #[doc = "< Keep-alive packet retry send count. Default is 3 counts"]
    pub keep_alive_count: ::core::ffi::c_int,
    #[doc = " Custom session opening callback.\n\n Called on a new session socket just after accept(), but before reading any data.\n\n This is an opportunity to set up e.g. SSL encryption using global_transport_ctx\n and the send/recv/pending session overrides.\n\n If a context needs to be maintained between these functions, store it in the session using\n httpd_sess_set_transport_ctx() and retrieve it later with httpd_sess_get_transport_ctx()\n\n Returning a value other than ESP_OK will immediately close the new socket."]
    pub open_fn: httpd_open_func_t,
    #[doc = " Custom session closing callback.\n\n Called when a session is deleted, before freeing user and transport contexts and before\n closing the socket. This is a place for custom de-init code common to all sockets.\n\n The server will only close the socket if no custom session closing callback is set.\n If a custom callback is used, `close(sockfd)` should be called in here for most cases.\n\n Set the user or transport context to NULL if it was freed here, so the server does not\n try to free it again.\n\n This function is run for all terminated sessions, including sessions where the socket\n was closed by the network stack - that is, the file descriptor may not be valid anymore."]
    pub close_fn: httpd_close_func_t,
    #[doc = " URI matcher function.\n\n Called when searching for a matching URI:\n     1) whose request handler is to be executed right\n        after an HTTP request is successfully parsed\n     2) in order to prevent duplication while registering\n        a new URI handler using `httpd_register_uri_handler()`\n\n Available options are:\n     1) NULL : Internally do basic matching using `strncmp()`\n     2) `httpd_uri_match_wildcard()` : URI wildcard matcher\n\n Users can implement their own matching functions (See description\n of the `httpd_uri_match_func_t` function prototype)"]
    pub uri_match_fn: httpd_uri_match_func_t,
}
impl Default for httpd_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   HTTP Server Configuration Structure\n\n @note    Use HTTPD_DEFAULT_CONFIG() to initialize the configuration\n          to a default value and then modify only those fields that are\n          specifically determined by the use case."]
pub type httpd_config_t = httpd_config;
extern "C" {
    #[doc = " @brief Starts the web server\n\n Create an instance of HTTP server and allocate memory/resources for it\n depending upon the specified configuration.\n\n Example usage:\n @code{c}\n\n //Function for starting the webserver\n httpd_handle_t start_webserver(void)\n {\n      // Generate default configuration\n      httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n\n      // Empty handle to http_server\n      httpd_handle_t server = NULL;\n\n      // Start the httpd server\n      if (httpd_start(&server, &config) == ESP_OK) {\n          // Register URI handlers\n          httpd_register_uri_handler(server, &uri_get);\n          httpd_register_uri_handler(server, &uri_post);\n      }\n      // If server failed to start, handle will be NULL\n      return server;\n }\n\n @endcode\n\n @param[in]  config   Configuration for new instance of the server\n @param[out] handle   Handle to newly created instance of the server. NULL on error\n @return\n  - ESP_OK    : Instance created successfully\n  - ESP_ERR_INVALID_ARG      : Null argument(s)\n  - ESP_ERR_HTTPD_ALLOC_MEM  : Failed to allocate memory for instance\n  - ESP_ERR_HTTPD_TASK       : Failed to launch server task"]
    pub fn httpd_start(handle: *mut httpd_handle_t, config: *const httpd_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stops the web server\n\n Deallocates memory/resources used by an HTTP server instance and\n deletes it. Once deleted the handle can no longer be used for accessing\n the instance.\n\n Example usage:\n @code{c}\n\n // Function for stopping the webserver\n void stop_webserver(httpd_handle_t server)\n {\n      // Ensure handle is non NULL\n      if (server != NULL) {\n          // Stop the httpd server\n          httpd_stop(server);\n      }\n }\n\n @endcode\n\n @param[in] handle Handle to server returned by httpd_start\n @return\n  - ESP_OK : Server stopped successfully\n  - ESP_ERR_INVALID_ARG : Handle argument is Null"]
    pub fn httpd_stop(handle: httpd_handle_t) -> esp_err_t;
}
#[doc = " @brief HTTP Request Data Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct httpd_req {
    #[doc = "< Handle to server instance"]
    pub handle: httpd_handle_t,
    #[doc = "< The type of HTTP request, -1 if unsupported method"]
    pub method: ::core::ffi::c_int,
    #[doc = "< The URI of this request (1 byte extra for null termination)"]
    pub uri: [::core::ffi::c_char; 513usize],
    #[doc = "< Length of the request body"]
    pub content_len: usize,
    #[doc = "< Internally used members"]
    pub aux: *mut ::core::ffi::c_void,
    #[doc = " User context pointer passed during URI registration."]
    pub user_ctx: *mut ::core::ffi::c_void,
    #[doc = " Session Context Pointer\n\n A session context. Contexts are maintained across 'sessions' for a\n given open TCP connection. One session could have multiple request\n responses. The web server will ensure that the context persists\n across all these request and responses.\n\n By default, this is NULL. URI Handlers can set this to any meaningful\n value.\n\n If the underlying socket gets closed, and this pointer is non-NULL,\n the web server will free up the context by calling free(), unless\n free_ctx function is set."]
    pub sess_ctx: *mut ::core::ffi::c_void,
    #[doc = " Pointer to free context hook\n\n Function to free session context\n\n If the web server's socket closes, it frees up the session context by\n calling free() on the sess_ctx member. If you wish to use a custom\n function for freeing the session context, please specify that here."]
    pub free_ctx: httpd_free_ctx_fn_t,
    #[doc = " Flag indicating if Session Context changes should be ignored\n\n By default, if you change the sess_ctx in some URI handler, the http server\n will internally free the earlier context (if non NULL), after the URI handler\n returns. If you want to manage the allocation/reallocation/freeing of\n sess_ctx yourself, set this flag to true, so that the server will not\n perform any checks on it. The context will be cleared by the server\n (by calling free_ctx or free()) only if the socket gets closed."]
    pub ignore_sess_ctx_changes: bool,
}
impl Default for httpd_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief HTTP Request Data Structure"]
pub type httpd_req_t = httpd_req;
#[doc = " @brief Structure for URI handler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct httpd_uri {
    #[doc = "< The URI to handle"]
    pub uri: *const ::core::ffi::c_char,
    #[doc = "< Method supported by the URI"]
    pub method: httpd_method_t,
    #[doc = " Handler to call for supported request method. This must\n return ESP_OK, or else the underlying socket will be closed."]
    pub handler: ::core::option::Option<unsafe extern "C" fn(r: *mut httpd_req_t) -> esp_err_t>,
    #[doc = " Pointer to user context data which will be available to handler"]
    pub user_ctx: *mut ::core::ffi::c_void,
}
impl Default for httpd_uri {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Structure for URI handler"]
pub type httpd_uri_t = httpd_uri;
extern "C" {
    #[doc = " @brief   Registers a URI handler\n\n @note    URI handlers can be registered in real time as long as the\n          server handle is valid.\n\n Example usage:\n @code{c}\n\n esp_err_t my_uri_handler(httpd_req_t* req)\n {\n     // Recv , Process and Send\n     ....\n     ....\n     ....\n\n     // Fail condition\n     if (....) {\n         // Return fail to close session //\n         return ESP_FAIL;\n     }\n\n     // On success\n     return ESP_OK;\n }\n\n // URI handler structure\n httpd_uri_t my_uri {\n     .uri      = \"/my_uri/path/xyz\",\n     .method   = HTTPD_GET,\n     .handler  = my_uri_handler,\n     .user_ctx = NULL\n };\n\n // Register handler\n if (httpd_register_uri_handler(server_handle, &my_uri) != ESP_OK) {\n    // If failed to register handler\n    ....\n }\n\n @endcode\n\n @param[in] handle      handle to HTTPD server instance\n @param[in] uri_handler pointer to handler that needs to be registered\n\n @return\n  - ESP_OK : On successfully registering the handler\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_HTTPD_HANDLERS_FULL  : If no slots left for new handler\n  - ESP_ERR_HTTPD_HANDLER_EXISTS : If handler with same URI and\n                                   method is already registered"]
    pub fn httpd_register_uri_handler(
        handle: httpd_handle_t,
        uri_handler: *const httpd_uri_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Unregister a URI handler\n\n @param[in] handle    handle to HTTPD server instance\n @param[in] uri       URI string\n @param[in] method    HTTP method\n\n @return\n  - ESP_OK : On successfully deregistering the handler\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_NOT_FOUND   : Handler with specified URI and method not found"]
    pub fn httpd_unregister_uri_handler(
        handle: httpd_handle_t,
        uri: *const ::core::ffi::c_char,
        method: httpd_method_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Unregister all URI handlers with the specified uri string\n\n @param[in] handle   handle to HTTPD server instance\n @param[in] uri      uri string specifying all handlers that need\n                     to be deregisterd\n\n @return\n  - ESP_OK : On successfully deregistering all such handlers\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_NOT_FOUND   : No handler registered with specified uri string"]
    pub fn httpd_unregister_uri(
        handle: httpd_handle_t,
        uri: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
pub const httpd_err_code_t_HTTPD_500_INTERNAL_SERVER_ERROR: httpd_err_code_t = 0;
pub const httpd_err_code_t_HTTPD_501_METHOD_NOT_IMPLEMENTED: httpd_err_code_t = 1;
pub const httpd_err_code_t_HTTPD_505_VERSION_NOT_SUPPORTED: httpd_err_code_t = 2;
pub const httpd_err_code_t_HTTPD_400_BAD_REQUEST: httpd_err_code_t = 3;
pub const httpd_err_code_t_HTTPD_401_UNAUTHORIZED: httpd_err_code_t = 4;
pub const httpd_err_code_t_HTTPD_403_FORBIDDEN: httpd_err_code_t = 5;
pub const httpd_err_code_t_HTTPD_404_NOT_FOUND: httpd_err_code_t = 6;
pub const httpd_err_code_t_HTTPD_405_METHOD_NOT_ALLOWED: httpd_err_code_t = 7;
pub const httpd_err_code_t_HTTPD_408_REQ_TIMEOUT: httpd_err_code_t = 8;
pub const httpd_err_code_t_HTTPD_411_LENGTH_REQUIRED: httpd_err_code_t = 9;
pub const httpd_err_code_t_HTTPD_414_URI_TOO_LONG: httpd_err_code_t = 10;
pub const httpd_err_code_t_HTTPD_431_REQ_HDR_FIELDS_TOO_LARGE: httpd_err_code_t = 11;
pub const httpd_err_code_t_HTTPD_ERR_CODE_MAX: httpd_err_code_t = 12;
#[doc = " @brief Error codes sent as HTTP response in case of errors\n        encountered during processing of an HTTP request"]
pub type httpd_err_code_t = ::core::ffi::c_uint;
#[doc = " @brief  Function prototype for HTTP error handling.\n\n This function is executed upon HTTP errors generated during\n internal processing of an HTTP request. This is used to override\n the default behavior on error, which is to send HTTP error response\n and close the underlying socket.\n\n @note\n  - If implemented, the server will not automatically send out HTTP\n    error response codes, therefore, httpd_resp_send_err() must be\n    invoked inside this function if user wishes to generate HTTP\n    error responses.\n  - When invoked, the validity of `uri`, `method`, `content_len`\n    and `user_ctx` fields of the httpd_req_t parameter is not\n    guaranteed as the HTTP request may be partially received/parsed.\n  - The function must return ESP_OK if underlying socket needs to\n    be kept open. Any other value will ensure that the socket is\n    closed. The return value is ignored when error is of type\n    `HTTPD_500_INTERNAL_SERVER_ERROR` and the socket closed anyway.\n\n @param[in] req    HTTP request for which the error needs to be handled\n @param[in] error  Error type\n\n @return\n  - ESP_OK   : error handled successful\n  - ESP_FAIL : failure indicates that the underlying socket needs to be closed"]
pub type httpd_err_handler_func_t = ::core::option::Option<
    unsafe extern "C" fn(req: *mut httpd_req_t, error: httpd_err_code_t) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief  Function for registering HTTP error handlers\n\n This function maps a handler function to any supported error code\n given by `httpd_err_code_t`. See prototype `httpd_err_handler_func_t`\n above for details.\n\n @param[in] handle     HTTP server handle\n @param[in] error      Error type\n @param[in] handler_fn User implemented handler function\n                       (Pass NULL to unset any previously set handler)\n\n @return\n  - ESP_OK : handler registered successfully\n  - ESP_ERR_INVALID_ARG : invalid error code or server handle"]
    pub fn httpd_register_err_handler(
        handle: httpd_handle_t,
        error: httpd_err_code_t,
        handler_fn: httpd_err_handler_func_t,
    ) -> esp_err_t;
}
#[doc = " @brief  Prototype for HTTPDs low-level send function\n\n @note   User specified send function must handle errors internally,\n         depending upon the set value of errno, and return specific\n         HTTPD_SOCK_ERR_ codes, which will eventually be conveyed as\n         return value of httpd_send() function\n\n @param[in] hd        server instance\n @param[in] sockfd    session socket file descriptor\n @param[in] buf       buffer with bytes to send\n @param[in] buf_len   data size\n @param[in] flags     flags for the send() function\n @return\n  - Bytes : The number of bytes sent successfully\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket send()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket send()"]
pub type httpd_send_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_char,
        buf_len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief  Prototype for HTTPDs low-level recv function\n\n @note   User specified recv function must handle errors internally,\n         depending upon the set value of errno, and return specific\n         HTTPD_SOCK_ERR_ codes, which will eventually be conveyed as\n         return value of httpd_req_recv() function\n\n @param[in] hd        server instance\n @param[in] sockfd    session socket file descriptor\n @param[in] buf       buffer with bytes to send\n @param[in] buf_len   data size\n @param[in] flags     flags for the send() function\n @return\n  - Bytes : The number of bytes received successfully\n  - 0     : Buffer length parameter is zero / connection closed by peer\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket recv()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket recv()"]
pub type httpd_recv_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_char,
        buf_len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief  Prototype for HTTPDs low-level \"get pending bytes\" function\n\n @note   User specified pending function must handle errors internally,\n         depending upon the set value of errno, and return specific\n         HTTPD_SOCK_ERR_ codes, which will be handled accordingly in\n         the server task.\n\n @param[in] hd       server instance\n @param[in] sockfd   session socket file descriptor\n @return\n  - Bytes : The number of bytes waiting to be received\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket pending()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket pending()"]
pub type httpd_pending_func_t = ::core::option::Option<
    unsafe extern "C" fn(hd: httpd_handle_t, sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " @brief   Override web server's receive function (by session FD)\n\n This function overrides the web server's receive function. This same function is\n used to read HTTP request packets.\n\n @note    This API is supposed to be called either from the context of\n          - an http session APIs where sockfd is a valid parameter\n          - a URI handler where sockfd is obtained using httpd_req_to_sockfd()\n\n @param[in] hd        HTTPD instance handle\n @param[in] sockfd    Session socket FD\n @param[in] recv_func The receive function to be set for this session\n\n @return\n  - ESP_OK : On successfully registering override\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_sess_set_recv_override(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        recv_func: httpd_recv_func_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Override web server's send function (by session FD)\n\n This function overrides the web server's send function. This same function is\n used to send out any response to any HTTP request.\n\n @note    This API is supposed to be called either from the context of\n          - an http session APIs where sockfd is a valid parameter\n          - a URI handler where sockfd is obtained using httpd_req_to_sockfd()\n\n @param[in] hd        HTTPD instance handle\n @param[in] sockfd    Session socket FD\n @param[in] send_func The send function to be set for this session\n\n @return\n  - ESP_OK : On successfully registering override\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_sess_set_send_override(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        send_func: httpd_send_func_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Override web server's pending function (by session FD)\n\n This function overrides the web server's pending function. This function is\n used to test for pending bytes in a socket.\n\n @note    This API is supposed to be called either from the context of\n          - an http session APIs where sockfd is a valid parameter\n          - a URI handler where sockfd is obtained using httpd_req_to_sockfd()\n\n @param[in] hd           HTTPD instance handle\n @param[in] sockfd       Session socket FD\n @param[in] pending_func The receive function to be set for this session\n\n @return\n  - ESP_OK : On successfully registering override\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_sess_set_pending_override(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        pending_func: httpd_pending_func_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get the Socket Descriptor from the HTTP request\n\n This API will return the socket descriptor of the session for\n which URI handler was executed on reception of HTTP request.\n This is useful when user wants to call functions that require\n session socket fd, from within a URI handler, ie. :\n      httpd_sess_get_ctx(),\n      httpd_sess_trigger_close(),\n      httpd_sess_update_lru_counter().\n\n @note    This API is supposed to be called only from the context of\n          a URI handler where httpd_req_t* request pointer is valid.\n\n @param[in] r The request whose socket descriptor should be found\n\n @return\n  - Socket descriptor : The socket descriptor for this request\n  - -1 : Invalid/NULL request pointer"]
    pub fn httpd_req_to_sockfd(r: *mut httpd_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   API to read content data from the HTTP request\n\n This API will read HTTP content data from the HTTP request into\n provided buffer. Use content_len provided in httpd_req_t structure\n to know the length of data to be fetched. If content_len is too\n large for the buffer then user may have to make multiple calls to\n this function, each time fetching 'buf_len' number of bytes,\n while the pointer to content data is incremented internally by\n the same number.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - If an error is returned, the URI handler must further return an error.\n    This will ensure that the erroneous socket is closed and cleaned up by\n    the web server.\n  - Presently Chunked Encoding is not supported\n\n @param[in] r         The request being responded to\n @param[in] buf       Pointer to a buffer that the data will be read into\n @param[in] buf_len   Length of the buffer\n\n @return\n  - Bytes : Number of bytes read into the buffer successfully\n  - 0     : Buffer length parameter is zero / connection closed by peer\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket recv()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket recv()"]
    pub fn httpd_req_recv(
        r: *mut httpd_req_t,
        buf: *mut ::core::ffi::c_char,
        buf_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Search for a field in request headers and\n          return the string length of it's value\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - Once httpd_resp_send() API is called all request headers\n    are purged, so request headers need be copied into separate\n    buffers if they are required later.\n\n @param[in]  r        The request being responded to\n @param[in]  field    The header field to be searched in the request\n\n @return\n  - Length    : If field is found in the request URL\n  - Zero      : Field not found / Invalid request / Null arguments"]
    pub fn httpd_req_get_hdr_value_len(
        r: *mut httpd_req_t,
        field: *const ::core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief   Get the value string of a field from the request headers\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - Once httpd_resp_send() API is called all request headers\n    are purged, so request headers need be copied into separate\n    buffers if they are required later.\n  - If output size is greater than input, then the value is truncated,\n    accompanied by truncation error as return value.\n  - Use httpd_req_get_hdr_value_len() to know the right buffer length\n\n @param[in]  r        The request being responded to\n @param[in]  field    The field to be searched in the header\n @param[out] val      Pointer to the buffer into which the value will be copied if the field is found\n @param[in]  val_size Size of the user buffer \"val\"\n\n @return\n  - ESP_OK : Field found in the request header and value string copied\n  - ESP_ERR_NOT_FOUND          : Key not found\n  - ESP_ERR_INVALID_ARG        : Null arguments\n  - ESP_ERR_HTTPD_INVALID_REQ  : Invalid HTTP request pointer\n  - ESP_ERR_HTTPD_RESULT_TRUNC : Value string truncated"]
    pub fn httpd_req_get_hdr_value_str(
        r: *mut httpd_req_t,
        field: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_char,
        val_size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get Query string length from the request URL\n\n @note    This API is supposed to be called only from the context of\n          a URI handler where httpd_req_t* request pointer is valid\n\n @param[in]  r    The request being responded to\n\n @return\n  - Length    : Query is found in the request URL\n  - Zero      : Query not found / Null arguments / Invalid request"]
    pub fn httpd_req_get_url_query_len(r: *mut httpd_req_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Get Query string from the request URL\n\n @note\n  - Presently, the user can fetch the full URL query string, but decoding\n    will have to be performed by the user. Request headers can be read using\n    httpd_req_get_hdr_value_str() to know the 'Content-Type' (eg. Content-Type:\n    application/x-www-form-urlencoded) and then the appropriate decoding\n    algorithm needs to be applied.\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid\n  - If output size is greater than input, then the value is truncated,\n    accompanied by truncation error as return value\n  - Prior to calling this function, one can use httpd_req_get_url_query_len()\n    to know the query string length beforehand and hence allocate the buffer\n    of right size (usually query string length + 1 for null termination)\n    for storing the query string\n\n @param[in]  r         The request being responded to\n @param[out] buf       Pointer to the buffer into which the query string will be copied (if found)\n @param[in]  buf_len   Length of output buffer\n\n @return\n  - ESP_OK : Query is found in the request URL and copied to buffer\n  - ESP_ERR_NOT_FOUND          : Query not found\n  - ESP_ERR_INVALID_ARG        : Null arguments\n  - ESP_ERR_HTTPD_INVALID_REQ  : Invalid HTTP request pointer\n  - ESP_ERR_HTTPD_RESULT_TRUNC : Query string truncated"]
    pub fn httpd_req_get_url_query_str(
        r: *mut httpd_req_t,
        buf: *mut ::core::ffi::c_char,
        buf_len: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Helper function to get a URL query tag from a query\n          string of the type param1=val1&param2=val2\n\n @note\n  - The components of URL query string (keys and values) are not URLdecoded.\n    The user must check for 'Content-Type' field in the request headers and\n    then depending upon the specified encoding (URLencoded or otherwise) apply\n    the appropriate decoding algorithm.\n  - If actual value size is greater than val_size, then the value is truncated,\n    accompanied by truncation error as return value.\n\n @param[in]  qry       Pointer to query string\n @param[in]  key       The key to be searched in the query string\n @param[out] val       Pointer to the buffer into which the value will be copied if the key is found\n @param[in]  val_size  Size of the user buffer \"val\"\n\n @return\n  - ESP_OK : Key is found in the URL query string and copied to buffer\n  - ESP_ERR_NOT_FOUND          : Key not found\n  - ESP_ERR_INVALID_ARG        : Null arguments\n  - ESP_ERR_HTTPD_RESULT_TRUNC : Value string truncated"]
    pub fn httpd_query_key_value(
        qry: *const ::core::ffi::c_char,
        key: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_char,
        val_size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get the value string of a cookie value from the \"Cookie\" request headers by cookie name.\n\n @param[in]       req             Pointer to the HTTP request\n @param[in]       cookie_name     The cookie name to be searched in the request\n @param[out]      val             Pointer to the buffer into which the value of cookie will be copied if the cookie is found\n @param[inout]    val_size        Pointer to size of the user buffer \"val\". This variable will contain cookie length if\n                                  ESP_OK is returned and required buffer length incase ESP_ERR_HTTPD_RESULT_TRUNC is returned.\n\n @return\n  - ESP_OK : Key is found in the cookie string and copied to buffer\n  - ESP_ERR_NOT_FOUND          : Key not found\n  - ESP_ERR_INVALID_ARG        : Null arguments\n  - ESP_ERR_HTTPD_RESULT_TRUNC : Value string truncated\n  - ESP_ERR_NO_MEM             : Memory allocation failure"]
    pub fn httpd_req_get_cookie_val(
        req: *mut httpd_req_t,
        cookie_name: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_char,
        val_size: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Test if a URI matches the given wildcard template.\n\n Template may end with \"?\" to make the previous character optional (typically a slash),\n \"*\" for a wildcard match, and \"?*\" to make the previous character optional, and if present,\n allow anything to follow.\n\n Example:\n   - * matches everything\n   - /foo/? matches /foo and /foo/\n   - /foo/\\* (sans the backslash) matches /foo/ and /foo/bar, but not /foo or /fo\n   - /foo/?* or /foo/\\*?  (sans the backslash) matches /foo/, /foo/bar, and also /foo, but not /foox or /fo\n\n The special characters \"?\" and \"*\" anywhere else in the template will be taken literally.\n\n @param[in] uri_template   URI template (pattern)\n @param[in] uri_to_match   URI to be matched\n @param[in] match_upto     how many characters of the URI buffer to test\n                          (there may be trailing query string etc.)\n\n @return true if a match was found"]
    pub fn httpd_uri_match_wildcard(
        uri_template: *const ::core::ffi::c_char,
        uri_to_match: *const ::core::ffi::c_char,
        match_upto: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   API to send a complete HTTP response.\n\n This API will send the data as an HTTP response to the request.\n This assumes that you have the entire response ready in a single\n buffer. If you wish to send response in incremental chunks use\n httpd_resp_send_chunk() instead.\n\n If no status code and content-type were set, by default this\n will send 200 OK status code and content type as text/html.\n You may call the following functions before this API to configure\n the response headers :\n      httpd_resp_set_status() - for setting the HTTP status string,\n      httpd_resp_set_type()   - for setting the Content Type,\n      httpd_resp_set_hdr()    - for appending any additional field\n                                value entries in the response header\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - Once this API is called, the request has been responded to.\n  - No additional data can then be sent for the request.\n  - Once this API is called, all request headers are purged, so\n    request headers need be copied into separate buffers if\n    they are required later.\n\n @param[in] r         The request being responded to\n @param[in] buf       Buffer from where the content is to be fetched\n @param[in] buf_len   Length of the buffer, HTTPD_RESP_USE_STRLEN to use strlen()\n\n @return\n  - ESP_OK : On successfully sending the response packet\n  - ESP_ERR_INVALID_ARG : Null request pointer\n  - ESP_ERR_HTTPD_RESP_HDR    : Essential headers are too large for internal buffer\n  - ESP_ERR_HTTPD_RESP_SEND   : Error in raw send\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request"]
    pub fn httpd_resp_send(
        r: *mut httpd_req_t,
        buf: *const ::core::ffi::c_char,
        buf_len: isize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   API to send one HTTP chunk\n\n This API will send the data as an HTTP response to the\n request. This API will use chunked-encoding and send the response\n in the form of chunks. If you have the entire response contained in\n a single buffer, please use httpd_resp_send() instead.\n\n If no status code and content-type were set, by default this will\n send 200 OK status code and content type as text/html. You may\n call the following functions before this API to configure the\n response headers\n      httpd_resp_set_status() - for setting the HTTP status string,\n      httpd_resp_set_type()   - for setting the Content Type,\n      httpd_resp_set_hdr()    - for appending any additional field\n                                value entries in the response header\n\n @note\n - This API is supposed to be called only from the context of\n   a URI handler where httpd_req_t* request pointer is valid.\n - When you are finished sending all your chunks, you must call\n   this function with buf_len as 0.\n - Once this API is called, all request headers are purged, so\n   request headers need be copied into separate buffers if they\n   are required later.\n\n @param[in] r         The request being responded to\n @param[in] buf       Pointer to a buffer that stores the data\n @param[in] buf_len   Length of the buffer, HTTPD_RESP_USE_STRLEN to use strlen()\n\n @return\n  - ESP_OK : On successfully sending the response packet chunk\n  - ESP_ERR_INVALID_ARG : Null request pointer\n  - ESP_ERR_HTTPD_RESP_HDR    : Essential headers are too large for internal buffer\n  - ESP_ERR_HTTPD_RESP_SEND   : Error in raw send\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request pointer"]
    pub fn httpd_resp_send_chunk(
        r: *mut httpd_req_t,
        buf: *const ::core::ffi::c_char,
        buf_len: isize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   API to set the HTTP status code\n\n This API sets the status of the HTTP response to the value specified.\n By default, the '200 OK' response is sent as the response.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - This API only sets the status to this value. The status isn't\n    sent out until any of the send APIs is executed.\n  - Make sure that the lifetime of the status string is valid till\n    send function is called.\n\n @param[in] r         The request being responded to\n @param[in] status    The HTTP status code of this response\n\n @return\n  - ESP_OK : On success\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request pointer"]
    pub fn httpd_resp_set_status(
        r: *mut httpd_req_t,
        status: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   API to set the HTTP content type\n\n This API sets the 'Content Type' field of the response.\n The default content type is 'text/html'.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - This API only sets the content type to this value. The type\n    isn't sent out until any of the send APIs is executed.\n  - Make sure that the lifetime of the type string is valid till\n    send function is called.\n\n @param[in] r     The request being responded to\n @param[in] type  The Content Type of the response\n\n @return\n  - ESP_OK   : On success\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request pointer"]
    pub fn httpd_resp_set_type(r: *mut httpd_req_t, type_: *const ::core::ffi::c_char)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   API to append any additional headers\n\n This API sets any additional header fields that need to be sent in the response.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - The header isn't sent out until any of the send APIs is executed.\n  - The maximum allowed number of additional headers is limited to\n    value of max_resp_headers in config structure.\n  - Make sure that the lifetime of the field value strings are valid till\n    send function is called.\n\n @param[in] r     The request being responded to\n @param[in] field The field name of the HTTP header\n @param[in] value The value of this HTTP header\n\n @return\n  - ESP_OK : On successfully appending new header\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_HTTPD_RESP_HDR    : Total additional headers exceed max allowed\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request pointer"]
    pub fn httpd_resp_set_hdr(
        r: *mut httpd_req_t,
        field: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   For sending out error code in response to HTTP request.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - Once this API is called, all request headers are purged, so\n    request headers need be copied into separate buffers if\n    they are required later.\n  - If you wish to send additional data in the body of the\n    response, please use the lower-level functions directly.\n\n @param[in] req     Pointer to the HTTP request for which the response needs to be sent\n @param[in] error   Error type to send\n @param[in] msg     Error message string (pass NULL for default message)\n\n @return\n  - ESP_OK : On successfully sending the response packet\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_HTTPD_RESP_SEND   : Error in raw send\n  - ESP_ERR_HTTPD_INVALID_REQ : Invalid request pointer"]
    pub fn httpd_resp_send_err(
        req: *mut httpd_req_t,
        error: httpd_err_code_t,
        msg: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Raw HTTP send\n\n Call this API if you wish to construct your custom response packet.\n When using this, all essential header, eg. HTTP version, Status Code,\n Content Type and Length, Encoding, etc. will have to be constructed\n manually, and HTTP delimeters (CRLF) will need to be placed correctly\n for separating sub-sections of the HTTP response packet.\n\n If the send override function is set, this API will end up\n calling that function eventually to send data out.\n\n @note\n  - This API is supposed to be called only from the context of\n    a URI handler where httpd_req_t* request pointer is valid.\n  - Unless the response has the correct HTTP structure (which the\n    user must now ensure) it is not guaranteed that it will be\n    recognized by the client. For most cases, you wouldn't have\n    to call this API, but you would rather use either of :\n          httpd_resp_send(),\n          httpd_resp_send_chunk()\n\n @param[in] r         The request being responded to\n @param[in] buf       Buffer from where the fully constructed packet is to be read\n @param[in] buf_len   Length of the buffer\n\n @return\n  - Bytes : Number of bytes that were sent successfully\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket send()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket send()"]
    pub fn httpd_send(
        r: *mut httpd_req_t,
        buf: *const ::core::ffi::c_char,
        buf_len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " A low level API to send data on a given socket\n\n @note This API is not recommended to be used in any request handler.\n Use this only for advanced use cases, wherein some asynchronous\n data is to be sent over a socket.\n\n This internally calls the default send function, or the function registered by\n httpd_sess_set_send_override().\n\n @param[in] hd        server instance\n @param[in] sockfd    session socket file descriptor\n @param[in] buf       buffer with bytes to send\n @param[in] buf_len   data size\n @param[in] flags     flags for the send() function\n @return\n  - Bytes : The number of bytes sent successfully\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket send()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket send()"]
    pub fn httpd_socket_send(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_char,
        buf_len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " A low level API to receive data from a given socket\n\n @note This API is not recommended to be used in any request handler.\n Use this only for advanced use cases, wherein some asynchronous\n communication is required.\n\n This internally calls the default recv function, or the function registered by\n httpd_sess_set_recv_override().\n\n @param[in] hd        server instance\n @param[in] sockfd    session socket file descriptor\n @param[in] buf       buffer with bytes to send\n @param[in] buf_len   data size\n @param[in] flags     flags for the send() function\n @return\n  - Bytes : The number of bytes received successfully\n  - 0     : Buffer length parameter is zero / connection closed by peer\n  - HTTPD_SOCK_ERR_INVALID  : Invalid arguments\n  - HTTPD_SOCK_ERR_TIMEOUT  : Timeout/interrupted while calling socket recv()\n  - HTTPD_SOCK_ERR_FAIL     : Unrecoverable error while calling socket recv()"]
    pub fn httpd_socket_recv(
        hd: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_char,
        buf_len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get session context from socket descriptor\n\n Typically if a session context is created, it is available to URI handlers\n through the httpd_req_t structure. But, there are cases where the web\n server's send/receive functions may require the context (for example, for\n accessing keying information etc). Since the send/receive function only have\n the socket descriptor at their disposal, this API provides them with a way to\n retrieve the session context.\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor for which the context should be extracted.\n\n @return\n  - void* : Pointer to the context associated with this session\n  - NULL  : Empty context / Invalid handle / Invalid socket fd"]
    pub fn httpd_sess_get_ctx(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Set session context by socket descriptor\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor for which the context should be extracted.\n @param[in] ctx       Context object to assign to the session\n @param[in] free_fn   Function that should be called to free the context"]
    pub fn httpd_sess_set_ctx(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        ctx: *mut ::core::ffi::c_void,
        free_fn: httpd_free_ctx_fn_t,
    );
}
extern "C" {
    #[doc = " @brief   Get session 'transport' context by socket descriptor\n @see     httpd_sess_get_ctx()\n\n This context is used by the send/receive functions, for example to manage SSL context.\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor for which the context should be extracted.\n @return\n  - void* : Pointer to the transport context associated with this session\n  - NULL  : Empty context / Invalid handle / Invalid socket fd"]
    pub fn httpd_sess_get_transport_ctx(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Set session 'transport' context by socket descriptor\n @see     httpd_sess_set_ctx()\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor for which the context should be extracted.\n @param[in] ctx       Transport context object to assign to the session\n @param[in] free_fn   Function that should be called to free the transport context"]
    pub fn httpd_sess_set_transport_ctx(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
        ctx: *mut ::core::ffi::c_void,
        free_fn: httpd_free_ctx_fn_t,
    );
}
extern "C" {
    #[doc = " @brief   Get HTTPD global user context (it was set in the server config struct)\n\n @param[in] handle    Handle to server returned by httpd_start\n @return global user context"]
    pub fn httpd_get_global_user_ctx(handle: httpd_handle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Get HTTPD global transport context (it was set in the server config struct)\n\n @param[in] handle    Handle to server returned by httpd_start\n @return global transport context"]
    pub fn httpd_get_global_transport_ctx(handle: httpd_handle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Trigger an httpd session close externally\n\n @note    Calling this API is only required in special circumstances wherein\n          some application requires to close an httpd client session asynchronously.\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor of the session to be closed\n\n @return\n  - ESP_OK    : On successfully initiating closure\n  - ESP_FAIL  : Failure to queue work\n  - ESP_ERR_NOT_FOUND   : Socket fd not found\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_sess_trigger_close(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Update LRU counter for a given socket\n\n LRU Counters are internally associated with each session to monitor\n how recently a session exchanged traffic. When LRU purge is enabled,\n if a client is requesting for connection but maximum number of\n sockets/sessions is reached, then the session having the earliest\n LRU counter is closed automatically.\n\n Updating the LRU counter manually prevents the socket from being purged\n due to the Least Recently Used (LRU) logic, even though it might not\n have received traffic for some time. This is useful when all open\n sockets/session are frequently exchanging traffic but the user specifically\n wants one of the sessions to be kept open, irrespective of when it last\n exchanged a packet.\n\n @note    Calling this API is only necessary if the LRU Purge Enable option\n          is enabled.\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] sockfd    The socket descriptor of the session for which LRU counter\n                      is to be updated\n\n @return\n  - ESP_OK : Socket found and LRU counter updated\n  - ESP_ERR_NOT_FOUND   : Socket not found\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_sess_update_lru_counter(
        handle: httpd_handle_t,
        sockfd: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Returns list of current socket descriptors of active sessions\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in,out] fds   In: Size of provided client_fds array\n                      Out: Number of valid client fds returned in client_fds,\n @param[out] client_fds  Array of client fds\n\n @note Size of provided array has to be equal or greater then maximum number of opened\n       sockets, configured upon initialization with max_open_sockets field in\n       httpd_config_t structure.\n\n @return\n  - ESP_OK              : Successfully retrieved session list\n  - ESP_ERR_INVALID_ARG : Wrong arguments or list is longer than provided array"]
    pub fn httpd_get_client_list(
        handle: httpd_handle_t,
        fds: *mut usize,
        client_fds: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[doc = " @brief   Prototype of the HTTPD work function\n          Please refer to httpd_queue_work() for more details.\n @param[in] arg   The arguments for this work function"]
pub type httpd_work_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief   Queue execution of a function in HTTPD's context\n\n This API queues a work function for asynchronous execution\n\n @note    Some protocols require that the web server generate some asynchronous data\n          and send it to the persistently opened connection. This facility is for use\n          by such protocols.\n\n @param[in] handle    Handle to server returned by httpd_start\n @param[in] work      Pointer to the function to be executed in the HTTPD's context\n @param[in] arg       Pointer to the arguments that should be passed to this function\n\n @return\n  - ESP_OK   : On successfully queueing the work\n  - ESP_FAIL : Failure in ctrl socket\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn httpd_queue_work(
        handle: httpd_handle_t,
        work: httpd_work_fn_t,
        arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client {
    _unused: [u8; 0],
}
pub type esp_mqtt_client_handle_t = *mut esp_mqtt_client;
pub const esp_mqtt_event_id_t_MQTT_EVENT_ANY: esp_mqtt_event_id_t = -1;
pub const esp_mqtt_event_id_t_MQTT_EVENT_ERROR: esp_mqtt_event_id_t = 0;
#[doc = "< connected event, additional context:\nsession_present flag"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_CONNECTED: esp_mqtt_event_id_t = 1;
#[doc = "< disconnected event"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_DISCONNECTED: esp_mqtt_event_id_t = 2;
#[doc = "< subscribed event, additional context:\n- msg_id               message id\n- data                 pointer to the received\ndata\n- data_len             length of the data for this\nevent"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_SUBSCRIBED: esp_mqtt_event_id_t = 3;
#[doc = "< unsubscribed event"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_UNSUBSCRIBED: esp_mqtt_event_id_t = 4;
#[doc = "< published event, additional context:  msg_id"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_PUBLISHED: esp_mqtt_event_id_t = 5;
#[doc = "< data event, additional context:\n- msg_id               message id\n- topic                pointer to the received topic\n- topic_len            length of the topic\n- data                 pointer to the received data\n- data_len             length of the data for this event\n- current_data_offset  offset of the current data for\nthis event\n- total_data_len       total length of the data received\n- retain               retain flag of the message\n- qos                  QoS level of the message\n- dup                  dup flag of the message\nNote: Multiple MQTT_EVENT_DATA could be fired for one\nmessage, if it is         longer than internal buffer. In that\ncase only first event contains topic         pointer and length,\nother contain data only with current data length         and\ncurrent data offset updating."]
pub const esp_mqtt_event_id_t_MQTT_EVENT_DATA: esp_mqtt_event_id_t = 6;
#[doc = "< The event occurs before connecting"]
pub const esp_mqtt_event_id_t_MQTT_EVENT_BEFORE_CONNECT: esp_mqtt_event_id_t = 7;
#[doc = "< Notification on delete of one message from the\ninternal outbox,        if the message couldn't have been sent\nand acknowledged before expiring        defined in\nOUTBOX_EXPIRED_TIMEOUT_MS.        (events are not posted upon\ndeletion of successfully acknowledged messages)\n- This event id is posted only if\nMQTT_REPORT_DELETED_MESSAGES==1\n- Additional context: msg_id (id of the deleted\nmessage)."]
pub const esp_mqtt_event_id_t_MQTT_EVENT_DELETED: esp_mqtt_event_id_t = 8;
#[doc = " @brief *MQTT* event types.\n\n User event handler receives context data in `esp_mqtt_event_t` structure with\n  - `client` - *MQTT* client handle\n  - various other data depending on event type\n"]
pub type esp_mqtt_event_id_t = ::core::ffi::c_int;
#[doc = "< Connection accepted"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_ACCEPTED: esp_mqtt_connect_return_code_t =
    0;
#[doc = "< *MQTT* connection refused reason: Wrong\nprotocol"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_REFUSE_PROTOCOL:
    esp_mqtt_connect_return_code_t = 1;
#[doc = "< *MQTT* connection refused reason: ID\nrejected"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_REFUSE_ID_REJECTED:
    esp_mqtt_connect_return_code_t = 2;
#[doc = "< *MQTT* connection refused\nreason: Server unavailable"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_REFUSE_SERVER_UNAVAILABLE:
    esp_mqtt_connect_return_code_t = 3;
#[doc = "< *MQTT* connection refused reason:\nWrong user"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_REFUSE_BAD_USERNAME:
    esp_mqtt_connect_return_code_t = 4;
#[doc = "< *MQTT* connection refused reason:\nWrong username or password"]
pub const esp_mqtt_connect_return_code_t_MQTT_CONNECTION_REFUSE_NOT_AUTHORIZED:
    esp_mqtt_connect_return_code_t = 5;
#[doc = " *MQTT* connection error codes propagated via ERROR event"]
pub type esp_mqtt_connect_return_code_t = ::core::ffi::c_uint;
pub const esp_mqtt_error_type_t_MQTT_ERROR_TYPE_NONE: esp_mqtt_error_type_t = 0;
pub const esp_mqtt_error_type_t_MQTT_ERROR_TYPE_TCP_TRANSPORT: esp_mqtt_error_type_t = 1;
pub const esp_mqtt_error_type_t_MQTT_ERROR_TYPE_CONNECTION_REFUSED: esp_mqtt_error_type_t = 2;
#[doc = " *MQTT* connection error codes propagated via ERROR event"]
pub type esp_mqtt_error_type_t = ::core::ffi::c_uint;
pub const esp_mqtt_transport_t_MQTT_TRANSPORT_UNKNOWN: esp_mqtt_transport_t = 0;
#[doc = "< *MQTT* over TCP, using scheme: ``MQTT``"]
pub const esp_mqtt_transport_t_MQTT_TRANSPORT_OVER_TCP: esp_mqtt_transport_t = 1;
#[doc = "< *MQTT* over SSL, using scheme: ``MQTTS``"]
pub const esp_mqtt_transport_t_MQTT_TRANSPORT_OVER_SSL: esp_mqtt_transport_t = 2;
#[doc = "< *MQTT* over Websocket, using scheme:: ``ws``"]
pub const esp_mqtt_transport_t_MQTT_TRANSPORT_OVER_WS: esp_mqtt_transport_t = 3;
#[doc = "< *MQTT* over Websocket Secure, using scheme:\n``wss``"]
pub const esp_mqtt_transport_t_MQTT_TRANSPORT_OVER_WSS: esp_mqtt_transport_t = 4;
pub type esp_mqtt_transport_t = ::core::ffi::c_uint;
pub const esp_mqtt_protocol_ver_t_MQTT_PROTOCOL_UNDEFINED: esp_mqtt_protocol_ver_t = 0;
pub const esp_mqtt_protocol_ver_t_MQTT_PROTOCOL_V_3_1: esp_mqtt_protocol_ver_t = 1;
pub const esp_mqtt_protocol_ver_t_MQTT_PROTOCOL_V_3_1_1: esp_mqtt_protocol_ver_t = 2;
pub const esp_mqtt_protocol_ver_t_MQTT_PROTOCOL_V_5: esp_mqtt_protocol_ver_t = 3;
#[doc = "  *MQTT* protocol version used for connection"]
pub type esp_mqtt_protocol_ver_t = ::core::ffi::c_uint;
#[doc = " @brief *MQTT* error code structure to be passed as a contextual information\n into ERROR event\n\n Important: This structure extends `esp_tls_last_error` error structure and is\n backward compatible with it (so might be down-casted and treated as\n `esp_tls_last_error` error, but recommended to update applications if used\n this way previously)\n\n Use this structure directly checking error_type first and then appropriate\n error code depending on the source of the error:\n\n | error_type | related member variables | note |\n | MQTT_ERROR_TYPE_TCP_TRANSPORT | esp_tls_last_esp_err, esp_tls_stack_err,\n esp_tls_cert_verify_flags, sock_errno | Error reported from\n tcp_transport/esp-tls | | MQTT_ERROR_TYPE_CONNECTION_REFUSED |\n connect_return_code | Internal error reported from *MQTT* broker on\n connection |"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_error_codes {
    #[doc = "< last esp_err code reported from esp-tls\ncomponent"]
    pub esp_tls_last_esp_err: esp_err_t,
    #[doc = "< tls specific error code reported from underlying\ntls stack"]
    pub esp_tls_stack_err: ::core::ffi::c_int,
    #[doc = "< tls flags reported from underlying tls\nstack during certificate verification"]
    pub esp_tls_cert_verify_flags: ::core::ffi::c_int,
    #[doc = "< error type referring to the source of the error"]
    pub error_type: esp_mqtt_error_type_t,
    #[doc = "< connection refused error code reported from\nMQTT* broker on connection"]
    pub connect_return_code: esp_mqtt_connect_return_code_t,
    #[doc = "< errno from the underlying socket"]
    pub esp_transport_sock_errno: ::core::ffi::c_int,
}
impl Default for esp_mqtt_error_codes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief *MQTT* error code structure to be passed as a contextual information\n into ERROR event\n\n Important: This structure extends `esp_tls_last_error` error structure and is\n backward compatible with it (so might be down-casted and treated as\n `esp_tls_last_error` error, but recommended to update applications if used\n this way previously)\n\n Use this structure directly checking error_type first and then appropriate\n error code depending on the source of the error:\n\n | error_type | related member variables | note |\n | MQTT_ERROR_TYPE_TCP_TRANSPORT | esp_tls_last_esp_err, esp_tls_stack_err,\n esp_tls_cert_verify_flags, sock_errno | Error reported from\n tcp_transport/esp-tls | | MQTT_ERROR_TYPE_CONNECTION_REFUSED |\n connect_return_code | Internal error reported from *MQTT* broker on\n connection |"]
pub type esp_mqtt_error_codes_t = esp_mqtt_error_codes;
#[doc = " *MQTT* event configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_event_t {
    #[doc = "< *MQTT* event type"]
    pub event_id: esp_mqtt_event_id_t,
    #[doc = "< *MQTT* client handle for this event"]
    pub client: esp_mqtt_client_handle_t,
    #[doc = "< Data associated with this event"]
    pub data: *mut ::core::ffi::c_char,
    #[doc = "< Length of the data for this event"]
    pub data_len: ::core::ffi::c_int,
    #[doc = "< Total length of the data (longer data are supplied\nwith multiple events)"]
    pub total_data_len: ::core::ffi::c_int,
    #[doc = "< Actual offset for the data associated with this\nevent"]
    pub current_data_offset: ::core::ffi::c_int,
    #[doc = "< Topic associated with this event"]
    pub topic: *mut ::core::ffi::c_char,
    #[doc = "< Length of the topic for this event associated with this\nevent"]
    pub topic_len: ::core::ffi::c_int,
    #[doc = "< *MQTT* messaged id of message"]
    pub msg_id: ::core::ffi::c_int,
    #[doc = "< *MQTT* session_present flag for connection event"]
    pub session_present: ::core::ffi::c_int,
    #[doc = "< esp-mqtt error handle including esp-tls errors as well\nas internal *MQTT* errors"]
    pub error_handle: *mut esp_mqtt_error_codes_t,
    #[doc = "< Retained flag of the message associated with this event"]
    pub retain: bool,
    #[doc = "< QoS of the messages associated with this event"]
    pub qos: ::core::ffi::c_int,
    #[doc = "< dup flag of the message associated with this event"]
    pub dup: bool,
    #[doc = "< MQTT protocol version used for connection, defaults to value from menuconfig"]
    pub protocol_ver: esp_mqtt_protocol_ver_t,
}
impl Default for esp_mqtt_event_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type esp_mqtt_event_handle_t = *mut esp_mqtt_event_t;
pub type mqtt_event_callback_t =
    ::core::option::Option<unsafe extern "C" fn(event: esp_mqtt_event_handle_t) -> esp_err_t>;
#[doc = " *MQTT* client configuration structure\n\n  - Default values can be set via menuconfig\n  - All certificates and key data could be passed in PEM or DER format. PEM format must have a terminating NULL\n    character and the related len field set to 0. DER format requires a related len field set to the correct length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t {
    #[doc = "< Broker address and security verification"]
    pub broker: esp_mqtt_client_config_t_broker_t,
    #[doc = "< User credentials for broker"]
    pub credentials: esp_mqtt_client_config_t_credentials_t,
    #[doc = "< *MQTT* session configuration."]
    pub session: esp_mqtt_client_config_t_session_t,
    #[doc = "< Network configuration"]
    pub network: esp_mqtt_client_config_t_network_t,
    #[doc = "< FreeRTOS task configuration."]
    pub task: esp_mqtt_client_config_t_task_t,
    #[doc = "< Buffer size configuration."]
    pub buffer: esp_mqtt_client_config_t_buffer_t,
}
#[doc = "   Broker related configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_broker_t {
    #[doc = "< Broker address configuration"]
    pub address: esp_mqtt_client_config_t_broker_t_address_t,
    #[doc = "< Security verification of the broker"]
    pub verification: esp_mqtt_client_config_t_broker_t_verification_t,
}
#[doc = " Broker address\n\n  - uri have precedence over other fields\n  - If uri isn't set at least hostname, transport and port should."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_broker_t_address_t {
    #[doc = "< Complete *MQTT* broker URI"]
    pub uri: *const ::core::ffi::c_char,
    #[doc = "< Hostname, to set ipv4 pass it as string)"]
    pub hostname: *const ::core::ffi::c_char,
    #[doc = "< Selects transport"]
    pub transport: esp_mqtt_transport_t,
    #[doc = "< Path in the URI"]
    pub path: *const ::core::ffi::c_char,
    #[doc = "< *MQTT* server port"]
    pub port: u32,
}
impl Default for esp_mqtt_client_config_t_broker_t_address_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Broker identity verification\n\n If fields are not set broker's identity isn't verified. it's recommended\n to set the options in this struct for security reasons."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_broker_t_verification_t {
    #[doc = "< Use a global ca_store, look esp-tls\ndocumentation for details."]
    pub use_global_ca_store: bool,
    #[doc = "< Pointer to ESP x509 Certificate Bundle attach function for\nthe usage of certificate bundles."]
    pub crt_bundle_attach:
        ::core::option::Option<unsafe extern "C" fn(conf: *mut ::core::ffi::c_void) -> esp_err_t>,
    #[doc = "< Certificate data, default is NULL, not required to verify the server."]
    pub certificate: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by certificate."]
    pub certificate_len: usize,
    #[doc = "< Pointer to PSK struct defined in esp_tls.h to enable PSK\nauthentication (as alternative to certificate verification).\nPSK is enabled only if there are no other ways to\nverify broker."]
    pub psk_hint_key: *const psk_key_hint,
    #[doc = "< Skip any validation of server certificate CN field, this reduces the\nsecurity of TLS and makes the *MQTT* client susceptible to MITM attacks"]
    pub skip_cert_common_name_check: bool,
    #[doc = "< NULL-terminated list of supported application protocols to be used for ALPN"]
    pub alpn_protos: *mut *const ::core::ffi::c_char,
}
impl Default for esp_mqtt_client_config_t_broker_t_verification_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for esp_mqtt_client_config_t_broker_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Client related credentials for authentication."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_credentials_t {
    #[doc = "< *MQTT* username"]
    pub username: *const ::core::ffi::c_char,
    #[doc = "< Set *MQTT* client identifier. Ignored if set_null_client_id == true If NULL set\nthe default client id. Default client id is ``ESP32_%CHIPID%`` where `%CHIPID%` are\nlast 3 bytes of MAC address in hex format"]
    pub client_id: *const ::core::ffi::c_char,
    #[doc = "< Selects a NULL client id"]
    pub set_null_client_id: bool,
    #[doc = "< Client authentication"]
    pub authentication: esp_mqtt_client_config_t_credentials_t_authentication_t,
}
#[doc = " Client authentication\n\n Fields related to client authentication by broker\n\n For mutual authentication using TLS, user could select certificate and key,\n secure element or digital signature peripheral if available.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_credentials_t_authentication_t {
    #[doc = "< *MQTT* password"]
    pub password: *const ::core::ffi::c_char,
    #[doc = "< Certificate for ssl mutual authentication, not required if mutual\nauthentication is not needed. Must be provided with `key`."]
    pub certificate: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by certificate."]
    pub certificate_len: usize,
    #[doc = "< Private key for SSL mutual authentication, not required if mutual authentication\nis not needed. If it is not NULL, also `certificate` has to be provided."]
    pub key: *const ::core::ffi::c_char,
    #[doc = "< Length of the buffer pointed to by key."]
    pub key_len: usize,
    #[doc = "< Client key decryption password, not PEM nor DER, if provided\n`key_password_len` must be correctly set."]
    pub key_password: *const ::core::ffi::c_char,
    #[doc = "< Length of the password pointed to by `key_password`"]
    pub key_password_len: ::core::ffi::c_int,
    #[doc = "< Enable secure element, available in ESP32-ROOM-32SE, for SSL connection"]
    pub use_secure_element: bool,
    #[doc = "< Carrier of handle for digital signature parameters, digital signature peripheral is\navailable in some Espressif devices."]
    pub ds_data: *mut ::core::ffi::c_void,
}
impl Default for esp_mqtt_client_config_t_credentials_t_authentication_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for esp_mqtt_client_config_t_credentials_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " *MQTT* Session related configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_session_t {
    #[doc = "< Last will configuration"]
    pub last_will: esp_mqtt_client_config_t_session_t_last_will_t,
    #[doc = "< *MQTT* clean session, default clean_session is true"]
    pub disable_clean_session: bool,
    #[doc = "< *MQTT* keepalive, default is 120 seconds"]
    pub keepalive: ::core::ffi::c_int,
    #[doc = "< Set `disable_keepalive=true` to turn off keep-alive mechanism, keepalive is active\nby default. Note: setting the config value `keepalive` to `0` doesn't disable\nkeepalive feature, but uses a default keepalive period"]
    pub disable_keepalive: bool,
    #[doc = "< *MQTT* protocol version used for connection."]
    pub protocol_ver: esp_mqtt_protocol_ver_t,
    #[doc = "< timeout for retransmitting of failed packet"]
    pub message_retransmit_timeout: ::core::ffi::c_int,
}
#[doc = " Last Will and Testament message configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_mqtt_client_config_t_session_t_last_will_t {
    #[doc = "< LWT (Last Will and Testament) message topic"]
    pub topic: *const ::core::ffi::c_char,
    #[doc = "< LWT message, may be NULL terminated"]
    pub msg: *const ::core::ffi::c_char,
    #[doc = "< LWT message length, if msg isn't NULL terminated must have the correct length"]
    pub msg_len: ::core::ffi::c_int,
    #[doc = "< LWT message QoS"]
    pub qos: ::core::ffi::c_int,
    #[doc = "< LWT retained message flag"]
    pub retain: ::core::ffi::c_int,
}
impl Default for esp_mqtt_client_config_t_session_t_last_will_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for esp_mqtt_client_config_t_session_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Network related configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_mqtt_client_config_t_network_t {
    #[doc = "< Reconnect to the broker after this value in miliseconds if auto reconnect is not\ndisabled (defaults to 10s)"]
    pub reconnect_timeout_ms: ::core::ffi::c_int,
    #[doc = "< Abort network operation if it is not completed after this value, in milliseconds\n(defaults to 10s)."]
    pub timeout_ms: ::core::ffi::c_int,
    #[doc = "< Refresh connection after this value (in milliseconds)"]
    pub refresh_connection_after_ms: ::core::ffi::c_int,
    #[doc = "< Client will reconnect to server (when errors/disconnect). Set\n`disable_auto_reconnect=true` to disable"]
    pub disable_auto_reconnect: bool,
}
#[doc = " Client task configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_mqtt_client_config_t_task_t {
    #[doc = "< *MQTT* task priority"]
    pub priority: ::core::ffi::c_int,
    #[doc = "< *MQTT* task stack size"]
    pub stack_size: ::core::ffi::c_int,
}
#[doc = " Client buffer size configuration\n\n Client have two buffers for input and output respectivelly."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_mqtt_client_config_t_buffer_t {
    #[doc = "< size of *MQTT* send/receive buffer"]
    pub size: ::core::ffi::c_int,
    #[doc = "< size of *MQTT* output buffer. If not defined, defaults to the size defined by\n``buffer_size``"]
    pub out_size: ::core::ffi::c_int,
}
impl Default for esp_mqtt_client_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Creates *MQTT* client handle based on the configuration\n\n @param config    *MQTT* configuration structure\n\n @return mqtt_client_handle if successfully created, NULL on error"]
    pub fn esp_mqtt_client_init(
        config: *const esp_mqtt_client_config_t,
    ) -> esp_mqtt_client_handle_t;
}
extern "C" {
    #[doc = " @brief Sets *MQTT* connection URI. This API is usually used to overrides the\n URI configured in esp_mqtt_client_init\n\n @param client    *MQTT* client handle\n @param uri\n\n @return ESP_FAIL if URI parse error, ESP_OK on success"]
    pub fn esp_mqtt_client_set_uri(
        client: esp_mqtt_client_handle_t,
        uri: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Starts *MQTT* client with already created client handle\n\n @param client    *MQTT* client handle\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG on wrong initialization\n         ESP_FAIL on other error"]
    pub fn esp_mqtt_client_start(client: esp_mqtt_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief This api is typically used to force reconnection upon a specific event\n\n @param client    *MQTT* client handle\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG on wrong initialization\n         ESP_FAIL if client is in invalid state"]
    pub fn esp_mqtt_client_reconnect(client: esp_mqtt_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief This api is typically used to force disconnection from the broker\n\n @param client    *MQTT* client handle\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG on wrong initialization"]
    pub fn esp_mqtt_client_disconnect(client: esp_mqtt_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stops *MQTT* client tasks\n\n  * Notes:\n  - Cannot be called from the *MQTT* event handler\n\n @param client    *MQTT* client handle\n\n @return ESP_OK on success\n         ESP_ERR_INVALID_ARG on wrong initialization\n         ESP_FAIL if client is in invalid state"]
    pub fn esp_mqtt_client_stop(client: esp_mqtt_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Subscribe the client to defined topic with defined qos\n\n Notes:\n - Client must be connected to send subscribe message\n - This API is could be executed from a user task or\n from a *MQTT* event callback i.e. internal *MQTT* task\n (API is protected by internal mutex, so it might block\n if a longer data receive operation is in progress.\n\n @param client    *MQTT* client handle\n @param topic\n @param qos  // TODO describe parameters\n\n @return message_id of the subscribe message on success\n         -1 on failure"]
    pub fn esp_mqtt_client_subscribe(
        client: esp_mqtt_client_handle_t,
        topic: *const ::core::ffi::c_char,
        qos: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Unsubscribe the client from defined topic\n\n Notes:\n - Client must be connected to send unsubscribe message\n - It is thread safe, please refer to `esp_mqtt_client_subscribe` for details\n\n @param client    *MQTT* client handle\n @param topic\n\n @return message_id of the subscribe message on success\n         -1 on failure"]
    pub fn esp_mqtt_client_unsubscribe(
        client: esp_mqtt_client_handle_t,
        topic: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Client to send a publish message to the broker\n\n Notes:\n - This API might block for several seconds, either due to network timeout\n (10s) or if publishing payloads longer than internal buffer (due to message\n   fragmentation)\n - Client doesn't have to be connected for this API to work, enqueueing the\n messages with qos>1 (returning -1 for all the qos=0 messages if\n disconnected). If MQTT_SKIP_PUBLISH_IF_DISCONNECTED is enabled, this API will\n not attempt to publish when the client is not connected and will always\n return -1.\n - It is thread safe, please refer to `esp_mqtt_client_subscribe` for details\n\n @param client    *MQTT* client handle\n @param topic     topic string\n @param data      payload string (set to NULL, sending empty payload message)\n @param len       data length, if set to 0, length is calculated from payload\n string\n @param qos       QoS of publish message\n @param retain    retain flag\n\n @return message_id of the publish message (for QoS 0 message_id will always\n be zero) on success. -1 on failure."]
    pub fn esp_mqtt_client_publish(
        client: esp_mqtt_client_handle_t,
        topic: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        qos: ::core::ffi::c_int,
        retain: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Enqueue a message to the outbox, to be sent later. Typically used for\n messages with qos>0, but could be also used for qos=0 messages if store=true.\n\n This API generates and stores the publish message into the internal outbox\n and the actual sending to the network is performed in the mqtt-task context\n (in contrast to the esp_mqtt_client_publish() which sends the publish message\n immediately in the user task's context). Thus, it could be used as a non\n blocking version of esp_mqtt_client_publish().\n\n @param client    *MQTT* client handle\n @param topic     topic string\n @param data      payload string (set to NULL, sending empty payload message)\n @param len       data length, if set to 0, length is calculated from payload\n string\n @param qos       QoS of publish message\n @param retain    retain flag\n @param store     if true, all messages are enqueued; otherwise only QoS 1 and\n QoS 2 are enqueued\n\n @return message_id if queued successfully, -1 otherwise"]
    pub fn esp_mqtt_client_enqueue(
        client: esp_mqtt_client_handle_t,
        topic: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        qos: ::core::ffi::c_int,
        retain: ::core::ffi::c_int,
        store: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Destroys the client handle\n\n Notes:\n  - Cannot be called from the *MQTT* event handler\n\n @param client    *MQTT* client handle\n\n @return ESP_OK\n         ESP_ERR_INVALID_ARG on wrong initialization"]
    pub fn esp_mqtt_client_destroy(client: esp_mqtt_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set configuration structure, typically used when updating the config\n (i.e. on \"before_connect\" event\n\n @param client    *MQTT* client handle\n\n @param config    *MQTT* configuration structure\n\n @return ESP_ERR_NO_MEM if failed to allocate\n         ESP_ERR_INVALID_ARG if conflicts on transport configuration.\n         ESP_OK on success"]
    pub fn esp_mqtt_set_config(
        client: esp_mqtt_client_handle_t,
        config: *const esp_mqtt_client_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Registers *MQTT* event\n\n @param client            *MQTT* client handle\n @param event             event type\n @param event_handler     handler callback\n @param event_handler_arg handlers context\n\n @return ESP_ERR_NO_MEM if failed to allocate\n         ESP_ERR_INVALID_ARG on wrong initialization\n         ESP_OK on success"]
    pub fn esp_mqtt_client_register_event(
        client: esp_mqtt_client_handle_t,
        event: esp_mqtt_event_id_t,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get outbox size\n\n @param client            *MQTT* client handle\n @return outbox size\n         0 on wrong initialization"]
    pub fn esp_mqtt_client_get_outbox_size(client: esp_mqtt_client_handle_t) -> ::core::ffi::c_int;
}
#[doc = " Opaque pointer type representing non-volatile storage handle"]
pub type nvs_handle_t = u32;
pub type nvs_handle = nvs_handle_t;
#[doc = "< Read only"]
pub const nvs_open_mode_t_NVS_READONLY: nvs_open_mode_t = 0;
#[doc = "< Read and write"]
pub const nvs_open_mode_t_NVS_READWRITE: nvs_open_mode_t = 1;
#[doc = " @brief Mode of opening the non-volatile storage"]
pub type nvs_open_mode_t = ::core::ffi::c_uint;
#[doc = " @brief Mode of opening the non-volatile storage"]
pub use self::nvs_open_mode_t as nvs_open_mode;
#[doc = "< Type uint8_t"]
pub const nvs_type_t_NVS_TYPE_U8: nvs_type_t = 1;
#[doc = "< Type int8_t"]
pub const nvs_type_t_NVS_TYPE_I8: nvs_type_t = 17;
#[doc = "< Type uint16_t"]
pub const nvs_type_t_NVS_TYPE_U16: nvs_type_t = 2;
#[doc = "< Type int16_t"]
pub const nvs_type_t_NVS_TYPE_I16: nvs_type_t = 18;
#[doc = "< Type uint32_t"]
pub const nvs_type_t_NVS_TYPE_U32: nvs_type_t = 4;
#[doc = "< Type int32_t"]
pub const nvs_type_t_NVS_TYPE_I32: nvs_type_t = 20;
#[doc = "< Type uint64_t"]
pub const nvs_type_t_NVS_TYPE_U64: nvs_type_t = 8;
#[doc = "< Type int64_t"]
pub const nvs_type_t_NVS_TYPE_I64: nvs_type_t = 24;
#[doc = "< Type string"]
pub const nvs_type_t_NVS_TYPE_STR: nvs_type_t = 33;
#[doc = "< Type blob"]
pub const nvs_type_t_NVS_TYPE_BLOB: nvs_type_t = 66;
#[doc = "< Must be last"]
pub const nvs_type_t_NVS_TYPE_ANY: nvs_type_t = 255;
#[doc = " @brief Types of variables\n"]
pub type nvs_type_t = ::core::ffi::c_uint;
#[doc = " @brief information about entry obtained from nvs_entry_info function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_entry_info_t {
    #[doc = "< Namespace to which key-value belong"]
    pub namespace_name: [::core::ffi::c_char; 16usize],
    #[doc = "< Key of stored key-value pair"]
    pub key: [::core::ffi::c_char; 16usize],
    #[doc = "< Type of stored key-value pair"]
    pub type_: nvs_type_t,
}
impl Default for nvs_entry_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_opaque_iterator_t {
    _unused: [u8; 0],
}
#[doc = " Opaque pointer type representing iterator to nvs entries"]
pub type nvs_iterator_t = *mut nvs_opaque_iterator_t;
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from the default NVS partition\n\n Multiple internal ESP-IDF and third party application modules can store\n their key-value pairs in the NVS module. In order to reduce possible\n conflicts on key names, each module can use its own namespace.\n The default NVS partition is the one that is labelled \"nvs\" in the partition\n table.\n\n @param[in]  namespace_name   Namespace name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[in]  open_mode        NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will\n                              open a handle for reading only. All write requests will\n                              be rejected for this handle.\n @param[out] out_handle       If successful (return code is zero), handle will be\n                              returned in this argument.\n\n @return\n             - ESP_OK if storage handle was opened successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized\n             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"nvs\" is not found\n             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and\n               mode is NVS_READONLY\n             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints\n             - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is no space for a new entry or there are too many different\n                                  namespaces (maximum allowed different namespaces: 254)\n             - other error codes from the underlying storage driver"]
    pub fn nvs_open(
        namespace_name: *const ::core::ffi::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from specified partition\n\n The behaviour is same as nvs_open() API. However this API can operate on a specified NVS\n partition instead of default NVS partition. Note that the specified partition must be registered\n with NVS using nvs_flash_init_partition() API.\n\n @param[in]  part_name        Label (name) of the partition of interest for object read/write/erase\n @param[in]  namespace_name   Namespace name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[in]  open_mode        NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will\n                              open a handle for reading only. All write requests will\n                              be rejected for this handle.\n @param[out] out_handle       If successful (return code is zero), handle will be\n                              returned in this argument.\n\n @return\n             - ESP_OK if storage handle was opened successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized\n             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found\n             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and\n               mode is NVS_READONLY\n             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints\n             - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is no space for a new entry or there are too many different\n                                  namespaces (maximum allowed different namespaces: 254)\n             - other error codes from the underlying storage driver"]
    pub fn nvs_open_from_partition(
        part_name: *const ::core::ffi::c_char,
        namespace_name: *const ::core::ffi::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/\n/**\n @brief      set int8_t value for given key\n\n Set value for the key, given its name. Note that the actual storage will not be updated\n until \\c nvs_commit is called.\n\n @param[in]  handle  Handle obtained from nvs_open function.\n                     Handles that were opened read only cannot be used.\n @param[in]  key     Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[in]  value   The value to set.\n\n @return\n             - ESP_OK if value was set successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only\n             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints\n             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the\n               underlying storage to save the value\n             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash\n               write operation has failed. The value was written however, and\n               update will be finished after re-initialization of nvs, provided that\n               flash operation doesn't fail again."]
    pub fn nvs_set_i8(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: i8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set uint8_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_u8(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set int16_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_i16(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: i16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set uint16_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_u16(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set int32_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_i32(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: i32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set uint32_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_u32(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set int64_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_i64(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: i64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set uint64_t value for given key\n\n This function is the same as \\c nvs_set_i8 except for the data type."]
    pub fn nvs_set_u64(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      set string for given key\n\n Set value for the key, given its name. Note that the actual storage will not be updated\n until \\c nvs_commit is called.\n\n @param[in]  handle  Handle obtained from nvs_open function.\n                     Handles that were opened read only cannot be used.\n @param[in]  key     Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[in]  value   The value to set.\n                     For strings, the maximum length (including null character) is\n                     4000 bytes, if there is one complete page free for writing.\n                     This decreases, however, if the free space is fragmented.\n\n @return\n             - ESP_OK if value was set successfully\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only\n             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints\n             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the\n               underlying storage to save the value\n             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash\n               write operation has failed. The value was written however, and\n               update will be finished after re-initialization of nvs, provided that\n               flash operation doesn't fail again.\n             - ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long"]
    pub fn nvs_set_str(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       set variable length binary value for given key\n\n This family of functions set value for the key, given its name. Note that\n actual storage will not be updated until nvs_commit function is called.\n\n @param[in]  handle  Handle obtained from nvs_open function.\n                     Handles that were opened read only cannot be used.\n @param[in]  key     Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[in]  value   The value to set.\n @param[in]  length  length of binary value to set, in bytes; Maximum length is\n                     508000 bytes or (97.6% of the partition size - 4000) bytes\n                     whichever is lower.\n\n @return\n             - ESP_OK if value was set successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only\n             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints\n             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the\n               underlying storage to save the value\n             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash\n               write operation has failed. The value was written however, and\n               update will be finished after re-initialization of nvs, provided that\n               flash operation doesn't fail again.\n             - ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long"]
    pub fn nvs_set_blob(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_void,
        length: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/\n/**\n @brief      get int8_t value for given key\n\n These functions retrieve value for the key, given its name. If \\c key does not\n exist, or the requested variable type doesn't match the type which was used\n when setting a value, an error is returned.\n\n In case of any error, out_value is not modified.\n\n \\c out_value has to be a pointer to an already allocated variable of the given type.\n\n \\code{c}\n // Example of using nvs_get_i32:\n int32_t max_buffer_size = 4096; // default value\n esp_err_t err = nvs_get_i32(my_handle, \"max_buffer_size\", &max_buffer_size);\n assert(err == ESP_OK || err == ESP_ERR_NVS_NOT_FOUND);\n // if ESP_ERR_NVS_NOT_FOUND was returned, max_buffer_size will still\n // have its default value.\n\n \\endcode\n\n @param[in]     handle     Handle obtained from nvs_open function.\n @param[in]     key        Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param         out_value  Pointer to the output value.\n                           May be NULL for nvs_get_str and nvs_get_blob, in this\n                           case required length will be returned in length argument.\n\n @return\n             - ESP_OK if the value was retrieved successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints\n             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_i8(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut i8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get uint8_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_u8(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get int16_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_i16(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get uint16_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_u16(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get int32_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_i32(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut i32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get uint32_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_u32(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get int64_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_i64(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut i64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get uint64_t value for given key\n\n This function is the same as \\c nvs_get_i8 except for the data type."]
    pub fn nvs_get_u64(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/\n/**\n @brief      get string value for given key\n\n These functions retrieve the data of an entry, given its key. If key does not\n exist, or the requested variable type doesn't match the type which was used\n when setting a value, an error is returned.\n\n In case of any error, out_value is not modified.\n\n All functions expect out_value to be a pointer to an already allocated variable\n of the given type.\n\n nvs_get_str and nvs_get_blob functions support WinAPI-style length queries.\n To get the size necessary to store the value, call nvs_get_str or nvs_get_blob\n with zero out_value and non-zero pointer to length. Variable pointed to\n by length argument will be set to the required length. For nvs_get_str,\n this length includes the zero terminator. When calling nvs_get_str and\n nvs_get_blob with non-zero out_value, length has to be non-zero and has to\n point to the length available in out_value.\n It is suggested that nvs_get/set_str is used for zero-terminated C strings, and\n nvs_get/set_blob used for arbitrary data structures.\n\n \\code{c}\n // Example (without error checking) of using nvs_get_str to get a string into dynamic array:\n size_t required_size;\n nvs_get_str(my_handle, \"server_name\", NULL, &required_size);\n char* server_name = malloc(required_size);\n nvs_get_str(my_handle, \"server_name\", server_name, &required_size);\n\n // Example (without error checking) of using nvs_get_blob to get a binary data\n into a static array:\n uint8_t mac_addr[6];\n size_t size = sizeof(mac_addr);\n nvs_get_blob(my_handle, \"dst_mac_addr\", mac_addr, &size);\n \\endcode\n\n @param[in]     handle     Handle obtained from nvs_open function.\n @param[in]     key        Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n @param[out]    out_value  Pointer to the output value.\n                           May be NULL for nvs_get_str and nvs_get_blob, in this\n                           case required length will be returned in length argument.\n @param[inout]  length     A non-zero pointer to the variable holding the length of out_value.\n                           In case out_value a zero, will be set to the length\n                           required to hold the value. In case out_value is not\n                           zero, will be set to the actual length of the value\n                           written. For nvs_get_str this includes zero terminator.\n\n @return\n             - ESP_OK if the value was retrieved successfully\n             - ESP_FAIL if there is an internal error; most likely due to corrupted\n               NVS partition (only if NVS assertion checks are disabled)\n             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints\n             - ESP_ERR_NVS_INVALID_LENGTH if \\c length is not sufficient to store data"]
    pub fn nvs_get_str(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut ::core::ffi::c_char,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get blob value for given key\n\n This function behaves the same as \\c nvs_get_str, except for the data type."]
    pub fn nvs_get_blob(
        handle: nvs_handle_t,
        key: *const ::core::ffi::c_char,
        out_value: *mut ::core::ffi::c_void,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase key-value pair with given key name.\n\n Note that actual storage may not be updated until nvs_commit function is called.\n\n @param[in]  handle  Storage handle obtained with nvs_open.\n                     Handles that were opened read only cannot be used.\n\n @param[in]  key     Key name. Maximum length is (NVS_KEY_NAME_MAX_SIZE-1) characters. Shouldn't be empty.\n\n @return\n              - ESP_OK if erase operation was successful\n              - ESP_FAIL if there is an internal error; most likely due to corrupted\n                NVS partition (only if NVS assertion checks are disabled)\n              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only\n              - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist\n              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_key(handle: nvs_handle_t, key: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase all key-value pairs in a namespace\n\n Note that actual storage may not be updated until nvs_commit function is called.\n\n @param[in]  handle  Storage handle obtained with nvs_open.\n                     Handles that were opened read only cannot be used.\n\n @return\n              - ESP_OK if erase operation was successful\n              - ESP_FAIL if there is an internal error; most likely due to corrupted\n                NVS partition (only if NVS assertion checks are disabled)\n              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only\n              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_all(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Write any pending changes to non-volatile storage\n\n After setting any values, nvs_commit() must be called to ensure changes are written\n to non-volatile storage. Individual implementations may write to storage at other times,\n but this is not guaranteed.\n\n @param[in]  handle  Storage handle obtained with nvs_open.\n                     Handles that were opened read only cannot be used.\n\n @return\n             - ESP_OK if the changes have been written successfully\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL\n             - other error codes from the underlying storage driver"]
    pub fn nvs_commit(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Close the storage handle and free any allocated resources\n\n This function should be called for each handle opened with nvs_open once\n the handle is not in use any more. Closing the handle may not automatically\n write the changes to nonvolatile storage. This has to be done explicitly using\n nvs_commit function.\n Once this function is called on a handle, the handle should no longer be used.\n\n @param[in]  handle  Storage handle to close"]
    pub fn nvs_close(handle: nvs_handle_t);
}
#[doc = " @note Info about storage space NVS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvs_stats_t {
    #[doc = "< Amount of used entries."]
    pub used_entries: usize,
    #[doc = "< Amount of free entries."]
    pub free_entries: usize,
    #[doc = "< Amount all available entries."]
    pub total_entries: usize,
    #[doc = "< Amount name space."]
    pub namespace_count: usize,
}
extern "C" {
    #[doc = " @brief      Fill structure nvs_stats_t. It provides info about used memory the partition.\n\n This function calculates to runtime the number of used entries, free entries, total entries,\n and amount namespace in partition.\n\n \\code{c}\n // Example of nvs_get_stats() to get the number of used entries and free entries:\n nvs_stats_t nvs_stats;\n nvs_get_stats(NULL, &nvs_stats);\n printf(\"Count: UsedEntries = (%d), FreeEntries = (%d), AllEntries = (%d)\\n\",\nnvs_stats.used_entries, nvs_stats.free_entries, nvs_stats.total_entries);\n \\endcode\n\n @param[in]   part_name   Partition name NVS in the partition table.\n                          If pass a NULL than will use NVS_DEFAULT_PART_NAME (\"nvs\").\n\n @param[out]  nvs_stats   Returns filled structure nvs_states_t.\n                          It provides info about used memory the partition.\n\n\n @return\n             - ESP_OK if the changes have been written successfully.\n               Return param nvs_stats will be filled.\n             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"name\" is not found.\n               Return param nvs_stats will be filled 0.\n             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized.\n               Return param nvs_stats will be filled 0.\n             - ESP_ERR_INVALID_ARG if nvs_stats equal to NULL.\n             - ESP_ERR_INVALID_STATE if there is page with the status of INVALID.\n               Return param nvs_stats will be filled not with correct values because\n               not all pages will be counted. Counting will be interrupted at the first INVALID page."]
    pub fn nvs_get_stats(
        part_name: *const ::core::ffi::c_char,
        nvs_stats: *mut nvs_stats_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Calculate all entries in a namespace.\n\n An entry represents the smallest storage unit in NVS.\n Strings and blobs may occupy more than one entry.\n Note that to find out the total number of entries occupied by the namespace,\n add one to the returned value used_entries (if err is equal to ESP_OK).\n Because the name space entry takes one entry.\n\n \\code{c}\n // Example of nvs_get_used_entry_count() to get amount of all key-value pairs in one namespace:\n nvs_handle_t handle;\n nvs_open(\"namespace1\", NVS_READWRITE, &handle);\n ...\n size_t used_entries;\n size_t total_entries_namespace;\n if(nvs_get_used_entry_count(handle, &used_entries) == ESP_OK){\n     // the total number of entries occupied by the namespace\n     total_entries_namespace = used_entries + 1;\n }\n \\endcode\n\n @param[in]   handle              Handle obtained from nvs_open function.\n\n @param[out]  used_entries        Returns amount of used entries from a namespace.\n\n\n @return\n             - ESP_OK if the changes have been written successfully.\n               Return param used_entries will be filled valid value.\n             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized.\n               Return param used_entries will be filled 0.\n             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL.\n               Return param used_entries will be filled 0.\n             - ESP_ERR_INVALID_ARG if used_entries equal to NULL.\n             - Other error codes from the underlying storage driver.\n               Return param used_entries will be filled 0."]
    pub fn nvs_get_used_entry_count(handle: nvs_handle_t, used_entries: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Create an iterator to enumerate NVS entries based on one or more parameters\n\n \\code{c}\n // Example of listing all the key-value pairs of any type under specified partition and namespace\n  nvs_iterator_t it = NULL;\n  esp_err_t res = nvs_entry_find(<nvs_partition_name>, <namespace>, NVS_TYPE_ANY, &it);\n  while(res == ESP_OK) {\n      nvs_entry_info_t info;\n      nvs_entry_info(it, &info); // Can omit error check if parameters are guaranteed to be non-NULL\n      printf(\"key '%s', type '%d' \\n\", info.key, info.type);\n      res = nvs_entry_next(&it);\n  }\n  nvs_release_iterator(it);\n \\endcode\n\n @param[in]   part_name       Partition name\n\n @param[in]   namespace_name  Set this value if looking for entries with\n                              a specific namespace. Pass NULL otherwise.\n\n @param[in]   type            One of nvs_type_t values.\n\n @param[out] output_iterator\n          Set to a valid iterator to enumerate all the entries found.\n          Set to NULL if no entry for specified criteria was found.\n          If any other error except ESP_ERR_INVALID_ARG occurs, \\c output_iterator is NULL, too.\n          If ESP_ERR_INVALID_ARG occurs, \\c output_iterator is not changed.\n          If a valid iterator is obtained through this function, it has to be released\n          using \\c nvs_release_iterator when not used any more, unless ESP_ERR_INVALID_ARG is returned.\n\n @return\n             - ESP_OK if no internal error or programming error occurred.\n             - ESP_ERR_NVS_NOT_FOUND if no element of specified criteria has been found.\n             - ESP_ERR_NO_MEM if memory has been exhausted during allocation of internal structures.\n             - ESP_ERR_INVALID_ARG if any of the parameters is NULL.\n                  Note: don't release \\c output_iterator in case ESP_ERR_INVALID_ARG has been returned"]
    pub fn nvs_entry_find(
        part_name: *const ::core::ffi::c_char,
        namespace_name: *const ::core::ffi::c_char,
        type_: nvs_type_t,
        output_iterator: *mut nvs_iterator_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Advances the iterator to next item matching the iterator criteria.\n\n Note that any copies of the iterator will be invalid after this call.\n\n @param[inout]   iterator Iterator obtained from nvs_entry_find function. Must be non-NULL.\n                          If any error except ESP_ERR_INVALID_ARG occurs, \\c iterator is set to NULL.\n                          If ESP_ERR_INVALID_ARG occurs, \\c iterator is not changed.\n\n @return\n             - ESP_OK if no internal error or programming error occurred.\n             - ESP_ERR_NVS_NOT_FOUND if no next element matching the iterator criteria.\n             - ESP_ERR_INVALID_ARG if \\c iterator is NULL.\n             - Possibly other errors in the future for internal programming or flash errors."]
    pub fn nvs_entry_next(iterator: *mut nvs_iterator_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Fills nvs_entry_info_t structure with information about entry pointed to by the iterator.\n\n @param[in]   iterator     Iterator obtained from nvs_entry_find function. Must be non-NULL.\n\n @param[out]  out_info     Structure to which entry information is copied.\n\n @return\n             - ESP_OK if all parameters are valid; current iterator data has been written to out_info\n             - ESP_ERR_INVALID_ARG if one of the parameters is NULL."]
    pub fn nvs_entry_info(iterator: nvs_iterator_t, out_info: *mut nvs_entry_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Release iterator\n\n @param[in]   iterator    Release iterator obtained from nvs_entry_find function. NULL argument is allowed.\n"]
    pub fn nvs_release_iterator(iterator: nvs_iterator_t);
}
#[doc = " @brief Key for encryption and decryption"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvs_sec_cfg_t {
    #[doc = "<  XTS encryption and decryption key"]
    pub eky: [u8; 32usize],
    #[doc = "<  XTS tweak key"]
    pub tky: [u8; 32usize],
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition.\n\n This API initialises the default NVS partition. The default NVS partition\n is the one that is labeled \"nvs\" in the partition table.\n\n When \"NVS_ENCRYPTION\" is enabled in the menuconfig, this API enables\n the NVS encryption for the default NVS partition as follows\n      1. Read security configurations from the first NVS key\n         partition listed in the partition table. (NVS key partition is\n         any \"data\" type partition which has the subtype value set to \"nvs_keys\")\n      2. If the NVS key partiton obtained in the previous step is empty,\n         generate and store new keys in that NVS key partiton.\n      3. Internally call \"nvs_flash_secure_init()\" with\n         the security configurations obtained/generated in the previous steps.\n\n Post initialization NVS read/write APIs\n remain the same irrespective of NVS encryption.\n\n @return\n      - ESP_OK if storage was successfully initialized.\n      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages\n        (which may happen if NVS partition was truncated)\n      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table\n      - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n      - one of the error codes from the underlying flash storage driver\n      - error codes from nvs_flash_read_security_cfg API (when \"NVS_ENCRYPTION\" is enabled).\n      - error codes from nvs_flash_generate_keys API (when \"NVS_ENCRYPTION\" is enabled).\n      - error codes from nvs_flash_secure_init_partition API (when \"NVS_ENCRYPTION\" is enabled) ."]
    pub fn nvs_flash_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition.\n\n @param[in]  partition_label   Label of the partition. Must be no longer than 16 characters.\n\n @return\n      - ESP_OK if storage was successfully initialized.\n      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages\n        (which may happen if NVS partition was truncated)\n      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table\n      - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition(partition_label: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the partition specified by partition pointer.\n\n @param[in] partition pointer to a partition obtained by the ESP partition API.\n\n @return\n      - ESP_OK if storage was successfully initialized\n      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages\n        (which may happen if NVS partition was truncated)\n      - ESP_ERR_INVALID_ARG in case partition is NULL\n      - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition_ptr(partition: *const esp_partition_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the default NVS partition\n\n Default NVS partition is the partition with \"nvs\" label in the partition table.\n\n @return\n      - ESP_OK on success (storage was deinitialized)\n      - ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call"]
    pub fn nvs_flash_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the given NVS partition\n\n @param[in]  partition_label   Label of the partition\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not\n        initialized prior to this call"]
    pub fn nvs_flash_deinit_partition(partition_label: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase the default NVS partition\n\n Erases all contents of the default NVS partition (one with label \"nvs\").\n\n @note If the partition is initialized, this function first de-initializes it. Afterwards, the partition has to\n       be initialized again to be used.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if there is no NVS partition labeled \"nvs\" in the\n        partition table\n      - different error in case de-initialization fails (shouldn't happen)"]
    pub fn nvs_flash_erase() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase specified NVS partition\n\n Erase all content of a specified NVS partition\n\n @note If the partition is initialized, this function first de-initializes it. Afterwards, the partition has to\n       be initialized again to be used.\n\n @param[in]  part_name    Name (label) of the partition which should be erased\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name\n        in the partition table\n      - different error in case de-initialization fails (shouldn't happen)"]
    pub fn nvs_flash_erase_partition(part_name: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase custom partition.\n\n Erase all content of specified custom partition.\n\n @note\n  If the partition is initialized, this function first de-initializes it.\n  Afterwards, the partition has to be initialized again to be used.\n\n @param[in] partition pointer to a partition obtained by the ESP partition API.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_NOT_FOUND if there is no partition with the specified\n        parameters in the partition table\n      - ESP_ERR_INVALID_ARG in case partition is NULL\n      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_erase_partition_ptr(partition: *const esp_partition_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition.\n\n This API initialises the default NVS partition. The default NVS partition\n is the one that is labeled \"nvs\" in the partition table.\n\n @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption.\n                              If cfg is NULL, no encryption is used.\n\n @return\n      - ESP_OK if storage has been initialized successfully.\n      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages\n        (which may happen if NVS partition was truncated)\n      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table\n      - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init(cfg: *mut nvs_sec_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition.\n\n @param[in]  partition_label   Label of the partition. Note that internally, a reference to\n                               passed value is kept and it should be accessible for future operations\n\n @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption.\n                              If cfg is null, no encryption/decryption is used.\n @return\n      - ESP_OK if storage has been initialized successfully.\n      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages\n        (which may happen if NVS partition was truncated)\n      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table\n      - ESP_ERR_NO_MEM in case memory could not be allocated for the internal structures\n      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init_partition(
        partition_label: *const ::core::ffi::c_char,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Generate and store NVS keys in the provided esp partition\n\n @param[in]  partition Pointer to partition structure obtained using\n                       esp_partition_find_first or esp_partition_get.\n                       Must be non-NULL.\n @param[out] cfg       Pointer to nvs security configuration structure.\n                       Pointer must be non-NULL.\n                       Generated keys will be populated in this structure.\n\n\n @return\n      -ESP_OK, if cfg was read successfully;\n      -ESP_INVALID_ARG, if partition or cfg;\n      -or error codes from esp_partition_write/erase APIs."]
    pub fn nvs_flash_generate_keys(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read NVS security configuration from a partition.\n\n @param[in]  partition Pointer to partition structure obtained using\n                       esp_partition_find_first or esp_partition_get.\n                       Must be non-NULL.\n @param[out] cfg       Pointer to nvs security configuration structure.\n                       Pointer must be non-NULL.\n\n @note  Provided partition is assumed to be marked 'encrypted'.\n\n @return\n      -ESP_OK, if cfg was read successfully;\n      -ESP_INVALID_ARG, if partition or cfg;\n      -ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys.\n      -ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt\n      -or error codes from esp_partition_read API."]
    pub fn nvs_flash_read_security_cfg(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
#[doc = " @brief   Protocomm Security 1 parameters: Proof Of Possession"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protocomm_security1_params {
    #[doc = " Pointer to buffer containing the proof of possession data"]
    pub data: *const u8,
    #[doc = " Length (in bytes) of the proof of possession data"]
    pub len: u16,
}
impl Default for protocomm_security1_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Protocomm Security 1 parameters: Proof Of Possession"]
pub type protocomm_security1_params_t = protocomm_security1_params;
#[doc = " @brief   Protocomm Security 1 parameters: Proof Of Possession"]
pub type protocomm_security_pop_t = protocomm_security1_params_t;
#[doc = " @brief Protocomm Security 2 parameters: Salt and Verifier\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protocomm_security2_params {
    #[doc = " Pointer to the buffer containing the salt"]
    pub salt: *const ::core::ffi::c_char,
    #[doc = " Length (in bytes) of the salt"]
    pub salt_len: u16,
    #[doc = " Pointer to the buffer containing the verifier"]
    pub verifier: *const ::core::ffi::c_char,
    #[doc = " Length (in bytes) of the verifier"]
    pub verifier_len: u16,
}
impl Default for protocomm_security2_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Protocomm Security 2 parameters: Salt and Verifier\n"]
pub type protocomm_security2_params_t = protocomm_security2_params;
pub type protocomm_security_handle_t = *mut ::core::ffi::c_void;
#[doc = " @brief   Protocomm security object structure.\n\n The member functions are used for implementing secure\n protocomm sessions.\n\n @note    This structure should not have any dynamic\n          members to allow re-entrancy"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct protocomm_security {
    #[doc = " Unique version number of security implementation"]
    pub ver: ::core::ffi::c_int,
    #[doc = " Function for initializing/allocating security\n infrastructure"]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(handle: *mut protocomm_security_handle_t) -> esp_err_t,
    >,
    #[doc = " Function for deallocating security infrastructure"]
    pub cleanup: ::core::option::Option<
        unsafe extern "C" fn(handle: protocomm_security_handle_t) -> esp_err_t,
    >,
    #[doc = " Starts new secure transport session with specified ID"]
    pub new_transport_session: ::core::option::Option<
        unsafe extern "C" fn(handle: protocomm_security_handle_t, session_id: u32) -> esp_err_t,
    >,
    #[doc = " Closes a secure transport session with specified ID"]
    pub close_transport_session: ::core::option::Option<
        unsafe extern "C" fn(handle: protocomm_security_handle_t, session_id: u32) -> esp_err_t,
    >,
    #[doc = " Handler function for authenticating connection\n request and establishing secure session"]
    pub security_req_handler: ::core::option::Option<
        unsafe extern "C" fn(
            handle: protocomm_security_handle_t,
            sec_params: *const ::core::ffi::c_void,
            session_id: u32,
            inbuf: *const u8,
            inlen: isize,
            outbuf: *mut *mut u8,
            outlen: *mut isize,
            priv_data: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " Function which implements the encryption algorithm"]
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            handle: protocomm_security_handle_t,
            session_id: u32,
            inbuf: *const u8,
            inlen: isize,
            outbuf: *mut *mut u8,
            outlen: *mut isize,
        ) -> esp_err_t,
    >,
    #[doc = " Function which implements the decryption algorithm"]
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            handle: protocomm_security_handle_t,
            session_id: u32,
            inbuf: *const u8,
            inlen: isize,
            outbuf: *mut *mut u8,
            outlen: *mut isize,
        ) -> esp_err_t,
    >,
}
#[doc = " @brief   Protocomm security object structure.\n\n The member functions are used for implementing secure\n protocomm sessions.\n\n @note    This structure should not have any dynamic\n          members to allow re-entrancy"]
pub type protocomm_security_t = protocomm_security;
#[doc = " @brief Function prototype for protocomm endpoint handler"]
pub type protocomm_req_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        session_id: u32,
        inbuf: *const u8,
        inlen: isize,
        outbuf: *mut *mut u8,
        outlen: *mut isize,
        priv_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protocomm {
    _unused: [u8; 0],
}
#[doc = " @brief   This structure corresponds to a unique instance of protocomm\n          returned when the API `protocomm_new()` is called. The remaining\n          Protocomm APIs require this object as the first parameter.\n\n @note    Structure of the protocomm object is kept private"]
pub type protocomm_t = protocomm;
extern "C" {
    #[doc = " @brief   Create a new protocomm instance\n\n This API will return a new dynamically allocated protocomm instance\n with all elements of the protocomm_t structure initialized to NULL.\n\n @return\n  - protocomm_t* : On success\n  - NULL : No memory for allocating new instance"]
    pub fn protocomm_new() -> *mut protocomm_t;
}
extern "C" {
    #[doc = " @brief   Delete a protocomm instance\n\n This API will deallocate a protocomm instance that was created\n using `protocomm_new()`.\n\n @param[in] pc    Pointer to the protocomm instance to be deleted"]
    pub fn protocomm_delete(pc: *mut protocomm_t);
}
extern "C" {
    #[doc = " @brief   Add endpoint request handler for a protocomm instance\n\n This API will bind an endpoint handler function to the specified\n endpoint name, along with any private data that needs to be pass to\n the handler at the time of call.\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n  - This function internally calls the registered `add_endpoint()`\n    function of the selected transport which is a member of the\n    protocomm_t instance structure.\n\n @param[in] pc        Pointer to the protocomm instance\n @param[in] ep_name   Endpoint identifier(name) string\n @param[in] h         Endpoint handler function\n @param[in] priv_data Pointer to private data to be passed as a\n                      parameter to the handler function on call.\n                      Pass NULL if not needed.\n\n @return\n  - ESP_OK : Success\n  - ESP_FAIL : Error adding endpoint / Endpoint with this name already exists\n  - ESP_ERR_NO_MEM : Error allocating endpoint resource\n  - ESP_ERR_INVALID_ARG : Null instance/name/handler arguments"]
    pub fn protocomm_add_endpoint(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
        h: protocomm_req_handler_t,
        priv_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Remove endpoint request handler for a protocomm instance\n\n This API will remove a registered endpoint handler identified by\n an endpoint name.\n\n @note\n  - This function internally calls the registered `remove_endpoint()`\n    function which is a member of the protocomm_t instance structure.\n\n @param[in] pc        Pointer to the protocomm instance\n @param[in] ep_name   Endpoint identifier(name) string\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_NOT_FOUND : Endpoint with specified name doesn't exist\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_remove_endpoint(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Allocates internal resources for new transport session\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n\n @param[in]  pc         Pointer to the protocomm instance\n @param[in]  session_id Unique ID for a communication session\n\n @return\n  - ESP_OK : Request handled successfully\n  - ESP_ERR_NO_MEM : Error allocating internal resource\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_open_session(pc: *mut protocomm_t, session_id: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Frees internal resources used by a transport session\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n\n @param[in]  pc         Pointer to the protocomm instance\n @param[in]  session_id Unique ID for a communication session\n\n @return\n  - ESP_OK : Request handled successfully\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_close_session(pc: *mut protocomm_t, session_id: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Calls the registered handler of an endpoint session\n          for processing incoming data and generating the response\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n  - Resulting output buffer must be deallocated by the caller.\n\n @param[in]  pc         Pointer to the protocomm instance\n @param[in]  ep_name    Endpoint identifier(name) string\n @param[in]  session_id Unique ID for a communication session\n @param[in]  inbuf      Input buffer contains input request data which is to be\n                        processed by the registered handler\n @param[in]  inlen      Length of the input buffer\n @param[out] outbuf     Pointer to internally allocated output buffer,\n                        where the resulting response data output from\n                        the registered handler is to be stored\n @param[out] outlen     Buffer length of the allocated output buffer\n\n @return\n  - ESP_OK : Request handled successfully\n  - ESP_FAIL : Internal error in execution of registered handler\n  - ESP_ERR_NO_MEM : Error allocating internal resource\n  - ESP_ERR_NOT_FOUND : Endpoint with specified name doesn't exist\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_req_handle(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
        session_id: u32,
        inbuf: *const u8,
        inlen: isize,
        outbuf: *mut *mut u8,
        outlen: *mut isize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Add endpoint security for a protocomm instance\n\n This API will bind a security session establisher to the specified\n endpoint name, along with any proof of possession that may be required\n for authenticating a session client.\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n  - The choice of security can be any `protocomm_security_t` instance.\n    Choices `protocomm_security0` and `protocomm_security1` and `protocomm_security2` are readily available.\n\n @param[in] pc            Pointer to the protocomm instance\n @param[in] ep_name       Endpoint identifier(name) string\n @param[in] sec           Pointer to endpoint security instance\n @param[in] sec_params    Pointer to security params (NULL if not needed)\n                          The pointer should contain the security params struct\n                          of appropriate security version.\n                          For protocomm security version 1 and 2\n                          sec_params should contain pointer to struct of type\n                          protocomm_security1_params_t and protocmm_security2_params_t respectively.\n                          The contents of this pointer must be valid till the security session\n                          has been running and is not closed.\n @return\n  - ESP_OK : Success\n  - ESP_FAIL : Error adding endpoint / Endpoint with this name already exists\n  - ESP_ERR_INVALID_STATE : Security endpoint already set\n  - ESP_ERR_NO_MEM : Error allocating endpoint resource\n  - ESP_ERR_INVALID_ARG : Null instance/name/handler arguments"]
    pub fn protocomm_set_security(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
        sec: *const protocomm_security_t,
        sec_params: *const ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Remove endpoint security for a protocomm instance\n\n This API will remove a registered security endpoint identified by\n an endpoint name.\n\n @param[in] pc        Pointer to the protocomm instance\n @param[in] ep_name   Endpoint identifier(name) string\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_NOT_FOUND : Endpoint with specified name doesn't exist\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_unset_security(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set endpoint for version verification\n\n This API can be used for setting an application specific protocol\n version which can be verified by clients through the endpoint.\n\n @note\n  - An endpoint must be bound to a valid protocomm instance,\n    created using `protocomm_new()`.\n\n @param[in] pc        Pointer to the protocomm instance\n @param[in] ep_name   Endpoint identifier(name) string\n @param[in] version   Version identifier(name) string\n\n @return\n  - ESP_OK : Success\n  - ESP_FAIL : Error adding endpoint / Endpoint with this name already exists\n  - ESP_ERR_INVALID_STATE : Version endpoint already set\n  - ESP_ERR_NO_MEM : Error allocating endpoint resource\n  - ESP_ERR_INVALID_ARG : Null instance/name/handler arguments"]
    pub fn protocomm_set_version(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
        version: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Remove version verification endpoint from a protocomm instance\n\n This API will remove a registered version endpoint identified by\n an endpoint name.\n\n @param[in] pc        Pointer to the protocomm instance\n @param[in] ep_name   Endpoint identifier(name) string\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_NOT_FOUND : Endpoint with specified name doesn't exist\n  - ESP_ERR_INVALID_ARG : Null instance/name arguments"]
    pub fn protocomm_unset_version(
        pc: *mut protocomm_t,
        ep_name: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
pub const wifi_prov_sta_state_t_WIFI_PROV_STA_CONNECTING: wifi_prov_sta_state_t = 0;
pub const wifi_prov_sta_state_t_WIFI_PROV_STA_CONNECTED: wifi_prov_sta_state_t = 1;
pub const wifi_prov_sta_state_t_WIFI_PROV_STA_DISCONNECTED: wifi_prov_sta_state_t = 2;
#[doc = " @brief   WiFi STA status for conveying back to the provisioning master"]
pub type wifi_prov_sta_state_t = ::core::ffi::c_uint;
pub const wifi_prov_sta_fail_reason_t_WIFI_PROV_STA_AUTH_ERROR: wifi_prov_sta_fail_reason_t = 0;
pub const wifi_prov_sta_fail_reason_t_WIFI_PROV_STA_AP_NOT_FOUND: wifi_prov_sta_fail_reason_t = 1;
#[doc = " @brief   WiFi STA connection fail reason"]
pub type wifi_prov_sta_fail_reason_t = ::core::ffi::c_uint;
#[doc = " @brief   WiFi STA connected status information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_sta_conn_info_t {
    #[doc = " IP Address received by station"]
    pub ip_addr: [::core::ffi::c_char; 16usize],
    #[doc = "< BSSID of the AP to which connection was estalished"]
    pub bssid: [::core::ffi::c_char; 6usize],
    #[doc = "< SSID of the to which connection was estalished"]
    pub ssid: [::core::ffi::c_char; 33usize],
    #[doc = "< Channel of the AP"]
    pub channel: u8,
    #[doc = "< Authorization mode of the AP"]
    pub auth_mode: u8,
}
impl Default for wifi_prov_sta_conn_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   WiFi status data to be sent in response to `get_status` request from master"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_prov_config_get_data_t {
    #[doc = "< WiFi state of the station"]
    pub wifi_state: wifi_prov_sta_state_t,
    pub __bindgen_anon_1: wifi_prov_config_get_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_prov_config_get_data_t__bindgen_ty_1 {
    #[doc = " Reason for disconnection (valid only when `wifi_state` is `WIFI_STATION_DISCONNECTED`)"]
    pub fail_reason: wifi_prov_sta_fail_reason_t,
    #[doc = " Connection information (valid only when `wifi_state` is `WIFI_STATION_CONNECTED`)"]
    pub conn_info: wifi_prov_sta_conn_info_t,
}
impl Default for wifi_prov_config_get_data_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for wifi_prov_config_get_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   WiFi config data received by slave during `set_config` request from master"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_config_set_data_t {
    #[doc = "< SSID of the AP to which the slave is to be connected"]
    pub ssid: [::core::ffi::c_char; 33usize],
    #[doc = "< Password of the AP"]
    pub password: [::core::ffi::c_char; 64usize],
    #[doc = "< BSSID of the AP"]
    pub bssid: [::core::ffi::c_char; 6usize],
    #[doc = "< Channel of the AP"]
    pub channel: u8,
}
impl Default for wifi_prov_config_set_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_ctx {
    _unused: [u8; 0],
}
#[doc = " @brief   Type of context data passed to each get/set/apply handler\n           function set in `wifi_prov_config_handlers` structure.\n\n This is passed as an opaque pointer, thereby allowing it be defined\n later in application code as per requirements."]
pub type wifi_prov_ctx_t = wifi_prov_ctx;
#[doc = " @brief   Internal handlers for receiving and responding to protocomm\n          requests from master\n\n This is to be passed as priv_data for protocomm request handler\n (refer to `wifi_prov_config_data_handler()`) when calling `protocomm_add_endpoint()`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_config_handlers {
    #[doc = " Handler function called when connection status\n of the slave (in WiFi station mode) is requested"]
    pub get_status_handler: ::core::option::Option<
        unsafe extern "C" fn(
            resp_data: *mut wifi_prov_config_get_data_t,
            ctx: *mut *mut wifi_prov_ctx_t,
        ) -> esp_err_t,
    >,
    #[doc = " Handler function called when WiFi connection configuration\n (eg. AP SSID, password, etc.) of the slave (in WiFi station mode)\n is to be set to user provided values"]
    pub set_config_handler: ::core::option::Option<
        unsafe extern "C" fn(
            req_data: *const wifi_prov_config_set_data_t,
            ctx: *mut *mut wifi_prov_ctx_t,
        ) -> esp_err_t,
    >,
    #[doc = " Handler function for applying the configuration that was set in\n `set_config_handler`. After applying the station may get connected to\n the AP or may fail to connect. The slave must be ready to convey the\n updated connection status information when `get_status_handler` is\n invoked again by the master."]
    pub apply_config_handler:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut *mut wifi_prov_ctx_t) -> esp_err_t>,
    #[doc = " Context pointer to be passed to above handler functions upon invocation"]
    pub ctx: *mut wifi_prov_ctx_t,
}
impl Default for wifi_prov_config_handlers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Internal handlers for receiving and responding to protocomm\n          requests from master\n\n This is to be passed as priv_data for protocomm request handler\n (refer to `wifi_prov_config_data_handler()`) when calling `protocomm_add_endpoint()`."]
pub type wifi_prov_config_handlers_t = wifi_prov_config_handlers;
extern "C" {
    #[doc = " @brief   Handler for receiving and responding to requests from master\n\n This is to be registered as the `wifi_config` endpoint handler\n (protocomm `protocomm_req_handler_t`) using `protocomm_add_endpoint()`"]
    pub fn wifi_prov_config_data_handler(
        session_id: u32,
        inbuf: *const u8,
        inlen: isize,
        outbuf: *mut *mut u8,
        outlen: *mut isize,
        priv_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub static mut WIFI_PROV_EVENT: esp_event_base_t;
}
#[doc = " Emitted when the manager is initialized"]
pub const wifi_prov_cb_event_t_WIFI_PROV_INIT: wifi_prov_cb_event_t = 0;
#[doc = " Indicates that provisioning has started"]
pub const wifi_prov_cb_event_t_WIFI_PROV_START: wifi_prov_cb_event_t = 1;
#[doc = " Emitted when Wi-Fi AP credentials are received via `protocomm`\n endpoint `wifi_config`. The event data in this case is a pointer\n to the corresponding `wifi_sta_config_t` structure"]
pub const wifi_prov_cb_event_t_WIFI_PROV_CRED_RECV: wifi_prov_cb_event_t = 2;
#[doc = " Emitted when device fails to connect to the AP of which the\n credentials were received earlier on event `WIFI_PROV_CRED_RECV`.\n The event data in this case is a pointer to the disconnection\n reason code with type `wifi_prov_sta_fail_reason_t`"]
pub const wifi_prov_cb_event_t_WIFI_PROV_CRED_FAIL: wifi_prov_cb_event_t = 3;
#[doc = " Emitted when device successfully connects to the AP of which the\n credentials were received earlier on event `WIFI_PROV_CRED_RECV`"]
pub const wifi_prov_cb_event_t_WIFI_PROV_CRED_SUCCESS: wifi_prov_cb_event_t = 4;
#[doc = " Signals that provisioning service has stopped"]
pub const wifi_prov_cb_event_t_WIFI_PROV_END: wifi_prov_cb_event_t = 5;
#[doc = " Signals that manager has been de-initialized"]
pub const wifi_prov_cb_event_t_WIFI_PROV_DEINIT: wifi_prov_cb_event_t = 6;
#[doc = " @brief   Events generated by manager\n\n These events are generated in order of declaration and, for the\n stretch of time between initialization and de-initialization of\n the manager, each event is signaled only once"]
pub type wifi_prov_cb_event_t = ::core::ffi::c_uint;
pub type wifi_prov_cb_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::core::ffi::c_void,
        event: wifi_prov_cb_event_t,
        event_data: *mut ::core::ffi::c_void,
    ),
>;
#[doc = " @brief   Event handler that is used by the manager while\n          provisioning service is active"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_event_handler_t {
    #[doc = " Callback function to be executed on provisioning events"]
    pub event_cb: wifi_prov_cb_func_t,
    #[doc = " User context data to pass as parameter to callback function"]
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for wifi_prov_event_handler_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Structure for specifying the provisioning scheme to be\n          followed by the manager\n\n @note    Ready to use schemes are available:\n              - wifi_prov_scheme_ble     : for provisioning over BLE transport + GATT server\n              - wifi_prov_scheme_softap  : for provisioning over SoftAP transport + HTTP server\n              - wifi_prov_scheme_console : for provisioning over Serial UART transport + Console (for debugging)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_scheme {
    #[doc = " Function which is to be called by the manager when it is to\n start the provisioning service associated with a protocomm instance\n and a scheme specific configuration"]
    pub prov_start: ::core::option::Option<
        unsafe extern "C" fn(pc: *mut protocomm_t, config: *mut ::core::ffi::c_void) -> esp_err_t,
    >,
    #[doc = " Function which is to be called by the manager to stop the\n provisioning service previously associated with a protocomm instance"]
    pub prov_stop: ::core::option::Option<unsafe extern "C" fn(pc: *mut protocomm_t) -> esp_err_t>,
    #[doc = " Function which is to be called by the manager to generate\n a new configuration for the provisioning service, that is\n to be passed to prov_start()"]
    pub new_config: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " Function which is to be called by the manager to delete a\n configuration generated using new_config()"]
    pub delete_config:
        ::core::option::Option<unsafe extern "C" fn(config: *mut ::core::ffi::c_void)>,
    #[doc = " Function which is to be called by the manager to set the\n service name and key values in the configuration structure"]
    pub set_config_service: ::core::option::Option<
        unsafe extern "C" fn(
            config: *mut ::core::ffi::c_void,
            service_name: *const ::core::ffi::c_char,
            service_key: *const ::core::ffi::c_char,
        ) -> esp_err_t,
    >,
    #[doc = " Function which is to be called by the manager to set a protocomm endpoint\n with an identifying name and UUID in the configuration structure"]
    pub set_config_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            config: *mut ::core::ffi::c_void,
            endpoint_name: *const ::core::ffi::c_char,
            uuid: u16,
        ) -> esp_err_t,
    >,
    #[doc = " Sets mode of operation of Wi-Fi during provisioning\n This is set to :\n - WIFI_MODE_APSTA for SoftAP transport\n - WIFI_MODE_STA for BLE transport"]
    pub wifi_mode: wifi_mode_t,
}
impl Default for wifi_prov_scheme {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Structure for specifying the provisioning scheme to be\n          followed by the manager\n\n @note    Ready to use schemes are available:\n              - wifi_prov_scheme_ble     : for provisioning over BLE transport + GATT server\n              - wifi_prov_scheme_softap  : for provisioning over SoftAP transport + HTTP server\n              - wifi_prov_scheme_console : for provisioning over Serial UART transport + Console (for debugging)"]
pub type wifi_prov_scheme_t = wifi_prov_scheme;
#[doc = " @brief   Structure for specifying the manager configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_prov_mgr_config_t {
    #[doc = " Provisioning scheme to use. Following schemes are already available:\n     - wifi_prov_scheme_ble     : for provisioning over BLE transport + GATT server\n     - wifi_prov_scheme_softap  : for provisioning over SoftAP transport + HTTP server + mDNS (optional)\n     - wifi_prov_scheme_console : for provisioning over Serial UART transport + Console (for debugging)"]
    pub scheme: wifi_prov_scheme_t,
    #[doc = " Event handler required by the scheme for incorporating scheme specific\n behavior while provisioning manager is running. Various options may be\n provided by the scheme for setting this field. Use WIFI_PROV_EVENT_HANDLER_NONE\n when not used. When using scheme wifi_prov_scheme_ble, the following\n options are available:\n     - WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM\n     - WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BLE\n     - WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BT"]
    pub scheme_event_handler: wifi_prov_event_handler_t,
    #[doc = " Event handler that can be set for the purpose of incorporating application\n specific behavior. Use WIFI_PROV_EVENT_HANDLER_NONE when not used."]
    pub app_event_handler: wifi_prov_event_handler_t,
}
impl Default for wifi_prov_mgr_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " No security (plain-text communication)"]
pub const wifi_prov_security_WIFI_PROV_SECURITY_0: wifi_prov_security = 0;
#[doc = " This secure communication mode consists of\n   X25519 key exchange\n + proof of possession (pop) based authentication\n + AES-CTR encryption"]
pub const wifi_prov_security_WIFI_PROV_SECURITY_1: wifi_prov_security = 1;
#[doc = " This secure communication mode consists of\n  SRP6a based authentication and key exchange\n  + AES-GCM encryption/decryption"]
pub const wifi_prov_security_WIFI_PROV_SECURITY_2: wifi_prov_security = 2;
#[doc = " @brief   Security modes supported by the Provisioning Manager.\n\n These are same as the security modes provided by protocomm"]
pub type wifi_prov_security = ::core::ffi::c_uint;
#[doc = " @brief   Security modes supported by the Provisioning Manager.\n\n These are same as the security modes provided by protocomm"]
pub use self::wifi_prov_security as wifi_prov_security_t;
#[doc = " @brief  Security 1 params structure\n         This needs to be passed when using WIFI_PROV_SECURITY_1"]
pub type wifi_prov_security1_params_t = ::core::ffi::c_char;
#[doc = " @brief Protocomm Security 2 parameters: Salt and Verifier\n"]
pub type wifi_prov_security2_params_t = protocomm_security2_params_t;
extern "C" {
    #[doc = " @brief   Initialize provisioning manager instance\n\n Configures the manager and allocates internal resources\n\n Configuration specifies the provisioning scheme (transport)\n and event handlers\n\n Event WIFI_PROV_INIT is emitted right after initialization\n is complete\n\n @param[in] config Configuration structure\n\n @return\n  - ESP_OK      : Success\n  - ESP_FAIL    : Fail"]
    pub fn wifi_prov_mgr_init(config: wifi_prov_mgr_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop provisioning (if running) and release\n          resource used by the manager\n\n Event WIFI_PROV_DEINIT is emitted right after de-initialization\n is finished\n\n If provisioning service is  still active when this API is called,\n it first stops the service, hence emitting WIFI_PROV_END, and\n then performs the de-initialization"]
    pub fn wifi_prov_mgr_deinit();
}
extern "C" {
    #[doc = " @brief   Checks if device is provisioned\n\n This checks if Wi-Fi credentials are present on the NVS\n\n The Wi-Fi credentials are assumed to be kept in the same\n NVS namespace as used by esp_wifi component\n\n If one were to call esp_wifi_set_config() directly instead\n of going through the provisioning process, this function will\n still yield true (i.e. device will be found to be provisioned)\n\n @note    Calling wifi_prov_mgr_start_provisioning() automatically\n          resets the provision state, irrespective of what the\n          state was prior to making the call.\n\n @param[out] provisioned  True if provisioned, else false\n\n @return\n  - ESP_OK      : Retrieved provision state successfully\n  - ESP_FAIL    : Wi-Fi not initialized\n  - ESP_ERR_INVALID_ARG   : Null argument supplied"]
    pub fn wifi_prov_mgr_is_provisioned(provisioned: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Start provisioning service\n\n This starts the provisioning service according to the scheme\n configured at the time of initialization. For scheme :\n - wifi_prov_scheme_ble : This starts protocomm_ble, which internally initializes\n                          BLE transport and starts GATT server for handling\n                          provisioning requests\n - wifi_prov_scheme_softap : This activates SoftAP mode of Wi-Fi and starts\n                          protocomm_httpd, which internally starts an HTTP\n                          server for handling provisioning requests (If mDNS is\n                          active it also starts advertising service with type\n                          _esp_wifi_prov._tcp)\n\n Event WIFI_PROV_START is emitted right after provisioning starts without failure\n\n @note   This API will start provisioning service even if device is found to be\n         already provisioned, i.e. wifi_prov_mgr_is_provisioned() yields true\n\n @param[in] security      Specify which protocomm security scheme to use :\n                              - WIFI_PROV_SECURITY_0 : For no security\n                              - WIFI_PROV_SECURITY_1 : x25519 secure handshake for session\n                                establishment followed by AES-CTR encryption of provisioning messages\n                              - WIFI_PROV_SECURITY_2:  SRP6a based authentication and key exchange\n                                followed by AES-GCM encryption/decryption of provisioning messages\n @param[in] wifi_prov_sec_params\n                          Pointer to security params (NULL if not needed).\n                          This is not needed for protocomm security 0\n                          This pointer should hold the struct of type\n                          wifi_prov_security1_params_t for protocomm security 1\n                          and wifi_prov_security2_params_t for protocomm security 2 respectively.\n                          This pointer and its contents should be valid till the provisioning service is\n                          running and has not been stopped or de-inited.\n @param[in] service_name  Unique name of the service. This translates to:\n                              - Wi-Fi SSID when provisioning mode is softAP\n                              - Device name when provisioning mode is BLE\n @param[in] service_key   Key required by client to access the service (NULL if not needed).\n                          This translates to:\n                              - Wi-Fi password when provisioning mode is softAP\n                              - ignored when provisioning mode is BLE\n\n @return\n  - ESP_OK      : Provisioning started successfully\n  - ESP_FAIL    : Failed to start provisioning service\n  - ESP_ERR_INVALID_STATE : Provisioning manager not initialized or already started"]
    pub fn wifi_prov_mgr_start_provisioning(
        security: wifi_prov_security_t,
        wifi_prov_sec_params: *const ::core::ffi::c_void,
        service_name: *const ::core::ffi::c_char,
        service_key: *const ::core::ffi::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop provisioning service\n\n If provisioning service is active, this API will initiate a process to stop\n the service and return. Once the service actually stops, the event WIFI_PROV_END\n will be emitted.\n\n If wifi_prov_mgr_deinit() is called without calling this API first, it will\n automatically stop the provisioning service and emit the WIFI_PROV_END, followed\n by WIFI_PROV_DEINIT, before returning.\n\n This API will generally be used along with wifi_prov_mgr_disable_auto_stop()\n in the scenario when the main application has registered its own endpoints,\n and wishes that the provisioning service is stopped only when some protocomm\n command from the client side application is received.\n\n Calling this API inside an endpoint handler, with sufficient cleanup_delay,\n will allow the response / acknowledgment to be sent successfully before the\n underlying protocomm service is stopped.\n\n Cleaup_delay is set when calling wifi_prov_mgr_disable_auto_stop().\n If not specified, it defaults to 1000ms.\n\n For straightforward cases, using this API is usually not necessary as\n provisioning is stopped automatically once WIFI_PROV_CRED_SUCCESS is emitted.\n Stopping is delayed (maximum 30 seconds) thus allowing the client side\n application to query for Wi-Fi state, i.e. after receiving the first query\n and sending `Wi-Fi state connected` response the service is stopped immediately."]
    pub fn wifi_prov_mgr_stop_provisioning();
}
extern "C" {
    #[doc = " @brief   Wait for provisioning service to finish\n\n Calling this API will block until provisioning service is stopped\n i.e. till event WIFI_PROV_END is emitted.\n\n This will not block if provisioning is not started or not initialized."]
    pub fn wifi_prov_mgr_wait();
}
extern "C" {
    #[doc = " @brief   Disable auto stopping of provisioning service upon completion\n\n By default, once provisioning is complete, the provisioning service is automatically\n stopped, and all endpoints (along with those registered by main application) are\n deactivated.\n\n This API is useful in the case when main application wishes to close provisioning service\n only after it receives some protocomm command from the client side app. For example, after\n connecting to Wi-Fi, the device may want to connect to the cloud, and only once that is\n successfully, the device is said to be fully configured. But, then it is upto the main\n application to explicitly call wifi_prov_mgr_stop_provisioning() later when the device is\n fully configured and the provisioning service is no longer required.\n\n @note    This must be called before executing wifi_prov_mgr_start_provisioning()\n\n @param[in] cleanup_delay Sets the delay after which the actual cleanup of transport related\n                          resources is done after a call to wifi_prov_mgr_stop_provisioning()\n                          returns. Minimum allowed value is 100ms. If not specified, this will\n                          default to 1000ms.\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_INVALID_STATE : Manager not initialized or\n                            provisioning service already started"]
    pub fn wifi_prov_mgr_disable_auto_stop(cleanup_delay: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set application version and capabilities in the JSON data returned by\n          proto-ver endpoint\n\n This function can be called multiple times, to specify information about the various\n application specific services running on the device, identified by unique labels.\n\n The provisioning service itself registers an entry in the JSON data, by the label \"prov\",\n containing only provisioning service version and capabilities. Application services should\n use a label other than \"prov\" so as not to overwrite this.\n\n @note    This must be called before executing wifi_prov_mgr_start_provisioning()\n\n @param[in] label   String indicating the application name.\n\n @param[in] version String indicating the application version.\n                    There is no constraint on format.\n\n @param[in] capabilities  Array of strings with capabilities.\n                          These could be used by the client side app to know\n                          the application registered endpoint capabilities\n\n @param[in] total_capabilities  Size of capabilities array\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_INVALID_STATE : Manager not initialized or\n                            provisioning service already started\n  - ESP_ERR_NO_MEM : Failed to allocate memory for version string\n  - ESP_ERR_INVALID_ARG : Null argument"]
    pub fn wifi_prov_mgr_set_app_info(
        label: *const ::core::ffi::c_char,
        version: *const ::core::ffi::c_char,
        capabilities: *mut *const ::core::ffi::c_char,
        total_capabilities: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Create an additional endpoint and allocate internal resources for it\n\n This API is to be called by the application if it wants to create an additional\n endpoint. All additional endpoints will be assigned UUIDs starting from 0xFF54\n and so on in the order of execution.\n\n protocomm handler for the created endpoint is to be registered later using\n wifi_prov_mgr_endpoint_register() after provisioning has started.\n\n @note    This API can only be called BEFORE provisioning is started\n\n @note    Additional endpoints can be used for configuring client provided\n          parameters other than Wi-Fi credentials, that are necessary for the\n          main application and hence must be set prior to starting the application\n\n @note    After session establishment, the additional endpoints must be targeted\n          first by the client side application before sending Wi-Fi configuration,\n          because once Wi-Fi configuration finishes the provisioning service is\n          stopped and hence all endpoints are unregistered\n\n @param[in] ep_name  unique name of the endpoint\n\n @return\n  - ESP_OK      : Success\n  - ESP_FAIL    : Failure"]
    pub fn wifi_prov_mgr_endpoint_create(ep_name: *const ::core::ffi::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register a handler for the previously created endpoint\n\n This API can be called by the application to register a protocomm handler\n to any endpoint that was created using wifi_prov_mgr_endpoint_create().\n\n @note    This API can only be called AFTER provisioning has started\n\n @note    Additional endpoints can be used for configuring client provided\n          parameters other than Wi-Fi credentials, that are necessary for the\n          main application and hence must be set prior to starting the application\n\n @note    After session establishment, the additional endpoints must be targeted\n          first by the client side application before sending Wi-Fi configuration,\n          because once Wi-Fi configuration finishes the provisioning service is\n          stopped and hence all endpoints are unregistered\n\n @param[in] ep_name   Name of the endpoint\n @param[in] handler   Endpoint handler function\n @param[in] user_ctx  User data\n\n @return\n  - ESP_OK      : Success\n  - ESP_FAIL    : Failure"]
    pub fn wifi_prov_mgr_endpoint_register(
        ep_name: *const ::core::ffi::c_char,
        handler: protocomm_req_handler_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Unregister the handler for an endpoint\n\n This API can be called if the application wants to selectively\n unregister the handler of an endpoint while the provisioning\n is still in progress.\n\n All the endpoint handlers are unregistered automatically when\n the provisioning stops.\n\n @param[in] ep_name  Name of the endpoint"]
    pub fn wifi_prov_mgr_endpoint_unregister(ep_name: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief   Get state of Wi-Fi Station during provisioning\n\n @param[out] state    Pointer to wifi_prov_sta_state_t\n                      variable to be filled\n\n @return\n  - ESP_OK    : Successfully retrieved Wi-Fi state\n  - ESP_FAIL  : Provisioning app not running"]
    pub fn wifi_prov_mgr_get_wifi_state(state: *mut wifi_prov_sta_state_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get reason code in case of Wi-Fi station\n          disconnection during provisioning\n\n @param[out] reason    Pointer to wifi_prov_sta_fail_reason_t\n                       variable to be filled\n\n @return\n  - ESP_OK    : Successfully retrieved Wi-Fi disconnect reason\n  - ESP_FAIL  : Provisioning app not running"]
    pub fn wifi_prov_mgr_get_wifi_disconnect_reason(
        reason: *mut wifi_prov_sta_fail_reason_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Runs Wi-Fi as Station with the supplied configuration\n\n Configures the Wi-Fi station mode to connect to the AP with\n SSID and password specified in config structure and sets\n Wi-Fi to run as station.\n\n This is automatically called by provisioning service upon\n receiving new credentials.\n\n If credentials are to be supplied to the manager via a\n different mode other than through protocomm, then this\n API needs to be called.\n\n Event WIFI_PROV_CRED_RECV is emitted after credentials have\n been applied and Wi-Fi station started\n\n @param[in] wifi_cfg  Pointer to Wi-Fi configuration structure\n\n @return\n  - ESP_OK      : Wi-Fi configured and started successfully\n  - ESP_FAIL    : Failed to set configuration"]
    pub fn wifi_prov_mgr_configure_sta(wifi_cfg: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Reset Wi-Fi provisioning config\n\n Calling this API will restore WiFi stack persistent settings to default values.\n\n @return\n  - ESP_OK      : Reset provisioning config successfully\n  - ESP_FAIL    : Failed to reset provisioning config"]
    pub fn wifi_prov_mgr_reset_provisioning() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Reset internal state machine and clear provisioned credentials.\n\n This API can be used to restart provisioning in case invalid credentials are entered.\n\n @return\n  - ESP_OK      : Reset provisioning state machine successfully\n  - ESP_FAIL    : Failed to reset provisioning state machine\n  - ESP_ERR_INVALID_STATE : Manager not initialized"]
    pub fn wifi_prov_mgr_reset_sm_state_on_failure() -> esp_err_t;
}
#[doc = " @brief   This structure maps handler required by protocomm layer to\n          UUIDs which are used to uniquely identify BLE characteristics\n          from a smartphone or a similar client device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct name_uuid {
    #[doc = " Name of the handler, which is passed to protocomm layer"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " UUID to be assigned to the BLE characteristic which is\n mapped to the handler"]
    pub uuid: u16,
}
impl Default for name_uuid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   This structure maps handler required by protocomm layer to\n          UUIDs which are used to uniquely identify BLE characteristics\n          from a smartphone or a similar client device."]
pub type protocomm_ble_name_uuid_t = name_uuid;
#[doc = " @brief   Config parameters for protocomm BLE service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protocomm_ble_config {
    #[doc = " BLE device name being broadcast at the time of provisioning"]
    pub device_name: [::core::ffi::c_char; 30usize],
    #[doc = " 128 bit UUID of the provisioning service"]
    pub service_uuid: [u8; 16usize],
    #[doc = " BLE device manufacturer data pointer in advertisement"]
    pub manufacturer_data: *mut u8,
    #[doc = " BLE device manufacturer data length in advertisement"]
    pub manufacturer_data_len: isize,
    #[doc = " Number of entries in the Name-UUID lookup table"]
    pub nu_lookup_count: isize,
    #[doc = " Pointer to the Name-UUID lookup table"]
    pub nu_lookup: *mut protocomm_ble_name_uuid_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for protocomm_ble_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl protocomm_ble_config {
    #[inline]
    pub fn ble_bonding(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ble_bonding(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ble_sm_sc(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ble_sm_sc(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ble_link_encryption(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ble_link_encryption(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ble_bonding: ::core::ffi::c_uint,
        ble_sm_sc: ::core::ffi::c_uint,
        ble_link_encryption: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ble_bonding: u32 = unsafe { ::core::mem::transmute(ble_bonding) };
            ble_bonding as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ble_sm_sc: u32 = unsafe { ::core::mem::transmute(ble_sm_sc) };
            ble_sm_sc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ble_link_encryption: u32 = unsafe { ::core::mem::transmute(ble_link_encryption) };
            ble_link_encryption as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief   Config parameters for protocomm BLE service"]
pub type protocomm_ble_config_t = protocomm_ble_config;
extern "C" {
    #[doc = " @brief   Start Bluetooth Low Energy based transport layer for provisioning\n\n Initialize and start required BLE service for provisioning. This includes\n the initialization for characteristics/service for BLE.\n\n @param[in] pc        Protocomm instance pointer obtained from protocomm_new()\n @param[in] config    Pointer to config structure for initializing BLE\n\n @return\n  - ESP_OK : Success\n  - ESP_FAIL : Simple BLE start error\n  - ESP_ERR_NO_MEM : Error allocating memory for internal resources\n  - ESP_ERR_INVALID_STATE : Error in ble config\n  - ESP_ERR_INVALID_ARG : Null arguments"]
    pub fn protocomm_ble_start(
        pc: *mut protocomm_t,
        config: *const protocomm_ble_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop Bluetooth Low Energy based transport layer for provisioning\n\n Stops service/task responsible for BLE based interactions for provisioning\n\n @note    You might want to optionally reclaim memory from Bluetooth.\n          Refer to the documentation of `esp_bt_mem_release` in that case.\n\n @param[in] pc    Same protocomm instance that was passed to protocomm_ble_start()\n\n @return\n  - ESP_OK : Success\n  - ESP_FAIL : Simple BLE stop error\n  - ESP_ERR_INVALID_ARG : Null / incorrect protocomm instance"]
    pub fn protocomm_ble_stop(pc: *mut protocomm_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Scheme that can be used by manager for provisioning\n          over BLE transport with GATT server"]
    pub static wifi_prov_scheme_ble: wifi_prov_scheme_t;
}
extern "C" {
    pub fn wifi_prov_scheme_ble_event_cb_free_btdm(
        user_data: *mut ::core::ffi::c_void,
        event: wifi_prov_cb_event_t,
        event_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn wifi_prov_scheme_ble_event_cb_free_ble(
        user_data: *mut ::core::ffi::c_void,
        event: wifi_prov_cb_event_t,
        event_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn wifi_prov_scheme_ble_event_cb_free_bt(
        user_data: *mut ::core::ffi::c_void,
        event: wifi_prov_cb_event_t,
        event_data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief   Set the 128 bit GATT service UUID used for provisioning\n\n This API is used to override the default 128 bit provisioning\n service UUID, which is 0000ffff-0000-1000-8000-00805f9b34fb.\n\n This must be called before starting provisioning, i.e. before\n making a call to wifi_prov_mgr_start_provisioning(), otherwise\n the default UUID will be used.\n\n @note    The data being pointed to by the argument must be valid\n          atleast till provisioning is started. Upon start, the\n          manager will store an internal copy of this UUID, and\n          this data can be freed or invalidated afterwords.\n\n @param[in] uuid128  A custom 128 bit UUID\n\n @return\n  - ESP_OK              : Success\n  - ESP_ERR_INVALID_ARG : Null argument"]
    pub fn wifi_prov_scheme_ble_set_service_uuid(uuid128: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set manufacturer specific data in scan response\n\n This must be called before starting provisioning, i.e. before\n making a call to wifi_prov_mgr_start_provisioning().\n\n @note    It is important to understand that length of custom manufacturer\n          data should be within limits. The manufacturer data goes into scan\n          response along with BLE device name. By default, BLE device name\n          length is of 11 Bytes, however it can vary as per application use\n          case. So, one has to honour the scan response data size limits i.e.\n          (mfg_data_len + 2) < 31 - (device_name_length + 2 ). If the\n          mfg_data length exceeds this limit, the length will be truncated.\n\n @param[in] mfg_data      Custom manufacturer data\n @param[in] mfg_data_len  Manufacturer data length\n\n @return\n  - ESP_OK              : Success\n  - ESP_ERR_INVALID_ARG : Null argument"]
    pub fn wifi_prov_scheme_ble_set_mfg_data(mfg_data: *mut u8, mfg_data_len: isize) -> esp_err_t;
}
#[doc = " @brief   Config parameters for protocomm HTTP server"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct protocomm_http_server_config_t {
    #[doc = "< Port on which the HTTP server will listen"]
    pub port: u16,
    #[doc = " Stack size of server task, adjusted depending\n upon stack usage of endpoint handler"]
    pub stack_size: usize,
    #[doc = "< Priority of server task"]
    pub task_priority: ::core::ffi::c_uint,
}
#[doc = " Protocomm HTTPD Configuration Data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union protocomm_httpd_config_data_t {
    #[doc = " HTTP Server Handle, if ext_handle_provided is set to true"]
    pub handle: *mut ::core::ffi::c_void,
    #[doc = " HTTP Server Configuration, if a server is not already active"]
    pub config: protocomm_http_server_config_t,
}
impl Default for protocomm_httpd_config_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Config parameters for protocomm HTTP server"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct protocomm_httpd_config_t {
    #[doc = " Flag to indicate of an external HTTP Server Handle has been provided.\n In such as case, protocomm will use the same HTTP Server and not start\n a new one internally."]
    pub ext_handle_provided: bool,
    #[doc = " Protocomm HTTPD Configuration Data"]
    pub data: protocomm_httpd_config_data_t,
}
impl Default for protocomm_httpd_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Start HTTPD protocomm transport\n\n This API internally creates a framework to allow endpoint registration and security\n configuration for the protocomm.\n\n @note    This is a singleton. ie. Protocomm can have multiple instances, but only\n          one instance can be bound to an HTTP transport layer.\n\n @param[in] pc        Protocomm instance pointer obtained from protocomm_new()\n @param[in] config    Pointer to config structure for initializing HTTP server\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_INVALID_ARG : Null arguments\n  - ESP_ERR_NOT_SUPPORTED : Transport layer bound to another protocomm instance\n  - ESP_ERR_INVALID_STATE : Transport layer already bound to this protocomm instance\n  - ESP_ERR_NO_MEM : Memory allocation for server resource failed\n  - ESP_ERR_HTTPD_* : HTTP server error on start"]
    pub fn protocomm_httpd_start(
        pc: *mut protocomm_t,
        config: *const protocomm_httpd_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop HTTPD protocomm transport\n\n This API cleans up the HTTPD transport protocomm and frees all the handlers registered\n with the protocomm.\n\n @param[in] pc    Same protocomm instance that was passed to protocomm_httpd_start()\n\n @return\n  - ESP_OK : Success\n  - ESP_ERR_INVALID_ARG : Null / incorrect protocomm instance pointer"]
    pub fn protocomm_httpd_stop(pc: *mut protocomm_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Scheme that can be used by manager for provisioning\n          over SoftAP transport with HTTP server"]
    pub static wifi_prov_scheme_softap: wifi_prov_scheme_t;
}
extern "C" {
    #[doc = " @brief Provide HTTPD Server handle externally.\n\n Useful in cases wherein applications need the webserver for some\n different operations, and do not want the wifi provisioning component\n to start/stop a new instance.\n\n @note This API should be called before wifi_prov_mgr_start_provisioning()\n\n @param[in] handle Handle to HTTPD server instance"]
    pub fn wifi_prov_scheme_softap_set_httpd_handle(handle: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_dev_s {
    pub bt_select: u32,
    pub out: gpio_dev_s__bindgen_ty_1,
    pub out_w1ts: gpio_dev_s__bindgen_ty_2,
    pub out_w1tc: gpio_dev_s__bindgen_ty_3,
    pub reserved_10: u32,
    pub reserved_14: u32,
    pub reserved_18: u32,
    pub sdio_select: gpio_dev_s__bindgen_ty_4,
    pub enable: gpio_dev_s__bindgen_ty_5,
    pub enable_w1ts: gpio_dev_s__bindgen_ty_6,
    pub enable_w1tc: gpio_dev_s__bindgen_ty_7,
    pub reserved_2c: u32,
    pub reserved_30: u32,
    pub reserved_34: u32,
    pub strap: gpio_dev_s__bindgen_ty_8,
    pub in_: gpio_dev_s__bindgen_ty_9,
    pub reserved_40: u32,
    pub status: gpio_dev_s__bindgen_ty_10,
    pub status_w1ts: gpio_dev_s__bindgen_ty_11,
    pub status_w1tc: gpio_dev_s__bindgen_ty_12,
    pub reserved_50: u32,
    pub reserved_54: u32,
    pub reserved_58: u32,
    pub pcpu_int: gpio_dev_s__bindgen_ty_13,
    pub pcpu_nmi_int: gpio_dev_s__bindgen_ty_14,
    pub cpusdio_int: gpio_dev_s__bindgen_ty_15,
    pub reserved_68: u32,
    pub reserved_6c: u32,
    pub reserved_70: u32,
    pub pin: [gpio_dev_s__bindgen_ty_16; 26usize],
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub reserved_fc: u32,
    pub reserved_100: u32,
    pub reserved_104: u32,
    pub reserved_108: u32,
    pub reserved_10c: u32,
    pub reserved_110: u32,
    pub reserved_114: u32,
    pub reserved_118: u32,
    pub reserved_11c: u32,
    pub reserved_120: u32,
    pub reserved_124: u32,
    pub reserved_128: u32,
    pub reserved_12c: u32,
    pub reserved_130: u32,
    pub reserved_134: u32,
    pub reserved_138: u32,
    pub reserved_13c: u32,
    pub reserved_140: u32,
    pub reserved_144: u32,
    pub reserved_148: u32,
    pub status_next: gpio_dev_s__bindgen_ty_17,
    pub reserved_150: u32,
    pub func_in_sel_cfg: [gpio_dev_s__bindgen_ty_18; 128usize],
    pub reserved_354: u32,
    pub reserved_358: u32,
    pub reserved_35c: u32,
    pub reserved_360: u32,
    pub reserved_364: u32,
    pub reserved_368: u32,
    pub reserved_36c: u32,
    pub reserved_370: u32,
    pub reserved_374: u32,
    pub reserved_378: u32,
    pub reserved_37c: u32,
    pub reserved_380: u32,
    pub reserved_384: u32,
    pub reserved_388: u32,
    pub reserved_38c: u32,
    pub reserved_390: u32,
    pub reserved_394: u32,
    pub reserved_398: u32,
    pub reserved_39c: u32,
    pub reserved_3a0: u32,
    pub reserved_3a4: u32,
    pub reserved_3a8: u32,
    pub reserved_3ac: u32,
    pub reserved_3b0: u32,
    pub reserved_3b4: u32,
    pub reserved_3b8: u32,
    pub reserved_3bc: u32,
    pub reserved_3c0: u32,
    pub reserved_3c4: u32,
    pub reserved_3c8: u32,
    pub reserved_3cc: u32,
    pub reserved_3d0: u32,
    pub reserved_3d4: u32,
    pub reserved_3d8: u32,
    pub reserved_3dc: u32,
    pub reserved_3e0: u32,
    pub reserved_3e4: u32,
    pub reserved_3e8: u32,
    pub reserved_3ec: u32,
    pub reserved_3f0: u32,
    pub reserved_3f4: u32,
    pub reserved_3f8: u32,
    pub reserved_3fc: u32,
    pub reserved_400: u32,
    pub reserved_404: u32,
    pub reserved_408: u32,
    pub reserved_40c: u32,
    pub reserved_410: u32,
    pub reserved_414: u32,
    pub reserved_418: u32,
    pub reserved_41c: u32,
    pub reserved_420: u32,
    pub reserved_424: u32,
    pub reserved_428: u32,
    pub reserved_42c: u32,
    pub reserved_430: u32,
    pub reserved_434: u32,
    pub reserved_438: u32,
    pub reserved_43c: u32,
    pub reserved_440: u32,
    pub reserved_444: u32,
    pub reserved_448: u32,
    pub reserved_44c: u32,
    pub reserved_450: u32,
    pub reserved_454: u32,
    pub reserved_458: u32,
    pub reserved_45c: u32,
    pub reserved_460: u32,
    pub reserved_464: u32,
    pub reserved_468: u32,
    pub reserved_46c: u32,
    pub reserved_470: u32,
    pub reserved_474: u32,
    pub reserved_478: u32,
    pub reserved_47c: u32,
    pub reserved_480: u32,
    pub reserved_484: u32,
    pub reserved_488: u32,
    pub reserved_48c: u32,
    pub reserved_490: u32,
    pub reserved_494: u32,
    pub reserved_498: u32,
    pub reserved_49c: u32,
    pub reserved_4a0: u32,
    pub reserved_4a4: u32,
    pub reserved_4a8: u32,
    pub reserved_4ac: u32,
    pub reserved_4b0: u32,
    pub reserved_4b4: u32,
    pub reserved_4b8: u32,
    pub reserved_4bc: u32,
    pub reserved_4c0: u32,
    pub reserved_4c4: u32,
    pub reserved_4c8: u32,
    pub reserved_4cc: u32,
    pub reserved_4d0: u32,
    pub reserved_4d4: u32,
    pub reserved_4d8: u32,
    pub reserved_4dc: u32,
    pub reserved_4e0: u32,
    pub reserved_4e4: u32,
    pub reserved_4e8: u32,
    pub reserved_4ec: u32,
    pub reserved_4f0: u32,
    pub reserved_4f4: u32,
    pub reserved_4f8: u32,
    pub reserved_4fc: u32,
    pub reserved_500: u32,
    pub reserved_504: u32,
    pub reserved_508: u32,
    pub reserved_50c: u32,
    pub reserved_510: u32,
    pub reserved_514: u32,
    pub reserved_518: u32,
    pub reserved_51c: u32,
    pub reserved_520: u32,
    pub reserved_524: u32,
    pub reserved_528: u32,
    pub reserved_52c: u32,
    pub reserved_530: u32,
    pub reserved_534: u32,
    pub reserved_538: u32,
    pub reserved_53c: u32,
    pub reserved_540: u32,
    pub reserved_544: u32,
    pub reserved_548: u32,
    pub reserved_54c: u32,
    pub reserved_550: u32,
    pub func_out_sel_cfg: [gpio_dev_s__bindgen_ty_19; 26usize],
    pub reserved_5bc: u32,
    pub reserved_5c0: u32,
    pub reserved_5c4: u32,
    pub reserved_5c8: u32,
    pub reserved_5cc: u32,
    pub reserved_5d0: u32,
    pub reserved_5d4: u32,
    pub reserved_5d8: u32,
    pub reserved_5dc: u32,
    pub reserved_5e0: u32,
    pub reserved_5e4: u32,
    pub reserved_5e8: u32,
    pub reserved_5ec: u32,
    pub reserved_5f0: u32,
    pub reserved_5f4: u32,
    pub reserved_5f8: u32,
    pub reserved_5fc: u32,
    pub reserved_600: u32,
    pub reserved_604: u32,
    pub reserved_608: u32,
    pub reserved_60c: u32,
    pub reserved_610: u32,
    pub reserved_614: u32,
    pub reserved_618: u32,
    pub reserved_61c: u32,
    pub reserved_620: u32,
    pub reserved_624: u32,
    pub reserved_628: u32,
    pub clock_gate: gpio_dev_s__bindgen_ty_20,
    pub reserved_630: u32,
    pub reserved_634: u32,
    pub reserved_638: u32,
    pub reserved_63c: u32,
    pub reserved_640: u32,
    pub reserved_644: u32,
    pub reserved_648: u32,
    pub reserved_64c: u32,
    pub reserved_650: u32,
    pub reserved_654: u32,
    pub reserved_658: u32,
    pub reserved_65c: u32,
    pub reserved_660: u32,
    pub reserved_664: u32,
    pub reserved_668: u32,
    pub reserved_66c: u32,
    pub reserved_670: u32,
    pub reserved_674: u32,
    pub reserved_678: u32,
    pub reserved_67c: u32,
    pub reserved_680: u32,
    pub reserved_684: u32,
    pub reserved_688: u32,
    pub reserved_68c: u32,
    pub reserved_690: u32,
    pub reserved_694: u32,
    pub reserved_698: u32,
    pub reserved_69c: u32,
    pub reserved_6a0: u32,
    pub reserved_6a4: u32,
    pub reserved_6a8: u32,
    pub reserved_6ac: u32,
    pub reserved_6b0: u32,
    pub reserved_6b4: u32,
    pub reserved_6b8: u32,
    pub reserved_6bc: u32,
    pub reserved_6c0: u32,
    pub reserved_6c4: u32,
    pub reserved_6c8: u32,
    pub reserved_6cc: u32,
    pub reserved_6d0: u32,
    pub reserved_6d4: u32,
    pub reserved_6d8: u32,
    pub reserved_6dc: u32,
    pub reserved_6e0: u32,
    pub reserved_6e4: u32,
    pub reserved_6e8: u32,
    pub reserved_6ec: u32,
    pub reserved_6f0: u32,
    pub reserved_6f4: u32,
    pub reserved_6f8: u32,
    pub date: gpio_dev_s__bindgen_ty_21,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn out_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_out_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(out_w1ts: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let out_w1ts: u32 = unsafe { ::core::mem::transmute(out_w1ts) };
            out_w1ts as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn out_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_out_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(out_w1tc: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let out_w1tc: u32 = unsafe { ::core::mem::transmute(out_w1tc) };
            out_w1tc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn enable_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_enable_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_w1ts: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let enable_w1ts: u32 = unsafe { ::core::mem::transmute(enable_w1ts) };
            enable_w1ts as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn enable_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_enable_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_w1tc: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let enable_w1tc: u32 = unsafe { ::core::mem::transmute(enable_w1tc) };
            enable_w1tc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(strapping: u32, reserved16: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::core::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr_st: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn status_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_status_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status_w1ts: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let status_w1ts: u32 = unsafe { ::core::mem::transmute(status_w1ts) };
            status_w1ts as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn status_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_status_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status_w1tc: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let status_w1tc: u32 = unsafe { ::core::mem::transmute(status_w1tc) };
            status_w1tc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved26: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn sync2_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sync2_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync1_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sync1_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sync2_bypass: u32,
        pad_driver: u32,
        sync1_bypass: u32,
        reserved5: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sync2_bypass: u32 = unsafe { ::core::mem::transmute(sync2_bypass) };
            sync2_bypass as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let sync1_bypass: u32 = unsafe { ::core::mem::transmute(sync1_bypass) };
            sync1_bypass as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::core::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::core::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr_st_next(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st_next(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st_next: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let intr_st_next: u32 = unsafe { ::core::mem::transmute(intr_st_next) };
            intr_st_next as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::core::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::core::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inv_sel: u32 = unsafe { ::core::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let oen_sel: u32 = unsafe { ::core::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::core::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(clk_en: u32, reserved1: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gpio_dev_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gpio_dev_t = gpio_dev_s;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
extern "C" {
    pub static GPIO_PIN_MUX_REG: [u32; 22usize];
}
extern "C" {
    pub static GPIO_HOLD_MASK: [u32; 22usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_cntl_dev_s {
    pub options0: rtc_cntl_dev_s__bindgen_ty_1,
    pub slp_timer0: u32,
    pub slp_timer1: rtc_cntl_dev_s__bindgen_ty_2,
    pub time_update: rtc_cntl_dev_s__bindgen_ty_3,
    pub time_low0: u32,
    pub time_high0: rtc_cntl_dev_s__bindgen_ty_4,
    pub state0: rtc_cntl_dev_s__bindgen_ty_5,
    pub timer1: rtc_cntl_dev_s__bindgen_ty_6,
    pub timer2: rtc_cntl_dev_s__bindgen_ty_7,
    pub timer3: rtc_cntl_dev_s__bindgen_ty_8,
    pub timer4: rtc_cntl_dev_s__bindgen_ty_9,
    pub timer5: rtc_cntl_dev_s__bindgen_ty_10,
    pub timer6: rtc_cntl_dev_s__bindgen_ty_11,
    pub ana_conf: rtc_cntl_dev_s__bindgen_ty_12,
    pub reset_state: rtc_cntl_dev_s__bindgen_ty_13,
    pub wakeup_state: rtc_cntl_dev_s__bindgen_ty_14,
    pub int_ena: rtc_cntl_dev_s__bindgen_ty_15,
    pub int_raw: rtc_cntl_dev_s__bindgen_ty_16,
    pub int_st: rtc_cntl_dev_s__bindgen_ty_17,
    pub int_clr: rtc_cntl_dev_s__bindgen_ty_18,
    pub store: [u32; 4usize],
    pub ext_xtl_conf: rtc_cntl_dev_s__bindgen_ty_19,
    pub ext_wakeup_conf: rtc_cntl_dev_s__bindgen_ty_20,
    pub slp_reject_conf: rtc_cntl_dev_s__bindgen_ty_21,
    pub cpu_period_conf: rtc_cntl_dev_s__bindgen_ty_22,
    pub clk_conf: rtc_cntl_dev_s__bindgen_ty_23,
    pub slow_clk_conf: rtc_cntl_dev_s__bindgen_ty_24,
    pub sdio_conf: rtc_cntl_dev_s__bindgen_ty_25,
    pub bias_conf: rtc_cntl_dev_s__bindgen_ty_26,
    pub rtc: rtc_cntl_dev_s__bindgen_ty_27,
    pub rtc_pwc: rtc_cntl_dev_s__bindgen_ty_28,
    pub dig_pwc: rtc_cntl_dev_s__bindgen_ty_29,
    pub dig_iso: rtc_cntl_dev_s__bindgen_ty_30,
    pub wdt_config0: rtc_cntl_dev_s__bindgen_ty_31,
    pub wdt_config1: u32,
    pub wdt_config2: u32,
    pub wdt_config3: u32,
    pub wdt_config4: u32,
    pub wdt_feed: rtc_cntl_dev_s__bindgen_ty_32,
    pub wdt_wprotect: u32,
    pub swd_conf: rtc_cntl_dev_s__bindgen_ty_33,
    pub swd_wprotect: u32,
    pub sw_cpu_stall: rtc_cntl_dev_s__bindgen_ty_34,
    pub store4: u32,
    pub store5: u32,
    pub store6: u32,
    pub store7: u32,
    pub low_power_st: rtc_cntl_dev_s__bindgen_ty_35,
    pub diag0: u32,
    pub pad_hold: rtc_cntl_dev_s__bindgen_ty_36,
    pub dig_pad_hold: u32,
    pub brown_out: rtc_cntl_dev_s__bindgen_ty_37,
    pub time_low1: u32,
    pub time_high1: rtc_cntl_dev_s__bindgen_ty_38,
    pub xtal32k_clk_factor: u32,
    pub xtal32k_conf: rtc_cntl_dev_s__bindgen_ty_39,
    pub usb_conf: rtc_cntl_dev_s__bindgen_ty_40,
    pub slp_reject_cause: rtc_cntl_dev_s__bindgen_ty_41,
    pub option1: rtc_cntl_dev_s__bindgen_ty_42,
    pub slp_wakeup_cause: rtc_cntl_dev_s__bindgen_ty_43,
    pub ulp_cp_timer_1: rtc_cntl_dev_s__bindgen_ty_44,
    pub int_ena_w1ts: rtc_cntl_dev_s__bindgen_ty_45,
    pub int_ena_w1tc: rtc_cntl_dev_s__bindgen_ty_46,
    pub retention_ctrl: rtc_cntl_dev_s__bindgen_ty_47,
    pub fib_sel: rtc_cntl_dev_s__bindgen_ty_48,
    pub gpio_wakeup: rtc_cntl_dev_s__bindgen_ty_49,
    pub dbg_sel: rtc_cntl_dev_s__bindgen_ty_50,
    pub dbg_map: rtc_cntl_dev_s__bindgen_ty_51,
    pub sensor_ctrl: rtc_cntl_dev_s__bindgen_ty_52,
    pub dbg_sar_sel: rtc_cntl_dev_s__bindgen_ty_53,
    pub pg_ctrl: rtc_cntl_dev_s__bindgen_ty_54,
    pub reserved_128: u32,
    pub reserved_12c: u32,
    pub reserved_130: u32,
    pub reserved_134: u32,
    pub reserved_138: u32,
    pub reserved_13c: u32,
    pub reserved_140: u32,
    pub reserved_144: u32,
    pub reserved_148: u32,
    pub reserved_14c: u32,
    pub reserved_150: u32,
    pub reserved_154: u32,
    pub reserved_158: u32,
    pub reserved_15c: u32,
    pub reserved_160: u32,
    pub reserved_164: u32,
    pub reserved_168: u32,
    pub reserved_16c: u32,
    pub reserved_170: u32,
    pub reserved_174: u32,
    pub reserved_178: u32,
    pub reserved_17c: u32,
    pub reserved_180: u32,
    pub reserved_184: u32,
    pub reserved_188: u32,
    pub reserved_18c: u32,
    pub reserved_190: u32,
    pub reserved_194: u32,
    pub reserved_198: u32,
    pub reserved_19c: u32,
    pub reserved_1a0: u32,
    pub reserved_1a4: u32,
    pub reserved_1a8: u32,
    pub reserved_1ac: u32,
    pub reserved_1b0: u32,
    pub reserved_1b4: u32,
    pub reserved_1b8: u32,
    pub reserved_1bc: u32,
    pub reserved_1c0: u32,
    pub reserved_1c4: u32,
    pub reserved_1c8: u32,
    pub reserved_1cc: u32,
    pub reserved_1d0: u32,
    pub reserved_1d4: u32,
    pub reserved_1d8: u32,
    pub reserved_1dc: u32,
    pub reserved_1e0: u32,
    pub reserved_1e4: u32,
    pub reserved_1e8: u32,
    pub reserved_1ec: u32,
    pub reserved_1f0: u32,
    pub reserved_1f4: u32,
    pub reserved_1f8: u32,
    pub date: rtc_cntl_dev_s__bindgen_ty_55,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sw_stall_appcpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_appcpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_stall_procpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_procpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_appcpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_appcpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_procpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_procpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_en_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_en_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_norst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_norst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_sys_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_sys_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_stall_appcpu_c0: u32,
        sw_stall_procpu_c0: u32,
        sw_appcpu_rst: u32,
        sw_procpu_rst: u32,
        bb_i2c_force_pd: u32,
        bb_i2c_force_pu: u32,
        bbpll_i2c_force_pd: u32,
        bbpll_i2c_force_pu: u32,
        bbpll_force_pd: u32,
        bbpll_force_pu: u32,
        xtl_force_pd: u32,
        xtl_force_pu: u32,
        xtl_en_wait: u32,
        reserved18: u32,
        ctr_sel: u32,
        xtl_force_iso: u32,
        pll_force_iso: u32,
        analog_force_iso: u32,
        xtl_force_noiso: u32,
        pll_force_noiso: u32,
        analog_force_noiso: u32,
        dg_wrap_force_rst: u32,
        dg_wrap_force_norst: u32,
        sw_sys_rst: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sw_stall_appcpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_appcpu_c0) };
            sw_stall_appcpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let sw_stall_procpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_procpu_c0) };
            sw_stall_procpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sw_appcpu_rst: u32 = unsafe { ::core::mem::transmute(sw_appcpu_rst) };
            sw_appcpu_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sw_procpu_rst: u32 = unsafe { ::core::mem::transmute(sw_procpu_rst) };
            sw_procpu_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bb_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pd) };
            bb_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bb_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pu) };
            bb_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bbpll_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pd) };
            bbpll_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bbpll_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pu) };
            bbpll_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bbpll_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_force_pd) };
            bbpll_force_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bbpll_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_force_pu) };
            bbpll_force_pu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let xtl_force_pd: u32 = unsafe { ::core::mem::transmute(xtl_force_pd) };
            xtl_force_pd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let xtl_force_pu: u32 = unsafe { ::core::mem::transmute(xtl_force_pu) };
            xtl_force_pu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let xtl_en_wait: u32 = unsafe { ::core::mem::transmute(xtl_en_wait) };
            xtl_en_wait as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let ctr_sel: u32 = unsafe { ::core::mem::transmute(ctr_sel) };
            ctr_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let xtl_force_iso: u32 = unsafe { ::core::mem::transmute(xtl_force_iso) };
            xtl_force_iso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let pll_force_iso: u32 = unsafe { ::core::mem::transmute(pll_force_iso) };
            pll_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let analog_force_iso: u32 = unsafe { ::core::mem::transmute(analog_force_iso) };
            analog_force_iso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xtl_force_noiso: u32 = unsafe { ::core::mem::transmute(xtl_force_noiso) };
            xtl_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let pll_force_noiso: u32 = unsafe { ::core::mem::transmute(pll_force_noiso) };
            pll_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let analog_force_noiso: u32 = unsafe { ::core::mem::transmute(analog_force_noiso) };
            analog_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dg_wrap_force_rst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_rst) };
            dg_wrap_force_rst as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_norst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_norst) };
            dg_wrap_force_norst as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sw_sys_rst: u32 = unsafe { ::core::mem::transmute(sw_sys_rst) };
            sw_sys_rst as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn slp_val_hi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_slp_val_hi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn main_timer_alarm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_timer_alarm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_val_hi: u32,
        main_timer_alarm_en: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let slp_val_hi: u32 = unsafe { ::core::mem::transmute(slp_val_hi) };
            slp_val_hi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let main_timer_alarm_en: u32 = unsafe { ::core::mem::transmute(main_timer_alarm_en) };
            main_timer_alarm_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_sys_stall(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_sys_stall(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_xtl_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_xtl_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_sys_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_sys_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        timer_sys_stall: u32,
        timer_xtl_off: u32,
        timer_sys_rst: u32,
        reserved30: u32,
        update: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let timer_sys_stall: u32 = unsafe { ::core::mem::transmute(timer_sys_stall) };
            timer_sys_stall as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let timer_xtl_off: u32 = unsafe { ::core::mem::transmute(timer_xtl_off) };
            timer_xtl_off as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let timer_sys_rst: u32 = unsafe { ::core::mem::transmute(timer_sys_rst) };
            timer_sys_rst as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update: u32 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn rtc_timer_value0_high(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_timer_value0_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_timer_value0_high: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtc_timer_value0_high: u32 =
                unsafe { ::core::mem::transmute(rtc_timer_value0_high) };
            rtc_timer_value0_high as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn rtc_sw_cpu_int(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sw_cpu_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_slp_reject_cause_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_slp_reject_cause_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn apb2rtc_bridge_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apb2rtc_bridge_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_active_ind(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_active_ind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_sw_cpu_int: u32,
        rtc_slp_reject_cause_clr: u32,
        reserved2: u32,
        apb2rtc_bridge_sel: u32,
        reserved23: u32,
        sdio_active_ind: u32,
        slp_wakeup: u32,
        slp_reject: u32,
        sleep_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rtc_sw_cpu_int: u32 = unsafe { ::core::mem::transmute(rtc_sw_cpu_int) };
            rtc_sw_cpu_int as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtc_slp_reject_cause_clr: u32 =
                unsafe { ::core::mem::transmute(rtc_slp_reject_cause_clr) };
            rtc_slp_reject_cause_clr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 20u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let apb2rtc_bridge_sel: u32 = unsafe { ::core::mem::transmute(apb2rtc_bridge_sel) };
            apb2rtc_bridge_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sdio_active_ind: u32 = unsafe { ::core::mem::transmute(sdio_active_ind) };
            sdio_active_ind as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sleep_en: u32 = unsafe { ::core::mem::transmute(sleep_en) };
            sleep_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn cpu_stall_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_stall_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pll_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpu_stall_en: u32,
        cpu_stall_wait: u32,
        ck8m_wait: u32,
        xtl_buf_wait: u32,
        pll_buf_wait: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cpu_stall_en: u32 = unsafe { ::core::mem::transmute(cpu_stall_en) };
            cpu_stall_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let cpu_stall_wait: u32 = unsafe { ::core::mem::transmute(cpu_stall_wait) };
            cpu_stall_wait as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let ck8m_wait: u32 = unsafe { ::core::mem::transmute(ck8m_wait) };
            ck8m_wait as u64
        });
        __bindgen_bitfield_unit.set(14usize, 10u8, {
            let xtl_buf_wait: u32 = unsafe { ::core::mem::transmute(xtl_buf_wait) };
            xtl_buf_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let pll_buf_wait: u32 = unsafe { ::core::mem::transmute(pll_buf_wait) };
            pll_buf_wait as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn min_time_ck8m_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_time_ck8m_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        min_time_ck8m_off: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let min_time_ck8m_off: u32 = unsafe { ::core::mem::transmute(min_time_ck8m_off) };
            min_time_ck8m_off as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn wifi_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_bt_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_bt_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wifi_wait_timer: u32,
        wifi_powerup_timer: u32,
        bt_wait_timer: u32,
        bt_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let wifi_wait_timer: u32 = unsafe { ::core::mem::transmute(wifi_wait_timer) };
            wifi_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let wifi_powerup_timer: u32 = unsafe { ::core::mem::transmute(wifi_powerup_timer) };
            wifi_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let bt_wait_timer: u32 = unsafe { ::core::mem::transmute(bt_wait_timer) };
            bt_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let bt_powerup_timer: u32 = unsafe { ::core::mem::transmute(bt_powerup_timer) };
            bt_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn cpu_top_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpu_top_wait_timer: u32,
        cpu_top_powerup_timer: u32,
        dg_wrap_wait_timer: u32,
        dg_wrap_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let cpu_top_wait_timer: u32 = unsafe { ::core::mem::transmute(cpu_top_wait_timer) };
            cpu_top_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let cpu_top_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(cpu_top_powerup_timer) };
            cpu_top_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let dg_wrap_wait_timer: u32 = unsafe { ::core::mem::transmute(dg_wrap_wait_timer) };
            dg_wrap_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let dg_wrap_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(dg_wrap_powerup_timer) };
            dg_wrap_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn min_slp_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_slp_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        min_slp_val: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let min_slp_val: u32 = unsafe { ::core::mem::transmute(min_slp_val) };
            min_slp_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dg_peri_wait_timer: u32,
        dg_peri_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let dg_peri_wait_timer: u32 = unsafe { ::core::mem::transmute(dg_peri_wait_timer) };
            dg_peri_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let dg_peri_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(dg_peri_powerup_timer) };
            dg_peri_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_reset_por_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_reset_por_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_reset_por_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_reset_por_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_rst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_rst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_cal_slp_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_cal_slp_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pvtmon_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pvtmon_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txrf_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txrf_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfrx_pbus_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rfrx_pbus_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ckgen_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ckgen_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        i2c_reset_por_force_pd: u32,
        i2c_reset_por_force_pu: u32,
        glitch_rst_en: u32,
        reserved21: u32,
        sar_i2c_pu: u32,
        plla_force_pd: u32,
        plla_force_pu: u32,
        bbpll_cal_slp_start: u32,
        pvtmon_pu: u32,
        txrf_i2c_pu: u32,
        rfrx_pbus_pu: u32,
        reserved29: u32,
        ckgen_i2c_pu: u32,
        pll_i2c_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let i2c_reset_por_force_pd: u32 =
                unsafe { ::core::mem::transmute(i2c_reset_por_force_pd) };
            i2c_reset_por_force_pd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let i2c_reset_por_force_pu: u32 =
                unsafe { ::core::mem::transmute(i2c_reset_por_force_pu) };
            i2c_reset_por_force_pu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let glitch_rst_en: u32 = unsafe { ::core::mem::transmute(glitch_rst_en) };
            glitch_rst_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sar_i2c_pu: u32 = unsafe { ::core::mem::transmute(sar_i2c_pu) };
            sar_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let plla_force_pd: u32 = unsafe { ::core::mem::transmute(plla_force_pd) };
            plla_force_pd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let plla_force_pu: u32 = unsafe { ::core::mem::transmute(plla_force_pu) };
            plla_force_pu as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bbpll_cal_slp_start: u32 = unsafe { ::core::mem::transmute(bbpll_cal_slp_start) };
            bbpll_cal_slp_start as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let pvtmon_pu: u32 = unsafe { ::core::mem::transmute(pvtmon_pu) };
            pvtmon_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let txrf_i2c_pu: u32 = unsafe { ::core::mem::transmute(txrf_i2c_pu) };
            txrf_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rfrx_pbus_pu: u32 = unsafe { ::core::mem::transmute(rfrx_pbus_pu) };
            rfrx_pbus_pu as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ckgen_i2c_pu: u32 = unsafe { ::core::mem::transmute(ckgen_i2c_pu) };
            ckgen_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pll_i2c_pu: u32 = unsafe { ::core::mem::transmute(pll_i2c_pu) };
            pll_i2c_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn reset_cause_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_cause_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_vector_sel_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_vector_sel_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_vector_sel_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_vector_sel_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_reset_flag_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_all_reset_flag_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_reset_flag_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_all_reset_flag_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_reset_flag_clr_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_all_reset_flag_clr_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_reset_flag_clr_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_all_reset_flag_clr_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ocd_halt_on_reset_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ocd_halt_on_reset_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ocd_halt_on_reset_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ocd_halt_on_reset_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jtag_reset_flag_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jtag_reset_flag_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jtag_reset_flag_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jtag_reset_flag_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jtag_reset_flag_clr_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jtag_reset_flag_clr_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jtag_reset_flag_clr_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_jtag_reset_flag_clr_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dreset_mask_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dreset_mask_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dreset_mask_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dreset_mask_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset_cause_procpu: u32,
        reset_cause_appcpu: u32,
        stat_vector_sel_appcpu: u32,
        stat_vector_sel_procpu: u32,
        all_reset_flag_procpu: u32,
        all_reset_flag_appcpu: u32,
        all_reset_flag_clr_procpu: u32,
        all_reset_flag_clr_appcpu: u32,
        ocd_halt_on_reset_appcpu: u32,
        ocd_halt_on_reset_procpu: u32,
        jtag_reset_flag_procpu: u32,
        jtag_reset_flag_appcpu: u32,
        jtag_reset_flag_clr_procpu: u32,
        jtag_reset_flag_clr_appcpu: u32,
        rtc_dreset_mask_appcpu: u32,
        rtc_dreset_mask_procpu: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reset_cause_procpu: u32 = unsafe { ::core::mem::transmute(reset_cause_procpu) };
            reset_cause_procpu as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let reset_cause_appcpu: u32 = unsafe { ::core::mem::transmute(reset_cause_appcpu) };
            reset_cause_appcpu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let stat_vector_sel_appcpu: u32 =
                unsafe { ::core::mem::transmute(stat_vector_sel_appcpu) };
            stat_vector_sel_appcpu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let stat_vector_sel_procpu: u32 =
                unsafe { ::core::mem::transmute(stat_vector_sel_procpu) };
            stat_vector_sel_procpu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let all_reset_flag_procpu: u32 =
                unsafe { ::core::mem::transmute(all_reset_flag_procpu) };
            all_reset_flag_procpu as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let all_reset_flag_appcpu: u32 =
                unsafe { ::core::mem::transmute(all_reset_flag_appcpu) };
            all_reset_flag_appcpu as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let all_reset_flag_clr_procpu: u32 =
                unsafe { ::core::mem::transmute(all_reset_flag_clr_procpu) };
            all_reset_flag_clr_procpu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let all_reset_flag_clr_appcpu: u32 =
                unsafe { ::core::mem::transmute(all_reset_flag_clr_appcpu) };
            all_reset_flag_clr_appcpu as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ocd_halt_on_reset_appcpu: u32 =
                unsafe { ::core::mem::transmute(ocd_halt_on_reset_appcpu) };
            ocd_halt_on_reset_appcpu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ocd_halt_on_reset_procpu: u32 =
                unsafe { ::core::mem::transmute(ocd_halt_on_reset_procpu) };
            ocd_halt_on_reset_procpu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let jtag_reset_flag_procpu: u32 =
                unsafe { ::core::mem::transmute(jtag_reset_flag_procpu) };
            jtag_reset_flag_procpu as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let jtag_reset_flag_appcpu: u32 =
                unsafe { ::core::mem::transmute(jtag_reset_flag_appcpu) };
            jtag_reset_flag_appcpu as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let jtag_reset_flag_clr_procpu: u32 =
                unsafe { ::core::mem::transmute(jtag_reset_flag_clr_procpu) };
            jtag_reset_flag_clr_procpu as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let jtag_reset_flag_clr_appcpu: u32 =
                unsafe { ::core::mem::transmute(jtag_reset_flag_clr_appcpu) };
            jtag_reset_flag_clr_appcpu as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rtc_dreset_mask_appcpu: u32 =
                unsafe { ::core::mem::transmute(rtc_dreset_mask_appcpu) };
            rtc_dreset_mask_appcpu as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rtc_dreset_mask_procpu: u32 =
                unsafe { ::core::mem::transmute(rtc_dreset_mask_procpu) };
            rtc_dreset_mask_procpu as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wakeup_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wakeup_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_wakeup_ena: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let rtc_wakeup_ena: u32 = unsafe { ::core::mem::transmute(rtc_wakeup_ena) };
            rtc_wakeup_ena as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        reserved2: u32,
        rtc_wdt: u32,
        reserved4: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved11: u32,
        rtc_swd: u32,
        rtc_xtal32k_dead: u32,
        reserved17: u32,
        rtc_glitch_det: u32,
        rtc_bbpll_cal: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd: u32 = unsafe { ::core::mem::transmute(rtc_swd) };
            rtc_swd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead: u32 = unsafe { ::core::mem::transmute(rtc_xtal32k_dead) };
            rtc_xtal32k_dead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det) };
            rtc_glitch_det as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal) };
            rtc_bbpll_cal as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        reserved2: u32,
        rtc_wdt: u32,
        reserved4: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved11: u32,
        rtc_swd: u32,
        rtc_xtal32k_dead: u32,
        reserved17: u32,
        rtc_glitch_det: u32,
        rtc_bbpll_cal: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd: u32 = unsafe { ::core::mem::transmute(rtc_swd) };
            rtc_swd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead: u32 = unsafe { ::core::mem::transmute(rtc_xtal32k_dead) };
            rtc_xtal32k_dead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det) };
            rtc_glitch_det as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal) };
            rtc_bbpll_cal as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        reserved2: u32,
        rtc_wdt: u32,
        reserved4: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved11: u32,
        rtc_swd: u32,
        rtc_xtal32k_dead: u32,
        reserved17: u32,
        rtc_glitch_det: u32,
        rtc_bbpll_cal: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd: u32 = unsafe { ::core::mem::transmute(rtc_swd) };
            rtc_swd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead: u32 = unsafe { ::core::mem::transmute(rtc_xtal32k_dead) };
            rtc_xtal32k_dead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det) };
            rtc_glitch_det as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal) };
            rtc_bbpll_cal as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        reserved2: u32,
        rtc_wdt: u32,
        reserved4: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved11: u32,
        rtc_swd: u32,
        rtc_xtal32k_dead: u32,
        reserved17: u32,
        rtc_glitch_det: u32,
        rtc_bbpll_cal: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd: u32 = unsafe { ::core::mem::transmute(rtc_swd) };
            rtc_swd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead: u32 = unsafe { ::core::mem::transmute(rtc_xtal32k_dead) };
            rtc_xtal32k_dead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det) };
            rtc_glitch_det as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal) };
            rtc_bbpll_cal as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn xtal32k_wdt_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_wdt_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_wdt_clk_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_wdt_clk_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_wdt_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_wdt_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_ext_clk_fo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_ext_clk_fo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_auto_backup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_auto_backup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_auto_restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_auto_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_auto_return(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_auto_return(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_xpd_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_xpd_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enckinit_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enckinit_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbuf_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dbuf_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dgm_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dgm_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dres_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dres_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dac_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_gpio_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_gpio_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xtal32k_wdt_en: u32,
        xtal32k_wdt_clk_fo: u32,
        xtal32k_wdt_reset: u32,
        xtal32k_ext_clk_fo: u32,
        xtal32k_auto_backup: u32,
        xtal32k_auto_restart: u32,
        xtal32k_auto_return: u32,
        xtal32k_xpd_force: u32,
        enckinit_xtal_32k: u32,
        dbuf_xtal_32k: u32,
        dgm_xtal_32k: u32,
        dres_xtal_32k: u32,
        xpd_xtal_32k: u32,
        dac_xtal_32k: u32,
        rtc_wdt_state: u32,
        rtc_xtal32k_gpio_sel: u32,
        reserved24: u32,
        ctr_lv: u32,
        ctr_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xtal32k_wdt_en: u32 = unsafe { ::core::mem::transmute(xtal32k_wdt_en) };
            xtal32k_wdt_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xtal32k_wdt_clk_fo: u32 = unsafe { ::core::mem::transmute(xtal32k_wdt_clk_fo) };
            xtal32k_wdt_clk_fo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let xtal32k_wdt_reset: u32 = unsafe { ::core::mem::transmute(xtal32k_wdt_reset) };
            xtal32k_wdt_reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let xtal32k_ext_clk_fo: u32 = unsafe { ::core::mem::transmute(xtal32k_ext_clk_fo) };
            xtal32k_ext_clk_fo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let xtal32k_auto_backup: u32 = unsafe { ::core::mem::transmute(xtal32k_auto_backup) };
            xtal32k_auto_backup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let xtal32k_auto_restart: u32 = unsafe { ::core::mem::transmute(xtal32k_auto_restart) };
            xtal32k_auto_restart as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let xtal32k_auto_return: u32 = unsafe { ::core::mem::transmute(xtal32k_auto_return) };
            xtal32k_auto_return as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let xtal32k_xpd_force: u32 = unsafe { ::core::mem::transmute(xtal32k_xpd_force) };
            xtal32k_xpd_force as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enckinit_xtal_32k: u32 = unsafe { ::core::mem::transmute(enckinit_xtal_32k) };
            enckinit_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dbuf_xtal_32k: u32 = unsafe { ::core::mem::transmute(dbuf_xtal_32k) };
            dbuf_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let dgm_xtal_32k: u32 = unsafe { ::core::mem::transmute(dgm_xtal_32k) };
            dgm_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let dres_xtal_32k: u32 = unsafe { ::core::mem::transmute(dres_xtal_32k) };
            dres_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let xpd_xtal_32k: u32 = unsafe { ::core::mem::transmute(xpd_xtal_32k) };
            xpd_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let dac_xtal_32k: u32 = unsafe { ::core::mem::transmute(dac_xtal_32k) };
            dac_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let rtc_wdt_state: u32 = unsafe { ::core::mem::transmute(rtc_wdt_state) };
            rtc_wdt_state as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rtc_xtal32k_gpio_sel: u32 = unsafe { ::core::mem::transmute(rtc_xtal32k_gpio_sel) };
            rtc_xtal32k_gpio_sel as u64
        });
        __bindgen_bitfield_unit.set(24usize, 6u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ctr_lv: u32 = unsafe { ::core::mem::transmute(ctr_lv) };
            ctr_lv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ctr_en: u32 = unsafe { ::core::mem::transmute(ctr_en) };
            ctr_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_wakeup_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_wakeup_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        gpio_wakeup_filter: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let gpio_wakeup_filter: u32 = unsafe { ::core::mem::transmute(gpio_wakeup_filter) };
            gpio_wakeup_filter as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_sleep_reject_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sleep_reject_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn light_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_light_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deep_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deep_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_sleep_reject_ena: u32,
        light_slp_reject_en: u32,
        deep_slp_reject_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 18u8, {
            let rtc_sleep_reject_ena: u32 = unsafe { ::core::mem::transmute(rtc_sleep_reject_ena) };
            rtc_sleep_reject_ena as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let light_slp_reject_en: u32 = unsafe { ::core::mem::transmute(light_slp_reject_en) };
            light_slp_reject_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let deep_slp_reject_en: u32 = unsafe { ::core::mem::transmute(deep_slp_reject_en) };
            deep_slp_reject_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn cpusel_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpusel_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpuperiod_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cpuperiod_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        cpusel_conf: u32,
        cpuperiod_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpusel_conf: u32 = unsafe { ::core::mem::transmute(cpusel_conf) };
            cpusel_conf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cpuperiod_sel: u32 = unsafe { ::core::mem::transmute(cpuperiod_sel) };
            cpuperiod_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn efuse_clk_force_gating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_efuse_clk_force_gating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn efuse_clk_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_efuse_clk_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div_sel_vld(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div_sel_vld(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_xtal32k_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_xtal32k_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_d256_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_d256_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_dfreq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_dfreq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal_global_force_gating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_global_force_gating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal_global_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_global_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fast_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ana_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        efuse_clk_force_gating: u32,
        efuse_clk_force_nogating: u32,
        ck8m_div_sel_vld: u32,
        ck8m_div: u32,
        enb_ck8m: u32,
        enb_ck8m_div: u32,
        dig_xtal32k_en: u32,
        dig_clk8m_d256_en: u32,
        dig_clk8m_en: u32,
        reserved11: u32,
        ck8m_div_sel: u32,
        xtal_force_nogating: u32,
        ck8m_force_nogating: u32,
        ck8m_dfreq: u32,
        ck8m_force_pd: u32,
        ck8m_force_pu: u32,
        xtal_global_force_gating: u32,
        xtal_global_force_nogating: u32,
        fast_clk_rtc_sel: u32,
        ana_clk_rtc_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let efuse_clk_force_gating: u32 =
                unsafe { ::core::mem::transmute(efuse_clk_force_gating) };
            efuse_clk_force_gating as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let efuse_clk_force_nogating: u32 =
                unsafe { ::core::mem::transmute(efuse_clk_force_nogating) };
            efuse_clk_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ck8m_div_sel_vld: u32 = unsafe { ::core::mem::transmute(ck8m_div_sel_vld) };
            ck8m_div_sel_vld as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let ck8m_div: u32 = unsafe { ::core::mem::transmute(ck8m_div) };
            ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enb_ck8m: u32 = unsafe { ::core::mem::transmute(enb_ck8m) };
            enb_ck8m as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enb_ck8m_div: u32 = unsafe { ::core::mem::transmute(enb_ck8m_div) };
            enb_ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_xtal32k_en: u32 = unsafe { ::core::mem::transmute(dig_xtal32k_en) };
            dig_xtal32k_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dig_clk8m_d256_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_d256_en) };
            dig_clk8m_d256_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dig_clk8m_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_en) };
            dig_clk8m_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ck8m_div_sel: u32 = unsafe { ::core::mem::transmute(ck8m_div_sel) };
            ck8m_div_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let xtal_force_nogating: u32 = unsafe { ::core::mem::transmute(xtal_force_nogating) };
            xtal_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ck8m_force_nogating: u32 = unsafe { ::core::mem::transmute(ck8m_force_nogating) };
            ck8m_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let ck8m_dfreq: u32 = unsafe { ::core::mem::transmute(ck8m_dfreq) };
            ck8m_dfreq as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ck8m_force_pd: u32 = unsafe { ::core::mem::transmute(ck8m_force_pd) };
            ck8m_force_pd as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ck8m_force_pu: u32 = unsafe { ::core::mem::transmute(ck8m_force_pu) };
            ck8m_force_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let xtal_global_force_gating: u32 =
                unsafe { ::core::mem::transmute(xtal_global_force_gating) };
            xtal_global_force_gating as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let xtal_global_force_nogating: u32 =
                unsafe { ::core::mem::transmute(xtal_global_force_nogating) };
            xtal_global_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fast_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(fast_clk_rtc_sel) };
            fast_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let ana_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(ana_clk_rtc_sel) };
            ana_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ana_clk_div_vld(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ana_clk_div_vld(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ana_clk_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ana_clk_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_clk_next_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slow_clk_next_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_ana_clk_div_vld: u32,
        rtc_ana_clk_div: u32,
        slow_clk_next_edge: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rtc_ana_clk_div_vld: u32 = unsafe { ::core::mem::transmute(rtc_ana_clk_div_vld) };
            rtc_ana_clk_div_vld as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let rtc_ana_clk_div: u32 = unsafe { ::core::mem::transmute(rtc_ana_clk_div) };
            rtc_ana_clk_div as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let slow_clk_next_edge: u32 = unsafe { ::core::mem::transmute(slow_clk_next_edge) };
            slow_clk_next_edge as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn sdio_timer_target(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_timer_target(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_dthdrv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_dthdrv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_dcap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_dcap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_initi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_initi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_en_initi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_en_initi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_dcurlim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_dcurlim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_modecurlim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_modecurlim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_encurlim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_encurlim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_tieh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_tieh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reg1p8_ready(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg1p8_ready(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drefl_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefl_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefm_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefm_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefh_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefh_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sdio_timer_target: u32,
        reserved8: u32,
        sdio_dthdrv: u32,
        sdio_dcap: u32,
        sdio_initi: u32,
        sdio_en_initi: u32,
        sdio_dcurlim: u32,
        sdio_modecurlim: u32,
        sdio_encurlim: u32,
        sdio_pd_en: u32,
        sdio_force: u32,
        sdio_tieh: u32,
        reg1p8_ready: u32,
        drefl_sdio: u32,
        drefm_sdio: u32,
        drefh_sdio: u32,
        xpd_sdio: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sdio_timer_target: u32 = unsafe { ::core::mem::transmute(sdio_timer_target) };
            sdio_timer_target as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let sdio_dthdrv: u32 = unsafe { ::core::mem::transmute(sdio_dthdrv) };
            sdio_dthdrv as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let sdio_dcap: u32 = unsafe { ::core::mem::transmute(sdio_dcap) };
            sdio_dcap as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let sdio_initi: u32 = unsafe { ::core::mem::transmute(sdio_initi) };
            sdio_initi as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sdio_en_initi: u32 = unsafe { ::core::mem::transmute(sdio_en_initi) };
            sdio_en_initi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let sdio_dcurlim: u32 = unsafe { ::core::mem::transmute(sdio_dcurlim) };
            sdio_dcurlim as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sdio_modecurlim: u32 = unsafe { ::core::mem::transmute(sdio_modecurlim) };
            sdio_modecurlim as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sdio_encurlim: u32 = unsafe { ::core::mem::transmute(sdio_encurlim) };
            sdio_encurlim as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sdio_pd_en: u32 = unsafe { ::core::mem::transmute(sdio_pd_en) };
            sdio_pd_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sdio_force: u32 = unsafe { ::core::mem::transmute(sdio_force) };
            sdio_force as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sdio_tieh: u32 = unsafe { ::core::mem::transmute(sdio_tieh) };
            sdio_tieh as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reg1p8_ready: u32 = unsafe { ::core::mem::transmute(reg1p8_ready) };
            reg1p8_ready as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let drefl_sdio: u32 = unsafe { ::core::mem::transmute(drefl_sdio) };
            drefl_sdio as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let drefm_sdio: u32 = unsafe { ::core::mem::transmute(drefm_sdio) };
            drefm_sdio as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drefh_sdio: u32 = unsafe { ::core::mem::transmute(drefh_sdio) };
            drefh_sdio as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_sdio: u32 = unsafe { ::core::mem::transmute(xpd_sdio) };
            xpd_sdio as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn dg_vdd_drv_b_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dg_vdd_drv_b_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_vdd_drv_b_slp_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_vdd_drv_b_slp_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_buf_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_buf_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_buf_wake(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_buf_wake(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_buf_deep_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_buf_deep_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_buf_monitor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_buf_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur_deep_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur_deep_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_cur_monitor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_cur_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep_deep_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep_deep_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep_monitor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten_deep_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten_deep_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten_monitor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dg_vdd_drv_b_slp: u32,
        dg_vdd_drv_b_slp_en: u32,
        reserved9: u32,
        bias_buf_idle: u32,
        bias_buf_wake: u32,
        bias_buf_deep_slp: u32,
        bias_buf_monitor: u32,
        pd_cur_deep_slp: u32,
        pd_cur_monitor: u32,
        bias_sleep_deep_slp: u32,
        bias_sleep_monitor: u32,
        dbg_atten_deep_slp: u32,
        dbg_atten_monitor: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let dg_vdd_drv_b_slp: u32 = unsafe { ::core::mem::transmute(dg_vdd_drv_b_slp) };
            dg_vdd_drv_b_slp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dg_vdd_drv_b_slp_en: u32 = unsafe { ::core::mem::transmute(dg_vdd_drv_b_slp_en) };
            dg_vdd_drv_b_slp_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bias_buf_idle: u32 = unsafe { ::core::mem::transmute(bias_buf_idle) };
            bias_buf_idle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bias_buf_wake: u32 = unsafe { ::core::mem::transmute(bias_buf_wake) };
            bias_buf_wake as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let bias_buf_deep_slp: u32 = unsafe { ::core::mem::transmute(bias_buf_deep_slp) };
            bias_buf_deep_slp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let bias_buf_monitor: u32 = unsafe { ::core::mem::transmute(bias_buf_monitor) };
            bias_buf_monitor as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let pd_cur_deep_slp: u32 = unsafe { ::core::mem::transmute(pd_cur_deep_slp) };
            pd_cur_deep_slp as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pd_cur_monitor: u32 = unsafe { ::core::mem::transmute(pd_cur_monitor) };
            pd_cur_monitor as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bias_sleep_deep_slp: u32 = unsafe { ::core::mem::transmute(bias_sleep_deep_slp) };
            bias_sleep_deep_slp as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bias_sleep_monitor: u32 = unsafe { ::core::mem::transmute(bias_sleep_monitor) };
            bias_sleep_monitor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 4u8, {
            let dbg_atten_deep_slp: u32 = unsafe { ::core::mem::transmute(dbg_atten_deep_slp) };
            dbg_atten_deep_slp as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let dbg_atten_monitor: u32 = unsafe { ::core::mem::transmute(dbg_atten_monitor) };
            dbg_atten_monitor as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_cal_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_cal_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sck_dcap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sck_dcap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtculator_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtculator_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtculator_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtculator_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_cal_en: u32,
        reserved8: u32,
        sck_dcap: u32,
        reserved22: u32,
        rtc_dboost_force_pd: u32,
        rtc_dboost_force_pu: u32,
        rtculator_force_pd: u32,
        rtculator_force_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dig_cal_en: u32 = unsafe { ::core::mem::transmute(dig_cal_en) };
            dig_cal_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 8u8, {
            let sck_dcap: u32 = unsafe { ::core::mem::transmute(sck_dcap) };
            sck_dcap as u64
        });
        __bindgen_bitfield_unit.set(22usize, 6u8, {
            let reserved22: u32 = unsafe { ::core::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtc_dboost_force_pd: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pd) };
            rtc_dboost_force_pd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rtc_dboost_force_pu: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pu) };
            rtc_dboost_force_pu as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtculator_force_pd: u32 = unsafe { ::core::mem::transmute(rtculator_force_pd) };
            rtculator_force_pd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rtculator_force_pu: u32 = unsafe { ::core::mem::transmute(rtculator_force_pu) };
            rtculator_force_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_pad_force_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_pad_force_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_pad_force_hold: u32,
        reserved22: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rtc_pad_force_hold: u32 = unsafe { ::core::mem::transmute(rtc_pad_force_hold) };
            rtc_pad_force_hold as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved22: u32 = unsafe { ::core::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn vdd_spi_pwr_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vdd_spi_pwr_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vdd_spi_pwr_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vdd_spi_pwr_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vdd_spi_pwr_drv: u32,
        vdd_spi_pwr_force: u32,
        lslp_mem_force_pd: u32,
        lslp_mem_force_pu: u32,
        reserved5: u32,
        bt_force_pd: u32,
        bt_force_pu: u32,
        dg_peri_force_pd: u32,
        dg_peri_force_pu: u32,
        fastmem_force_lpd: u32,
        fastmem_force_lpu: u32,
        wifi_force_pd: u32,
        wifi_force_pu: u32,
        dg_wrap_force_pd: u32,
        dg_wrap_force_pu: u32,
        cpu_top_force_pd: u32,
        cpu_top_force_pu: u32,
        reserved23: u32,
        bt_pd_en: u32,
        dg_peri_pd_en: u32,
        cpu_top_pd_en: u32,
        wifi_pd_en: u32,
        dg_wrap_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let vdd_spi_pwr_drv: u32 = unsafe { ::core::mem::transmute(vdd_spi_pwr_drv) };
            vdd_spi_pwr_drv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let vdd_spi_pwr_force: u32 = unsafe { ::core::mem::transmute(vdd_spi_pwr_force) };
            vdd_spi_pwr_force as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lslp_mem_force_pd: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pd) };
            lslp_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lslp_mem_force_pu: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pu) };
            lslp_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bt_force_pd: u32 = unsafe { ::core::mem::transmute(bt_force_pd) };
            bt_force_pd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let bt_force_pu: u32 = unsafe { ::core::mem::transmute(bt_force_pu) };
            bt_force_pu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dg_peri_force_pd: u32 = unsafe { ::core::mem::transmute(dg_peri_force_pd) };
            dg_peri_force_pd as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dg_peri_force_pu: u32 = unsafe { ::core::mem::transmute(dg_peri_force_pu) };
            dg_peri_force_pu as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fastmem_force_lpd: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpd) };
            fastmem_force_lpd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let fastmem_force_lpu: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpu) };
            fastmem_force_lpu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let wifi_force_pd: u32 = unsafe { ::core::mem::transmute(wifi_force_pd) };
            wifi_force_pd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let wifi_force_pu: u32 = unsafe { ::core::mem::transmute(wifi_force_pu) };
            wifi_force_pu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let dg_wrap_force_pd: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pd) };
            dg_wrap_force_pd as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let dg_wrap_force_pu: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pu) };
            dg_wrap_force_pu as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let cpu_top_force_pd: u32 = unsafe { ::core::mem::transmute(cpu_top_force_pd) };
            cpu_top_force_pd as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let cpu_top_force_pu: u32 = unsafe { ::core::mem::transmute(cpu_top_force_pu) };
            cpu_top_force_pu as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let bt_pd_en: u32 = unsafe { ::core::mem::transmute(bt_pd_en) };
            bt_pd_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let dg_peri_pd_en: u32 = unsafe { ::core::mem::transmute(dg_peri_pd_en) };
            dg_peri_pd_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpu_top_pd_en: u32 = unsafe { ::core::mem::transmute(cpu_top_pd_en) };
            cpu_top_pd_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wifi_pd_en: u32 = unsafe { ::core::mem::transmute(wifi_pd_en) };
            wifi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_pd_en: u32 = unsafe { ::core::mem::transmute(dg_wrap_pd_en) };
            dg_wrap_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clr_dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clr_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_unhold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_unhold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_peri_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_peri_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_top_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_top_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_iso_force_off: u32,
        dig_iso_force_on: u32,
        dg_pad_autohold: u32,
        clr_dg_pad_autohold: u32,
        dg_pad_autohold_en: u32,
        dg_pad_force_noiso: u32,
        dg_pad_force_iso: u32,
        dg_pad_force_unhold: u32,
        dg_pad_force_hold: u32,
        reserved16: u32,
        bt_force_iso: u32,
        bt_force_noiso: u32,
        dg_peri_force_iso: u32,
        dg_peri_force_noiso: u32,
        cpu_top_force_iso: u32,
        cpu_top_force_noiso: u32,
        wifi_force_iso: u32,
        wifi_force_noiso: u32,
        dg_wrap_force_iso: u32,
        dg_wrap_force_noiso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dig_iso_force_off: u32 = unsafe { ::core::mem::transmute(dig_iso_force_off) };
            dig_iso_force_off as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_iso_force_on: u32 = unsafe { ::core::mem::transmute(dig_iso_force_on) };
            dig_iso_force_on as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold) };
            dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clr_dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(clr_dg_pad_autohold) };
            clr_dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dg_pad_autohold_en: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold_en) };
            dg_pad_autohold_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dg_pad_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_noiso) };
            dg_pad_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dg_pad_force_iso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_iso) };
            dg_pad_force_iso as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dg_pad_force_unhold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_unhold) };
            dg_pad_force_unhold as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dg_pad_force_hold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_hold) };
            dg_pad_force_hold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let bt_force_iso: u32 = unsafe { ::core::mem::transmute(bt_force_iso) };
            bt_force_iso as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let bt_force_noiso: u32 = unsafe { ::core::mem::transmute(bt_force_noiso) };
            bt_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dg_peri_force_iso: u32 = unsafe { ::core::mem::transmute(dg_peri_force_iso) };
            dg_peri_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let dg_peri_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_peri_force_noiso) };
            dg_peri_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let cpu_top_force_iso: u32 = unsafe { ::core::mem::transmute(cpu_top_force_iso) };
            cpu_top_force_iso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let cpu_top_force_noiso: u32 = unsafe { ::core::mem::transmute(cpu_top_force_noiso) };
            cpu_top_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wifi_force_iso: u32 = unsafe { ::core::mem::transmute(wifi_force_iso) };
            wifi_force_iso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wifi_force_noiso: u32 = unsafe { ::core::mem::transmute(wifi_force_noiso) };
            wifi_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_iso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_iso) };
            dg_wrap_force_iso as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_noiso) };
            dg_wrap_force_noiso as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_30 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn chip_reset_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_chip_reset_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn chip_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chip_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pause_in_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pause_in_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flashboot_mod_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flashboot_mod_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sys_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sys_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chip_reset_width: u32,
        chip_reset_en: u32,
        pause_in_slp: u32,
        appcpu_reset_en: u32,
        procpu_reset_en: u32,
        flashboot_mod_en: u32,
        sys_reset_length: u32,
        cpu_reset_length: u32,
        stg3: u32,
        stg2: u32,
        stg1: u32,
        stg0: u32,
        en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let chip_reset_width: u32 = unsafe { ::core::mem::transmute(chip_reset_width) };
            chip_reset_width as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let chip_reset_en: u32 = unsafe { ::core::mem::transmute(chip_reset_en) };
            chip_reset_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let pause_in_slp: u32 = unsafe { ::core::mem::transmute(pause_in_slp) };
            pause_in_slp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let appcpu_reset_en: u32 = unsafe { ::core::mem::transmute(appcpu_reset_en) };
            appcpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let procpu_reset_en: u32 = unsafe { ::core::mem::transmute(procpu_reset_en) };
            procpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let flashboot_mod_en: u32 = unsafe { ::core::mem::transmute(flashboot_mod_en) };
            flashboot_mod_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let sys_reset_length: u32 = unsafe { ::core::mem::transmute(sys_reset_length) };
            sys_reset_length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let cpu_reset_length: u32 = unsafe { ::core::mem::transmute(cpu_reset_length) };
            cpu_reset_length as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let stg3: u32 = unsafe { ::core::mem::transmute(stg3) };
            stg3 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let stg2: u32 = unsafe { ::core::mem::transmute(stg2) };
            stg2 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let stg1: u32 = unsafe { ::core::mem::transmute(stg1) };
            stg1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let stg0: u32 = unsafe { ::core::mem::transmute(stg0) };
            stg0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn feed(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_feed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, feed: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let feed: u32 = unsafe { ::core::mem::transmute(feed) };
            feed as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn swd_reset_flag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_reset_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_feed_int(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_feed_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_bypass_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_bypass_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_signal_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_swd_signal_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_rst_flag_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_rst_flag_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_feed(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_feed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn swd_auto_feed_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_swd_auto_feed_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        swd_reset_flag: u32,
        swd_feed_int: u32,
        reserved2: u32,
        swd_bypass_rst: u32,
        swd_signal_width: u32,
        swd_rst_flag_clr: u32,
        swd_feed: u32,
        swd_disable: u32,
        swd_auto_feed_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let swd_reset_flag: u32 = unsafe { ::core::mem::transmute(swd_reset_flag) };
            swd_reset_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let swd_feed_int: u32 = unsafe { ::core::mem::transmute(swd_feed_int) };
            swd_feed_int as u64
        });
        __bindgen_bitfield_unit.set(2usize, 15u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let swd_bypass_rst: u32 = unsafe { ::core::mem::transmute(swd_bypass_rst) };
            swd_bypass_rst as u64
        });
        __bindgen_bitfield_unit.set(18usize, 10u8, {
            let swd_signal_width: u32 = unsafe { ::core::mem::transmute(swd_signal_width) };
            swd_signal_width as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let swd_rst_flag_clr: u32 = unsafe { ::core::mem::transmute(swd_rst_flag_clr) };
            swd_rst_flag_clr as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let swd_feed: u32 = unsafe { ::core::mem::transmute(swd_feed) };
            swd_feed as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let swd_disable: u32 = unsafe { ::core::mem::transmute(swd_disable) };
            swd_disable as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let swd_auto_feed_en: u32 = unsafe { ::core::mem::transmute(swd_auto_feed_en) };
            swd_auto_feed_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        appcpu_c1: u32,
        procpu_c1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 6u8, {
            let appcpu_c1: u32 = unsafe { ::core::mem::transmute(appcpu_c1) };
            appcpu_c1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let procpu_c1: u32 = unsafe { ::core::mem::transmute(procpu_c1) };
            procpu_c1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn xpd_rom0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_rom0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_dig_dcdc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_dig_dcdc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_peri_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_peri_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_rtc_peri(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_rtc_peri(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_wifi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_wifi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_dig(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_dig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch_state_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch_state_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch_state_switch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch_state_switch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch_state_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch_state_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch_state_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch_state_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_cocpu_state_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_cocpu_state_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_cocpu_state_switch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_cocpu_state_switch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_cocpu_state_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_cocpu_state_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_cocpu_state_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_cocpu_state_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_xtal_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_xtal_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_pll_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_pll_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_rdy_for_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_rdy_for_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_wait_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_wait_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_in_wakeup_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_in_wakeup_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_in_low_power_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_in_low_power_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_in_wait_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_in_wait_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_in_wait_pll(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_in_wait_pll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_in_wait_xtl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_in_wait_xtl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_in_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_in_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state_in_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state_in_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xpd_rom0: u32,
        reserved1: u32,
        xpd_dig_dcdc: u32,
        rtc_peri_iso: u32,
        xpd_rtc_peri: u32,
        wifi_iso: u32,
        xpd_wifi: u32,
        dig_iso: u32,
        xpd_dig: u32,
        rtc_touch_state_start: u32,
        rtc_touch_state_switch: u32,
        rtc_touch_state_slp: u32,
        rtc_touch_state_done: u32,
        rtc_cocpu_state_start: u32,
        rtc_cocpu_state_switch: u32,
        rtc_cocpu_state_slp: u32,
        rtc_cocpu_state_done: u32,
        rtc_main_state_xtal_iso: u32,
        rtc_main_state_pll_on: u32,
        rtc_rdy_for_wakeup: u32,
        rtc_main_state_wait_end: u32,
        rtc_in_wakeup_state: u32,
        rtc_in_low_power_state: u32,
        rtc_main_state_in_wait_8m: u32,
        rtc_main_state_in_wait_pll: u32,
        rtc_main_state_in_wait_xtl: u32,
        rtc_main_state_in_slp: u32,
        rtc_main_state_in_idle: u32,
        rtc_main_state: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xpd_rom0: u32 = unsafe { ::core::mem::transmute(xpd_rom0) };
            xpd_rom0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let xpd_dig_dcdc: u32 = unsafe { ::core::mem::transmute(xpd_dig_dcdc) };
            xpd_dig_dcdc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_peri_iso: u32 = unsafe { ::core::mem::transmute(rtc_peri_iso) };
            rtc_peri_iso as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let xpd_rtc_peri: u32 = unsafe { ::core::mem::transmute(xpd_rtc_peri) };
            xpd_rtc_peri as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let wifi_iso: u32 = unsafe { ::core::mem::transmute(wifi_iso) };
            wifi_iso as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let xpd_wifi: u32 = unsafe { ::core::mem::transmute(xpd_wifi) };
            xpd_wifi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dig_iso: u32 = unsafe { ::core::mem::transmute(dig_iso) };
            dig_iso as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let xpd_dig: u32 = unsafe { ::core::mem::transmute(xpd_dig) };
            xpd_dig as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rtc_touch_state_start: u32 =
                unsafe { ::core::mem::transmute(rtc_touch_state_start) };
            rtc_touch_state_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_touch_state_switch: u32 =
                unsafe { ::core::mem::transmute(rtc_touch_state_switch) };
            rtc_touch_state_switch as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rtc_touch_state_slp: u32 = unsafe { ::core::mem::transmute(rtc_touch_state_slp) };
            rtc_touch_state_slp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rtc_touch_state_done: u32 = unsafe { ::core::mem::transmute(rtc_touch_state_done) };
            rtc_touch_state_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rtc_cocpu_state_start: u32 =
                unsafe { ::core::mem::transmute(rtc_cocpu_state_start) };
            rtc_cocpu_state_start as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rtc_cocpu_state_switch: u32 =
                unsafe { ::core::mem::transmute(rtc_cocpu_state_switch) };
            rtc_cocpu_state_switch as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_cocpu_state_slp: u32 = unsafe { ::core::mem::transmute(rtc_cocpu_state_slp) };
            rtc_cocpu_state_slp as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_cocpu_state_done: u32 = unsafe { ::core::mem::transmute(rtc_cocpu_state_done) };
            rtc_cocpu_state_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rtc_main_state_xtal_iso: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_xtal_iso) };
            rtc_main_state_xtal_iso as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rtc_main_state_pll_on: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_pll_on) };
            rtc_main_state_pll_on as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_rdy_for_wakeup: u32 = unsafe { ::core::mem::transmute(rtc_rdy_for_wakeup) };
            rtc_rdy_for_wakeup as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_main_state_wait_end: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_wait_end) };
            rtc_main_state_wait_end as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rtc_in_wakeup_state: u32 = unsafe { ::core::mem::transmute(rtc_in_wakeup_state) };
            rtc_in_wakeup_state as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rtc_in_low_power_state: u32 =
                unsafe { ::core::mem::transmute(rtc_in_low_power_state) };
            rtc_in_low_power_state as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rtc_main_state_in_wait_8m: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_in_wait_8m) };
            rtc_main_state_in_wait_8m as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rtc_main_state_in_wait_pll: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_in_wait_pll) };
            rtc_main_state_in_wait_pll as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rtc_main_state_in_wait_xtl: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_in_wait_xtl) };
            rtc_main_state_in_wait_xtl as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rtc_main_state_in_slp: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_in_slp) };
            rtc_main_state_in_slp as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rtc_main_state_in_idle: u32 =
                unsafe { ::core::mem::transmute(rtc_main_state_in_idle) };
            rtc_main_state_in_idle as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rtc_main_state: u32 = unsafe { ::core::mem::transmute(rtc_main_state) };
            rtc_main_state as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_35 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn rtc_gpio_pin0_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin0_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin1_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin1_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin2_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin2_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin3_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin3_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin4_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin4_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin5_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin5_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_gpio_pin0_hold: u32,
        rtc_gpio_pin1_hold: u32,
        rtc_gpio_pin2_hold: u32,
        rtc_gpio_pin3_hold: u32,
        rtc_gpio_pin4_hold: u32,
        rtc_gpio_pin5_hold: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rtc_gpio_pin0_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin0_hold) };
            rtc_gpio_pin0_hold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtc_gpio_pin1_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin1_hold) };
            rtc_gpio_pin1_hold as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rtc_gpio_pin2_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin2_hold) };
            rtc_gpio_pin2_hold as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_gpio_pin3_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin3_hold) };
            rtc_gpio_pin3_hold as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_gpio_pin4_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin4_hold) };
            rtc_gpio_pin4_hold as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_gpio_pin5_hold: u32 = unsafe { ::core::mem::transmute(rtc_gpio_pin5_hold) };
            rtc_gpio_pin5_hold as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_36 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_int_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn close_flash_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_flash_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_rf_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_rf_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_rst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_rst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        int_wait: u32,
        close_flash_ena: u32,
        pd_rf_ena: u32,
        rst_wait: u32,
        rst_ena: u32,
        rst_sel: u32,
        ana_rst_en: u32,
        cnt_clr: u32,
        ena: u32,
        det: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 10u8, {
            let int_wait: u32 = unsafe { ::core::mem::transmute(int_wait) };
            int_wait as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let close_flash_ena: u32 = unsafe { ::core::mem::transmute(close_flash_ena) };
            close_flash_ena as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pd_rf_ena: u32 = unsafe { ::core::mem::transmute(pd_rf_ena) };
            pd_rf_ena as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let rst_wait: u32 = unsafe { ::core::mem::transmute(rst_wait) };
            rst_wait as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rst_ena: u32 = unsafe { ::core::mem::transmute(rst_ena) };
            rst_ena as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rst_sel: u32 = unsafe { ::core::mem::transmute(rst_sel) };
            rst_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ana_rst_en: u32 = unsafe { ::core::mem::transmute(ana_rst_en) };
            ana_rst_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cnt_clr: u32 = unsafe { ::core::mem::transmute(cnt_clr) };
            cnt_clr as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ena: u32 = unsafe { ::core::mem::transmute(ena) };
            ena as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let det: u32 = unsafe { ::core::mem::transmute(det) };
            det as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_37 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_38 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    #[inline]
    pub fn rtc_timer_value1_high(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_timer_value1_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_timer_value1_high: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtc_timer_value1_high: u32 =
                unsafe { ::core::mem::transmute(rtc_timer_value1_high) };
            rtc_timer_value1_high as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_38 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_39 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_39__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_39__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_39__bindgen_ty_1 {
    #[inline]
    pub fn xtal32k_return_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_return_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_restart_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_restart_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_wdt_timeout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_wdt_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal32k_stable_thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xtal32k_stable_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xtal32k_return_wait: u32,
        xtal32k_restart_wait: u32,
        xtal32k_wdt_timeout: u32,
        xtal32k_stable_thres: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let xtal32k_return_wait: u32 = unsafe { ::core::mem::transmute(xtal32k_return_wait) };
            xtal32k_return_wait as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let xtal32k_restart_wait: u32 = unsafe { ::core::mem::transmute(xtal32k_restart_wait) };
            xtal32k_restart_wait as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let xtal32k_wdt_timeout: u32 = unsafe { ::core::mem::transmute(xtal32k_wdt_timeout) };
            xtal32k_wdt_timeout as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let xtal32k_stable_thres: u32 = unsafe { ::core::mem::transmute(xtal32k_stable_thres) };
            xtal32k_stable_thres as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_39 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_40 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_40__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_40__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_40__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn io_mux_reset_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_mux_reset_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        io_mux_reset_disable: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let io_mux_reset_disable: u32 = unsafe { ::core::mem::transmute(io_mux_reset_disable) };
            io_mux_reset_disable as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_40 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_41 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_41__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_41__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_41__bindgen_ty_1 {
    #[inline]
    pub fn reject_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reject_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reject_cause: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reject_cause: u32 = unsafe { ::core::mem::transmute(reject_cause) };
            reject_cause as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_41 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_42 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_42__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_42__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_42__bindgen_ty_1 {
    #[inline]
    pub fn force_download_boot(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_download_boot(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_download_boot: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_download_boot: u32 = unsafe { ::core::mem::transmute(force_download_boot) };
            force_download_boot as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_42 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_43 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_43__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_43__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_43__bindgen_ty_1 {
    #[inline]
    pub fn wakeup_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wakeup_cause: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 17u8, {
            let wakeup_cause: u32 = unsafe { ::core::mem::transmute(wakeup_cause) };
            wakeup_cause as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_43 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_44 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_44__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_44__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_44__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_timer_slp_cycle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_timer_slp_cycle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ulp_cp_timer_slp_cycle: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let ulp_cp_timer_slp_cycle: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_timer_slp_cycle) };
            ulp_cp_timer_slp_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_44 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_45 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_45__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_45__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_45__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal_w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup_w1ts: u32,
        slp_reject_w1ts: u32,
        reserved2: u32,
        rtc_wdt_w1ts: u32,
        reserved4: u32,
        w1ts: u32,
        rtc_main_timer_w1ts: u32,
        reserved11: u32,
        rtc_swd_w1ts: u32,
        rtc_xtal32k_dead_w1ts: u32,
        reserved17: u32,
        rtc_glitch_det_w1ts: u32,
        rtc_bbpll_cal_w1ts: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup_w1ts: u32 = unsafe { ::core::mem::transmute(slp_wakeup_w1ts) };
            slp_wakeup_w1ts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject_w1ts: u32 = unsafe { ::core::mem::transmute(slp_reject_w1ts) };
            slp_reject_w1ts as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt_w1ts: u32 = unsafe { ::core::mem::transmute(rtc_wdt_w1ts) };
            rtc_wdt_w1ts as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer_w1ts: u32 = unsafe { ::core::mem::transmute(rtc_main_timer_w1ts) };
            rtc_main_timer_w1ts as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd_w1ts: u32 = unsafe { ::core::mem::transmute(rtc_swd_w1ts) };
            rtc_swd_w1ts as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead_w1ts: u32 =
                unsafe { ::core::mem::transmute(rtc_xtal32k_dead_w1ts) };
            rtc_xtal32k_dead_w1ts as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det_w1ts: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det_w1ts) };
            rtc_glitch_det_w1ts as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal_w1ts: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal_w1ts) };
            rtc_bbpll_cal_w1ts as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_45 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_46 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_46__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_46__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_46__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_swd_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_swd_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_xtal32k_dead_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_xtal32k_dead_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_glitch_det_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_glitch_det_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_bbpll_cal_w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_bbpll_cal_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup_w1tc: u32,
        slp_reject_w1tc: u32,
        reserved2: u32,
        rtc_wdt_w1tc: u32,
        reserved4: u32,
        w1tc: u32,
        rtc_main_timer_w1tc: u32,
        reserved11: u32,
        rtc_swd_w1tc: u32,
        rtc_xtal32k_dead_w1tc: u32,
        reserved17: u32,
        rtc_glitch_det_w1tc: u32,
        rtc_bbpll_cal_w1tc: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup_w1tc: u32 = unsafe { ::core::mem::transmute(slp_wakeup_w1tc) };
            slp_wakeup_w1tc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject_w1tc: u32 = unsafe { ::core::mem::transmute(slp_reject_w1tc) };
            slp_reject_w1tc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt_w1tc: u32 = unsafe { ::core::mem::transmute(rtc_wdt_w1tc) };
            rtc_wdt_w1tc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 5u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rtc_main_timer_w1tc: u32 = unsafe { ::core::mem::transmute(rtc_main_timer_w1tc) };
            rtc_main_timer_w1tc as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtc_swd_w1tc: u32 = unsafe { ::core::mem::transmute(rtc_swd_w1tc) };
            rtc_swd_w1tc as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rtc_xtal32k_dead_w1tc: u32 =
                unsafe { ::core::mem::transmute(rtc_xtal32k_dead_w1tc) };
            rtc_xtal32k_dead_w1tc as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rtc_glitch_det_w1tc: u32 = unsafe { ::core::mem::transmute(rtc_glitch_det_w1tc) };
            rtc_glitch_det_w1tc as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rtc_bbpll_cal_w1tc: u32 = unsafe { ::core::mem::transmute(rtc_bbpll_cal_w1tc) };
            rtc_bbpll_cal_w1tc as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_46 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_47 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_47__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_47__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_47__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn retention_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retention_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn retention_done_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_retention_done_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn retention_clkoff_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_retention_clkoff_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn retention_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retention_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn retention_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_retention_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        retention_clk_sel: u32,
        retention_done_wait: u32,
        retention_clkoff_wait: u32,
        retention_en: u32,
        retention_wait: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let retention_clk_sel: u32 = unsafe { ::core::mem::transmute(retention_clk_sel) };
            retention_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let retention_done_wait: u32 = unsafe { ::core::mem::transmute(retention_done_wait) };
            retention_done_wait as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let retention_clkoff_wait: u32 =
                unsafe { ::core::mem::transmute(retention_clkoff_wait) };
            retention_clkoff_wait as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let retention_en: u32 = unsafe { ::core::mem::transmute(retention_en) };
            retention_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let retention_wait: u32 = unsafe { ::core::mem::transmute(retention_wait) };
            retention_wait as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_47 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_48 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_48__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_48__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_48__bindgen_ty_1 {
    #[inline]
    pub fn rtc_fib_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_fib_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rtc_fib_sel: u32, reserved3: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rtc_fib_sel: u32 = unsafe { ::core::mem::transmute(rtc_fib_sel) };
            rtc_fib_sel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_48 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_49 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_49__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_49__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_49__bindgen_ty_1 {
    #[inline]
    pub fn rtc_gpio_wakeup_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_wakeup_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_wakeup_status_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_wakeup_status_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin_clk_gate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin_clk_gate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin5_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin5_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin4_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin4_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin3_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin3_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin2_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin2_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin1_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin1_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin0_int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin0_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin5_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin5_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin4_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin4_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin3_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin3_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin2_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin2_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin1_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin1_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin0_wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin0_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_gpio_wakeup_status: u32,
        rtc_gpio_wakeup_status_clr: u32,
        rtc_gpio_pin_clk_gate: u32,
        rtc_gpio_pin5_int_type: u32,
        rtc_gpio_pin4_int_type: u32,
        rtc_gpio_pin3_int_type: u32,
        rtc_gpio_pin2_int_type: u32,
        rtc_gpio_pin1_int_type: u32,
        rtc_gpio_pin0_int_type: u32,
        rtc_gpio_pin5_wakeup_enable: u32,
        rtc_gpio_pin4_wakeup_enable: u32,
        rtc_gpio_pin3_wakeup_enable: u32,
        rtc_gpio_pin2_wakeup_enable: u32,
        rtc_gpio_pin1_wakeup_enable: u32,
        rtc_gpio_pin0_wakeup_enable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let rtc_gpio_wakeup_status: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_wakeup_status) };
            rtc_gpio_wakeup_status as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_gpio_wakeup_status_clr: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_wakeup_status_clr) };
            rtc_gpio_wakeup_status_clr as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_gpio_pin_clk_gate: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin_clk_gate) };
            rtc_gpio_pin_clk_gate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let rtc_gpio_pin5_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin5_int_type) };
            rtc_gpio_pin5_int_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let rtc_gpio_pin4_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin4_int_type) };
            rtc_gpio_pin4_int_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let rtc_gpio_pin3_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin3_int_type) };
            rtc_gpio_pin3_int_type as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let rtc_gpio_pin2_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin2_int_type) };
            rtc_gpio_pin2_int_type as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let rtc_gpio_pin1_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin1_int_type) };
            rtc_gpio_pin1_int_type as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let rtc_gpio_pin0_int_type: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin0_int_type) };
            rtc_gpio_pin0_int_type as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rtc_gpio_pin5_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin5_wakeup_enable) };
            rtc_gpio_pin5_wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rtc_gpio_pin4_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin4_wakeup_enable) };
            rtc_gpio_pin4_wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtc_gpio_pin3_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin3_wakeup_enable) };
            rtc_gpio_pin3_wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rtc_gpio_pin2_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin2_wakeup_enable) };
            rtc_gpio_pin2_wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtc_gpio_pin1_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin1_wakeup_enable) };
            rtc_gpio_pin1_wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rtc_gpio_pin0_wakeup_enable: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin0_wakeup_enable) };
            rtc_gpio_pin0_wakeup_enable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_49 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_50 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_50__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_50__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_50__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_12m_no_gating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_12m_no_gating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_bit_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_bit_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_sel0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_sel0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_sel1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_sel1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_sel2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_sel2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_sel3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_sel3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_debug_sel4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_debug_sel4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_debug_12m_no_gating: u32,
        rtc_debug_bit_sel: u32,
        rtc_debug_sel0: u32,
        rtc_debug_sel1: u32,
        rtc_debug_sel2: u32,
        rtc_debug_sel3: u32,
        rtc_debug_sel4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtc_debug_12m_no_gating: u32 =
                unsafe { ::core::mem::transmute(rtc_debug_12m_no_gating) };
            rtc_debug_12m_no_gating as u64
        });
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let rtc_debug_bit_sel: u32 = unsafe { ::core::mem::transmute(rtc_debug_bit_sel) };
            rtc_debug_bit_sel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let rtc_debug_sel0: u32 = unsafe { ::core::mem::transmute(rtc_debug_sel0) };
            rtc_debug_sel0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let rtc_debug_sel1: u32 = unsafe { ::core::mem::transmute(rtc_debug_sel1) };
            rtc_debug_sel1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let rtc_debug_sel2: u32 = unsafe { ::core::mem::transmute(rtc_debug_sel2) };
            rtc_debug_sel2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let rtc_debug_sel3: u32 = unsafe { ::core::mem::transmute(rtc_debug_sel3) };
            rtc_debug_sel3 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let rtc_debug_sel4: u32 = unsafe { ::core::mem::transmute(rtc_debug_sel4) };
            rtc_debug_sel4 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_50 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_51 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_51__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_51__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_51__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin5_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin5_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin4_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin4_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin3_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin3_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin2_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin2_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin1_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin1_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin0_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin0_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin5_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin5_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin4_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin4_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin3_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin3_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin2_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin2_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin1_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin1_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_gpio_pin0_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_gpio_pin0_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_gpio_pin5_mux_sel: u32,
        rtc_gpio_pin4_mux_sel: u32,
        rtc_gpio_pin3_mux_sel: u32,
        rtc_gpio_pin2_mux_sel: u32,
        rtc_gpio_pin1_mux_sel: u32,
        rtc_gpio_pin0_mux_sel: u32,
        rtc_gpio_pin5_fun_sel: u32,
        rtc_gpio_pin4_fun_sel: u32,
        rtc_gpio_pin3_fun_sel: u32,
        rtc_gpio_pin2_fun_sel: u32,
        rtc_gpio_pin1_fun_sel: u32,
        rtc_gpio_pin0_fun_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rtc_gpio_pin5_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin5_mux_sel) };
            rtc_gpio_pin5_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_gpio_pin4_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin4_mux_sel) };
            rtc_gpio_pin4_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_gpio_pin3_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin3_mux_sel) };
            rtc_gpio_pin3_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_gpio_pin2_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin2_mux_sel) };
            rtc_gpio_pin2_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_gpio_pin1_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin1_mux_sel) };
            rtc_gpio_pin1_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_gpio_pin0_mux_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin0_mux_sel) };
            rtc_gpio_pin0_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let rtc_gpio_pin5_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin5_fun_sel) };
            rtc_gpio_pin5_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let rtc_gpio_pin4_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin4_fun_sel) };
            rtc_gpio_pin4_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rtc_gpio_pin3_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin3_fun_sel) };
            rtc_gpio_pin3_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let rtc_gpio_pin2_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin2_fun_sel) };
            rtc_gpio_pin2_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let rtc_gpio_pin1_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin1_fun_sel) };
            rtc_gpio_pin1_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rtc_gpio_pin0_fun_sel: u32 =
                unsafe { ::core::mem::transmute(rtc_gpio_pin0_fun_sel) };
            rtc_gpio_pin0_fun_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_51 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_52 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_52__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_52__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_52__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_pwdet_cct(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_pwdet_cct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xpd_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_force_xpd_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sar2_pwdet_cct: u32,
        force_xpd_sar: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let sar2_pwdet_cct: u32 = unsafe { ::core::mem::transmute(sar2_pwdet_cct) };
            sar2_pwdet_cct as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let force_xpd_sar: u32 = unsafe { ::core::mem::transmute(force_xpd_sar) };
            force_xpd_sar as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_52 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_53 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_53__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_53__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_53__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_debug_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sar_debug_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sar_debug_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let sar_debug_sel: u32 = unsafe { ::core::mem::transmute(sar_debug_sel) };
            sar_debug_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_53 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_54 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_54__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_54__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_54__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn power_glitch_dsense(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_power_glitch_dsense(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn power_glitch_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_glitch_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_glitch_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_glitch_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_glitch_efuse_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_glitch_efuse_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_glitch_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_glitch_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        power_glitch_dsense: u32,
        power_glitch_force_pd: u32,
        power_glitch_force_pu: u32,
        power_glitch_efuse_sel: u32,
        power_glitch_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 26u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let power_glitch_dsense: u32 = unsafe { ::core::mem::transmute(power_glitch_dsense) };
            power_glitch_dsense as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let power_glitch_force_pd: u32 =
                unsafe { ::core::mem::transmute(power_glitch_force_pd) };
            power_glitch_force_pd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let power_glitch_force_pu: u32 =
                unsafe { ::core::mem::transmute(power_glitch_force_pu) };
            power_glitch_force_pu as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let power_glitch_efuse_sel: u32 =
                unsafe { ::core::mem::transmute(power_glitch_efuse_sel) };
            power_glitch_efuse_sel as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let power_glitch_en: u32 = unsafe { ::core::mem::transmute(power_glitch_en) };
            power_glitch_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_54 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_55 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_55__bindgen_ty_1,
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_55__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtc_cntl_dev_s__bindgen_ty_55__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_55 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rtc_cntl_dev_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rtc_cntl_dev_t = rtc_cntl_dev_s;
extern "C" {
    pub static mut RTCCNTL: rtc_cntl_dev_t;
}
extern "C" {
    #[doc = " @brief Get the GPIO number of a specific ADC1 channel.\n\n @param channel Channel to get the GPIO number\n @param gpio_num output buffer to hold the GPIO number\n\n @return\n   - ESP_OK if success\n   - ESP_ERR_INVALID_ARG if channel not valid"]
    pub fn adc1_pad_get_io_num(channel: adc1_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the attenuation of a particular channel on ADC1, and configure its associated GPIO pin mux.\n\n The default ADC voltage is for attenuation 0 dB and listed in the table below.\n By setting higher attenuation it is possible to read higher voltages.\n\n Due to ADC characteristics, most accurate results are obtained within the \"suggested range\"\n shown in the following table.\n\n     +----------+-------------+-----------------+\n     |          | attenuation | suggested range |\n     |    SoC   |     (dB)    |      (mV)       |\n     +==========+=============+=================+\n     |          |       0     |    100 ~  950   |\n     |          +-------------+-----------------+\n     |          |       2.5   |    100 ~ 1250   |\n     |   ESP32  +-------------+-----------------+\n     |          |       6     |    150 ~ 1750   |\n     |          +-------------+-----------------+\n     |          |      11     |    150 ~ 2450   |\n     +----------+-------------+-----------------+\n     |          |       0     |      0 ~  750   |\n     |          +-------------+-----------------+\n     |          |       2.5   |      0 ~ 1050   |\n     | ESP32-S2 +-------------+-----------------+\n     |          |       6     |      0 ~ 1300   |\n     |          +-------------+-----------------+\n     |          |      11     |      0 ~ 2500   |\n     +----------+-------------+-----------------+\n\n For maximum accuracy, use the ADC calibration APIs and measure voltages within these recommended ranges.\n\n @note For any given channel, this function must be called before the first time ``adc1_get_raw()`` is called for that channel.\n\n @note This function can be called multiple times to configure multiple\n       ADC channels simultaneously. You may call ``adc1_get_raw()`` only after configuring a channel.\n\n @param channel ADC1 channel to configure\n @param atten  Attenuation level\n\n @return\n     - ESP_OK success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc1_config_channel_atten(channel: adc1_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure ADC1 capture width, meanwhile enable output invert for ADC1.\n        The configuration is for all channels of ADC1\n @param width_bit Bit capture width for ADC1\n\n @return\n     - ESP_OK success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc1_config_width(width_bit: adc_bits_width_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take an ADC1 reading from a single channel.\n @note ESP32:\n       When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,\n       the input of GPIO36 and GPIO39 will be pulled down for about 80ns.\n       When enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.\n       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.\n       As a workaround, call adc_power_acquire() in the app. This will result in higher power consumption (by ~1mA),\n       but will remove the glitches on GPIO36 and GPIO39.\n\n @note Call ``adc1_config_width()`` before the first time this\n       function is called.\n\n @note For any given channel, adc1_config_channel_atten(channel)\n       must be called before the first time this function is called. Configuring\n       a new channel does not prevent a previously configured channel from being read.\n\n @param  channel ADC1 channel to read\n\n @return\n     - -1: Parameter error\n     -  Other: ADC1 channel reading."]
    pub fn adc1_get_raw(channel: adc1_channel_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get the GPIO number of a specific ADC2 channel.\n\n @param channel Channel to get the GPIO number\n\n @param gpio_num output buffer to hold the GPIO number\n\n @return\n   - ESP_OK if success\n   - ESP_ERR_INVALID_ARG if channel not valid"]
    pub fn adc2_pad_get_io_num(channel: adc2_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure the ADC2 channel, including setting attenuation.\n\n The default ADC voltage is for attenuation 0 dB and listed in the table below.\n By setting higher attenuation it is possible to read higher voltages.\n\n Due to ADC characteristics, most accurate results are obtained within the \"suggested range\"\n shown in the following table.\n\n     +----------+-------------+-----------------+\n     |          | attenuation | suggested range |\n     |    SoC   |     (dB)    |      (mV)       |\n     +==========+=============+=================+\n     |          |       0     |    100 ~  950   |\n     |          +-------------+-----------------+\n     |          |       2.5   |    100 ~ 1250   |\n     |   ESP32  +-------------+-----------------+\n     |          |       6     |    150 ~ 1750   |\n     |          +-------------+-----------------+\n     |          |      11     |    150 ~ 2450   |\n     +----------+-------------+-----------------+\n     |          |       0     |      0 ~  750   |\n     |          +-------------+-----------------+\n     |          |       2.5   |      0 ~ 1050   |\n     | ESP32-S2 +-------------+-----------------+\n     |          |       6     |      0 ~ 1300   |\n     |          +-------------+-----------------+\n     |          |      11     |      0 ~ 2500   |\n     +----------+-------------+-----------------+\n\n For maximum accuracy, use the ADC calibration APIs and measure voltages within these recommended ranges.\n\n @note This function also configures the input GPIO pin mux to\n       connect it to the ADC2 channel. It must be called before calling\n       ``adc2_get_raw()`` for this channel.\n\n @note For any given channel, this function must be called before the first time ``adc2_get_raw()`` is called for that channel.\n\n @param channel ADC2 channel to configure\n @param atten  Attenuation level\n\n @return\n     - ESP_OK success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc2_config_channel_atten(channel: adc2_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take an ADC2 reading on a single channel\n\n @note ESP32:\n       When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,\n       the input of GPIO36 and GPIO39 will be pulled down for about 80ns.\n       When enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.\n       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.\n       As a workaround, call adc_power_acquire() in the app. This will result in higher power consumption (by ~1mA),\n       but will remove the glitches on GPIO36 and GPIO39.\n\n\n @note ESP32:\n       For a given channel, ``adc2_config_channel_atten()``\n       must be called before the first time this function is called. If Wi-Fi is started via ``esp_wifi_start()``, this\n       function will always fail with ``ESP_ERR_TIMEOUT``.\n\n @note ESP32-S2:\n       ADC2 support hardware arbiter. The arbiter is to improve the use efficiency of ADC2. After the control right is robbed by the high priority,\n       the low priority controller will read the invalid ADC2 data. Default priority: Wi-Fi > RTC > Digital;\n\n @param channel ADC2 channel to read\n @param width_bit Bit capture width for ADC2\n @param raw_out the variable to hold the output data.\n\n @return\n     - ESP_OK if success\n     - ESP_ERR_TIMEOUT ADC2 is being used by other controller and the request timed out.\n     - ESP_ERR_INVALID_STATE The controller status is invalid. Please try again."]
    pub fn adc2_get_raw(
        channel: adc2_channel_t,
        width_bit: adc_bits_width_t,
        raw_out: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Output ADC1 or ADC2's reference voltage to ``adc2_channe_t``'s IO.\n\n  This function routes the internal reference voltage of ADCn to one of\n  ADC2's channels. This reference voltage can then be manually measured\n  for calibration purposes.\n\n  @note  ESP32 only supports output of ADC2's internal reference voltage.\n  @param[in]  adc_unit ADC unit index\n  @param[in]  gpio     GPIO number (Only ADC2's channels IO are supported)\n\n  @return\n                  - ESP_OK: v_ref successfully routed to selected GPIO\n                  - ESP_ERR_INVALID_ARG: Unsupported GPIO"]
    pub fn adc_vref_to_gpio(adc_unit: adc_unit_t, gpio: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the Digital ADC.\n\n @param init_config Pointer to Digital ADC initilization config. Refer to ``adc_digi_init_config_t``.\n\n @return\n         - ESP_ERR_INVALID_ARG   If the combination of arguments is invalid.\n         - ESP_ERR_NOT_FOUND     No free interrupt found with the specified flags\n         - ESP_ERR_NO_MEM        If out of memory\n         - ESP_OK                On success"]
    pub fn adc_digi_initialize(init_config: *const adc_digi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read bytes from Digital ADC through DMA.\n\n @param[out] buf                 Buffer to read from ADC.\n @param[in]  length_max          Expected length of data read from the ADC.\n @param[out] out_length          Real length of data read from the ADC via this API.\n @param[in]  timeout_ms          Time to wait for data via this API, in millisecond.\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid. Usually it means the ADC sampling rate is faster than the task processing rate.\n         - ESP_ERR_TIMEOUT       Operation timed out\n         - ESP_OK                On success"]
    pub fn adc_digi_read_bytes(
        buf: *mut u8,
        length_max: u32,
        out_length: *mut u32,
        timeout_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start the Digital ADC and DMA peripherals. After this, the hardware starts working.\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_digi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the Digital ADC and DMA peripherals. After this, the hardware stops working.\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_digi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize the Digital ADC.\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_digi_deinitialize() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Setting the digital controller.\n\n @param config Pointer to digital controller paramter. Refer to ``adc_digi_config_t``.\n\n @return\n      - ESP_ERR_INVALID_STATE Driver state is invalid.\n      - ESP_ERR_INVALID_ARG   If the combination of arguments is invalid.\n      - ESP_OK                On success"]
    pub fn adc_digi_controller_configure(config: *const adc_digi_configuration_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_oneshot_unit_ctx_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of ADC unit handle for oneshot mode"]
pub type adc_oneshot_unit_handle_t = *mut adc_oneshot_unit_ctx_t;
#[doc = " @brief ADC oneshot driver initial configurations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_oneshot_unit_init_cfg_t {
    #[doc = "< ADC unit"]
    pub unit_id: adc_unit_t,
    #[doc = "< ADC controlled by ULP, see `adc_ulp_mode_t`"]
    pub ulp_mode: adc_ulp_mode_t,
}
impl Default for adc_oneshot_unit_init_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief ADC channel configurations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_oneshot_chan_cfg_t {
    #[doc = "< ADC attenuation"]
    pub atten: adc_atten_t,
    #[doc = "< ADC conversion result bits"]
    pub bitwidth: adc_bitwidth_t,
}
impl Default for adc_oneshot_chan_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create a handle to a specific ADC unit\n\n @note This API is thread-safe. For more details, see ADC programming guide\n\n @param[in]  init_config    Driver initial configurations\n @param[out] ret_unit       ADC unit handle\n\n @return\n        - ESP_OK:              On success\n        - ESP_ERR_INVALID_ARG: Invalid arguments\n        - ESP_ERR_NO_MEM:      No memory\n        - ESP_ERR_NOT_FOUND:   The ADC peripheral to be claimed is already in use"]
    pub fn adc_oneshot_new_unit(
        init_config: *const adc_oneshot_unit_init_cfg_t,
        ret_unit: *mut adc_oneshot_unit_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set ADC oneshot mode required configurations\n\n @note This API is thread-safe. For more details, see ADC programming guide\n\n @param[in] handle    ADC handle\n @param[in] channel   ADC channel to be configured\n @param[in] config    ADC configurations\n\n @return\n        - ESP_OK:              On success\n        - ESP_ERR_INVALID_ARG: Invalid arguments"]
    pub fn adc_oneshot_config_channel(
        handle: adc_oneshot_unit_handle_t,
        channel: adc_channel_t,
        config: *const adc_oneshot_chan_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get one ADC conversion raw result\n\n @note This API is thread-safe. For more details, see ADC programming guide\n @note This API should NOT be called in an ISR context\n\n @param[in] handle    ADC handle\n @param[in] chan      ADC channel\n @param[out] out_raw  ADC conversion raw result\n\n @return\n        - ESP_OK:                On success\n        - ESP_ERR_INVALID_ARG:   Invalid arguments\n        - ESP_ERR_TIMEOUT:       Timeout, the ADC result is invalid"]
    pub fn adc_oneshot_read(
        handle: adc_oneshot_unit_handle_t,
        chan: adc_channel_t,
        out_raw: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the ADC unit handle\n\n @note This API is thread-safe. For more details, see ADC programming guide\n\n @param[in] handle    ADC handle\n\n @return\n        - ESP_OK:              On success\n        - ESP_ERR_INVALID_ARG: Invalid arguments\n        - ESP_ERR_NOT_FOUND:   The ADC peripheral to be disclaimed isn't in use"]
    pub fn adc_oneshot_del_unit(handle: adc_oneshot_unit_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get ADC channel from the given GPIO number\n\n @param[in]  io_num     GPIO number\n @param[out] unit_id    ADC unit\n @param[out] channel    ADC channel\n\n @return\n        - ESP_OK:              On success\n        - ESP_ERR_INVALID_ARG: Invalid argument\n        - ESP_ERR_NOT_FOUND:   The IO is not a valid ADC pad"]
    pub fn adc_oneshot_io_to_channel(
        io_num: ::core::ffi::c_int,
        unit_id: *mut adc_unit_t,
        channel: *mut adc_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO number from the given ADC channel\n\n @param[in]  unit_id    ADC unit\n @param[in]  channel    ADC channel\n @param[out] io_num     GPIO number\n\n @param\n       - ESP_OK:              On success\n       - ESP_ERR_INVALID_ARG: Invalid argument"]
    pub fn adc_oneshot_channel_to_io(
        unit_id: adc_unit_t,
        channel: adc_channel_t,
        io_num: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_continuous_ctx_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of adc continuous mode driver handle"]
pub type adc_continuous_handle_t = *mut adc_continuous_ctx_t;
#[doc = " @brief ADC continuous mode driver initial configurations"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct adc_continuous_handle_cfg_t {
    #[doc = "< Max length of the conversion Results that driver can store, in bytes."]
    pub max_store_buf_size: u32,
    #[doc = "< Conversion frame size, in bytes. This should be in multiples of `SOC_ADC_DIGI_DATA_BYTES_PER_CONV`."]
    pub conv_frame_size: u32,
}
#[doc = " @brief ADC continuous mode driver configurations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_continuous_config_t {
    #[doc = "< Number of ADC channels that will be used"]
    pub pattern_num: u32,
    #[doc = "< List of configs for each ADC channel that will be used"]
    pub adc_pattern: *mut adc_digi_pattern_config_t,
    #[doc = "< The expected ADC sampling frequency in Hz. Please refer to `soc/soc_caps.h` to know available sampling frequency range"]
    pub sample_freq_hz: u32,
    #[doc = "< ADC DMA conversion mode, see `adc_digi_convert_mode_t`."]
    pub conv_mode: adc_digi_convert_mode_t,
    #[doc = "< ADC DMA conversion output format, see `adc_digi_output_format_t`."]
    pub format: adc_digi_output_format_t,
}
impl Default for adc_continuous_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Event data structure\n @note The `conv_frame_buffer` is maintained by the driver itself, so never free this piece of memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_continuous_evt_data_t {
    #[doc = "< Pointer to conversion result buffer for one conversion frame"]
    pub conv_frame_buffer: *mut u8,
    #[doc = "< Conversion frame size"]
    pub size: u32,
}
impl Default for adc_continuous_evt_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Prototype of ADC continuous mode event callback\n\n @param[in] handle    ADC continuous mode driver handle\n @param[in] edata     Pointer to ADC contunuous mode event data\n @param[in] user_data User registered context, registered when in `adc_continuous_register_event_callbacks()`\n\n @return Whether a high priority task is woken up by this function"]
pub type adc_continuous_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: adc_continuous_handle_t,
        edata: *const adc_continuous_evt_data_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief Group of ADC continuous mode callbacks\n\n @note These callbacks are all running in an ISR environment.\n @note When CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM.\n       Involved variables should be in internal RAM as well."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct adc_continuous_evt_cbs_t {
    #[doc = "< Event callback, invoked when one conversion frame is done. See `@brief Driver Backgrounds` to konw `conversion frame` concept."]
    pub on_conv_done: adc_continuous_callback_t,
    #[doc = "< Event callback, invoked when the internal pool is full."]
    pub on_pool_ovf: adc_continuous_callback_t,
}
extern "C" {
    #[doc = " @brief Initialize ADC continuous driver and get a handle to it\n\n @param[in]  hdl_config  Pointer to ADC initilization config. Refer to ``adc_continuous_handle_cfg_t``.\n @param[out] ret_handle  ADC continuous mode driver handle\n\n @return\n         - ESP_ERR_INVALID_ARG   If the combination of arguments is invalid.\n         - ESP_ERR_NOT_FOUND     No free interrupt found with the specified flags\n         - ESP_ERR_NO_MEM        If out of memory\n         - ESP_OK                On success"]
    pub fn adc_continuous_new_handle(
        hdl_config: *const adc_continuous_handle_cfg_t,
        ret_handle: *mut adc_continuous_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set ADC continuous mode required configurations\n\n @param[in] handle ADC continuous mode driver handle\n @param[in] config Refer to ``adc_digi_config_t``.\n\n @return\n      - ESP_ERR_INVALID_STATE: Driver state is invalid, you shouldn't call this API at this moment\n      - ESP_ERR_INVALID_ARG:   If the combination of arguments is invalid.\n      - ESP_OK:                On success"]
    pub fn adc_continuous_config(
        handle: adc_continuous_handle_t,
        config: *const adc_continuous_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register callbacks\n\n @note User can deregister a previously registered callback by calling this function and setting the to-be-deregistered callback member int\n       the `cbs` structure to NULL.\n @note When CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM.\n       Involved variables (including `user_data`) should be in internal RAM as well.\n @note You should only call this API when the ADC continuous mode driver isn't started. Check return value to know this.\n\n @param[in] handle    ADC continuous mode driver handle\n @param[in] cbs       Group of callback functions\n @param[in] user_data User data, which will be delivered to the callback functions directly\n\n @return\n        - ESP_OK:                On success\n        - ESP_ERR_INVALID_ARG:   Invalid arguments\n        - ESP_ERR_INVALID_STATE: Driver state is invalid, you shouldn't call this API at this moment"]
    pub fn adc_continuous_register_event_callbacks(
        handle: adc_continuous_handle_t,
        cbs: *const adc_continuous_evt_cbs_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start the ADC under continuous mode. After this, the hardware starts working.\n\n @param[in]  handle              ADC continuous mode driver handle\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_continuous_start(handle: adc_continuous_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read bytes from ADC under continuous mode.\n\n @param[in]  handle              ADC continuous mode driver handle\n @param[out] buf                 Conversion result buffer to read from ADC. Suggest convert to `adc_digi_output_data_t` for `ADC Conversion Results`.\n                                 See `@brief Driver Backgrounds` to know this concept.\n @param[in]  length_max          Expected length of the Conversion Results read from the ADC, in bytes.\n @param[out] out_length          Real length of the Conversion Results read from the ADC via this API, in bytes.\n @param[in]  timeout_ms          Time to wait for data via this API, in millisecond.\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid. Usually it means the ADC sampling rate is faster than the task processing rate.\n         - ESP_ERR_TIMEOUT       Operation timed out\n         - ESP_OK                On success"]
    pub fn adc_continuous_read(
        handle: adc_continuous_handle_t,
        buf: *mut u8,
        length_max: u32,
        out_length: *mut u32,
        timeout_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the ADC. After this, the hardware stops working.\n\n @param[in]  handle              ADC continuous mode driver handle\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_continuous_stop(handle: adc_continuous_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize the ADC continuous driver.\n\n @param[in]  handle              ADC continuous mode driver handle\n\n @return\n         - ESP_ERR_INVALID_STATE Driver state is invalid.\n         - ESP_OK                On success"]
    pub fn adc_continuous_deinit(handle: adc_continuous_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get ADC channel from the given GPIO number\n\n @param[in]  io_num     GPIO number\n @param[out] unit_id    ADC unit\n @param[out] channel    ADC channel\n\n @return\n        - ESP_OK:              On success\n        - ESP_ERR_INVALID_ARG: Invalid argument\n        - ESP_ERR_NOT_FOUND:   The IO is not a valid ADC pad"]
    pub fn adc_continuous_io_to_channel(
        io_num: ::core::ffi::c_int,
        unit_id: *mut adc_unit_t,
        channel: *mut adc_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO number from the given ADC channel\n\n @param[in]  unit_id    ADC unit\n @param[in]  channel    ADC channel\n @param[out] io_num     GPIO number\n\n @param\n       - ESP_OK:              On success\n       - ESP_ERR_INVALID_ARG: Invalid argument"]
    pub fn adc_continuous_channel_to_io(
        unit_id: adc_unit_t,
        channel: adc_channel_t,
        io_num: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
#[doc = "< Normal operating mode where TWAI controller can send/receive/acknowledge messages"]
pub const twai_mode_t_TWAI_MODE_NORMAL: twai_mode_t = 0;
#[doc = "< Transmission does not require acknowledgment. Use this mode for self testing"]
pub const twai_mode_t_TWAI_MODE_NO_ACK: twai_mode_t = 1;
#[doc = "< The TWAI controller will not influence the bus (No transmissions or acknowledgments) but can receive messages"]
pub const twai_mode_t_TWAI_MODE_LISTEN_ONLY: twai_mode_t = 2;
#[doc = " @brief   TWAI Controller operating modes"]
pub type twai_mode_t = ::core::ffi::c_uint;
#[doc = " @brief   Structure to store a TWAI message\n\n @note    The flags member is deprecated"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct twai_message_t {
    pub __bindgen_anon_1: twai_message_t__bindgen_ty_1,
    #[doc = "< 11 or 29 bit identifier"]
    pub identifier: u32,
    #[doc = "< Data length code"]
    pub data_length_code: u8,
    #[doc = "< Data bytes (not relevant in RTR frame)"]
    pub data: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union twai_message_t__bindgen_ty_1 {
    pub __bindgen_anon_1: twai_message_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Deprecated: Alternate way to set bits using message flags"]
    pub flags: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct twai_message_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl twai_message_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn extd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ss(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ss(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn self_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_self(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dlc_non_comp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dlc_non_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extd: u32,
        rtr: u32,
        ss: u32,
        self_: u32,
        dlc_non_comp: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extd: u32 = unsafe { ::core::mem::transmute(extd) };
            extd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtr: u32 = unsafe { ::core::mem::transmute(rtr) };
            rtr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ss: u32 = unsafe { ::core::mem::transmute(ss) };
            ss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let self_: u32 = unsafe { ::core::mem::transmute(self_) };
            self_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dlc_non_comp: u32 = unsafe { ::core::mem::transmute(dlc_non_comp) };
            dlc_non_comp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for twai_message_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for twai_message_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Structure for bit timing configuration of the TWAI driver\n\n @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct twai_timing_config_t {
    #[doc = "< Baudrate prescaler (i.e., APB clock divider). Any even number from 2 to 128 for ESP32, 2 to 32768 for ESP32S2.\nFor ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported"]
    pub brp: u32,
    #[doc = "< Timing segment 1 (Number of time quanta, between 1 to 16)"]
    pub tseg_1: u8,
    #[doc = "< Timing segment 2 (Number of time quanta, 1 to 8)"]
    pub tseg_2: u8,
    #[doc = "< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4)"]
    pub sjw: u8,
    #[doc = "< Enables triple sampling when the TWAI controller samples a bit"]
    pub triple_sampling: bool,
}
#[doc = " @brief   Structure for acceptance filter configuration of the TWAI driver (see documentation)\n\n @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct twai_filter_config_t {
    #[doc = "< 32-bit acceptance code"]
    pub acceptance_code: u32,
    #[doc = "< 32-bit acceptance mask"]
    pub acceptance_mask: u32,
    #[doc = "< Use Single Filter Mode (see documentation)"]
    pub single_filter: bool,
}
#[doc = "< Stopped state. The TWAI controller will not participate in any TWAI bus activities"]
pub const twai_state_t_TWAI_STATE_STOPPED: twai_state_t = 0;
#[doc = "< Running state. The TWAI controller can transmit and receive messages"]
pub const twai_state_t_TWAI_STATE_RUNNING: twai_state_t = 1;
#[doc = "< Bus-off state. The TWAI controller cannot participate in bus activities until it has recovered"]
pub const twai_state_t_TWAI_STATE_BUS_OFF: twai_state_t = 2;
#[doc = "< Recovering state. The TWAI controller is undergoing bus recovery"]
pub const twai_state_t_TWAI_STATE_RECOVERING: twai_state_t = 3;
#[doc = " @brief   TWAI driver states"]
pub type twai_state_t = ::core::ffi::c_uint;
#[doc = " @brief   Structure for general configuration of the TWAI driver\n\n @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct twai_general_config_t {
    #[doc = "< Mode of TWAI controller"]
    pub mode: twai_mode_t,
    #[doc = "< Transmit GPIO number"]
    pub tx_io: gpio_num_t,
    #[doc = "< Receive GPIO number"]
    pub rx_io: gpio_num_t,
    #[doc = "< CLKOUT GPIO number (optional, set to -1 if unused)"]
    pub clkout_io: gpio_num_t,
    #[doc = "< Bus off indicator GPIO number (optional, set to -1 if unused)"]
    pub bus_off_io: gpio_num_t,
    #[doc = "< Number of messages TX queue can hold (set to 0 to disable TX Queue)"]
    pub tx_queue_len: u32,
    #[doc = "< Number of messages RX queue can hold"]
    pub rx_queue_len: u32,
    #[doc = "< Bit field of alerts to enable (see documentation)"]
    pub alerts_enabled: u32,
    #[doc = "< CLKOUT divider. Can be 1 or any even number from 2 to 14 (optional, set to 0 if unused)"]
    pub clkout_divider: u32,
    #[doc = "< Interrupt flags to set the priority of the driver's ISR. Note that to use the ESP_INTR_FLAG_IRAM, the CONFIG_TWAI_ISR_IN_IRAM option should be enabled first."]
    pub intr_flags: ::core::ffi::c_int,
}
impl Default for twai_general_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Structure to store status information of TWAI driver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct twai_status_info_t {
    #[doc = "< Current state of TWAI controller (Stopped/Running/Bus-Off/Recovery)"]
    pub state: twai_state_t,
    #[doc = "< Number of messages queued for transmission or awaiting transmission completion"]
    pub msgs_to_tx: u32,
    #[doc = "< Number of messages in RX queue waiting to be read"]
    pub msgs_to_rx: u32,
    #[doc = "< Current value of Transmit Error Counter"]
    pub tx_error_counter: u32,
    #[doc = "< Current value of Receive Error Counter"]
    pub rx_error_counter: u32,
    #[doc = "< Number of messages that failed transmissions"]
    pub tx_failed_count: u32,
    #[doc = "< Number of messages that were lost due to a full RX queue (or errata workaround if enabled)"]
    pub rx_missed_count: u32,
    #[doc = "< Number of messages that were lost due to a RX FIFO overrun"]
    pub rx_overrun_count: u32,
    #[doc = "< Number of instances arbitration was lost"]
    pub arb_lost_count: u32,
    #[doc = "< Number of instances a bus error has occurred"]
    pub bus_error_count: u32,
}
impl Default for twai_status_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Install TWAI driver\n\n This function installs the TWAI driver using three configuration structures.\n The required memory is allocated and the TWAI driver is placed in the stopped\n state after running this function.\n\n @param[in]   g_config    General configuration structure\n @param[in]   t_config    Timing configuration structure\n @param[in]   f_config    Filter configuration structure\n\n @note    Macro initializers are available for the configuration structures (see documentation)\n\n @note    To reinstall the TWAI driver, call twai_driver_uninstall() first\n\n @return\n      - ESP_OK: Successfully installed TWAI driver\n      - ESP_ERR_INVALID_ARG: Arguments are invalid\n      - ESP_ERR_NO_MEM: Insufficient memory\n      - ESP_ERR_INVALID_STATE: Driver is already installed"]
    pub fn twai_driver_install(
        g_config: *const twai_general_config_t,
        t_config: *const twai_timing_config_t,
        f_config: *const twai_filter_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Uninstall the TWAI driver\n\n This function uninstalls the TWAI driver, freeing the memory utilized by the\n driver. This function can only be called when the driver is in the stopped\n state or the bus-off state.\n\n @warning The application must ensure that no tasks are blocked on TX/RX\n          queues or alerts when this function is called.\n\n @return\n      - ESP_OK: Successfully uninstalled TWAI driver\n      - ESP_ERR_INVALID_STATE: Driver is not in stopped/bus-off state, or is not installed"]
    pub fn twai_driver_uninstall() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Start the TWAI driver\n\n This function starts the TWAI driver, putting the TWAI driver into the running\n state. This allows the TWAI driver to participate in TWAI bus activities such\n as transmitting/receiving messages. The TX and RX queue are reset in this function,\n clearing any messages that are unread or pending transmission. This function\n can only be called when the TWAI driver is in the stopped state.\n\n @return\n      - ESP_OK: TWAI driver is now running\n      - ESP_ERR_INVALID_STATE: Driver is not in stopped state, or is not installed"]
    pub fn twai_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop the TWAI driver\n\n This function stops the TWAI driver, preventing any further message from being\n transmitted or received until twai_start() is called. Any messages in the TX\n queue are cleared. Any messages in the RX queue should be read by the\n application after this function is called. This function can only be called\n when the TWAI driver is in the running state.\n\n @warning A message currently being transmitted/received on the TWAI bus will\n          be ceased immediately. This may lead to other TWAI nodes interpreting\n          the unfinished message as an error.\n\n @return\n      - ESP_OK: TWAI driver is now Stopped\n      - ESP_ERR_INVALID_STATE: Driver is not in running state, or is not installed"]
    pub fn twai_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Transmit a TWAI message\n\n This function queues a TWAI message for transmission. Transmission will start\n immediately if no other messages are queued for transmission. If the TX queue\n is full, this function will block until more space becomes available or until\n it times out. If the TX queue is disabled (TX queue length = 0 in configuration),\n this function will return immediately if another message is undergoing\n transmission. This function can only be called when the TWAI driver is in the\n running state and cannot be called under Listen Only Mode.\n\n @param[in]   message         Message to transmit\n @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block on the TX queue\n\n @note    This function does not guarantee that the transmission is successful.\n          The TX_SUCCESS/TX_FAILED alert can be enabled to alert the application\n          upon the success/failure of a transmission.\n\n @note    The TX_IDLE alert can be used to alert the application when no other\n          messages are awaiting transmission.\n\n @return\n      - ESP_OK: Transmission successfully queued/initiated\n      - ESP_ERR_INVALID_ARG: Arguments are invalid\n      - ESP_ERR_TIMEOUT: Timed out waiting for space on TX queue\n      - ESP_FAIL: TX queue is disabled and another message is currently transmitting\n      - ESP_ERR_INVALID_STATE: TWAI driver is not in running state, or is not installed\n      - ESP_ERR_NOT_SUPPORTED: Listen Only Mode does not support transmissions"]
    pub fn twai_transmit(message: *const twai_message_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Receive a TWAI message\n\n This function receives a message from the RX queue. The flags field of the\n message structure will indicate the type of message received. This function\n will block if there are no messages in the RX queue\n\n @param[out]  message         Received message\n @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block on RX queue\n\n @warning The flags field of the received message should be checked to determine\n          if the received message contains any data bytes.\n\n @return\n      - ESP_OK: Message successfully received from RX queue\n      - ESP_ERR_TIMEOUT: Timed out waiting for message\n      - ESP_ERR_INVALID_ARG: Arguments are invalid\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed"]
    pub fn twai_receive(message: *mut twai_message_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Read TWAI driver alerts\n\n This function will read the alerts raised by the TWAI driver. If no alert has\n been issued when this function is called, this function will block until an alert\n occurs or until it timeouts.\n\n @param[out]  alerts          Bit field of raised alerts (see documentation for alert flags)\n @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block for alert\n\n @note    Multiple alerts can be raised simultaneously. The application should\n          check for all alerts that have been enabled.\n\n @return\n      - ESP_OK: Alerts read\n      - ESP_ERR_TIMEOUT: Timed out waiting for alerts\n      - ESP_ERR_INVALID_ARG: Arguments are invalid\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed"]
    pub fn twai_read_alerts(alerts: *mut u32, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Reconfigure which alerts are enabled\n\n This function reconfigures which alerts are enabled. If there are alerts\n which have not been read whilst reconfiguring, this function can read those\n alerts.\n\n @param[in]   alerts_enabled  Bit field of alerts to enable (see documentation for alert flags)\n @param[out]  current_alerts  Bit field of currently raised alerts. Set to NULL if unused\n\n @return\n      - ESP_OK: Alerts reconfigured\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed"]
    pub fn twai_reconfigure_alerts(alerts_enabled: u32, current_alerts: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Start the bus recovery process\n\n This function initiates the bus recovery process when the TWAI driver is in\n the bus-off state. Once initiated, the TWAI driver will enter the recovering\n state and wait for 128 occurrences of the bus-free signal on the TWAI bus\n before returning to the stopped state. This function will reset the TX queue,\n clearing any messages pending transmission.\n\n @note    The BUS_RECOVERED alert can be enabled to alert the application when\n          the bus recovery process completes.\n\n @return\n      - ESP_OK: Bus recovery started\n      - ESP_ERR_INVALID_STATE: TWAI driver is not in the bus-off state, or is not installed"]
    pub fn twai_initiate_recovery() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get current status information of the TWAI driver\n\n @param[out]  status_info     Status information\n\n @return\n      - ESP_OK: Status information retrieved\n      - ESP_ERR_INVALID_ARG: Arguments are invalid\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed"]
    pub fn twai_get_status_info(status_info: *mut twai_status_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the transmit queue\n\n This function will clear the transmit queue of all messages.\n\n @note    The transmit queue is automatically cleared when twai_stop() or\n          twai_initiate_recovery() is called.\n\n @return\n      - ESP_OK: Transmit queue cleared\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed or TX queue is disabled"]
    pub fn twai_clear_transmit_queue() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the receive queue\n\n This function will clear the receive queue of all messages.\n\n @note    The receive queue is automatically cleared when twai_start() is\n          called.\n\n @return\n      - ESP_OK: Transmit queue cleared\n      - ESP_ERR_INVALID_STATE: TWAI driver is not installed"]
    pub fn twai_clear_receive_queue() -> esp_err_t;
}
#[doc = "< Internal 17.5MHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_FAST: soc_root_clk_t = 0;
#[doc = "< Internal 136kHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_SLOW: soc_root_clk_t = 1;
#[doc = "< External 40MHz crystal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL: soc_root_clk_t = 2;
#[doc = "< External 32kHz crystal/clock signal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL32K: soc_root_clk_t = 3;
#[doc = " @brief Root clock"]
pub type soc_root_clk_t = ::core::ffi::c_uint;
#[doc = "< Select XTAL_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_XTAL: soc_cpu_clk_src_t = 0;
#[doc = "< Select PLL_CLK as CPU_CLK source (PLL_CLK is the output of 40MHz crystal oscillator frequency multiplier, can be 480MHz or 320MHz)"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_PLL: soc_cpu_clk_src_t = 1;
#[doc = "< Select RC_FAST_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_RC_FAST: soc_cpu_clk_src_t = 2;
#[doc = "< Invalid CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_INVALID: soc_cpu_clk_src_t = 3;
#[doc = " @brief CPU_CLK mux inputs, which are the supported clock sources for the CPU_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_cpu_clk_src_t = ::core::ffi::c_uint;
#[doc = "< Select RC_SLOW_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC_SLOW: soc_rtc_slow_clk_src_t = 0;
#[doc = "< Select XTAL32K_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_XTAL32K: soc_rtc_slow_clk_src_t = 1;
#[doc = "< Select RC_FAST_D256_CLK (referred as FOSC_DIV or 8m_d256/8md256 in TRM and reg. description) as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: soc_rtc_slow_clk_src_t = 2;
#[doc = "< Invalid RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_INVALID: soc_rtc_slow_clk_src_t = 3;
#[doc = " @brief RTC_SLOW_CLK mux inputs, which are the supported clock sources for the RTC_SLOW_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_slow_clk_src_t = ::core::ffi::c_uint;
#[doc = "< Select XTAL_D2_CLK (may referred as XTAL_CLK_DIV_2) as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_D2: soc_rtc_fast_clk_src_t = 0;
#[doc = "< Alias name for `SOC_RTC_FAST_CLK_SRC_XTAL_D2`"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_DIV: soc_rtc_fast_clk_src_t = 0;
#[doc = "< Select RC_FAST_CLK as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_RC_FAST: soc_rtc_fast_clk_src_t = 1;
#[doc = "< Invalid RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_INVALID: soc_rtc_fast_clk_src_t = 2;
#[doc = " @brief RTC_FAST_CLK mux inputs, which are the supported clock sources for the RTC_FAST_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_fast_clk_src_t = ::core::ffi::c_uint;
#[doc = "< CPU_CLK can be sourced from XTAL, PLL, or RC_FAST by configuring soc_cpu_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_CPU: soc_module_clk_t = 1;
#[doc = "< RTC_FAST_CLK can be sourced from XTAL_D2 or RC_FAST by configuring soc_rtc_fast_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_FAST: soc_module_clk_t = 2;
#[doc = "< RTC_SLOW_CLK can be sourced from RC_SLOW, XTAL32K, or RC_FAST_D256 by configuring soc_rtc_slow_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_SLOW: soc_module_clk_t = 3;
#[doc = "< APB_CLK is highly dependent on the CPU_CLK source"]
pub const soc_module_clk_t_SOC_MOD_CLK_APB: soc_module_clk_t = 4;
#[doc = "< PLL_F80M_CLK is derived from PLL, and has a fixed frequency of 80MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F80M: soc_module_clk_t = 5;
#[doc = "< PLL_F160M_CLK is derived from PLL, and has a fixed frequency of 160MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F160M: soc_module_clk_t = 6;
#[doc = "< PLL_D2_CLK is derived from PLL, it has a fixed divider of 2"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_D2: soc_module_clk_t = 7;
#[doc = "< XTAL32K_CLK comes from the external 32kHz crystal, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL32K: soc_module_clk_t = 8;
#[doc = "< RC_FAST_CLK comes from the internal 20MHz rc oscillator, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_RC_FAST: soc_module_clk_t = 9;
#[doc = "< RC_FAST_D256_CLK comes from the internal 20MHz rc oscillator, divided by 256, and passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_RC_FAST_D256: soc_module_clk_t = 10;
#[doc = "< XTAL_CLK comes from the external 40MHz crystal"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL: soc_module_clk_t = 11;
#[doc = " @brief Supported clock sources for modules (CPU, peripherals, RTC, etc.)\n\n @note enum starts from 1, to save 0 for special purpose"]
pub type soc_module_clk_t = ::core::ffi::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_APB: soc_periph_gptimer_clk_src_t = 4;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_XTAL: soc_periph_gptimer_clk_src_t = 11;
#[doc = "< Select APB as the default choice"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_DEFAULT: soc_periph_gptimer_clk_src_t = 4;
#[doc = " @brief Type of GPTimer clock source"]
pub type soc_periph_gptimer_clk_src_t = ::core::ffi::c_uint;
#[doc = "< Timer group clock source is APB"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_APB: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = "< Timer group clock source is XTAL"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_XTAL: soc_periph_tg_clk_src_legacy_t = 11;
#[doc = "< Timer group clock source default choice is APB"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_DEFAULT: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = " @brief Type of Timer Group clock source, reserved for the legacy timer group driver"]
pub type soc_periph_tg_clk_src_legacy_t = ::core::ffi::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_APB: soc_periph_rmt_clk_src_t = 4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_RC_FAST: soc_periph_rmt_clk_src_t = 9;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_XTAL: soc_periph_rmt_clk_src_t = 11;
#[doc = "< Select APB as the default choice"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_DEFAULT: soc_periph_rmt_clk_src_t = 4;
#[doc = " @brief Type of RMT clock source"]
pub type soc_periph_rmt_clk_src_t = ::core::ffi::c_uint;
#[doc = "< RMT source clock is APB"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_APB: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = "< RMT source clock is XTAL"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_XTAL: soc_periph_rmt_clk_src_legacy_t = 11;
#[doc = "< RMT source clock default choice is APB"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_DEFAULT: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = " @brief Type of RMT clock source, reserved for the legacy RMT driver"]
pub type soc_periph_rmt_clk_src_legacy_t = ::core::ffi::c_uint;
#[doc = "< Select XTAL as the source clock"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_XTAL:
    soc_periph_temperature_sensor_clk_src_t = 11;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_RC_FAST:
    soc_periph_temperature_sensor_clk_src_t = 9;
#[doc = "< Select XTAL as the default choice"]
pub const soc_periph_temperature_sensor_clk_src_t_TEMPERATURE_SENSOR_CLK_SRC_DEFAULT:
    soc_periph_temperature_sensor_clk_src_t = 11;
#[doc = " @brief Type of Temp Sensor clock source"]
pub type soc_periph_temperature_sensor_clk_src_t = ::core::ffi::c_uint;
#[doc = "< UART source clock is APB CLK"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_APB: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = "< UART source clock is RC_FAST"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_RTC: soc_periph_uart_clk_src_legacy_t = 9;
#[doc = "< UART source clock is XTAL"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_XTAL: soc_periph_uart_clk_src_legacy_t = 11;
#[doc = "< UART source clock default choice is APB"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_DEFAULT: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = " @brief Type of UART clock source, reserved for the legacy UART driver"]
pub type soc_periph_uart_clk_src_legacy_t = ::core::ffi::c_uint;
#[doc = "< Select PLL_F160M as the default source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_DEFAULT: soc_periph_i2s_clk_src_t = 6;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_PLL_160M: soc_periph_i2s_clk_src_t = 6;
#[doc = " @brief I2S clock source enum"]
pub type soc_periph_i2s_clk_src_t = ::core::ffi::c_uint;
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_XTAL: soc_periph_i2c_clk_src_t = 11;
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_RC_FAST: soc_periph_i2c_clk_src_t = 9;
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_DEFAULT: soc_periph_i2c_clk_src_t = 11;
#[doc = " @brief Type of I2C clock source."]
pub type soc_periph_i2c_clk_src_t = ::core::ffi::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_APB: soc_periph_sdm_clk_src_t = 4;
#[doc = "< Select APB as the default clock choice"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_DEFAULT: soc_periph_sdm_clk_src_t = 4;
#[doc = " @brief Sigma Delta Modulator clock source"]
pub type soc_periph_sdm_clk_src_t = ::core::ffi::c_uint;
#[doc = " @brief Type of GPTimer clock source"]
pub use self::soc_periph_gptimer_clk_src_t as gptimer_clock_source_t;
#[doc = "< Decrease count value"]
pub const gptimer_count_direction_t_GPTIMER_COUNT_DOWN: gptimer_count_direction_t = 0;
#[doc = "< Increase count value"]
pub const gptimer_count_direction_t_GPTIMER_COUNT_UP: gptimer_count_direction_t = 1;
#[doc = " @brief GPTimer count direction"]
pub type gptimer_count_direction_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gptimer_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of General Purpose Timer handle"]
pub type gptimer_handle_t = *mut gptimer_t;
#[doc = " @brief GPTimer alarm event data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gptimer_alarm_event_data_t {
    #[doc = "< Current count value"]
    pub count_value: u64,
    #[doc = "< Current alarm value"]
    pub alarm_value: u64,
}
#[doc = " @brief Timer alarm callback prototype\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @param[in] edata Alarm event data, fed by driver\n @param[in] user_ctx User data, passed from `gptimer_register_event_callbacks()`\n @return Whether a high priority task has been waken up by this function"]
pub type gptimer_alarm_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        timer: gptimer_handle_t,
        edata: *const gptimer_alarm_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief Group of supported GPTimer callbacks\n @note The callbacks are all running under ISR environment\n @note When CONFIG_GPTIMER_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gptimer_event_callbacks_t {
    #[doc = "< Timer alarm callback"]
    pub on_alarm: gptimer_alarm_cb_t,
}
#[doc = " @brief General Purpose Timer configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gptimer_config_t {
    #[doc = "< GPTimer clock source"]
    pub clk_src: gptimer_clock_source_t,
    #[doc = "< Count direction"]
    pub direction: gptimer_count_direction_t,
    #[doc = "< Counter resolution (working frequency) in Hz,\nhence, the step size of each count tick equals to (1 / resolution_hz) seconds"]
    pub resolution_hz: u32,
    #[doc = "< GPTimer config flags"]
    pub flags: gptimer_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gptimer_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl gptimer_config_t__bindgen_ty_1 {
    #[inline]
    pub fn intr_shared(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intr_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr_shared: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let intr_shared: u32 = unsafe { ::core::mem::transmute(intr_shared) };
            intr_shared as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gptimer_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief General Purpose Timer alarm configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gptimer_alarm_config_t {
    #[doc = "< Alarm target count value"]
    pub alarm_count: u64,
    #[doc = "< Alarm reload count value, effect only when `auto_reload_on_alarm` is set to true"]
    pub reload_count: u64,
    #[doc = "< Alarm config flags"]
    pub flags: gptimer_alarm_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct gptimer_alarm_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl gptimer_alarm_config_t__bindgen_ty_1 {
    #[inline]
    pub fn auto_reload_on_alarm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_reload_on_alarm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(auto_reload_on_alarm: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_reload_on_alarm: u32 = unsafe { ::core::mem::transmute(auto_reload_on_alarm) };
            auto_reload_on_alarm as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create a new General Purpose Timer, and return the handle\n\n @note The newly created timer is put in the \"init\" state.\n\n @param[in] config GPTimer configuration\n @param[out] ret_timer Returned timer handle\n @return\n      - ESP_OK: Create GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Create GPTimer failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create GPTimer failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create GPTimer failed because all hardware timers are used up and no more free one\n      - ESP_FAIL: Create GPTimer failed because of other error"]
    pub fn gptimer_new_timer(
        config: *const gptimer_config_t,
        ret_timer: *mut gptimer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the GPTimer handle\n\n @note A timer must be in the \"init\" state before it can be deleted.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @return\n      - ESP_OK: Delete GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Delete GPTimer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Delete GPTimer failed because the timer is not in init state\n      - ESP_FAIL: Delete GPTimer failed because of other error"]
    pub fn gptimer_del_timer(timer: gptimer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPTimer raw count value\n\n @note When updating the raw count of an active timer, the timer will immediately start counting from the new value.\n @note This function is allowed to run within ISR context\n @note If `CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` is enabled, this function will be placed in the IRAM by linker,\n       makes it possible to execute even when the Flash Cache is disabled.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @param[in] value Count value to be set\n @return\n      - ESP_OK: Set GPTimer raw count value successfully\n      - ESP_ERR_INVALID_ARG: Set GPTimer raw count value failed because of invalid argument\n      - ESP_FAIL: Set GPTimer raw count value failed because of other error"]
    pub fn gptimer_set_raw_count(timer: gptimer_handle_t, value: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPTimer raw count value\n\n @note With the raw count value and the resolution set in the `gptimer_config_t`, you can convert the count value into seconds.\n @note This function is allowed to run within ISR context\n @note If `CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` is enabled, this function will be placed in the IRAM by linker,\n       makes it possible to execute even when the Flash Cache is disabled.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @param[out] value Returned GPTimer count value\n @return\n      - ESP_OK: Get GPTimer raw count value successfully\n      - ESP_ERR_INVALID_ARG: Get GPTimer raw count value failed because of invalid argument\n      - ESP_FAIL: Get GPTimer raw count value failed because of other error"]
    pub fn gptimer_get_raw_count(timer: gptimer_handle_t, value: *mut u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set callbacks for GPTimer\n\n @note User registered callbacks are expected to be runnable within ISR context\n @note The first call to this function needs to be before the call to `gptimer_enable`\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Set event callbacks failed because the timer is not in init state\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn gptimer_register_event_callbacks(
        timer: gptimer_handle_t,
        cbs: *const gptimer_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set alarm event actions for GPTimer.\n\n @note This function is allowed to run within ISR context, so that user can set new alarm action immediately in the ISR callback.\n @note If `CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` is enabled, this function will be placed in the IRAM by linker,\n       makes it possible to execute even when the Flash Cache is disabled.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @param[in] config Alarm configuration, especially, set config to NULL means disabling the alarm function\n @return\n      - ESP_OK: Set alarm action for GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Set alarm action for GPTimer failed because of invalid argument\n      - ESP_FAIL: Set alarm action for GPTimer failed because of other error"]
    pub fn gptimer_set_alarm_action(
        timer: gptimer_handle_t,
        config: *const gptimer_alarm_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPTimer\n\n @note This function will transit the timer state from \"init\" to \"enable\".\n @note This function will enable the interrupt service, if it's lazy installed in `gptimer_register_event_callbacks`.\n @note This function will acquire a PM lock, if a specific source clock (e.g. APB) is selected in the `gptimer_config_t`, while `CONFIG_PM_ENABLE` is enabled.\n @note Enable a timer doesn't mean to start it. See also `gptimer_start()` for how to make the timer start counting.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @return\n      - ESP_OK: Enable GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Enable GPTimer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable GPTimer failed because the timer is already enabled\n      - ESP_FAIL: Enable GPTimer failed because of other error"]
    pub fn gptimer_enable(timer: gptimer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPTimer\n\n @note This function will transit the timer state from \"enable\" to \"init\".\n @note This function will disable the interrupt service if it's installed.\n @note This function will release the PM lock if it's acquired in the `gptimer_enable`.\n @note Disable a timer doesn't mean to stop it. See also `gptimer_stop` for how to make the timer stop counting.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @return\n      - ESP_OK: Disable GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Disable GPTimer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable GPTimer failed because the timer is not enabled yet\n      - ESP_FAIL: Disable GPTimer failed because of other error"]
    pub fn gptimer_disable(timer: gptimer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start GPTimer (internal counter starts counting)\n\n @note This function will transit the timer state from \"enable\" to \"run\".\n @note This function is allowed to run within ISR context\n @note If `CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` is enabled, this function will be placed in the IRAM by linker,\n       makes it possible to execute even when the Flash Cache is disabled.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @return\n      - ESP_OK: Start GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Start GPTimer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Start GPTimer failed because the timer is not enabled or is already in running\n      - ESP_FAIL: Start GPTimer failed because of other error"]
    pub fn gptimer_start(timer: gptimer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop GPTimer (internal counter stops counting)\n\n @note This function will transit the timer state from \"run\" to \"enable\".\n @note This function is allowed to run within ISR context\n @note If `CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM` is enabled, this function will be placed in the IRAM by linker,\n       makes it possible to execute even when the Flash Cache is disabled.\n\n @param[in] timer Timer handle created by `gptimer_new_timer()`\n @return\n      - ESP_OK: Stop GPTimer successfully\n      - ESP_ERR_INVALID_ARG: Stop GPTimer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Stop GPTimer failed because the timer is not in running.\n      - ESP_FAIL: Stop GPTimer failed because of other error"]
    pub fn gptimer_stop(timer: gptimer_handle_t) -> esp_err_t;
}
#[doc = " @brief I2C port number, can be I2C_NUM_0 ~ (I2C_NUM_MAX-1)."]
pub type i2c_port_t = ::core::ffi::c_int;
#[doc = "< I2C slave mode"]
pub const i2c_mode_t_I2C_MODE_SLAVE: i2c_mode_t = 0;
#[doc = "< I2C master mode"]
pub const i2c_mode_t_I2C_MODE_MASTER: i2c_mode_t = 1;
pub const i2c_mode_t_I2C_MODE_MAX: i2c_mode_t = 2;
pub type i2c_mode_t = ::core::ffi::c_uint;
#[doc = "< I2C write data"]
pub const i2c_rw_t_I2C_MASTER_WRITE: i2c_rw_t = 0;
#[doc = "< I2C read data"]
pub const i2c_rw_t_I2C_MASTER_READ: i2c_rw_t = 1;
pub type i2c_rw_t = ::core::ffi::c_uint;
#[doc = "< I2C data msb first"]
pub const i2c_trans_mode_t_I2C_DATA_MODE_MSB_FIRST: i2c_trans_mode_t = 0;
#[doc = "< I2C data lsb first"]
pub const i2c_trans_mode_t_I2C_DATA_MODE_LSB_FIRST: i2c_trans_mode_t = 1;
pub const i2c_trans_mode_t_I2C_DATA_MODE_MAX: i2c_trans_mode_t = 2;
pub type i2c_trans_mode_t = ::core::ffi::c_uint;
#[doc = "< I2C 7bit address for slave mode"]
pub const i2c_addr_mode_t_I2C_ADDR_BIT_7: i2c_addr_mode_t = 0;
#[doc = "< I2C 10bit address for slave mode"]
pub const i2c_addr_mode_t_I2C_ADDR_BIT_10: i2c_addr_mode_t = 1;
pub const i2c_addr_mode_t_I2C_ADDR_BIT_MAX: i2c_addr_mode_t = 2;
pub type i2c_addr_mode_t = ::core::ffi::c_uint;
#[doc = "< I2C ack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_ACK: i2c_ack_type_t = 0;
#[doc = "< I2C nack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_NACK: i2c_ack_type_t = 1;
#[doc = "< I2C nack for the last byte"]
pub const i2c_ack_type_t_I2C_MASTER_LAST_NACK: i2c_ack_type_t = 2;
pub const i2c_ack_type_t_I2C_MASTER_ACK_MAX: i2c_ack_type_t = 3;
pub type i2c_ack_type_t = ::core::ffi::c_uint;
#[doc = " @brief Type of I2C clock source."]
pub use self::soc_periph_i2c_clk_src_t as i2c_clock_source_t;
#[doc = " @brief I2C initialization parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2c_config_t {
    #[doc = "< I2C mode"]
    pub mode: i2c_mode_t,
    #[doc = "< GPIO number for I2C sda signal"]
    pub sda_io_num: ::core::ffi::c_int,
    #[doc = "< GPIO number for I2C scl signal"]
    pub scl_io_num: ::core::ffi::c_int,
    #[doc = "< Internal GPIO pull mode for I2C sda signal"]
    pub sda_pullup_en: bool,
    #[doc = "< Internal GPIO pull mode for I2C scl signal"]
    pub scl_pullup_en: bool,
    pub __bindgen_anon_1: i2c_config_t__bindgen_ty_1,
    #[doc = "< Bitwise of ``I2C_SCLK_SRC_FLAG_**FOR_DFS**`` for clk source choice"]
    pub clk_flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2c_config_t__bindgen_ty_1 {
    #[doc = "< I2C master config"]
    pub master: i2c_config_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< I2C slave config"]
    pub slave: i2c_config_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< I2C clock frequency for master mode, (no higher than 1MHz for now)"]
    pub clk_speed: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< I2C 10bit address mode enable for slave mode"]
    pub addr_10bit_en: u8,
    #[doc = "< I2C address for slave mode"]
    pub slave_addr: u16,
    #[doc = "< I2C expected clock speed from SCL."]
    pub maximum_speed: u32,
}
impl Default for i2c_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for i2c_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type i2c_cmd_handle_t = *mut ::core::ffi::c_void;
extern "C" {
    #[doc = " @brief Install an I2C driver\n @note  Not all Espressif chips can support slave mode (e.g. ESP32C2)\n\n @param i2c_num I2C port number\n @param mode I2C mode (either master or slave).\n @param slv_rx_buf_len Receiving buffer size. Only slave mode will use this value, it is ignored in master mode.\n @param slv_tx_buf_len Sending buffer size. Only slave mode will use this value, it is ignored in master mode.\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values.\n                         See esp_intr_alloc.h for more info.\n        @note\n        In master mode, if the cache is likely to be disabled(such as write flash) and the slave is time-sensitive,\n        `ESP_INTR_FLAG_IRAM` is suggested to be used. In this case, please use the memory allocated from internal RAM in i2c read and write function,\n        because we can not access the psram(if psram is enabled) in interrupt handle function when cache is disabled.\n\n @return\n     - ESP_OK   Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Driver installation error"]
    pub fn i2c_driver_install(
        i2c_num: i2c_port_t,
        mode: i2c_mode_t,
        slv_rx_buf_len: usize,
        slv_tx_buf_len: usize,
        intr_alloc_flags: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete I2C driver\n\n @note This function does not guarantee thread safety.\n       Please make sure that no thread will continuously hold semaphores before calling the delete function.\n\n @param i2c_num I2C port to delete\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_driver_delete(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure an I2C bus with the given configuration.\n\n @param i2c_num I2C port to configure\n @param i2c_conf Pointer to the I2C configuration\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_param_config(i2c_num: i2c_port_t, i2c_conf: *const i2c_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief reset I2C tx hardware fifo\n\n @param i2c_num I2C port number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_reset_tx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief reset I2C rx fifo\n\n @param i2c_num I2C port number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_reset_rx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure GPIO pins for I2C SCK and SDA signals.\n\n @param i2c_num I2C port number\n @param sda_io_num GPIO number for I2C SDA signal\n @param scl_io_num GPIO number for I2C SCL signal\n @param sda_pullup_en Enable the internal pullup for SDA pin\n @param scl_pullup_en Enable the internal pullup for SCL pin\n @param mode I2C mode\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_pin(
        i2c_num: i2c_port_t,
        sda_io_num: ::core::ffi::c_int,
        scl_io_num: ::core::ffi::c_int,
        sda_pullup_en: bool,
        scl_pullup_en: bool,
        mode: i2c_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Perform a write to a device connected to a particular I2C port.\n        This function is a wrapper to `i2c_master_start()`, `i2c_master_write()`, `i2c_master_read()`, etc...\n        It shall only be called in I2C master mode.\n\n @param i2c_num I2C port number to perform the transfer on\n @param device_address I2C device's 7-bit address\n @param write_buffer Bytes to send on the bus\n @param write_size Size, in bytes, of the write buffer\n @param ticks_to_wait Maximum ticks to wait before issuing a timeout.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Sending command error, slave hasn't ACK the transfer.\n     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode.\n     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_write_to_device(
        i2c_num: i2c_port_t,
        device_address: u8,
        write_buffer: *const u8,
        write_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Perform a read to a device connected to a particular I2C port.\n        This function is a wrapper to `i2c_master_start()`, `i2c_master_write()`, `i2c_master_read()`, etc...\n        It shall only be called in I2C master mode.\n\n @param i2c_num I2C port number to perform the transfer on\n @param device_address I2C device's 7-bit address\n @param read_buffer Buffer to store the bytes received on the bus\n @param read_size Size, in bytes, of the read buffer\n @param ticks_to_wait Maximum ticks to wait before issuing a timeout.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Sending command error, slave hasn't ACK the transfer.\n     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode.\n     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_read_from_device(
        i2c_num: i2c_port_t,
        device_address: u8,
        read_buffer: *mut u8,
        read_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Perform a write followed by a read to a device on the I2C bus.\n        A repeated start signal is used between the `write` and `read`, thus, the bus is\n        not released until the two transactions are finished.\n        This function is a wrapper to `i2c_master_start()`, `i2c_master_write()`, `i2c_master_read()`, etc...\n        It shall only be called in I2C master mode.\n\n @param i2c_num I2C port number to perform the transfer on\n @param device_address I2C device's 7-bit address\n @param write_buffer Bytes to send on the bus\n @param write_size Size, in bytes, of the write buffer\n @param read_buffer Buffer to store the bytes received on the bus\n @param read_size Size, in bytes, of the read buffer\n @param ticks_to_wait Maximum ticks to wait before issuing a timeout.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Sending command error, slave hasn't ACK the transfer.\n     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode.\n     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_write_read_device(
        i2c_num: i2c_port_t,
        device_address: u8,
        write_buffer: *const u8,
        write_size: usize,
        read_buffer: *mut u8,
        read_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create and initialize an I2C commands list with a given buffer.\n        All the allocations for data or signals (START, STOP, ACK, ...) will be\n        performed within this buffer.\n        This buffer must be valid during the whole transaction.\n        After finishing the I2C transactions, it is required to call `i2c_cmd_link_delete_static()`.\n\n @note It is **highly** advised to not allocate this buffer on the stack. The size of the data\n       used underneath may increase in the future, resulting in a possible stack overflow as the macro\n       `I2C_LINK_RECOMMENDED_SIZE` would also return a bigger value.\n       A better option is to use a buffer allocated statically or dynamically (with `malloc`).\n\n @param buffer Buffer to use for commands allocations\n @param size Size in bytes of the buffer\n\n @return Handle to the I2C command link or NULL if the buffer provided is too small, please\n         use `I2C_LINK_RECOMMENDED_SIZE` macro to get the recommended size for the buffer."]
    pub fn i2c_cmd_link_create_static(buffer: *mut u8, size: u32) -> i2c_cmd_handle_t;
}
extern "C" {
    #[doc = " @brief Create and initialize an I2C commands list with a given buffer.\n        After finishing the I2C transactions, it is required to call `i2c_cmd_link_delete()`\n        to release and return the resources.\n        The required bytes will be dynamically allocated.\n\n @return Handle to the I2C command link or NULL in case of insufficient dynamic memory."]
    pub fn i2c_cmd_link_create() -> i2c_cmd_handle_t;
}
extern "C" {
    #[doc = " @brief Free the I2C commands list allocated statically with `i2c_cmd_link_create_static`.\n\n @param cmd_handle I2C commands list allocated statically. This handle should be created thanks to\n                   `i2c_cmd_link_create_static()` function"]
    pub fn i2c_cmd_link_delete_static(cmd_handle: i2c_cmd_handle_t);
}
extern "C" {
    #[doc = " @brief Free the I2C commands list\n\n @param cmd_handle I2C commands list. This handle should be created thanks to\n                   `i2c_cmd_link_create()` function"]
    pub fn i2c_cmd_link_delete(cmd_handle: i2c_cmd_handle_t);
}
extern "C" {
    #[doc = " @brief Queue a \"START signal\" to the given commands list.\n        This function shall only be called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all the queued commands.\n\n @param cmd_handle I2C commands list\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_start(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a \"write byte\" command to the commands list.\n        A single byte will be sent on the I2C port. This function shall only be\n        called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all queued commands\n\n @param cmd_handle I2C commands list\n @param data Byte to send on the port\n @param ack_en Enable ACK signal\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_write_byte(cmd_handle: i2c_cmd_handle_t, data: u8, ack_en: bool)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a \"write (multiple) bytes\" command to the commands list.\n        This function shall only be called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all queued commands\n\n @param cmd_handle I2C commands list\n @param data Bytes to send. This buffer shall remain **valid** until the transaction is finished.\n             If the PSRAM is enabled and `intr_flag` is set to `ESP_INTR_FLAG_IRAM`,\n             `data` should be allocated from internal RAM.\n @param data_len Length, in bytes, of the data buffer\n @param ack_en Enable ACK signal\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_write(
        cmd_handle: i2c_cmd_handle_t,
        data: *const u8,
        data_len: usize,
        ack_en: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a \"read byte\" command to the commands list.\n        A single byte will be read on the I2C bus. This function shall only be\n        called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all queued commands\n\n @param cmd_handle I2C commands list\n @param data Pointer where the received byte will the stored. This buffer shall remain **valid**\n             until the transaction is finished.\n @param ack ACK signal\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_read_byte(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a \"read (multiple) bytes\" command to the commands list.\n        Multiple bytes will be read on the I2C bus. This function shall only be\n        called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all queued commands\n\n @param cmd_handle I2C commands list\n @param data Pointer where the received bytes will the stored. This buffer shall remain **valid**\n             until the transaction is finished.\n @param data_len Size, in bytes, of the `data` buffer\n @param ack ACK signal\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_read(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: usize,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a \"STOP signal\" to the given commands list.\n        This function shall only be called in I2C master mode.\n        Call `i2c_master_cmd_begin()` to send all the queued commands.\n\n @param cmd_handle I2C commands list\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM The static buffer used to create `cmd_handler` is too small\n     - ESP_FAIL No more memory left on the heap"]
    pub fn i2c_master_stop(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send all the queued commands on the I2C bus, in master mode.\n        The task will be blocked until all the commands have been sent out.\n        The I2C port is protected by mutex, so this function is thread-safe.\n        This function shall only be called in I2C master mode.\n\n @param i2c_num I2C port number\n @param cmd_handle I2C commands list\n @param ticks_to_wait Maximum ticks to wait before issuing a timeout.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Sending command error, slave hasn't ACK the transfer.\n     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode.\n     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_cmd_begin(
        i2c_num: i2c_port_t,
        cmd_handle: i2c_cmd_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write bytes to internal ringbuffer of the I2C slave data. When the TX fifo empty, the ISR will\n        fill the hardware FIFO with the internal ringbuffer's data.\n        @note This function shall only be called in I2C slave mode.\n\n @param i2c_num I2C port number\n @param data Bytes to write into internal buffer\n @param size Size, in bytes, of `data` buffer\n @param ticks_to_wait Maximum ticks to wait.\n\n @return\n     - ESP_FAIL (-1) Parameter error\n     - Other (>=0) The number of data bytes pushed to the I2C slave buffer."]
    pub fn i2c_slave_write_buffer(
        i2c_num: i2c_port_t,
        data: *const u8,
        size: ::core::ffi::c_int,
        ticks_to_wait: TickType_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Read bytes from I2C internal buffer. When the I2C bus receives data, the ISR will copy them\n        from the hardware RX FIFO to the internal ringbuffer.\n        Calling this function will then copy bytes from the internal ringbuffer to the `data` user buffer.\n        @note This function shall only be called in I2C slave mode.\n\n @param i2c_num I2C port number\n @param data Buffer to fill with ringbuffer's bytes\n @param max_size Maximum bytes to read\n @param ticks_to_wait Maximum waiting ticks\n\n @return\n     - ESP_FAIL(-1) Parameter error\n     - Others(>=0) The number of data bytes read from I2C slave buffer."]
    pub fn i2c_slave_read_buffer(
        i2c_num: i2c_port_t,
        data: *mut u8,
        max_size: usize,
        ticks_to_wait: TickType_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set I2C master clock period\n\n @param i2c_num I2C port number\n @param high_period Clock cycle number during SCL is high level, high_period is a 14 bit value\n @param low_period Clock cycle number during SCL is low level, low_period is a 14 bit value\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_period(
        i2c_num: i2c_port_t,
        high_period: ::core::ffi::c_int,
        low_period: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get I2C master clock period\n\n @param i2c_num I2C port number\n @param high_period pointer to get clock cycle number during SCL is high level, will get a 14 bit value\n @param low_period pointer to get clock cycle number during SCL is low level, will get a 14 bit value\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_period(
        i2c_num: i2c_port_t,
        high_period: *mut ::core::ffi::c_int,
        low_period: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable hardware filter on I2C bus\n        Sometimes the I2C bus is disturbed by high frequency noise(about 20ns), or the rising edge of\n        the SCL clock is very slow, these may cause the master state machine to break.\n        Enable hardware filter can filter out high frequency interference and make the master more stable.\n        @note Enable filter will slow down the SCL clock.\n\n @param i2c_num I2C port number to filter\n @param cyc_num the APB cycles need to be filtered (0<= cyc_num <=7).\n        When the period of a pulse is less than cyc_num * APB_cycle, the I2C controller will ignore this pulse.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_filter_enable(i2c_num: i2c_port_t, cyc_num: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable filter on I2C bus\n\n @param i2c_num I2C port number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_filter_disable(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C master start signal timing\n\n @param i2c_num I2C port number\n @param setup_time clock number between the falling-edge of SDA and rising-edge of SCL for start mark, it's a 10-bit value.\n @param hold_time clock num between the falling-edge of SDA and falling-edge of SCL for start mark, it's a 10-bit value.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_start_timing(
        i2c_num: i2c_port_t,
        setup_time: ::core::ffi::c_int,
        hold_time: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C master start signal timing\n\n @param i2c_num I2C port number\n @param setup_time pointer to get setup time\n @param hold_time pointer to get hold time\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_start_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut ::core::ffi::c_int,
        hold_time: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C master stop signal timing\n\n @param i2c_num I2C port number\n @param setup_time clock num between the rising-edge of SCL and the rising-edge of SDA, it's a 10-bit value.\n @param hold_time clock number after the STOP bit's rising-edge, it's a 14-bit value.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: ::core::ffi::c_int,
        hold_time: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C master stop signal timing\n\n @param i2c_num I2C port number\n @param setup_time pointer to get setup time.\n @param hold_time pointer to get hold time.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut ::core::ffi::c_int,
        hold_time: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C data signal timing\n\n @param i2c_num I2C port number\n @param sample_time clock number I2C used to sample data on SDA after the rising-edge of SCL, it's a 10-bit value\n @param hold_time clock number I2C used to hold the data after the falling-edge of SCL, it's a 10-bit value\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_data_timing(
        i2c_num: i2c_port_t,
        sample_time: ::core::ffi::c_int,
        hold_time: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C data signal timing\n\n @param i2c_num I2C port number\n @param sample_time pointer to get sample time\n @param hold_time pointer to get hold time\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_data_timing(
        i2c_num: i2c_port_t,
        sample_time: *mut ::core::ffi::c_int,
        hold_time: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C timeout value\n @param i2c_num I2C port number\n @param timeout timeout value for I2C bus (unit: APB 80Mhz clock cycle)\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_timeout(i2c_num: i2c_port_t, timeout: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C timeout value\n @param i2c_num I2C port number\n @param timeout pointer to get timeout value\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_timeout(i2c_num: i2c_port_t, timeout: *mut ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C data transfer mode\n\n @param i2c_num I2C port number\n @param tx_trans_mode I2C sending data mode\n @param rx_trans_mode I2C receving data mode\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: i2c_trans_mode_t,
        rx_trans_mode: i2c_trans_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C data transfer mode\n\n @param i2c_num I2C port number\n @param tx_trans_mode pointer to get I2C sending data mode\n @param rx_trans_mode pointer to get I2C receiving data mode\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: *mut i2c_trans_mode_t,
        rx_trans_mode: *mut i2c_trans_mode_t,
    ) -> esp_err_t;
}
#[doc = "< I2S channel slot format mono, transmit same data in all slots for tx mode, only receive the data in the first slots for rx mode."]
pub const i2s_slot_mode_t_I2S_SLOT_MODE_MONO: i2s_slot_mode_t = 1;
#[doc = "< I2S channel slot format stereo, transmit different data in different slots for tx mode, receive the data in all slots for rx mode."]
pub const i2s_slot_mode_t_I2S_SLOT_MODE_STEREO: i2s_slot_mode_t = 2;
#[doc = " @brief I2S channel slot mode"]
pub type i2s_slot_mode_t = ::core::ffi::c_uint;
#[doc = "< I2S channel direction RX"]
pub const i2s_dir_t_I2S_DIR_RX: i2s_dir_t = 1;
#[doc = "< I2S channel direction TX"]
pub const i2s_dir_t_I2S_DIR_TX: i2s_dir_t = 2;
#[doc = " @brief I2S channel direction"]
pub type i2s_dir_t = ::core::ffi::c_uint;
#[doc = "< I2S controller master role, bclk and ws signal will be set to output"]
pub const i2s_role_t_I2S_ROLE_MASTER: i2s_role_t = 0;
#[doc = "< I2S controller slave role, bclk and ws signal will be set to input"]
pub const i2s_role_t_I2S_ROLE_SLAVE: i2s_role_t = 1;
#[doc = " @brief I2S controller role"]
pub type i2s_role_t = ::core::ffi::c_uint;
#[doc = "< I2S channel data bit-width: 8"]
pub const i2s_data_bit_width_t_I2S_DATA_BIT_WIDTH_8BIT: i2s_data_bit_width_t = 8;
#[doc = "< I2S channel data bit-width: 16"]
pub const i2s_data_bit_width_t_I2S_DATA_BIT_WIDTH_16BIT: i2s_data_bit_width_t = 16;
#[doc = "< I2S channel data bit-width: 24"]
pub const i2s_data_bit_width_t_I2S_DATA_BIT_WIDTH_24BIT: i2s_data_bit_width_t = 24;
#[doc = "< I2S channel data bit-width: 32"]
pub const i2s_data_bit_width_t_I2S_DATA_BIT_WIDTH_32BIT: i2s_data_bit_width_t = 32;
#[doc = " @brief Available data bit width in one slot"]
pub type i2s_data_bit_width_t = ::core::ffi::c_uint;
#[doc = "< I2S channel slot bit-width equals to data bit-width"]
pub const i2s_slot_bit_width_t_I2S_SLOT_BIT_WIDTH_AUTO: i2s_slot_bit_width_t = 0;
#[doc = "< I2S channel slot bit-width: 8"]
pub const i2s_slot_bit_width_t_I2S_SLOT_BIT_WIDTH_8BIT: i2s_slot_bit_width_t = 8;
#[doc = "< I2S channel slot bit-width: 16"]
pub const i2s_slot_bit_width_t_I2S_SLOT_BIT_WIDTH_16BIT: i2s_slot_bit_width_t = 16;
#[doc = "< I2S channel slot bit-width: 24"]
pub const i2s_slot_bit_width_t_I2S_SLOT_BIT_WIDTH_24BIT: i2s_slot_bit_width_t = 24;
#[doc = "< I2S channel slot bit-width: 32"]
pub const i2s_slot_bit_width_t_I2S_SLOT_BIT_WIDTH_32BIT: i2s_slot_bit_width_t = 32;
#[doc = " @brief Total slot bit width in one slot\n"]
pub type i2s_slot_bit_width_t = ::core::ffi::c_uint;
#[doc = " @brief I2S clock source enum"]
pub use self::soc_periph_i2s_clk_src_t as i2s_clock_src_t;
#[doc = "< Disable A/U law decompress or compress"]
pub const i2s_pcm_compress_t_I2S_PCM_DISABLE: i2s_pcm_compress_t = 0;
#[doc = "< A-law decompress"]
pub const i2s_pcm_compress_t_I2S_PCM_A_DECOMPRESS: i2s_pcm_compress_t = 1;
#[doc = "< A-law compress"]
pub const i2s_pcm_compress_t_I2S_PCM_A_COMPRESS: i2s_pcm_compress_t = 2;
#[doc = "< U-law decompress"]
pub const i2s_pcm_compress_t_I2S_PCM_U_DECOMPRESS: i2s_pcm_compress_t = 3;
#[doc = "< U-law compress"]
pub const i2s_pcm_compress_t_I2S_PCM_U_COMPRESS: i2s_pcm_compress_t = 4;
#[doc = " @brief A/U-law decompress or compress configuration.\n"]
pub type i2s_pcm_compress_t = ::core::ffi::c_uint;
#[doc = "< I2S TX PDM signal scaling: /2"]
pub const i2s_pdm_sig_scale_t_I2S_PDM_SIG_SCALING_DIV_2: i2s_pdm_sig_scale_t = 0;
#[doc = "< I2S TX PDM signal scaling: x1"]
pub const i2s_pdm_sig_scale_t_I2S_PDM_SIG_SCALING_MUL_1: i2s_pdm_sig_scale_t = 1;
#[doc = "< I2S TX PDM signal scaling: x2"]
pub const i2s_pdm_sig_scale_t_I2S_PDM_SIG_SCALING_MUL_2: i2s_pdm_sig_scale_t = 2;
#[doc = "< I2S TX PDM signal scaling: x4"]
pub const i2s_pdm_sig_scale_t_I2S_PDM_SIG_SCALING_MUL_4: i2s_pdm_sig_scale_t = 3;
#[doc = " @brief pdm tx singnal scaling mode"]
pub type i2s_pdm_sig_scale_t = ::core::ffi::c_uint;
#[doc = "< Standard PDM format output, left and right slot data on a single line"]
pub const i2s_pdm_tx_line_mode_t_I2S_PDM_TX_ONE_LINE_CODEC: i2s_pdm_tx_line_mode_t = 0;
#[doc = "< PDM DAC format output, left or right slot data on a single line"]
pub const i2s_pdm_tx_line_mode_t_I2S_PDM_TX_ONE_LINE_DAC: i2s_pdm_tx_line_mode_t = 1;
#[doc = "< PDM DAC format output, left and right slot data on separated lines"]
pub const i2s_pdm_tx_line_mode_t_I2S_PDM_TX_TWO_LINE_DAC: i2s_pdm_tx_line_mode_t = 2;
#[doc = " @brief PDM TX line mode\n @note  For the standard codec mode, PDM pins are connect to a codec which requires both clock signal and data signal\n        For the DAC output mode, PDM data signal can be connected to a power amplifier directly with a low-pass filter,\n        normally, DAC output mode doesn't need the clock signal."]
pub type i2s_pdm_tx_line_mode_t = ::core::ffi::c_uint;
#[doc = "< I2S transmits or receives left slot"]
pub const i2s_std_slot_mask_t_I2S_STD_SLOT_LEFT: i2s_std_slot_mask_t = 1;
#[doc = "< I2S transmits or receives right slot"]
pub const i2s_std_slot_mask_t_I2S_STD_SLOT_RIGHT: i2s_std_slot_mask_t = 2;
#[doc = "< I2S transmits or receives both left and right slot"]
pub const i2s_std_slot_mask_t_I2S_STD_SLOT_BOTH: i2s_std_slot_mask_t = 3;
#[doc = " @brief I2S slot select in standard mode\n @note  It has different meanings in tx/rx/mono/stereo mode, and it may have differen behaviors on different targets\n        For the details, please refer to the I2S API reference"]
pub type i2s_std_slot_mask_t = ::core::ffi::c_uint;
#[doc = "< I2S PDM only transmits or receives the PDM device whose 'select' pin is pulled up"]
pub const i2s_pdm_slot_mask_t_I2S_PDM_SLOT_RIGHT: i2s_pdm_slot_mask_t = 1;
#[doc = "< I2S PDM only transmits or receives the PDM device whose 'select' pin is pulled down"]
pub const i2s_pdm_slot_mask_t_I2S_PDM_SLOT_LEFT: i2s_pdm_slot_mask_t = 2;
#[doc = "< I2S PDM transmits or receives both two slots"]
pub const i2s_pdm_slot_mask_t_I2S_PDM_SLOT_BOTH: i2s_pdm_slot_mask_t = 3;
#[doc = " @brief I2S slot select in PDM mode\n"]
pub type i2s_pdm_slot_mask_t = ::core::ffi::c_uint;
#[doc = "< I2S slot 0 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT0: i2s_tdm_slot_mask_t = 1;
#[doc = "< I2S slot 1 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT1: i2s_tdm_slot_mask_t = 2;
#[doc = "< I2S slot 2 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT2: i2s_tdm_slot_mask_t = 4;
#[doc = "< I2S slot 3 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT3: i2s_tdm_slot_mask_t = 8;
#[doc = "< I2S slot 4 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT4: i2s_tdm_slot_mask_t = 16;
#[doc = "< I2S slot 5 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT5: i2s_tdm_slot_mask_t = 32;
#[doc = "< I2S slot 6 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT6: i2s_tdm_slot_mask_t = 64;
#[doc = "< I2S slot 7 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT7: i2s_tdm_slot_mask_t = 128;
#[doc = "< I2S slot 8 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT8: i2s_tdm_slot_mask_t = 256;
#[doc = "< I2S slot 9 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT9: i2s_tdm_slot_mask_t = 512;
#[doc = "< I2S slot 10 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT10: i2s_tdm_slot_mask_t = 1024;
#[doc = "< I2S slot 11 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT11: i2s_tdm_slot_mask_t = 2048;
#[doc = "< I2S slot 12 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT12: i2s_tdm_slot_mask_t = 4096;
#[doc = "< I2S slot 13 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT13: i2s_tdm_slot_mask_t = 8192;
#[doc = "< I2S slot 14 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT14: i2s_tdm_slot_mask_t = 16384;
#[doc = "< I2S slot 15 enabled"]
pub const i2s_tdm_slot_mask_t_I2S_TDM_SLOT15: i2s_tdm_slot_mask_t = 32768;
#[doc = " @brief tdm slot number\n @note  Multiple slots in TDM mode.\n        For TX module, only the active slot send the audio data, the inactive slot send a constant or will be skipped if 'skip_msk' is set.\n        For RX module, only receive the audio data in active slots, the data in inactive slots will be ignored.\n        the bit map of active slot can not exceed (0x1<<total_slot_num).\n        e.g: slot_mask = (I2S_TDM_SLOT0 | I2S_TDM_SLOT3), here the active slot number is 2 and total_slot is not supposed to be smaller than 4."]
pub type i2s_tdm_slot_mask_t = ::core::ffi::c_uint;
#[doc = "< I2S controller port 0"]
pub const i2s_port_t_I2S_NUM_0: i2s_port_t = 0;
#[doc = "< Select whichever port is available"]
pub const i2s_port_t_I2S_NUM_AUTO: i2s_port_t = 1;
#[doc = " @brief I2S controller port number, the max port number is (SOC_I2S_NUM -1)."]
pub type i2s_port_t = ::core::ffi::c_uint;
#[doc = "< I2S controller using standard communication mode, support philips/MSB/PCM format"]
pub const i2s_comm_mode_t_I2S_COMM_MODE_STD: i2s_comm_mode_t = 0;
#[doc = "< I2S controller using PDM communication mode, support PDM output or input"]
pub const i2s_comm_mode_t_I2S_COMM_MODE_PDM: i2s_comm_mode_t = 1;
#[doc = "< I2S controller using TDM communication mode, support up to 16 slots per frame"]
pub const i2s_comm_mode_t_I2S_COMM_MODE_TDM: i2s_comm_mode_t = 2;
#[doc = "< Unspecified I2S controller mode"]
pub const i2s_comm_mode_t_I2S_COMM_MODE_NONE: i2s_comm_mode_t = 3;
#[doc = " @brief I2S controller communication mode"]
pub type i2s_comm_mode_t = ::core::ffi::c_uint;
#[doc = "< mclk = sample_rate * 128"]
pub const i2s_mclk_multiple_t_I2S_MCLK_MULTIPLE_128: i2s_mclk_multiple_t = 128;
#[doc = "< mclk = sample_rate * 256"]
pub const i2s_mclk_multiple_t_I2S_MCLK_MULTIPLE_256: i2s_mclk_multiple_t = 256;
#[doc = "< mclk = sample_rate * 384"]
pub const i2s_mclk_multiple_t_I2S_MCLK_MULTIPLE_384: i2s_mclk_multiple_t = 384;
#[doc = "< mclk = sample_rate * 512"]
pub const i2s_mclk_multiple_t_I2S_MCLK_MULTIPLE_512: i2s_mclk_multiple_t = 512;
#[doc = " @brief The multiple of mclk to sample rate"]
pub type i2s_mclk_multiple_t = ::core::ffi::c_uint;
#[doc = " @brief Event structure used in I2S event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_event_data_t {
    #[doc = "< The pointer of DMA buffer that just finished sending or receiving for `on_recv` and `on_sent` callback\n  NULL for `on_recv_q_ovf` and `on_send_q_ovf` callback"]
    pub data: *mut ::core::ffi::c_void,
    #[doc = "< The buffer size of DMA buffer when success to send or receive,\n  also the buffer size that dropped when queue overflow.\n  It is related to the dma_frame_num and data_bit_width, typically it is fixed when data_bit_width is not changed."]
    pub size: usize,
}
impl Default for i2s_event_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_channel_obj_t {
    _unused: [u8; 0],
}
pub type i2s_chan_handle_t = *mut i2s_channel_obj_t;
#[doc = " @brief I2S event callback\n @param[in] handle    I2S channel handle, created from `i2s_new_channel()`\n @param[in] event     I2S event data\n @param[in] user_ctx  User registered context, passed from `i2s_channel_register_event_callback()`\n\n @return Whether a high priority task has been waken up by this callback function"]
pub type i2s_isr_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: i2s_chan_handle_t,
        event: *mut i2s_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = "< data bit-width: 8"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_8BIT: i2s_bits_per_sample_t = 8;
#[doc = "< data bit-width: 16"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_16BIT: i2s_bits_per_sample_t = 16;
#[doc = "< data bit-width: 24"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_24BIT: i2s_bits_per_sample_t = 24;
#[doc = "< data bit-width: 32"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_32BIT: i2s_bits_per_sample_t = 32;
#[doc = " @brief I2S bit width per sample."]
pub type i2s_bits_per_sample_t = ::core::ffi::c_uint;
#[doc = "< channel bit-width equals to data bit-width"]
pub const i2s_bits_per_chan_t_I2S_BITS_PER_CHAN_DEFAULT: i2s_bits_per_chan_t = 0;
#[doc = "< channel bit-width: 8"]
pub const i2s_bits_per_chan_t_I2S_BITS_PER_CHAN_8BIT: i2s_bits_per_chan_t = 8;
#[doc = "< channel bit-width: 16"]
pub const i2s_bits_per_chan_t_I2S_BITS_PER_CHAN_16BIT: i2s_bits_per_chan_t = 16;
#[doc = "< channel bit-width: 24"]
pub const i2s_bits_per_chan_t_I2S_BITS_PER_CHAN_24BIT: i2s_bits_per_chan_t = 24;
#[doc = "< channel bit-width: 32"]
pub const i2s_bits_per_chan_t_I2S_BITS_PER_CHAN_32BIT: i2s_bits_per_chan_t = 32;
#[doc = " @brief I2S bit width per chan."]
pub type i2s_bits_per_chan_t = ::core::ffi::c_uint;
#[doc = "< I2S channel (mono), one channel activated. In this mode, you only need to send one channel data but the fifo will copy same data for the other unactivated channels automatically, then both channels will transmit same data."]
pub const i2s_channel_t_I2S_CHANNEL_MONO: i2s_channel_t = 1;
#[doc = "< I2S channel (stereo), two (or more) channels activated. In this mode, these channels will transmit different data."]
pub const i2s_channel_t_I2S_CHANNEL_STEREO: i2s_channel_t = 2;
#[doc = "< I2S channel 0 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH0: i2s_channel_t = 65536;
#[doc = "< I2S channel 1 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH1: i2s_channel_t = 131072;
#[doc = "< I2S channel 2 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH2: i2s_channel_t = 262144;
#[doc = "< I2S channel 3 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH3: i2s_channel_t = 524288;
#[doc = "< I2S channel 4 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH4: i2s_channel_t = 1048576;
#[doc = "< I2S channel 5 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH5: i2s_channel_t = 2097152;
#[doc = "< I2S channel 6 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH6: i2s_channel_t = 4194304;
#[doc = "< I2S channel 7 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH7: i2s_channel_t = 8388608;
#[doc = "< I2S channel 8 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH8: i2s_channel_t = 16777216;
#[doc = "< I2S channel 9 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH9: i2s_channel_t = 33554432;
#[doc = "< I2S channel 10 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH10: i2s_channel_t = 67108864;
#[doc = "< I2S channel 11 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH11: i2s_channel_t = 134217728;
#[doc = "< I2S channel 12 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH12: i2s_channel_t = 268435456;
#[doc = "< I2S channel 13 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH13: i2s_channel_t = 536870912;
#[doc = "< I2S channel 14 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH14: i2s_channel_t = 1073741824;
#[doc = "< I2S channel 15 activated"]
pub const i2s_channel_t_I2S_TDM_ACTIVE_CH15: i2s_channel_t = -2147483648;
#[doc = " @brief I2S channel."]
pub type i2s_channel_t = ::core::ffi::c_int;
#[doc = "< I2S communication I2S Philips standard, data launch at second BCK"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_STAND_I2S: i2s_comm_format_t = 1;
#[doc = "< I2S communication MSB alignment standard, data launch at first BCK"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_STAND_MSB: i2s_comm_format_t = 2;
#[doc = "< PCM Short standard, also known as DSP mode. The period of synchronization signal (WS) is 1 bck cycle."]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_STAND_PCM_SHORT: i2s_comm_format_t = 4;
#[doc = "< PCM Long standard. The period of synchronization signal (WS) is channel_bit*bck cycles."]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_STAND_PCM_LONG: i2s_comm_format_t = 12;
#[doc = "< standard max"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_STAND_MAX: i2s_comm_format_t = 13;
#[doc = "< I2S communication format I2S, correspond to `I2S_COMM_FORMAT_STAND_I2S`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S: i2s_comm_format_t = 1;
#[doc = "< I2S format MSB, (I2S_COMM_FORMAT_I2S |I2S_COMM_FORMAT_I2S_MSB) correspond to `I2S_COMM_FORMAT_STAND_I2S`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_MSB: i2s_comm_format_t = 1;
#[doc = "< I2S format LSB, (I2S_COMM_FORMAT_I2S |I2S_COMM_FORMAT_I2S_LSB) correspond to `I2S_COMM_FORMAT_STAND_MSB`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_LSB: i2s_comm_format_t = 2;
#[doc = "< I2S communication format PCM, correspond to `I2S_COMM_FORMAT_STAND_PCM_SHORT`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM: i2s_comm_format_t = 4;
#[doc = "< PCM Short, (I2S_COMM_FORMAT_PCM | I2S_COMM_FORMAT_PCM_SHORT) correspond to `I2S_COMM_FORMAT_STAND_PCM_SHORT`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM_SHORT: i2s_comm_format_t = 4;
#[doc = "< PCM Long, (I2S_COMM_FORMAT_PCM | I2S_COMM_FORMAT_PCM_LONG) correspond to `I2S_COMM_FORMAT_STAND_PCM_LONG`"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM_LONG: i2s_comm_format_t = 8;
#[doc = " @brief I2S communication standard format"]
pub type i2s_comm_format_t = ::core::ffi::c_uint;
#[doc = "< Separated left and right channel"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_RIGHT_LEFT: i2s_channel_fmt_t = 0;
#[doc = "< Load right channel data in both two channels"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_RIGHT: i2s_channel_fmt_t = 1;
#[doc = "< Load left channel data in both two channels"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_LEFT: i2s_channel_fmt_t = 2;
#[doc = "< Only load data in right channel (mono mode)"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_RIGHT: i2s_channel_fmt_t = 3;
#[doc = "< Only load data in left channel (mono mode)"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_LEFT: i2s_channel_fmt_t = 4;
#[doc = "< More than two channels are used"]
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_MULTIPLE: i2s_channel_fmt_t = 5;
#[doc = " @brief I2S channel format type"]
pub type i2s_channel_fmt_t = ::core::ffi::c_uint;
#[doc = "< Master mode"]
pub const i2s_mode_t_I2S_MODE_MASTER: i2s_mode_t = 1;
#[doc = "< Slave mode"]
pub const i2s_mode_t_I2S_MODE_SLAVE: i2s_mode_t = 2;
#[doc = "< TX mode"]
pub const i2s_mode_t_I2S_MODE_TX: i2s_mode_t = 4;
#[doc = "< RX mode"]
pub const i2s_mode_t_I2S_MODE_RX: i2s_mode_t = 8;
#[doc = "< I2S PDM mode"]
pub const i2s_mode_t_I2S_MODE_PDM: i2s_mode_t = 64;
#[doc = " @brief I2S Mode"]
pub type i2s_mode_t = ::core::ffi::c_uint;
#[doc = "< I2S DMA has no next descriptor for sending or receiving"]
pub const i2s_event_type_t_I2S_EVENT_DMA_ERROR: i2s_event_type_t = 0;
#[doc = "< I2S DMA finished sending one DMA buffer"]
pub const i2s_event_type_t_I2S_EVENT_TX_DONE: i2s_event_type_t = 1;
#[doc = "< I2S DMA finished receiving one DMA buffer"]
pub const i2s_event_type_t_I2S_EVENT_RX_DONE: i2s_event_type_t = 2;
#[doc = "< I2S DMA sending queue overflowed, the oldest data has been overwritten by the new data in the DMA buffer"]
pub const i2s_event_type_t_I2S_EVENT_TX_Q_OVF: i2s_event_type_t = 3;
#[doc = "< I2S DMA receive queue overflowed, the oldest data has been overwritten by the new data in the DMA buffer"]
pub const i2s_event_type_t_I2S_EVENT_RX_Q_OVF: i2s_event_type_t = 4;
#[doc = " @brief I2S event queue types"]
pub type i2s_event_type_t = ::core::ffi::c_uint;
#[doc = " @brief Event structure used in I2S event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_event_t {
    #[doc = "< I2S event type"]
    pub type_: i2s_event_type_t,
    #[doc = "< I2S data size for I2S_DATA event"]
    pub size: usize,
}
impl Default for i2s_event_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S GPIO pins configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_pin_config_t {
    #[doc = "< MCK pin, output"]
    pub mck_io_num: ::core::ffi::c_int,
    #[doc = "< BCK pin, input in slave role, output in master role"]
    pub bck_io_num: ::core::ffi::c_int,
    #[doc = "< WS pin, input in slave role, output in master role"]
    pub ws_io_num: ::core::ffi::c_int,
    #[doc = "< DATA pin, output"]
    pub data_out_num: ::core::ffi::c_int,
    #[doc = "< DATA pin, input"]
    pub data_in_num: ::core::ffi::c_int,
}
#[doc = " @brief I2S PCM configuration\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pcm_cfg_t {
    #[doc = "< I2S PCM a/u-law decompress or compress type"]
    pub pcm_type: i2s_pcm_compress_t,
}
impl Default for i2s_pcm_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S PDM up-sample rate configuration\n @note  TX PDM can only be set to the following two up-sampling rate configurations:\n        1: fp = 960, fs = sample_rate / 100, in this case, Fpdm = 128*48000\n        2: fp = 960, fs = 480, in this case, Fpdm = 128*Fpcm = 128*sample_rate\n        If the pdm receiver do not care the pdm serial clock, it's recommended set Fpdm = 128*48000.\n        Otherwise, the second configuration should be applied."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_pdm_tx_upsample_cfg_t {
    #[doc = "< I2S PDM sample rate"]
    pub sample_rate: ::core::ffi::c_int,
    #[doc = "< I2S PDM TX up-sampling parameter. Normally it should be set to 960"]
    pub fp: ::core::ffi::c_int,
    #[doc = "< I2S PDM TX up-sampling parameter. When it is set to 480, the pdm clock frequency Fpdm = 128 * sample_rate, when it is set to sample_rate / 100， Fpdm will be fixed to 128*48000"]
    pub fs: ::core::ffi::c_int,
}
#[doc = " @brief I2S driver configuration parameters\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2s_driver_config_t {
    #[doc = "< I2S work mode"]
    pub mode: i2s_mode_t,
    #[doc = "< I2S sample rate"]
    pub sample_rate: u32,
    #[doc = "< I2S sample bits in one channel"]
    pub bits_per_sample: i2s_bits_per_sample_t,
    #[doc = "< I2S channel format."]
    pub channel_format: i2s_channel_fmt_t,
    #[doc = "< I2S communication format"]
    pub communication_format: i2s_comm_format_t,
    #[doc = "< Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info"]
    pub intr_alloc_flags: ::core::ffi::c_int,
    pub __bindgen_anon_1: i2s_driver_config_t__bindgen_ty_1,
    pub __bindgen_anon_2: i2s_driver_config_t__bindgen_ty_2,
    #[doc = "< I2S using APLL as main I2S clock, enable it to get accurate clock"]
    pub use_apll: bool,
    #[doc = "< I2S auto clear tx descriptor if there is underflow condition (helps in avoiding noise in case of data unavailability)"]
    pub tx_desc_auto_clear: bool,
    #[doc = "< I2S using fixed MCLK output. If use_apll = true and fixed_mclk > 0, then the clock output for i2s is fixed and equal to the fixed_mclk value. If fixed_mclk set, mclk_multiple won't take effect"]
    pub fixed_mclk: ::core::ffi::c_int,
    #[doc = "< The multiple of I2S master clock(MCLK) to sample rate"]
    pub mclk_multiple: i2s_mclk_multiple_t,
    #[doc = "< I2S total bits in one channel， only take effect when larger than 'bits_per_sample', default '0' means equal to 'bits_per_sample'"]
    pub bits_per_chan: i2s_bits_per_chan_t,
    #[doc = "< I2S active channel bit mask, set value in `i2s_channel_t` to enable specific channel, the bit map of active channel can not exceed (0x1<<total_chan)."]
    pub chan_mask: i2s_channel_t,
    #[doc = "< I2S Total number of channels. If it is smaller than the biggest active channel number, it will be set to this number automatically."]
    pub total_chan: u32,
    #[doc = "< Set to enable left alignment"]
    pub left_align: bool,
    #[doc = "< Set to enable big endian"]
    pub big_edin: bool,
    #[doc = "< Set to enable msb order"]
    pub bit_order_msb: bool,
    #[doc = "< Set to enable skip mask. If it is enabled, only the data of the enabled channels will be sent, otherwise all data stored in DMA TX buffer will be sent"]
    pub skip_msk: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_driver_config_t__bindgen_ty_1 {
    #[doc = "< The total number of descriptors used by I2S DMA to receive/transmit data"]
    pub dma_desc_num: ::core::ffi::c_int,
    #[doc = "< This is an alias to 'dma_desc_num' for backward compatibility"]
    pub dma_buf_count: ::core::ffi::c_int,
}
impl Default for i2s_driver_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_driver_config_t__bindgen_ty_2 {
    #[doc = "< Frame number for one-time sampling. Frame here means the total data from all the channels in a WS cycle"]
    pub dma_frame_num: ::core::ffi::c_int,
    #[doc = "< This is an alias to 'dma_frame_num' for backward compatibility"]
    pub dma_buf_len: ::core::ffi::c_int,
}
impl Default for i2s_driver_config_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for i2s_driver_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S driver configuration parameters\n"]
pub type i2s_config_t = i2s_driver_config_t;
extern "C" {
    #[doc = " @brief Set I2S pin number\n\n @note\n The I2S peripheral output signals can be connected to multiple GPIO pads.\n However, the I2S peripheral input signal can only be connected to one GPIO pad.\n\n @param   i2s_num     I2S port number\n\n @param   pin         I2S Pin structure, or NULL to set 2-channel 8-bit internal DAC pin configuration (GPIO25 & GPIO26)\n\n Inside the pin configuration structure, set I2S_PIN_NO_CHANGE for any pin where\n the current configuration should not be changed.\n\n @note if *pin is set as NULL, this function will initialize both of the built-in DAC channels by default.\n       if you don't want this to happen and you want to initialize only one of the DAC channels, you can call i2s_set_dac_mode instead.\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL            IO error"]
    pub fn i2s_set_pin(i2s_num: i2s_port_t, pin: *const i2s_pin_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set TX PDM mode up-sample rate\n @note  If you have set PDM mode while calling 'i2s_driver_install',\n        default PDM TX upsample parameters have already been set,\n        no need to call this function again if you don't have to change the default configuration\n\n @param i2s_num I2S port number\n @param upsample_cfg Set I2S PDM up-sample rate configuration\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_pdm_tx_up_sample(
        i2s_num: i2s_port_t,
        upsample_cfg: *const i2s_pdm_tx_upsample_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install and start I2S driver.\n\n @param i2s_num         I2S port number\n\n @param i2s_config      I2S configurations - see i2s_config_t struct\n\n @param queue_size      I2S event queue size/depth.\n\n @param i2s_queue       I2S event queue handle, if set NULL, driver will not use an event queue.\n\n This function must be called before any I2S driver read/write operations.\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM      Out of memory\n     - ESP_ERR_INVALID_STATE  Current I2S port is in use"]
    pub fn i2s_driver_install(
        i2s_num: i2s_port_t,
        i2s_config: *const i2s_config_t,
        queue_size: ::core::ffi::c_int,
        i2s_queue: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall I2S driver.\n\n @param i2s_num  I2S port number\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE I2S port has been uninstalled by others (e.g. LCD i80)"]
    pub fn i2s_driver_uninstall(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer.\n\n @param i2s_num             I2S port number\n\n @param src                 Source address to write from\n\n @param size                Size of data in bytes\n\n @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in.\n\n @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this\n many ticks pass without space becoming available in the DMA\n transmit buffer, then the function will return (note that if the\n data is written to the DMA buffer in pieces, the overall operation\n may still take longer than this timeout.) Pass portMAX_DELAY for no\n timeout.\n\n @return\n     - ESP_OK               Success\n     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_write(
        i2s_num: i2s_port_t,
        src: *const ::core::ffi::c_void,
        size: usize,
        bytes_written: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer while expanding the number of bits per sample. For example, expanding 16-bit PCM to 32-bit PCM.\n\n @param i2s_num             I2S port number\n\n @param src                 Source address to write from\n\n @param size                Size of data in bytes\n\n @param src_bits            Source audio bit\n\n @param aim_bits            Bit wanted, no more than 32, and must be greater than src_bits\n\n @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in.\n\n @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this\n many ticks pass without space becoming available in the DMA\n transmit buffer, then the function will return (note that if the\n data is written to the DMA buffer in pieces, the overall operation\n may still take longer than this timeout.) Pass portMAX_DELAY for no\n timeout.\n\n Format of the data in source buffer is determined by the I2S\n configuration (see i2s_config_t).\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_write_expand(
        i2s_num: i2s_port_t,
        src: *const ::core::ffi::c_void,
        size: usize,
        src_bits: usize,
        aim_bits: usize,
        bytes_written: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from I2S DMA receive buffer\n\n @param i2s_num         I2S port number\n\n @param dest            Destination address to read into\n\n @param size            Size of data in bytes\n\n @param[out] bytes_read Number of bytes read, if timeout, bytes read will be less than the size passed in.\n\n @param ticks_to_wait   RX buffer wait timeout in RTOS ticks. If this many ticks pass without bytes becoming available in the DMA receive buffer, then the function will return (note that if data is read from the DMA buffer in pieces, the overall operation may still take longer than this timeout.) Pass portMAX_DELAY for no timeout.\n\n @note If the built-in ADC mode is enabled, we should call i2s_adc_enable and i2s_adc_disable around the whole reading process,\n       to prevent the data getting corrupted.\n\n @return\n     - ESP_OK               Success\n     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_read(
        i2s_num: i2s_port_t,
        dest: *mut ::core::ffi::c_void,
        size: usize,
        bytes_read: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set sample rate used for I2S RX and TX.\n\n The bit clock rate is determined by the sample rate and i2s_config_t configuration parameters (number of channels, bits_per_sample).\n\n `bit_clock = rate * (number of channels) * bits_per_sample`\n\n @param i2s_num  I2S port number\n\n @param rate I2S sample rate (ex: 8000, 44100...)\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_sample_rates(i2s_num: i2s_port_t, rate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop I2S driver\n\n There is no need to call i2s_stop() before calling i2s_driver_uninstall().\n\n Disables I2S TX/RX, until i2s_start() is called.\n\n @param i2s_num  I2S port number\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_stop(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start I2S driver\n\n It is not necessary to call this function after i2s_driver_install() (it is started automatically), however it is necessary to call it after i2s_stop().\n\n\n @param i2s_num  I2S port number\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_start(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Zero the contents of the TX DMA buffer.\n\n Pushes zero-byte samples into the TX DMA buffer, until it is full.\n\n @param i2s_num  I2S port number\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_zero_dma_buffer(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure I2S a/u-law decompress or compress\n\n @note  This function should be called after i2s driver installed\n        Only take effecttive when the i2s 'communication_format' is set to 'I2S_COMM_FORMAT_STAND_PCM_SHORT' or 'I2S_COMM_FORMAT_STAND_PCM_LONG'\n\n @param i2s_num  I2S port number\n\n @param pcm_cfg  including mode selection and a/u-law decompress or compress configuration paramater\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_pcm_config(i2s_num: i2s_port_t, pcm_cfg: *const i2s_pcm_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set clock & bit width used for I2S RX and TX.\n\n Similar to i2s_set_sample_rates(), but also sets bit width.\n\n 1. stop i2s;\n 2. calculate mclk, bck, bck_factor\n 3. malloc dma buffer;\n 4. start i2s\n\n @param i2s_num  I2S port number\n\n @param rate I2S sample rate (ex: 8000, 44100...)\n\n @param bits_cfg I2S bits configuration\n             the low 16 bits is for data bits per sample in one channel (see 'i2s_bits_per_sample_t')\n             the high 16 bits is for total bits in one channel (see 'i2s_bits_per_chan_t')\n             high 16bits =0 means same as the bits per sample.\n\n @param ch I2S channel, (I2S_CHANNEL_MONO, I2S_CHANNEL_STEREO or specific channel in TDM mode)\n\n @return\n     - ESP_OK              Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_clk(
        i2s_num: i2s_port_t,
        rate: u32,
        bits_cfg: u32,
        ch: i2s_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get clock set on particular port number.\n\n @param i2s_num  I2S port number\n\n @return\n     - actual clock set by i2s driver"]
    pub fn i2s_get_clk(i2s_num: i2s_port_t) -> f32;
}
#[doc = "< LEDC low speed speed_mode"]
pub const ledc_mode_t_LEDC_LOW_SPEED_MODE: ledc_mode_t = 0;
#[doc = "< LEDC speed limit"]
pub const ledc_mode_t_LEDC_SPEED_MODE_MAX: ledc_mode_t = 1;
pub type ledc_mode_t = ::core::ffi::c_uint;
#[doc = "< Disable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_DISABLE: ledc_intr_type_t = 0;
#[doc = "< Enable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_FADE_END: ledc_intr_type_t = 1;
pub const ledc_intr_type_t_LEDC_INTR_MAX: ledc_intr_type_t = 2;
pub type ledc_intr_type_t = ::core::ffi::c_uint;
#[doc = "< LEDC duty decrease direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_DECREASE: ledc_duty_direction_t = 0;
#[doc = "< LEDC duty increase direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_INCREASE: ledc_duty_direction_t = 1;
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_MAX: ledc_duty_direction_t = 2;
pub type ledc_duty_direction_t = ::core::ffi::c_uint;
#[doc = "< LEDC low speed timer clock source is 8MHz RTC clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_RTC8M: ledc_slow_clk_sel_t = 0;
#[doc = "< LEDC low speed timer clock source is 80MHz APB clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_APB: ledc_slow_clk_sel_t = 1;
#[doc = "< LEDC low speed timer clock source XTAL clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_XTAL: ledc_slow_clk_sel_t = 2;
pub type ledc_slow_clk_sel_t = ::core::ffi::c_uint;
#[doc = "< The driver will automatically select the source clock based on the giving resolution and duty parameter when init the timer"]
pub const ledc_clk_cfg_t_LEDC_AUTO_CLK: ledc_clk_cfg_t = 0;
#[doc = "< LEDC timer select APB clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_APB_CLK: ledc_clk_cfg_t = 1;
#[doc = "< LEDC timer select RTC8M_CLK as source clock. Only for low speed channels and this parameter must be the same for all low speed channels"]
pub const ledc_clk_cfg_t_LEDC_USE_RTC8M_CLK: ledc_clk_cfg_t = 2;
#[doc = "< LEDC timer select XTAL clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_XTAL_CLK: ledc_clk_cfg_t = 3;
#[doc = " In theory, the following enumeration shall be placed in LEDC driver's header.\n However, as the next enumeration, `ledc_clk_src_t`, makes the use of some of\n these values and to avoid mutual inclusion of the headers, we must define it\n here."]
pub type ledc_clk_cfg_t = ::core::ffi::c_uint;
#[doc = "< LEDC timer clock divided from APB clock (80Mhz)"]
pub const ledc_clk_src_t_LEDC_APB_CLK: ledc_clk_src_t = 1;
#[doc = "< Selecting this value for LEDC_TICK_SEL_TIMER let the hardware take its source clock from LEDC_APB_CLK_SEL"]
pub const ledc_clk_src_t_LEDC_SCLK: ledc_clk_src_t = 1;
pub type ledc_clk_src_t = ::core::ffi::c_uint;
#[doc = "< LEDC timer 0"]
pub const ledc_timer_t_LEDC_TIMER_0: ledc_timer_t = 0;
#[doc = "< LEDC timer 1"]
pub const ledc_timer_t_LEDC_TIMER_1: ledc_timer_t = 1;
#[doc = "< LEDC timer 2"]
pub const ledc_timer_t_LEDC_TIMER_2: ledc_timer_t = 2;
#[doc = "< LEDC timer 3"]
pub const ledc_timer_t_LEDC_TIMER_3: ledc_timer_t = 3;
pub const ledc_timer_t_LEDC_TIMER_MAX: ledc_timer_t = 4;
pub type ledc_timer_t = ::core::ffi::c_uint;
#[doc = "< LEDC channel 0"]
pub const ledc_channel_t_LEDC_CHANNEL_0: ledc_channel_t = 0;
#[doc = "< LEDC channel 1"]
pub const ledc_channel_t_LEDC_CHANNEL_1: ledc_channel_t = 1;
#[doc = "< LEDC channel 2"]
pub const ledc_channel_t_LEDC_CHANNEL_2: ledc_channel_t = 2;
#[doc = "< LEDC channel 3"]
pub const ledc_channel_t_LEDC_CHANNEL_3: ledc_channel_t = 3;
#[doc = "< LEDC channel 4"]
pub const ledc_channel_t_LEDC_CHANNEL_4: ledc_channel_t = 4;
#[doc = "< LEDC channel 5"]
pub const ledc_channel_t_LEDC_CHANNEL_5: ledc_channel_t = 5;
pub const ledc_channel_t_LEDC_CHANNEL_MAX: ledc_channel_t = 6;
pub type ledc_channel_t = ::core::ffi::c_uint;
#[doc = "< LEDC PWM duty resolution of  1 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_1_BIT: ledc_timer_bit_t = 1;
#[doc = "< LEDC PWM duty resolution of  2 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_2_BIT: ledc_timer_bit_t = 2;
#[doc = "< LEDC PWM duty resolution of  3 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_3_BIT: ledc_timer_bit_t = 3;
#[doc = "< LEDC PWM duty resolution of  4 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_4_BIT: ledc_timer_bit_t = 4;
#[doc = "< LEDC PWM duty resolution of  5 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_5_BIT: ledc_timer_bit_t = 5;
#[doc = "< LEDC PWM duty resolution of  6 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_6_BIT: ledc_timer_bit_t = 6;
#[doc = "< LEDC PWM duty resolution of  7 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_7_BIT: ledc_timer_bit_t = 7;
#[doc = "< LEDC PWM duty resolution of  8 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_8_BIT: ledc_timer_bit_t = 8;
#[doc = "< LEDC PWM duty resolution of  9 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_9_BIT: ledc_timer_bit_t = 9;
#[doc = "< LEDC PWM duty resolution of 10 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_10_BIT: ledc_timer_bit_t = 10;
#[doc = "< LEDC PWM duty resolution of 11 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_11_BIT: ledc_timer_bit_t = 11;
#[doc = "< LEDC PWM duty resolution of 12 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_12_BIT: ledc_timer_bit_t = 12;
#[doc = "< LEDC PWM duty resolution of 13 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_13_BIT: ledc_timer_bit_t = 13;
#[doc = "< LEDC PWM duty resolution of 14 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_14_BIT: ledc_timer_bit_t = 14;
pub const ledc_timer_bit_t_LEDC_TIMER_BIT_MAX: ledc_timer_bit_t = 15;
pub type ledc_timer_bit_t = ::core::ffi::c_uint;
#[doc = "< LEDC fade function will return immediately"]
pub const ledc_fade_mode_t_LEDC_FADE_NO_WAIT: ledc_fade_mode_t = 0;
#[doc = "< LEDC fade function will block until fading to the target duty"]
pub const ledc_fade_mode_t_LEDC_FADE_WAIT_DONE: ledc_fade_mode_t = 1;
pub const ledc_fade_mode_t_LEDC_FADE_MAX: ledc_fade_mode_t = 2;
pub type ledc_fade_mode_t = ::core::ffi::c_uint;
#[doc = " @brief Configuration parameters of LEDC channel for ledc_channel_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_channel_config_t {
    #[doc = "< the LEDC output gpio_num, if you want to use gpio16, gpio_num = 16"]
    pub gpio_num: ::core::ffi::c_int,
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    #[doc = "< LEDC channel (0 - 7)"]
    pub channel: ledc_channel_t,
    #[doc = "< configure interrupt, Fade interrupt enable  or Fade interrupt disable"]
    pub intr_type: ledc_intr_type_t,
    #[doc = "< Select the timer source of channel (0 - 3)"]
    pub timer_sel: ledc_timer_t,
    #[doc = "< LEDC channel duty, the range of duty setting is [0, (2**duty_resolution)]"]
    pub duty: u32,
    #[doc = "< LEDC channel hpoint value, the max value is 0xfffff"]
    pub hpoint: ::core::ffi::c_int,
    #[doc = "< LEDC flags"]
    pub flags: ledc_channel_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ledc_channel_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ledc_channel_config_t__bindgen_ty_1 {
    #[inline]
    pub fn output_invert(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output_invert(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        output_invert: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let output_invert: u32 = unsafe { ::core::mem::transmute(output_invert) };
            output_invert as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for ledc_channel_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Configuration parameters of LEDC Timer timer for ledc_timer_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_timer_config_t {
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    #[doc = "< LEDC channel duty resolution"]
    pub duty_resolution: ledc_timer_bit_t,
    #[doc = "< The timer source of channel (0 - 3)"]
    pub timer_num: ledc_timer_t,
    #[doc = "< LEDC timer frequency (Hz)"]
    pub freq_hz: u32,
    #[doc = "< Configure LEDC source clock from ledc_clk_cfg_t.\nNote that LEDC_USE_RTC8M_CLK and LEDC_USE_XTAL_CLK are\nnon-timer-specific clock sources. You can not have one LEDC timer uses\nRTC8M_CLK as the clock source and have another LEDC timer uses XTAL_CLK\nas its clock source. All chips except esp32 and esp32s2 do not have\ntimer-specific clock sources, which means clock source for all timers\nmust be the same one."]
    pub clk_cfg: ledc_clk_cfg_t,
}
impl Default for ledc_timer_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ledc_isr_handle_t = intr_handle_t;
#[doc = "< LEDC fade end event"]
pub const ledc_cb_event_t_LEDC_FADE_END_EVT: ledc_cb_event_t = 0;
#[doc = " @brief LEDC callback event type"]
pub type ledc_cb_event_t = ::core::ffi::c_uint;
#[doc = " @brief LEDC callback parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_cb_param_t {
    #[doc = "< Event name"]
    pub event: ledc_cb_event_t,
    #[doc = "< Speed mode of the LEDC channel group"]
    pub speed_mode: u32,
    #[doc = "< LEDC channel (0 - LEDC_CHANNEL_MAX-1)"]
    pub channel: u32,
    #[doc = "< LEDC current duty of the channel, the range of duty is [0, (2**duty_resolution) - 1]"]
    pub duty: u32,
}
impl Default for ledc_cb_param_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Type of LEDC event callback\n @param param LEDC callback parameter\n @param user_arg User registered data\n @return Whether a high priority task has been waken up by this function"]
pub type ledc_cb_t = ::core::option::Option<
    unsafe extern "C" fn(param: *const ledc_cb_param_t, user_arg: *mut ::core::ffi::c_void) -> bool,
>;
#[doc = " @brief Group of supported LEDC callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ledc_cbs_t {
    #[doc = "< LEDC fade_end callback function"]
    pub fade_cb: ledc_cb_t,
}
extern "C" {
    #[doc = " @brief LEDC channel configuration\n        Configure LEDC channel with the given channel/output gpio_num/interrupt/source timer/frequency(Hz)/LEDC duty resolution\n\n @param ledc_conf Pointer of LEDC channel configure struct\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_channel_config(ledc_conf: *const ledc_channel_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC timer configuration\n        Configure LEDC timer with the given source timer/frequency(Hz)/duty_resolution\n\n @param  timer_conf Pointer of LEDC timer configure struct\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_timer_config(timer_conf: *const ledc_timer_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC update channel parameters\n @note  Call this function to activate the LEDC updated parameters.\n        After ledc_set_duty, we need to call this function to update the settings.\n        And the new LEDC parameters don't take effect until the next PWM cycle.\n @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to\n        control one LEDC channel in different tasks at the same time.\n        A thread-safe version of API is ledc_set_duty_and_update\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n"]
    pub fn ledc_update_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC output gpio.\n\n @note This function only routes the LEDC signal to GPIO through matrix, other LEDC resources initialization are not involved.\n       Please use `ledc_channel_config()` instead to fully configure a LEDC channel.\n\n @param  gpio_num The LEDC output gpio\n @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param  ledc_channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_pin(
        gpio_num: ::core::ffi::c_int,
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC stop.\n        Disable LEDC output, and set idle level\n\n @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param  channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param  idle_level Set output idle level after LEDC stops.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_stop(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        idle_level: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC set channel frequency (Hz)\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param  timer_num LEDC timer index (0-3), select from ledc_timer_t\n @param  freq_hz Set the LEDC frequency\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_set_freq(
        speed_mode: ledc_mode_t,
        timer_num: ledc_timer_t,
        freq_hz: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      LEDC get channel frequency (Hz)\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param timer_num LEDC timer index (0-3), select from ledc_timer_t\n\n @return\n     - 0  error\n     - Others Current LEDC frequency"]
    pub fn ledc_get_freq(speed_mode: ledc_mode_t, timer_num: ledc_timer_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set duty and hpoint value\n        Only after calling ledc_update_duty will the duty update.\n @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to\n        control one LEDC channel in different tasks at the same time.\n        A thread-safe version of API is ledc_set_duty_and_update\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution) - 1]\n @param hpoint Set the LEDC hpoint value(max: 0xfffff)\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty_with_hpoint(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get hpoint value, the counter value when the output is set high level.\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @return\n     - LEDC_ERR_VAL if parameter error\n     - Others Current hpoint value of LEDC channel"]
    pub fn ledc_get_hpoint(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief LEDC set duty\n        This function do not change the hpoint value of this channel. if needed, please call ledc_set_duty_with_hpoint.\n        only after calling ledc_update_duty will the duty update.\n @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to\n        control one LEDC channel in different tasks at the same time.\n        A thread-safe version of API is ledc_set_duty_and_update.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution) - 1]\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t, duty: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get duty\n        This function returns the duty at the present PWM cycle.\n        You shouldn't expect the function to return the new duty in the same cycle of calling ledc_update_duty,\n        because duty update doesn't take effect until the next cycle.\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n\n @return\n     - LEDC_ERR_DUTY if parameter error\n     - Others Current LEDC duty"]
    pub fn ledc_get_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set gradient\n        Set LEDC gradient, After the function calls the ledc_update_duty function, the function can take effect.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param duty Set the start of the gradient duty, the range of duty setting is [0, (2**duty_resolution) - 1]\n @param fade_direction Set the direction of the gradient\n @param step_num Set the number of the gradient\n @param duty_cycle_num Set how many LEDC tick each time the gradient lasts\n @param duty_scale Set gradient change amplitude\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_fade(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        fade_direction: ledc_duty_direction_t,
        step_num: u32,
        duty_cycle_num: u32,
        duty_scale: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register LEDC interrupt handler, the handler is an ISR.\n        The handler will be attached to the same CPU core that this function is running on.\n\n @param fn Interrupt handler function.\n @param arg User-supplied argument passed to the handler function.\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will\n        be returned here.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Function pointer error."]
    pub fn ledc_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::core::ffi::c_int,
        handle: *mut ledc_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure LEDC settings\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param timer_sel  Timer index (0-3), there are 4 timers in LEDC module\n @param clock_divider Timer clock divide value, the timer clock is divided from the selected clock source\n @param duty_resolution Resolution of duty setting in number of bits. The range of duty values is [0, (2**duty_resolution)]\n @param clk_src Select LEDC source clock.\n\n @return\n     - (-1) Parameter error\n     - Other Current LEDC duty"]
    pub fn ledc_timer_set(
        speed_mode: ledc_mode_t,
        timer_sel: ledc_timer_t,
        clock_divider: u32,
        duty_resolution: u32,
        clk_src: ledc_clk_src_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset LEDC timer\n\n @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn ledc_timer_rst(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause LEDC timer counter\n\n @param  speed_mode  Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n"]
    pub fn ledc_timer_pause(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Resume LEDC timer\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param timer_sel LEDC timer index (0-3), select from ledc_timer_t\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn ledc_timer_resume(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Bind LEDC channel with the selected timer\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param timer_sel LEDC timer index (0-3), select from ledc_timer_t\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn ledc_bind_channel_timer(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        timer_sel: ledc_timer_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function.\n @note  Call ledc_fade_func_install() once before calling this function.\n        Call ledc_fade_start() after this to start fading.\n @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to\n        control one LEDC channel in different tasks at the same time.\n        A thread-safe version of API is ledc_set_fade_step_and_start\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode. ,\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]\n @param scale Controls the increase or decrease step scale.\n @param cycle_num increase or decrease the duty every cycle_num cycles\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_step(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function, with a limited time.\n @note  Call ledc_fade_func_install() once before calling this function.\n        Call ledc_fade_start() after this to start fading.\n @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to\n        control one LEDC channel in different tasks at the same time.\n        A thread-safe version of API is ledc_set_fade_step_and_start\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode. ,\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]\n @param max_fade_time_ms The maximum time of the fading ( ms ).\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_time(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install LEDC fade function. This function will occupy interrupt of LEDC module.\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function already installed."]
    pub fn ledc_fade_func_install(intr_alloc_flags: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall LEDC fade function.\n"]
    pub fn ledc_fade_func_uninstall();
}
extern "C" {
    #[doc = " @brief Start LEDC fading.\n @note  Call ledc_fade_func_install() once before calling this function.\n        Call this API right after ledc_set_fade_with_time or ledc_set_fade_with_step before to start fading.\n @note  Starting fade operation with this API is not thread-safe, use with care.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel number\n @param fade_mode Whether to block until fading done. See ledc_types.h ledc_fade_mode_t for more info.\n        Note that this function will not return until fading to the target duty if LEDC_FADE_WAIT_DONE mode is selected.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_ERR_INVALID_ARG Parameter error."]
    pub fn ledc_fade_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop LEDC fading. Duty of the channel will stay at its present vlaue.\n @note  This API can be called if a new fixed duty or a new fade want to be set while the last fade operation is still running in progress.\n @note  Call this API will abort the fading operation only if it was started by calling ledc_fade_start with LEDC_FADE_NO_WAIT mode.\n @note  If a fade was started with LEDC_FADE_WAIT_DONE mode, calling this API afterwards is no use in stopping the fade. Fade will continue until it reachs the target duty.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel number\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_ERR_INVALID_ARG Parameter error."]
    pub fn ledc_fade_stop(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set duty for LEDC channel and return when duty updated.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution) - 1]\n @param hpoint Set the LEDC hpoint value(max: 0xfffff)\n"]
    pub fn ledc_set_duty_and_update(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function, with a limited time.\n @note  Call ledc_fade_func_install() once, before calling this function.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]\n @param max_fade_time_ms The maximum time of the fading ( ms ).\n @param fade_mode choose blocking or non-blocking mode\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_time_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function.\n @note  Call ledc_fade_func_install() once before calling this function.\n @note  For ESP32, hardware does not support any duty change while a fade operation is running in progress on that channel.\n        Other duty operations will have to wait until the fade operation has finished.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]\n @param scale Controls the increase or decrease step scale.\n @param cycle_num increase or decrease the duty every cycle_num cycles\n @param fade_mode choose blocking or non-blocking mode\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_step_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC callback registration function\n @note  The callback is called from an ISR, it must never attempt to block, and any FreeRTOS API called must be ISR capable.\n @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode.\n @param channel LEDC channel index (0 - LEDC_CHANNEL_MAX-1), select from ledc_channel_t\n @param cbs Group of LEDC callback functions\n @param user_arg user registered data for the callback function\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE Fade function not installed.\n     - ESP_FAIL Fade function init error"]
    pub fn ledc_cb_register(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        cbs: *mut ledc_cbs_t,
        user_arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief Group of I2S callbacks\n @note The callbacks are all running under ISR environment\n @note When CONFIG_I2S_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM.\n       The variables used in the function should be in the SRAM as well."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_event_callbacks_t {
    #[doc = "< Callback of data received event, only for rx channel\n   The event data includes DMA buffer address and size that just finished receiving data"]
    pub on_recv: i2s_isr_callback_t,
    #[doc = "< Callback of receiving queue overflowed event, only for rx channel\n   The event data includes buffer size that has been overwritten"]
    pub on_recv_q_ovf: i2s_isr_callback_t,
    #[doc = "< Callback of data sent event, only for tx channel\n   The event data includes DMA buffer address and size that just finished sending data"]
    pub on_sent: i2s_isr_callback_t,
    #[doc = "< Callback of sending queue overflowed event, only for tx channel\n   The event data includes buffer size that has been overwritten"]
    pub on_send_q_ovf: i2s_isr_callback_t,
}
#[doc = " @brief I2S controller channel configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_chan_config_t {
    #[doc = "< I2S port id"]
    pub id: i2s_port_t,
    #[doc = "< I2S role, I2S_ROLE_MASTER or I2S_ROLE_SLAVE"]
    pub role: i2s_role_t,
    #[doc = "< I2S DMA buffer number, it is also the number of DMA descriptor"]
    pub dma_desc_num: u32,
    #[doc = "< I2S frame number in one DMA buffer. One frame means one-time sample data in all slots,\n   it should be the multiple of '3' when the data bit width is 24."]
    pub dma_frame_num: u32,
    #[doc = "< Set to auto clear DMA TX buffer, i2s will always send zero automatically if no data to send"]
    pub auto_clear: bool,
}
impl Default for i2s_chan_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S channel information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_chan_info_t {
    #[doc = "< I2S port id"]
    pub id: i2s_port_t,
    #[doc = "< I2S role, I2S_ROLE_MASTER or I2S_ROLE_SLAVE"]
    pub role: i2s_role_t,
    #[doc = "< I2S channel direction"]
    pub dir: i2s_dir_t,
    #[doc = "< I2S channel communication mode"]
    pub mode: i2s_comm_mode_t,
    #[doc = "< I2S pair channel handle in duplex mode, always NULL in simplex mode"]
    pub pair_chan: i2s_chan_handle_t,
}
impl Default for i2s_chan_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Allocate new I2S channel(s)\n @note  The new created I2S channel handle will be REGISTERED state after it is allocated successfully.\n @note  When the port id in channel configuration is I2S_NUM_AUTO, driver will allocate I2S port automatically\n        on one of the i2s controller, otherwise driver will try to allocate the new channel on the selected port.\n @note  If both tx_handle and rx_handle are not NULL, it means this I2S controller will work at full-duplex mode,\n        the rx and tx channels will be allocated on a same I2S port in this case.\n        Note that some configurations of tx/rx channel are shared on ESP32 and ESP32S2,\n        so please make sure they are working at same condition and under same status(start/stop).\n        Currently, full-duplex mode can't guarantee tx/rx channels write/read synchronously,\n        they can only share the clock signals for now.\n @note  If tx_handle OR rx_handle is NULL, it means this I2S controller will work at simplex mode.\n        For ESP32 and ESP32S2, the whole I2S controller (i.e. both rx and tx channel) will be occupied,\n        even if only one of rx or tx channel is registered.\n        For the other targets, another channel on this controller will still available.\n\n @param[in]   chan_cfg    I2S controller channel configurations\n @param[out]  ret_tx_handle   I2S channel handler used for managing the sending channel(optional)\n @param[out]  ret_rx_handle   I2S channel handler used for managing the receiving channel(optional)\n @return\n      - ESP_OK    Allocate new channel(s) success\n      - ESP_ERR_NOT_SUPPORTED The communication mode is not supported on the current chip\n      - ESP_ERR_INVALID_ARG   NULL pointer or illegal parameter in i2s_chan_config_t\n      - ESP_ERR_NOT_FOUND     No available I2S channel found"]
    pub fn i2s_new_channel(
        chan_cfg: *const i2s_chan_config_t,
        ret_tx_handle: *mut i2s_chan_handle_t,
        ret_rx_handle: *mut i2s_chan_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the i2s channel\n @note  Only allowed to be called when the i2s channel is at REGISTERED or READY state (i.e., it should stop before deleting it).\n @note  Resource will be free automatically if all channels in one port are deleted\n\n @param[in]   handle      I2S channel handler\n      - ESP_OK    Delete successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer"]
    pub fn i2s_del_channel(handle: i2s_chan_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get I2S channel information\n\n @param[in]   handle      I2S channel handler\n @param[out]  chan_info   I2S channel basic information\n @return\n      - ESP_OK    Get i2s channel information success\n      - ESP_ERR_NOT_FOUND     The input handle doesn't match any registered I2S channels, it may not an i2s channel handle or not available any more\n      - ESP_ERR_INVALID_ARG   The input handle or chan_info pointer is NULL"]
    pub fn i2s_channel_get_info(
        handle: i2s_chan_handle_t,
        chan_info: *mut i2s_chan_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the i2s channel\n @note  Only allowed to be called when the channel state is READY, (i.e., channel has been initialized, but not started)\n        the channel will enter RUNNING state once it is enabled successfully.\n @note  Enable the channel can start the I2S communication on hardware. It will start outputting bclk and ws signal.\n        For mclk signal, it will start to output when initialization is finished\n\n @param[in]   handle      I2S channel handler\n      - ESP_OK    Start successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer\n      - ESP_ERR_INVALID_STATE This channel has not initialized or already started"]
    pub fn i2s_channel_enable(handle: i2s_chan_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable the i2s channel\n @note  Only allowed to be called when the channel state is READY / RUNNING, (i.e., channel has been initialized)\n        the channel will enter READY state once it is disabled successfully.\n @note  Disable the channel can stop the I2S communication on hardware. It will stop bclk and ws signal but not mclk signal\n\n @param[in]   handle      I2S channel handler\n @return\n      - ESP_OK    Stop successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer\n      - ESP_ERR_INVALID_STATE This channel has not stated"]
    pub fn i2s_channel_disable(handle: i2s_chan_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2S write data\n @note  Only allowed to be called when the channel state is RUNNING, (i.e., tx channel has been started and is not writing now)\n        but the RUNNING only stands for the software state, it doesn't mean there is no the signal transporting on line.\n\n @param[in]   handle      I2S channel handler\n @param[in]   src         The pointer of sent data buffer\n @param[in]   size        Max data buffer length\n @param[out]  bytes_written   Byte number that actually be sent\n @param[in]   timeout_ms      Max block time\n @return\n      - ESP_OK    Write successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer or this handle is not tx handle\n      - ESP_ERR_TIMEOUT       Writing timeout, no writing event received from ISR within ticks_to_wait\n      - ESP_ERR_INVALID_STATE I2S is not ready to write"]
    pub fn i2s_channel_write(
        handle: i2s_chan_handle_t,
        src: *const ::core::ffi::c_void,
        size: usize,
        bytes_written: *mut usize,
        timeout_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2S read data\n @note  Only allowed to be called when the channel state is RUNNING\n        but the RUNNING only stands for the software state, it doesn't mean there is no the signal transporting on line.\n\n @param[in]   handle      I2S channel handler\n @param[in]   dest        The pointer of receiving data buffer\n @param[in]   size        Max data buffer length\n @param[out]  bytes_read      Byte number that actually be read\n @param[in]   timeout_ms      Max block time\n @return\n      - ESP_OK    Read successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer or this handle is not rx handle\n      - ESP_ERR_TIMEOUT       Reading timeout, no reading event received from ISR within ticks_to_wait\n      - ESP_ERR_INVALID_STATE I2S is not ready to read"]
    pub fn i2s_channel_read(
        handle: i2s_chan_handle_t,
        dest: *mut ::core::ffi::c_void,
        size: usize,
        bytes_read: *mut usize,
        timeout_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set event callbacks for I2S channel\n\n @note Only allowed to be called when the channel state is REGISTARED / READY, (i.e., before channel starts)\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `callbacks` structure to NULL.\n @note When CONFIG_I2S_ISR_IRAM_SAFE is enabled, the callback itself and functions called by it should be placed in IRAM.\n       The variables used in the function should be in the SRAM as well. The `user_data` should also reside in SRAM or internal RAM as well.\n\n @param[in] handle        I2S channel handler\n @param[in] callbacks     Group of callback functions\n @param[in] user_data     User data, which will be passed to callback functions directly\n @return\n      - ESP_OK                Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG   Set event callbacks failed because of invalid argument\n      - ESP_ERR_INVALID_STATE Set event callbacks failed because the current channel state is not REGISTARED or READY"]
    pub fn i2s_channel_register_event_callback(
        handle: i2s_chan_handle_t,
        callbacks: *const i2s_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief I2S slot configuration for pdm tx mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pdm_tx_slot_config_t {
    #[doc = "< I2S sample data bit width (valid data bits per sample), only support 16 bits for PDM mode"]
    pub data_bit_width: i2s_data_bit_width_t,
    #[doc = "< I2S slot bit width (total bits per slot), only support 16 bits for PDM mode"]
    pub slot_bit_width: i2s_slot_bit_width_t,
    #[doc = "< Set mono or stereo mode with I2S_SLOT_MODE_MONO or I2S_SLOT_MODE_STEREO\n   For PDM TX mode, mono means the data buffer only contains one slot data,\n   Stereo means the data buffer contains two slots data"]
    pub slot_mode: i2s_slot_mode_t,
    #[doc = "< Sigma-delta filter prescale"]
    pub sd_prescale: u32,
    #[doc = "< Sigma-delta filter scaling value"]
    pub sd_scale: i2s_pdm_sig_scale_t,
    #[doc = "< High pass filter scaling value"]
    pub hp_scale: i2s_pdm_sig_scale_t,
    #[doc = "< Low pass filter scaling value"]
    pub lp_scale: i2s_pdm_sig_scale_t,
    #[doc = "< Sinc filter scaling value"]
    pub sinc_scale: i2s_pdm_sig_scale_t,
    #[doc = "< PDM TX line mode, one-line codec, one-line dac, two-line dac mode can be selected"]
    pub line_mode: i2s_pdm_tx_line_mode_t,
    #[doc = "< High pass filter enable"]
    pub hp_en: bool,
    #[doc = "< High pass filter cut-off frequency, range 23.3Hz ~ 185Hz, see cut-off frequency sheet above"]
    pub hp_cut_off_freq_hz: f32,
    #[doc = "< Sigma-delta filter dither"]
    pub sd_dither: u32,
    #[doc = "< Sigma-delta filter dither2"]
    pub sd_dither2: u32,
}
impl Default for i2s_pdm_tx_slot_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S clock configuration for pdm tx mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pdm_tx_clk_config_t {
    #[doc = "< I2S sample rate, not suggest to exceed 48000 Hz, otherwise more glitches and noise may appear"]
    pub sample_rate_hz: u32,
    #[doc = "< Choose clock source"]
    pub clk_src: i2s_clock_src_t,
    #[doc = "< The multiple of mclk to the sample rate"]
    pub mclk_multiple: i2s_mclk_multiple_t,
    #[doc = "< Up-sampling param fp"]
    pub up_sample_fp: u32,
    #[doc = "< Up-sampling param fs, not allowed to be greater than 480"]
    pub up_sample_fs: u32,
}
impl Default for i2s_pdm_tx_clk_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S PDM tx mode GPIO pins configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pdm_tx_gpio_config_t {
    #[doc = "< PDM clk pin, output"]
    pub clk: gpio_num_t,
    #[doc = "< DATA pin, output"]
    pub dout: gpio_num_t,
    #[doc = "< The second data pin for the DAC dual-line mode,\n   only take effect when the line mode is `I2S_PDM_TX_TWO_LINE_DAC`"]
    pub dout2: gpio_num_t,
    #[doc = "< GPIO pin invert flags"]
    pub invert_flags: i2s_pdm_tx_gpio_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_pdm_tx_gpio_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl i2s_pdm_tx_gpio_config_t__bindgen_ty_1 {
    #[inline]
    pub fn clk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(clk_inv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clk_inv: u32 = unsafe { ::core::mem::transmute(clk_inv) };
            clk_inv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_pdm_tx_gpio_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S PDM TX mode major configuration that including clock/slot/gpio configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pdm_tx_config_t {
    #[doc = "< PDM TX clock configurations, can be generated by macro I2S_PDM_TX_CLK_DEFAULT_CONFIG"]
    pub clk_cfg: i2s_pdm_tx_clk_config_t,
    #[doc = "< PDM TX slot configurations, can be generated by macro I2S_PDM_TX_SLOT_DEFAULT_CONFIG"]
    pub slot_cfg: i2s_pdm_tx_slot_config_t,
    #[doc = "< PDM TX gpio configurations, specified by user"]
    pub gpio_cfg: i2s_pdm_tx_gpio_config_t,
}
impl Default for i2s_pdm_tx_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize i2s channel to PDM TX mode\n @note  Only allowed to be called when the channel state is REGISTERED, (i.e., channel has been allocated, but not initialized)\n        and the state will be updated to READY if initialization success, otherwise the state will return to REGISTERED.\n\n @param[in]   handle      I2S tx channel handler\n @param[in]   pdm_tx_cfg  Configurations for PDM TX mode, including clock, slot and gpio\n                          The clock configuration can be generated by the helper macro `I2S_PDM_TX_CLK_DEFAULT_CONFIG`\n                          The slot configuration can be generated by the helper macro `I2S_PDM_TX_SLOT_DEFAULT_CONFIG`\n\n @return\n      - ESP_OK    Initialize successfully\n      - ESP_ERR_NO_MEM        No memory for storing the channel information\n      - ESP_ERR_INVALID_ARG   NULL pointer or invalid configuration\n      - ESP_ERR_INVALID_STATE This channel is not registered"]
    pub fn i2s_channel_init_pdm_tx_mode(
        handle: i2s_chan_handle_t,
        pdm_tx_cfg: *const i2s_pdm_tx_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S clock for PDM TX mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to PDM TX mode, i.e., 'i2s_channel_init_pdm_tx_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S tx channel handler\n @param[in]   clk_cfg     PDM TX mode clock configuration, can be generated by `I2S_PDM_TX_CLK_DEFAULT_CONFIG`\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration or not PDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_pdm_tx_clock(
        handle: i2s_chan_handle_t,
        clk_cfg: *const i2s_pdm_tx_clk_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S slot for PDM TX mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to PDM TX mode, i.e., 'i2s_channel_init_pdm_tx_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S tx channel handler\n @param[in]   slot_cfg    PDM TX mode slot configuration, can be generated by `I2S_PDM_TX_SLOT_DEFAULT_CONFIG`\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_NO_MEM        No memory for DMA buffer\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not PDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_pdm_tx_slot(
        handle: i2s_chan_handle_t,
        slot_cfg: *const i2s_pdm_tx_slot_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S gpio for PDM TX mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to PDM TX mode, i.e., 'i2s_channel_init_pdm_tx_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S tx channel handler\n @param[in]   gpio_cfg    PDM TX mode gpio configuration, specified by user\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not PDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_pdm_tx_gpio(
        handle: i2s_chan_handle_t,
        gpio_cfg: *const i2s_pdm_tx_gpio_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief I2S slot configuration for standard mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_std_slot_config_t {
    #[doc = "< I2S sample data bit width (valid data bits per sample)"]
    pub data_bit_width: i2s_data_bit_width_t,
    #[doc = "< I2S slot bit width (total bits per slot)"]
    pub slot_bit_width: i2s_slot_bit_width_t,
    #[doc = "< Set mono or stereo mode with I2S_SLOT_MODE_MONO or I2S_SLOT_MODE_STEREO\n   In TX direction, mono means the written buffer contains only one slot data\n   and stereo means the written buffer contains both left and right data"]
    pub slot_mode: i2s_slot_mode_t,
    #[doc = "< Select the left, right or both slot"]
    pub slot_mask: i2s_std_slot_mask_t,
    #[doc = "< WS signal width (i.e. the number of bclk ticks that ws signal is high)"]
    pub ws_width: u32,
    #[doc = "< WS signal polarity, set true to enable high lever first"]
    pub ws_pol: bool,
    #[doc = "< Set to enable bit shift in Philips mode"]
    pub bit_shift: bool,
    #[doc = "< Set to enable left alignment"]
    pub left_align: bool,
    #[doc = "< Set to enable big endian"]
    pub big_endian: bool,
    #[doc = "< Set to enable lsb first"]
    pub bit_order_lsb: bool,
}
impl Default for i2s_std_slot_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S clock configuration for standard mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_std_clk_config_t {
    #[doc = "< I2S sample rate"]
    pub sample_rate_hz: u32,
    #[doc = "< Choose clock source"]
    pub clk_src: i2s_clock_src_t,
    #[doc = "< The multiple of mclk to the sample rate\n   Default is 256 in the helper macro, it can satisfy most of cases,\n   but please set this field a multiple of '3' (like 384) when using 24-bit data width,\n   otherwise the sample rate might be inaccurate"]
    pub mclk_multiple: i2s_mclk_multiple_t,
}
impl Default for i2s_std_clk_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S standard mode GPIO pins configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_std_gpio_config_t {
    #[doc = "< MCK pin, output"]
    pub mclk: gpio_num_t,
    #[doc = "< BCK pin, input in slave role, output in master role"]
    pub bclk: gpio_num_t,
    #[doc = "< WS pin, input in slave role, output in master role"]
    pub ws: gpio_num_t,
    #[doc = "< DATA pin, output"]
    pub dout: gpio_num_t,
    #[doc = "< DATA pin, input"]
    pub din: gpio_num_t,
    #[doc = "< GPIO pin invert flags"]
    pub invert_flags: i2s_std_gpio_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_std_gpio_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl i2s_std_gpio_config_t__bindgen_ty_1 {
    #[inline]
    pub fn mclk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mclk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bclk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bclk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ws_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ws_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mclk_inv: u32,
        bclk_inv: u32,
        ws_inv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mclk_inv: u32 = unsafe { ::core::mem::transmute(mclk_inv) };
            mclk_inv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bclk_inv: u32 = unsafe { ::core::mem::transmute(bclk_inv) };
            bclk_inv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ws_inv: u32 = unsafe { ::core::mem::transmute(ws_inv) };
            ws_inv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_std_gpio_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S standard mode major configuration that including clock/slot/gpio configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_std_config_t {
    #[doc = "< Standard mode clock configuration, can be generated by macro I2S_STD_CLK_DEFAULT_CONFIG"]
    pub clk_cfg: i2s_std_clk_config_t,
    #[doc = "< Standard mode slot configuration, can be generated by macros I2S_STD_[mode]_SLOT_DEFAULT_CONFIG, [mode] can be replaced with PHILIPS/MSB/PCM"]
    pub slot_cfg: i2s_std_slot_config_t,
    #[doc = "< Standard mode gpio configuration, specified by user"]
    pub gpio_cfg: i2s_std_gpio_config_t,
}
impl Default for i2s_std_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize i2s channel to standard mode\n @note  Only allowed to be called when the channel state is REGISTERED, (i.e., channel has been allocated, but not initialized)\n        and the state will be updated to READY if initialization success, otherwise the state will return to REGISTERED.\n\n @param[in]   handle      I2S channel handler\n @param[in]   std_cfg     Configurations for standard mode, including clock, slot and gpio\n                          The clock configuration can be generated by the helper macro `I2S_STD_CLK_DEFAULT_CONFIG`\n                          The slot configuration can be generated by the helper macro `I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG`,\n                          `I2S_STD_PCM_SLOT_DEFAULT_CONFIG` or `I2S_STD_MSB_SLOT_DEFAULT_CONFIG`\n\n @return\n      - ESP_OK    Initialize successfully\n      - ESP_ERR_NO_MEM        No memory for storing the channel information\n      - ESP_ERR_INVALID_ARG   NULL pointer or invalid configuration\n      - ESP_ERR_INVALID_STATE This channel is not registered"]
    pub fn i2s_channel_init_std_mode(
        handle: i2s_chan_handle_t,
        std_cfg: *const i2s_std_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S clock for standard mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to standard mode, i.e., 'i2s_channel_init_std_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   clk_cfg     Standard mode clock configuration, can be generated by `I2S_STD_CLK_DEFAULT_CONFIG`\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration or not standard mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_std_clock(
        handle: i2s_chan_handle_t,
        clk_cfg: *const i2s_std_clk_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S slot for standard mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to standard mode, i.e., 'i2s_channel_init_std_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   slot_cfg    Standard mode slot configuration, can be generated by `I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG`,\n                          `I2S_STD_PCM_SLOT_DEFAULT_CONFIG` and `I2S_STD_MSB_SLOT_DEFAULT_CONFIG`.\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_NO_MEM        No memory for DMA buffer\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not standard mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_std_slot(
        handle: i2s_chan_handle_t,
        slot_cfg: *const i2s_std_slot_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S gpio for standard mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to standard mode, i.e., 'i2s_channel_init_std_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   gpio_cfg    Standard mode gpio configuration, specified by user\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not standard mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_std_gpio(
        handle: i2s_chan_handle_t,
        gpio_cfg: *const i2s_std_gpio_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief I2S slot configuration for tdm mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_tdm_slot_config_t {
    #[doc = "< I2S sample data bit width (valid data bits per sample)"]
    pub data_bit_width: i2s_data_bit_width_t,
    #[doc = "< I2S slot bit width (total bits per slot)"]
    pub slot_bit_width: i2s_slot_bit_width_t,
    #[doc = "< Set mono or stereo mode with I2S_SLOT_MODE_MONO or I2S_SLOT_MODE_STEREO"]
    pub slot_mode: i2s_slot_mode_t,
    #[doc = "< Slot mask. Activating slots by setting 1 to corresponding bits. When the activated slots is not consecutive, those data in inactivated slots will be ignored"]
    pub slot_mask: i2s_tdm_slot_mask_t,
    #[doc = "< WS signal width (i.e. the number of bclk ticks that ws signal is high)"]
    pub ws_width: u32,
    #[doc = "< WS signal polarity, set true to enable high lever first"]
    pub ws_pol: bool,
    #[doc = "< Set true to enable bit shift in Philips mode"]
    pub bit_shift: bool,
    #[doc = "< Set true to enable left alignment"]
    pub left_align: bool,
    #[doc = "< Set true to enable big endian"]
    pub big_endian: bool,
    #[doc = "< Set true to enable lsb first"]
    pub bit_order_lsb: bool,
    #[doc = "< Set true to enable skip mask. If it is enabled, only the data of the enabled channels will be sent, otherwise all data stored in DMA TX buffer will be sent"]
    pub skip_mask: bool,
    #[doc = "< I2S total number of slots. If it is smaller than the biggest activated channel number, it will be set to this number automatically."]
    pub total_slot: u32,
}
impl Default for i2s_tdm_slot_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S clock configuration for tdm mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_tdm_clk_config_t {
    #[doc = "< I2S sample rate"]
    pub sample_rate_hz: u32,
    #[doc = "< Choose clock source"]
    pub clk_src: i2s_clock_src_t,
    #[doc = "< The multiple of mclk to the sample rate"]
    pub mclk_multiple: i2s_mclk_multiple_t,
}
impl Default for i2s_tdm_clk_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S TDM mode GPIO pins configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_tdm_gpio_config_t {
    #[doc = "< MCK pin, output"]
    pub mclk: gpio_num_t,
    #[doc = "< BCK pin, input in slave role, output in master role"]
    pub bclk: gpio_num_t,
    #[doc = "< WS pin, input in slave role, output in master role"]
    pub ws: gpio_num_t,
    #[doc = "< DATA pin, output"]
    pub dout: gpio_num_t,
    #[doc = "< DATA pin, input"]
    pub din: gpio_num_t,
    #[doc = "< GPIO pin invert flags"]
    pub invert_flags: i2s_tdm_gpio_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_tdm_gpio_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl i2s_tdm_gpio_config_t__bindgen_ty_1 {
    #[inline]
    pub fn mclk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mclk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bclk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bclk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ws_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ws_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mclk_inv: u32,
        bclk_inv: u32,
        ws_inv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mclk_inv: u32 = unsafe { ::core::mem::transmute(mclk_inv) };
            mclk_inv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bclk_inv: u32 = unsafe { ::core::mem::transmute(bclk_inv) };
            bclk_inv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ws_inv: u32 = unsafe { ::core::mem::transmute(ws_inv) };
            ws_inv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_tdm_gpio_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief I2S TDM mode major configuration that including clock/slot/gpio configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_tdm_config_t {
    #[doc = "< TDM mode clock configuration, can be generated by macro I2S_TDM_CLK_DEFAULT_CONFIG"]
    pub clk_cfg: i2s_tdm_clk_config_t,
    #[doc = "< TDM mode slot configuration, can be generated by macros I2S_TDM_[mode]_SLOT_DEFAULT_CONFIG, [mode] can be replaced with PHILIPS/MSB/PCM_SHORT/PCM_LONG"]
    pub slot_cfg: i2s_tdm_slot_config_t,
    #[doc = "< TDM mode gpio configuration, specified by user"]
    pub gpio_cfg: i2s_tdm_gpio_config_t,
}
impl Default for i2s_tdm_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize i2s channel to TDM mode\n @note  Only allowed to be called when the channel state is REGISTERED, (i.e., channel has been allocated, but not initialized)\n        and the state will be updated to READY if initialization success, otherwise the state will return to REGISTERED.\n\n @param[in]   handle      I2S channel handler\n @param[in]   tdm_cfg     Configurations for TDM mode, including clock, slot and gpio\n                          The clock configuration can be generated by the helper macro `I2S_TDM_CLK_DEFAULT_CONFIG`\n                          The slot configuration can be generated by the helper macro `I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG`,\n                          `I2S_TDM_PCM_SHORT_SLOT_DEFAULT_CONFIG`, `I2S_TDM_PCM_LONG_SLOT_DEFAULT_CONFIG` or `I2S_TDM_MSB_SLOT_DEFAULT_CONFIG`\n\n @return\n      - ESP_OK    Initialize successfully\n      - ESP_ERR_NO_MEM        No memory for storing the channel information\n      - ESP_ERR_INVALID_ARG   NULL pointer or invalid configuration\n      - ESP_ERR_INVALID_STATE This channel is not registered"]
    pub fn i2s_channel_init_tdm_mode(
        handle: i2s_chan_handle_t,
        tdm_cfg: *const i2s_tdm_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S clock for TDM mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to TDM mode, i.e., 'i2s_channel_init_tdm_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   clk_cfg     Standard mode clock configuration, can be generated by `I2S_TDM_CLK_DEFAULT_CONFIG`\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration or not TDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_tdm_clock(
        handle: i2s_chan_handle_t,
        clk_cfg: *const i2s_tdm_clk_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S slot for TDM mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to TDM mode, i.e., 'i2s_channel_init_tdm_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   slot_cfg    Standard mode slot configuration, can be generated by `I2S_TDM_PHILIPS_SLOT_DEFAULT_CONFIG`,\n                          `I2S_TDM_PCM_SHORT_SLOT_DEFAULT_CONFIG`, `I2S_TDM_PCM_LONG_SLOT_DEFAULT_CONFIG` or `I2S_TDM_MSB_SLOT_DEFAULT_CONFIG`.\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_NO_MEM        No memory for DMA buffer\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not TDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_tdm_slot(
        handle: i2s_chan_handle_t,
        slot_cfg: *const i2s_tdm_slot_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reconfigure the I2S gpio for TDM mode\n @note  Only allowed to be called when the channel state is READY, i.e., channel has been initialized, but not started\n        this function won't change the state. 'i2s_channel_disable' should be called before calling this function if i2s has started.\n @note  The input channel handle has to be initialized to TDM mode, i.e., 'i2s_channel_init_tdm_mode' has been called before reconfiguring\n\n @param[in]   handle      I2S channel handler\n @param[in]   gpio_cfg    Standard mode gpio configuration, specified by user\n @return\n      - ESP_OK    Set clock successfully\n      - ESP_ERR_INVALID_ARG   NULL pointer, invalid configuration  or not TDM mode\n      - ESP_ERR_INVALID_STATE This channel is not initialized or not stopped"]
    pub fn i2s_channel_reconfig_tdm_gpio(
        handle: i2s_chan_handle_t,
        gpio_cfg: *const i2s_tdm_gpio_config_t,
    ) -> esp_err_t;
}
pub type mcpwm_timer_clock_source_t = ::core::ffi::c_int;
pub type mcpwm_capture_clock_source_t = ::core::ffi::c_int;
#[doc = "< Counting direction: Increase"]
pub const mcpwm_timer_direction_t_MCPWM_TIMER_DIRECTION_UP: mcpwm_timer_direction_t = 0;
#[doc = "< Counting direction: Decrease"]
pub const mcpwm_timer_direction_t_MCPWM_TIMER_DIRECTION_DOWN: mcpwm_timer_direction_t = 1;
#[doc = " @brief MCPWM timer count direction"]
pub type mcpwm_timer_direction_t = ::core::ffi::c_uint;
#[doc = "< MCPWM timer counts to zero (i.e. counter is empty)"]
pub const mcpwm_timer_event_t_MCPWM_TIMER_EVENT_EMPTY: mcpwm_timer_event_t = 0;
#[doc = "< MCPWM timer counts to peak (i.e. counter is full)"]
pub const mcpwm_timer_event_t_MCPWM_TIMER_EVENT_FULL: mcpwm_timer_event_t = 1;
#[doc = "< MCPWM timer invalid event"]
pub const mcpwm_timer_event_t_MCPWM_TIMER_EVENT_INVALID: mcpwm_timer_event_t = 2;
#[doc = " @brief MCPWM timer events"]
pub type mcpwm_timer_event_t = ::core::ffi::c_uint;
#[doc = "< MCPWM timer paused"]
pub const mcpwm_timer_count_mode_t_MCPWM_TIMER_COUNT_MODE_PAUSE: mcpwm_timer_count_mode_t = 0;
#[doc = "< MCPWM timer counting up"]
pub const mcpwm_timer_count_mode_t_MCPWM_TIMER_COUNT_MODE_UP: mcpwm_timer_count_mode_t = 1;
#[doc = "< MCPWM timer counting down"]
pub const mcpwm_timer_count_mode_t_MCPWM_TIMER_COUNT_MODE_DOWN: mcpwm_timer_count_mode_t = 2;
#[doc = "< MCPWM timer counting up and down"]
pub const mcpwm_timer_count_mode_t_MCPWM_TIMER_COUNT_MODE_UP_DOWN: mcpwm_timer_count_mode_t = 3;
#[doc = " @brief MCPWM timer count modes"]
pub type mcpwm_timer_count_mode_t = ::core::ffi::c_uint;
#[doc = "< MCPWM timer stops when next count reaches zero"]
pub const mcpwm_timer_start_stop_cmd_t_MCPWM_TIMER_STOP_EMPTY: mcpwm_timer_start_stop_cmd_t = 0;
#[doc = "< MCPWM timer stops when next count reaches peak"]
pub const mcpwm_timer_start_stop_cmd_t_MCPWM_TIMER_STOP_FULL: mcpwm_timer_start_stop_cmd_t = 1;
#[doc = "< MCPWM timer starts couting, and don't stop until received stop command"]
pub const mcpwm_timer_start_stop_cmd_t_MCPWM_TIMER_START_NO_STOP: mcpwm_timer_start_stop_cmd_t = 2;
#[doc = "< MCPWM timer starts counting and stops when next count reaches zero"]
pub const mcpwm_timer_start_stop_cmd_t_MCPWM_TIMER_START_STOP_EMPTY: mcpwm_timer_start_stop_cmd_t =
    3;
#[doc = "< MCPWM timer starts counting and stops when next count reaches peak"]
pub const mcpwm_timer_start_stop_cmd_t_MCPWM_TIMER_START_STOP_FULL: mcpwm_timer_start_stop_cmd_t =
    4;
#[doc = " @brief MCPWM timer commands, specify the way to start or stop the timer"]
pub type mcpwm_timer_start_stop_cmd_t = ::core::ffi::c_uint;
#[doc = "< Generator action: Keep the same level"]
pub const mcpwm_generator_action_t_MCPWM_GEN_ACTION_KEEP: mcpwm_generator_action_t = 0;
#[doc = "< Generator action: Force to low level"]
pub const mcpwm_generator_action_t_MCPWM_GEN_ACTION_LOW: mcpwm_generator_action_t = 1;
#[doc = "< Generator action: Force to high level"]
pub const mcpwm_generator_action_t_MCPWM_GEN_ACTION_HIGH: mcpwm_generator_action_t = 2;
#[doc = "< Generator action: Toggle level"]
pub const mcpwm_generator_action_t_MCPWM_GEN_ACTION_TOGGLE: mcpwm_generator_action_t = 3;
#[doc = " @brief MCPWM generator actions"]
pub type mcpwm_generator_action_t = ::core::ffi::c_uint;
#[doc = "< Brake mode: CBC (cycle by cycle)"]
pub const mcpwm_operator_brake_mode_t_MCPWM_OPER_BRAKE_MODE_CBC: mcpwm_operator_brake_mode_t = 0;
#[doc = "< Brake mode, OST (one shot)"]
pub const mcpwm_operator_brake_mode_t_MCPWM_OPER_BRAKE_MODE_OST: mcpwm_operator_brake_mode_t = 1;
#[doc = "< MCPWM operator invalid brake mode"]
pub const mcpwm_operator_brake_mode_t_MCPWM_OPER_BRAKE_MODE_INVALID: mcpwm_operator_brake_mode_t =
    2;
#[doc = " @brief MCPWM operator brake mode"]
pub type mcpwm_operator_brake_mode_t = ::core::ffi::c_uint;
#[doc = "< Capture on the positive edge"]
pub const mcpwm_capture_edge_t_MCPWM_CAP_EDGE_POS: mcpwm_capture_edge_t = 0;
#[doc = "< Capture on the negative edge"]
pub const mcpwm_capture_edge_t_MCPWM_CAP_EDGE_NEG: mcpwm_capture_edge_t = 1;
#[doc = " @brief MCPWM capture edge"]
pub type mcpwm_capture_edge_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_timer_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM timer handle"]
pub type mcpwm_timer_handle_t = *mut mcpwm_timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_oper_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM operator handle"]
pub type mcpwm_oper_handle_t = *mut mcpwm_oper_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_cmpr_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM comparator handle"]
pub type mcpwm_cmpr_handle_t = *mut mcpwm_cmpr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_gen_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM generator handle"]
pub type mcpwm_gen_handle_t = *mut mcpwm_gen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_fault_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM fault handle"]
pub type mcpwm_fault_handle_t = *mut mcpwm_fault_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_sync_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM sync handle"]
pub type mcpwm_sync_handle_t = *mut mcpwm_sync_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_cap_timer_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM capture timer handle"]
pub type mcpwm_cap_timer_handle_t = *mut mcpwm_cap_timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_cap_channel_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of MCPWM capture channel handle"]
pub type mcpwm_cap_channel_handle_t = *mut mcpwm_cap_channel_t;
#[doc = " @brief MCPWM timer event data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_timer_event_data_t {
    #[doc = "< MCPWM timer count value"]
    pub count_value: u32,
    #[doc = "< MCPWM timer count direction"]
    pub direction: mcpwm_timer_direction_t,
}
impl Default for mcpwm_timer_event_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief MCPWM timer event callback function\n\n @param[in] timer MCPWM timer handle\n @param[in] edata MCPWM timer event data, fed by driver\n @param[in] user_ctx User data, set in `mcpwm_timer_register_event_callbacks()`\n @return Whether a high priority task has been waken up by this function"]
pub type mcpwm_timer_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        timer: mcpwm_timer_handle_t,
        edata: *const mcpwm_timer_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief MCPWM brake event data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_brake_event_data_t {}
#[doc = " @brief MCPWM operator brake event callback function\n\n @param[in] oper MCPWM operator handle\n @param[in] edata MCPWM brake event data, fed by driver\n @param[in] user_ctx User data, set in `mcpwm_operator_register_event_callbacks()`\n @return Whether a high priority task has been waken up by this function"]
pub type mcpwm_brake_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        oper: mcpwm_oper_handle_t,
        edata: *const mcpwm_brake_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief MCPWM fault event data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_fault_event_data_t {}
#[doc = " @brief MCPWM fault event callback function\n\n @param fault MCPWM fault handle\n @param edata MCPWM fault event data, fed by driver\n @param user_ctx User data, set in `mcpwm_fault_register_event_callbacks()`\n @return whether a task switch is needed after the callback returns"]
pub type mcpwm_fault_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        fault: mcpwm_fault_handle_t,
        edata: *const mcpwm_fault_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief MCPWM compare event data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_compare_event_data_t {
    #[doc = "< Compare value"]
    pub compare_ticks: u32,
    #[doc = "< Count direction"]
    pub direction: mcpwm_timer_direction_t,
}
impl Default for mcpwm_compare_event_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief MCPWM comparator event callback function\n\n @param comparator MCPWM comparator handle\n @param edata MCPWM comparator event data, fed by driver\n @param user_ctx User data, set in `mcpwm_comparator_register_event_callbacks()`\n @return Whether a high priority task has been waken up by this function"]
pub type mcpwm_compare_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        comparator: mcpwm_cmpr_handle_t,
        edata: *const mcpwm_compare_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief MCPWM capture event data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_capture_event_data_t {
    #[doc = "< Captured value"]
    pub cap_value: u32,
    #[doc = "< Capture edge"]
    pub cap_edge: mcpwm_capture_edge_t,
}
impl Default for mcpwm_capture_event_data_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief MCPWM capture event callback function\n\n @param cap_channel MCPWM capture channel handle\n @param edata MCPWM capture event data, fed by driver\n @param user_ctx User data, set in `mcpwm_capture_channel_register_event_callbacks()`\n @return Whether a high priority task has been waken up by this function"]
pub type mcpwm_capture_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        cap_channel: mcpwm_cap_channel_handle_t,
        edata: *const mcpwm_capture_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief Group of supported MCPWM timer event callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_timer_event_callbacks_t {
    #[doc = "< callback function when MCPWM timer counts to peak value"]
    pub on_full: mcpwm_timer_event_cb_t,
    #[doc = "< callback function when MCPWM timer counts to zero"]
    pub on_empty: mcpwm_timer_event_cb_t,
    #[doc = "< callback function when MCPWM timer stops"]
    pub on_stop: mcpwm_timer_event_cb_t,
}
#[doc = " @brief MCPWM timer configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_timer_config_t {
    #[doc = "< Specify from which group to allocate the MCPWM timer"]
    pub group_id: ::core::ffi::c_int,
    #[doc = "< MCPWM timer clock source"]
    pub clk_src: mcpwm_timer_clock_source_t,
    #[doc = "< Counter resolution in Hz, ranges from around 300KHz to 80MHz.\nThe step size of each count tick equals to (1 / resolution_hz) seconds"]
    pub resolution_hz: u32,
    #[doc = "< Count mode"]
    pub count_mode: mcpwm_timer_count_mode_t,
    #[doc = "< Number of count ticks within a period"]
    pub period_ticks: u32,
    #[doc = "< Extra configuration flags for timer"]
    pub flags: mcpwm_timer_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_timer_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_timer_config_t__bindgen_ty_1 {
    #[inline]
    pub fn update_period_on_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_period_on_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_period_on_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_period_on_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        update_period_on_empty: u32,
        update_period_on_sync: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update_period_on_empty: u32 =
                unsafe { ::core::mem::transmute(update_period_on_empty) };
            update_period_on_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update_period_on_sync: u32 =
                unsafe { ::core::mem::transmute(update_period_on_sync) };
            update_period_on_sync as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for mcpwm_timer_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM timer\n\n @param[in] config MCPWM timer configuration\n @param[out] ret_timer Returned MCPWM timer handle\n @return\n      - ESP_OK: Create MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM timer failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM timer failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM timer failed because all hardware timers are used up and no more free one\n      - ESP_FAIL: Create MCPWM timer failed because of other error"]
    pub fn mcpwm_new_timer(
        config: *const mcpwm_timer_config_t,
        ret_timer: *mut mcpwm_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM timer\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @return\n      - ESP_OK: Delete MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Delete MCPWM timer failed because timer is not in init state\n      - ESP_FAIL: Delete MCPWM timer failed because of other error"]
    pub fn mcpwm_del_timer(timer: mcpwm_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable MCPWM timer\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @return\n      - ESP_OK: Enable MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Enable MCPWM timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable MCPWM timer failed because timer is enabled already\n      - ESP_FAIL: Enable MCPWM timer failed because of other error"]
    pub fn mcpwm_timer_enable(timer: mcpwm_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable MCPWM timer\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @return\n      - ESP_OK: Disable MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Disable MCPWM timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable MCPWM timer failed because timer is disabled already\n      - ESP_FAIL: Disable MCPWM timer failed because of other error"]
    pub fn mcpwm_timer_disable(timer: mcpwm_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send specific start/stop commands to MCPWM timer\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @param[in] command Supported command list for MCPWM timer\n @return\n      - ESP_OK: Start or stop MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Start or stop MCPWM timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Start or stop MCPWM timer failed because timer is not enabled\n      - ESP_FAIL: Start or stop MCPWM timer failed because of other error"]
    pub fn mcpwm_timer_start_stop(
        timer: mcpwm_timer_handle_t,
        command: mcpwm_timer_start_stop_cmd_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set event callbacks for MCPWM timer\n\n @note The first call to this function needs to be before the call to `mcpwm_timer_enable`\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Set event callbacks failed because timer is not in init state\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn mcpwm_timer_register_event_callbacks(
        timer: mcpwm_timer_handle_t,
        cbs: *const mcpwm_timer_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM Timer sync phase configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_timer_sync_phase_config_t {
    #[doc = "< The sync event source. Set to NULL will disable the timer being synced by others"]
    pub sync_src: mcpwm_sync_handle_t,
    #[doc = "< The count value that should lock to upon sync event"]
    pub count_value: u32,
    #[doc = "< The count direction that should lock to upon sync event"]
    pub direction: mcpwm_timer_direction_t,
}
impl Default for mcpwm_timer_sync_phase_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set sync phase for MCPWM timer\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @param[in] config MCPWM timer sync phase configuration\n @return\n      - ESP_OK: Set sync phase for MCPWM timer successfully\n      - ESP_ERR_INVALID_ARG: Set sync phase for MCPWM timer failed because of invalid argument\n      - ESP_FAIL: Set sync phase for MCPWM timer failed because of other error"]
    pub fn mcpwm_timer_set_phase_on_sync(
        timer: mcpwm_timer_handle_t,
        config: *const mcpwm_timer_sync_phase_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM operator configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_operator_config_t {
    #[doc = "< Specify from which group to allocate the MCPWM operator"]
    pub group_id: ::core::ffi::c_int,
    #[doc = "< Extra configuration flags for operator"]
    pub flags: mcpwm_operator_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_operator_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_operator_config_t__bindgen_ty_1 {
    #[inline]
    pub fn update_gen_action_on_tez(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_gen_action_on_tez(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_gen_action_on_tep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_gen_action_on_tep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_gen_action_on_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_gen_action_on_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dead_time_on_tez(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dead_time_on_tez(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dead_time_on_tep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dead_time_on_tep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_dead_time_on_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_dead_time_on_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        update_gen_action_on_tez: u32,
        update_gen_action_on_tep: u32,
        update_gen_action_on_sync: u32,
        update_dead_time_on_tez: u32,
        update_dead_time_on_tep: u32,
        update_dead_time_on_sync: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update_gen_action_on_tez: u32 =
                unsafe { ::core::mem::transmute(update_gen_action_on_tez) };
            update_gen_action_on_tez as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update_gen_action_on_tep: u32 =
                unsafe { ::core::mem::transmute(update_gen_action_on_tep) };
            update_gen_action_on_tep as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let update_gen_action_on_sync: u32 =
                unsafe { ::core::mem::transmute(update_gen_action_on_sync) };
            update_gen_action_on_sync as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let update_dead_time_on_tez: u32 =
                unsafe { ::core::mem::transmute(update_dead_time_on_tez) };
            update_dead_time_on_tez as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let update_dead_time_on_tep: u32 =
                unsafe { ::core::mem::transmute(update_dead_time_on_tep) };
            update_dead_time_on_tep as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_dead_time_on_sync: u32 =
                unsafe { ::core::mem::transmute(update_dead_time_on_sync) };
            update_dead_time_on_sync as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM operator\n\n @param[in] config MCPWM operator configuration\n @param[out] ret_oper Returned MCPWM operator handle\n @return\n      - ESP_OK: Create MCPWM operator successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM operator failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM operator failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM operator failed because can't find free resource\n      - ESP_FAIL: Create MCPWM operator failed because of other error"]
    pub fn mcpwm_new_operator(
        config: *const mcpwm_operator_config_t,
        ret_oper: *mut mcpwm_oper_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM operator\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`\n @return\n      - ESP_OK: Delete MCPWM operator successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM operator failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM operator failed because of other error"]
    pub fn mcpwm_del_operator(oper: mcpwm_oper_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Connect MCPWM operator and timer, so that the operator can be driven by the timer\n\n @param[in] oper MCPWM operator handle, allocated by `mcpwm_new_operator()`\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @return\n      - ESP_OK: Connect MCPWM operator and timer successfully\n      - ESP_ERR_INVALID_ARG: Connect MCPWM operator and timer failed because of invalid argument\n      - ESP_FAIL: Connect MCPWM operator and timer failed because of other error"]
    pub fn mcpwm_operator_connect_timer(
        oper: mcpwm_oper_handle_t,
        timer: mcpwm_timer_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM brake configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_brake_config_t {
    #[doc = "< Which fault causes the operator to brake"]
    pub fault: mcpwm_fault_handle_t,
    #[doc = "< Brake mode"]
    pub brake_mode: mcpwm_operator_brake_mode_t,
    #[doc = "< Extra flags for brake configuration"]
    pub flags: mcpwm_brake_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_brake_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_brake_config_t__bindgen_ty_1 {
    #[inline]
    pub fn cbc_recover_on_tez(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_recover_on_tez(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbc_recover_on_tep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_recover_on_tep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cbc_recover_on_tez: u32,
        cbc_recover_on_tep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cbc_recover_on_tez: u32 = unsafe { ::core::mem::transmute(cbc_recover_on_tez) };
            cbc_recover_on_tez as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cbc_recover_on_tep: u32 = unsafe { ::core::mem::transmute(cbc_recover_on_tep) };
            cbc_recover_on_tep as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for mcpwm_brake_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set brake method for MCPWM operator\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`\n @param[in] config MCPWM brake configuration\n @return\n      - ESP_OK: Set trip for operator successfully\n      - ESP_ERR_INVALID_ARG: Set trip for operator failed because of invalid argument\n      - ESP_FAIL: Set trip for operator failed because of other error"]
    pub fn mcpwm_operator_set_brake_on_fault(
        oper: mcpwm_oper_handle_t,
        config: *const mcpwm_brake_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Try to make the operator recover from fault\n\n @note To recover from fault or escape from trip, you make sure the fault signal has dissappeared already.\n       Otherwise the recovery can't succeed.\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`\n @param[in] fault MCPWM fault handle\n @return\n      - ESP_OK: Recover from fault successfully\n      - ESP_ERR_INVALID_ARG: Recover from fault failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Recover from fault failed because the fault source is still active\n      - ESP_FAIL: Recover from fault failed because of other error"]
    pub fn mcpwm_operator_recover_from_fault(
        oper: mcpwm_oper_handle_t,
        fault: mcpwm_fault_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief Group of supported MCPWM operator event callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_operator_event_callbacks_t {
    #[doc = "< callback function when mcpwm operator brakes in CBC"]
    pub on_brake_cbc: mcpwm_brake_event_cb_t,
    #[doc = "< callback function when mcpwm operator brakes in OST"]
    pub on_brake_ost: mcpwm_brake_event_cb_t,
}
extern "C" {
    #[doc = " @brief Set event callbacks for MCPWM operator\n\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] oper MCPWM operator handle, allocated by `mcpwm_new_operator()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn mcpwm_operator_register_event_callbacks(
        oper: mcpwm_oper_handle_t,
        cbs: *const mcpwm_operator_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM carrier configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_carrier_config_t {
    #[doc = "< Carrier frequency in Hz"]
    pub frequency_hz: u32,
    #[doc = "< The duration of the first PWM pulse, in us"]
    pub first_pulse_duration_us: u32,
    #[doc = "< Carrier duty cycle"]
    pub duty_cycle: f32,
    #[doc = "< Extra flags for carrier configuration"]
    pub flags: mcpwm_carrier_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_carrier_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_carrier_config_t__bindgen_ty_1 {
    #[inline]
    pub fn invert_before_modulate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert_before_modulate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invert_after_modulate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert_after_modulate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        invert_before_modulate: u32,
        invert_after_modulate: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let invert_before_modulate: u32 =
                unsafe { ::core::mem::transmute(invert_before_modulate) };
            invert_before_modulate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let invert_after_modulate: u32 =
                unsafe { ::core::mem::transmute(invert_after_modulate) };
            invert_after_modulate as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Apply carrier feature for MCPWM operator\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`\n @param[in] config MCPWM carrier specific configuration\n @return\n      - ESP_OK: Set carrier for operator successfully\n      - ESP_ERR_INVALID_ARG: Set carrier for operator failed because of invalid argument\n      - ESP_FAIL: Set carrier for operator failed because of other error"]
    pub fn mcpwm_operator_apply_carrier(
        oper: mcpwm_oper_handle_t,
        config: *const mcpwm_carrier_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM comparator configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_comparator_config_t {
    #[doc = "< Extra configuration flags for comparator"]
    pub flags: mcpwm_comparator_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_comparator_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_comparator_config_t__bindgen_ty_1 {
    #[inline]
    pub fn update_cmp_on_tez(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_cmp_on_tez(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_cmp_on_tep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_cmp_on_tep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_cmp_on_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_cmp_on_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        update_cmp_on_tez: u32,
        update_cmp_on_tep: u32,
        update_cmp_on_sync: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update_cmp_on_tez: u32 = unsafe { ::core::mem::transmute(update_cmp_on_tez) };
            update_cmp_on_tez as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update_cmp_on_tep: u32 = unsafe { ::core::mem::transmute(update_cmp_on_tep) };
            update_cmp_on_tep as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let update_cmp_on_sync: u32 = unsafe { ::core::mem::transmute(update_cmp_on_sync) };
            update_cmp_on_sync as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM comparator\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`, the new comparator will be allocated from this operator\n @param[in] config MCPWM comparator configuration\n @param[out] ret_cmpr Returned MCPWM comparator\n @return\n      - ESP_OK: Create MCPWM comparator successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM comparator failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM comparator failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM comparator failed because can't find free resource\n      - ESP_FAIL: Create MCPWM comparator failed because of other error"]
    pub fn mcpwm_new_comparator(
        oper: mcpwm_oper_handle_t,
        config: *const mcpwm_comparator_config_t,
        ret_cmpr: *mut mcpwm_cmpr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM comparator\n\n @param[in] cmpr MCPWM comparator handle, allocated by `mcpwm_new_comparator()`\n @return\n      - ESP_OK: Delete MCPWM comparator successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM comparator failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM comparator failed because of other error"]
    pub fn mcpwm_del_comparator(cmpr: mcpwm_cmpr_handle_t) -> esp_err_t;
}
#[doc = " @brief Group of supported MCPWM compare event callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_comparator_event_callbacks_t {
    #[doc = "< ISR callback function which would be invoked when counter reaches compare value"]
    pub on_reach: mcpwm_compare_event_cb_t,
}
extern "C" {
    #[doc = " @brief Set event callbacks for MCPWM comparator\n\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] cmpr MCPWM comparator handle, allocated by `mcpwm_new_comparator()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn mcpwm_comparator_register_event_callbacks(
        cmpr: mcpwm_cmpr_handle_t,
        cbs: *const mcpwm_comparator_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set MCPWM comparator's compare value\n\n @param[in] cmpr MCPWM comparator handle, allocated by `mcpwm_new_comparator()`\n @param[in] cmp_ticks The new compare value\n @return\n      - ESP_OK: Set MCPWM compare value successfully\n      - ESP_ERR_INVALID_ARG: Set MCPWM compare value failed because of invalid argument (e.g. the cmp_ticks is out of range)\n      - ESP_ERR_INVALID_STATE: Set MCPWM compare value failed because the operator doesn't have a timer connected\n      - ESP_FAIL: Set MCPWM compare value failed because of other error"]
    pub fn mcpwm_comparator_set_compare_value(
        cmpr: mcpwm_cmpr_handle_t,
        cmp_ticks: u32,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM generator configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_generator_config_t {
    #[doc = "< The GPIO number used to output the PWM signal"]
    pub gen_gpio_num: ::core::ffi::c_int,
    #[doc = "< Extra configuration flags for generator"]
    pub flags: mcpwm_generator_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_generator_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_generator_config_t__bindgen_ty_1 {
    #[inline]
    pub fn invert_pwm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert_pwm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_loop_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_loop_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        invert_pwm: u32,
        io_loop_back: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let invert_pwm: u32 = unsafe { ::core::mem::transmute(invert_pwm) };
            invert_pwm as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_loop_back: u32 = unsafe { ::core::mem::transmute(io_loop_back) };
            io_loop_back as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Allocate MCPWM generator from given operator\n\n @param[in] oper MCPWM operator, allocated by `mcpwm_new_operator()`\n @param[in] config MCPWM generator configuration\n @param[out] ret_gen Returned MCPWM generator\n @return\n      - ESP_OK: Create MCPWM generator successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM generator failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM generator failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM generator failed because can't find free resource\n      - ESP_FAIL: Create MCPWM generator failed because of other error"]
    pub fn mcpwm_new_generator(
        oper: mcpwm_oper_handle_t,
        config: *const mcpwm_generator_config_t,
        ret_gen: *mut mcpwm_gen_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM generator\n\n @param[in] gen MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @return\n      - ESP_OK: Delete MCPWM generator successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM generator failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM generator failed because of other error"]
    pub fn mcpwm_del_generator(gen: mcpwm_gen_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set force level for MCPWM generator\n\n @note The force level will be applied to the generator immediately, regardless any other events that would change the generator's behaviour.\n @note If the `hold_on` is true, the force level will retain forever, until user removes the force level by setting the force level to `-1`.\n @note If the `hold_on` is false, the force level can be overridden by the next event action.\n\n @param[in] gen MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] level GPIO level to be applied to MCPWM generator, specially, -1 means to remove the force level\n @param[in] hold_on Whether the forced PWM level should retain (i.e. will remain unchanged until manually remove the force level)\n @return\n      - ESP_OK: Set force level for MCPWM generator successfully\n      - ESP_ERR_INVALID_ARG: Set force level for MCPWM generator failed because of invalid argument\n      - ESP_FAIL: Set force level for MCPWM generator failed because of other error"]
    pub fn mcpwm_generator_set_force_level(
        gen: mcpwm_gen_handle_t,
        level: ::core::ffi::c_int,
        hold_on: bool,
    ) -> esp_err_t;
}
#[doc = " @brief Generator action on specific timer event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_gen_timer_event_action_t {
    #[doc = "< Timer direction"]
    pub direction: mcpwm_timer_direction_t,
    #[doc = "< Timer event"]
    pub event: mcpwm_timer_event_t,
    #[doc = "< Generator action should perform"]
    pub action: mcpwm_generator_action_t,
}
impl Default for mcpwm_gen_timer_event_action_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set generator action on MCPWM timer event\n\n @param[in] gen MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM timer event action, can be constructed by `MCPWM_GEN_TIMER_EVENT_ACTION` helper macro\n @return\n      - ESP_OK: Set generator action successfully\n      - ESP_ERR_INVALID_ARG: Set generator action failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Set generator action failed because of timer is not connected to operator\n      - ESP_FAIL: Set generator action failed because of other error"]
    pub fn mcpwm_generator_set_action_on_timer_event(
        gen: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_timer_event_action_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set generator actions on multiple MCPWM timer events\n\n @note This is an aggregation version of `mcpwm_generator_set_action_on_timer_event`, which allows user to set multiple actions in one call.\n\n @param[in] gen MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM timer event action list, must be terminated by `MCPWM_GEN_TIMER_EVENT_ACTION_END()`\n @return\n      - ESP_OK: Set generator actions successfully\n      - ESP_ERR_INVALID_ARG: Set generator actions failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Set generator actions failed because of timer is not connected to operator\n      - ESP_FAIL: Set generator actions failed because of other error"]
    pub fn mcpwm_generator_set_actions_on_timer_event(
        gen: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_timer_event_action_t,
        ...
    ) -> esp_err_t;
}
#[doc = " @brief Generator action on specific comparator event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_gen_compare_event_action_t {
    #[doc = "< Timer direction"]
    pub direction: mcpwm_timer_direction_t,
    #[doc = "< Comparator handle"]
    pub comparator: mcpwm_cmpr_handle_t,
    #[doc = "< Generator action should perform"]
    pub action: mcpwm_generator_action_t,
}
impl Default for mcpwm_gen_compare_event_action_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set generator action on MCPWM compare event\n\n @param[in] generator MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM compare event action, can be constructed by `MCPWM_GEN_COMPARE_EVENT_ACTION` helper macro\n @return\n      - ESP_OK: Set generator action successfully\n      - ESP_ERR_INVALID_ARG: Set generator action failed because of invalid argument\n      - ESP_FAIL: Set generator action failed because of other error"]
    pub fn mcpwm_generator_set_action_on_compare_event(
        generator: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_compare_event_action_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set generator actions on multiple MCPWM compare events\n\n @note This is an aggregation version of `mcpwm_generator_set_action_on_compare_event`, which allows user to set multiple actions in one call.\n\n @param[in] generator MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM compare event action list, must be terminated by `MCPWM_GEN_COMPARE_EVENT_ACTION_END()`\n @return\n      - ESP_OK: Set generator actions successfully\n      - ESP_ERR_INVALID_ARG: Set generator actions failed because of invalid argument\n      - ESP_FAIL: Set generator actions failed because of other error"]
    pub fn mcpwm_generator_set_actions_on_compare_event(
        generator: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_compare_event_action_t,
        ...
    ) -> esp_err_t;
}
#[doc = " @brief Generator action on specific brake event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_gen_brake_event_action_t {
    #[doc = "< Timer direction"]
    pub direction: mcpwm_timer_direction_t,
    #[doc = "< Brake mode"]
    pub brake_mode: mcpwm_operator_brake_mode_t,
    #[doc = "< Generator action should perform"]
    pub action: mcpwm_generator_action_t,
}
impl Default for mcpwm_gen_brake_event_action_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set generator action on MCPWM brake event\n\n @param[in] generator MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM brake event action, can be constructed by `MCPWM_GEN_BRAKE_EVENT_ACTION` helper macro\n @return\n      - ESP_OK: Set generator action successfully\n      - ESP_ERR_INVALID_ARG: Set generator action failed because of invalid argument\n      - ESP_FAIL: Set generator action failed because of other error"]
    pub fn mcpwm_generator_set_action_on_brake_event(
        generator: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_brake_event_action_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set generator actions on multiple MCPWM brake events\n\n @note This is an aggregation version of `mcpwm_generator_set_action_on_brake_event`, which allows user to set multiple actions in one call.\n\n @param[in] generator MCPWM generator handle, allocated by `mcpwm_new_generator()`\n @param[in] ev_act MCPWM brake event action list, must be terminated by `MCPWM_GEN_BRAKE_EVENT_ACTION_END()`\n @return\n      - ESP_OK: Set generator actions successfully\n      - ESP_ERR_INVALID_ARG: Set generator actions failed because of invalid argument\n      - ESP_FAIL: Set generator actions failed because of other error"]
    pub fn mcpwm_generator_set_actions_on_brake_event(
        generator: mcpwm_gen_handle_t,
        ev_act: mcpwm_gen_brake_event_action_t,
        ...
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM dead time configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_dead_time_config_t {
    #[doc = "< delay time applied to rising edge, 0 means no rising delay time"]
    pub posedge_delay_ticks: u32,
    #[doc = "< delay time applied to falling edge, 0 means no falling delay time"]
    pub negedge_delay_ticks: u32,
    #[doc = "< Extra flags for dead time configuration"]
    pub flags: mcpwm_dead_time_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_dead_time_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_dead_time_config_t__bindgen_ty_1 {
    #[inline]
    pub fn invert_output(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert_output(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(invert_output: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let invert_output: u32 = unsafe { ::core::mem::transmute(invert_output) };
            invert_output as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Set dead time for MCPWM generator\n\n @param[in] in_generator MCPWM generator, before adding the dead time\n @param[in] out_generator MCPWM generator, after adding the dead time\n @param[in] config MCPWM dead time configuration\n @return\n      - ESP_OK: Set dead time for MCPWM generator successfully\n      - ESP_ERR_INVALID_ARG: Set dead time for MCPWM generator failed because of invalid argument\n      - ESP_FAIL: Set dead time for MCPWM generator failed because of other error"]
    pub fn mcpwm_generator_set_dead_time(
        in_generator: mcpwm_gen_handle_t,
        out_generator: mcpwm_gen_handle_t,
        config: *const mcpwm_dead_time_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM GPIO fault configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_gpio_fault_config_t {
    #[doc = "< In which MCPWM group that the GPIO fault belongs to"]
    pub group_id: ::core::ffi::c_int,
    #[doc = "< GPIO used by the fault signal"]
    pub gpio_num: ::core::ffi::c_int,
    #[doc = "< Extra configuration flags for GPIO fault"]
    pub flags: mcpwm_gpio_fault_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_gpio_fault_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_gpio_fault_config_t__bindgen_ty_1 {
    #[inline]
    pub fn active_level(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_level(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_loop_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_loop_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_up(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_up(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_down(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_down(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_level: u32,
        io_loop_back: u32,
        pull_up: u32,
        pull_down: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active_level: u32 = unsafe { ::core::mem::transmute(active_level) };
            active_level as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_loop_back: u32 = unsafe { ::core::mem::transmute(io_loop_back) };
            io_loop_back as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pull_up: u32 = unsafe { ::core::mem::transmute(pull_up) };
            pull_up as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pull_down: u32 = unsafe { ::core::mem::transmute(pull_down) };
            pull_down as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM GPIO fault\n\n @param[in] config MCPWM GPIO fault configuration\n @param[out] ret_fault Returned GPIO fault handle\n @return\n      - ESP_OK: Create MCPWM GPIO fault successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM GPIO fault failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM GPIO fault failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM GPIO fault failed because can't find free resource\n      - ESP_FAIL: Create MCPWM GPIO fault failed because of other error"]
    pub fn mcpwm_new_gpio_fault(
        config: *const mcpwm_gpio_fault_config_t,
        ret_fault: *mut mcpwm_fault_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM software fault configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_soft_fault_config_t {}
extern "C" {
    #[doc = " @brief Create MCPWM software fault\n\n @param[in] config MCPWM software fault configuration\n @param[out] ret_fault Returned software fault handle\n @return\n      - ESP_OK: Create MCPWM software fault successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM software fault failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM software fault failed because out of memory\n      - ESP_FAIL: Create MCPWM software fault failed because of other error"]
    pub fn mcpwm_new_soft_fault(
        config: *const mcpwm_soft_fault_config_t,
        ret_fault: *mut mcpwm_fault_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM fault\n\n @param[in] fault MCPWM fault handle allocated by `mcpwm_new_gpio_fault()` or `mcpwm_new_soft_fault()`\n @return\n      - ESP_OK: Delete MCPWM fault successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM fault failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM fault failed because of other error"]
    pub fn mcpwm_del_fault(fault: mcpwm_fault_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Activate the software fault, trigger the fault event for once\n\n @param[in] fault MCPWM soft fault, allocated by `mcpwm_new_soft_fault()`\n @return\n      - ESP_OK: Trigger MCPWM software fault event successfully\n      - ESP_ERR_INVALID_ARG: Trigger MCPWM software fault event failed because of invalid argument\n      - ESP_FAIL: Trigger MCPWM software fault event failed because of other error"]
    pub fn mcpwm_soft_fault_activate(fault: mcpwm_fault_handle_t) -> esp_err_t;
}
#[doc = " @brief Group of supported MCPWM fault event callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_fault_event_callbacks_t {
    #[doc = "< ISR callback function that would be invoked when fault signal becomes active"]
    pub on_fault_enter: mcpwm_fault_event_cb_t,
    #[doc = "< ISR callback function that would be invoked when fault signal becomes inactive"]
    pub on_fault_exit: mcpwm_fault_event_cb_t,
}
extern "C" {
    #[doc = " @brief Set event callbacks for MCPWM fault\n\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] fault MCPWM GPIO fault handle, allocated by `mcpwm_new_gpio_fault()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn mcpwm_fault_register_event_callbacks(
        fault: mcpwm_fault_handle_t,
        cbs: *const mcpwm_fault_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM timer sync source configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_timer_sync_src_config_t {
    #[doc = "< Timer event, upon which MCPWM timer will generate the sync signal"]
    pub timer_event: mcpwm_timer_event_t,
    #[doc = "< Extra configuration flags for timer sync source"]
    pub flags: mcpwm_timer_sync_src_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_timer_sync_src_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_timer_sync_src_config_t__bindgen_ty_1 {
    #[inline]
    pub fn propagate_input_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_propagate_input_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(propagate_input_sync: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let propagate_input_sync: u32 = unsafe { ::core::mem::transmute(propagate_input_sync) };
            propagate_input_sync as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for mcpwm_timer_sync_src_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM timer sync source\n\n @param[in] timer MCPWM timer handle, allocated by `mcpwm_new_timer()`\n @param[in] config MCPWM timer sync source configuration\n @param[out] ret_sync Returned MCPWM sync handle\n @return\n      - ESP_OK: Create MCPWM timer sync source successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM timer sync source failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM timer sync source failed because out of memory\n      - ESP_ERR_INVALID_STATE: Create MCPWM timer sync source failed because the timer has created a sync source before\n      - ESP_FAIL: Create MCPWM timer sync source failed because of other error"]
    pub fn mcpwm_new_timer_sync_src(
        timer: mcpwm_timer_handle_t,
        config: *const mcpwm_timer_sync_src_config_t,
        ret_sync: *mut mcpwm_sync_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM GPIO sync source configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_gpio_sync_src_config_t {
    #[doc = "< MCPWM group ID"]
    pub group_id: ::core::ffi::c_int,
    #[doc = "< GPIO used by sync source"]
    pub gpio_num: ::core::ffi::c_int,
    #[doc = "< Extra configuration flags for GPIO sync source"]
    pub flags: mcpwm_gpio_sync_src_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_gpio_sync_src_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_gpio_sync_src_config_t__bindgen_ty_1 {
    #[inline]
    pub fn active_neg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_neg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_loop_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_loop_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_up(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_up(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_down(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_down(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_neg: u32,
        io_loop_back: u32,
        pull_up: u32,
        pull_down: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active_neg: u32 = unsafe { ::core::mem::transmute(active_neg) };
            active_neg as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_loop_back: u32 = unsafe { ::core::mem::transmute(io_loop_back) };
            io_loop_back as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pull_up: u32 = unsafe { ::core::mem::transmute(pull_up) };
            pull_up as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pull_down: u32 = unsafe { ::core::mem::transmute(pull_down) };
            pull_down as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM GPIO sync source\n\n @param[in] config MCPWM GPIO sync source configuration\n @param[out] ret_sync Returned MCPWM GPIO sync handle\n @return\n      - ESP_OK: Create MCPWM GPIO sync source successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM GPIO sync source failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM GPIO sync source failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM GPIO sync source failed because can't find free resource\n      - ESP_FAIL: Create MCPWM GPIO sync source failed because of other error"]
    pub fn mcpwm_new_gpio_sync_src(
        config: *const mcpwm_gpio_sync_src_config_t,
        ret_sync: *mut mcpwm_sync_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM software sync configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_soft_sync_config_t {}
extern "C" {
    #[doc = " @brief Create MCPWM software sync source\n\n @param[in] config MCPWM software sync source configuration\n @param[out] ret_sync Returned software sync handle\n @return\n      - ESP_OK: Create MCPWM software sync successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM software sync failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM software sync failed because out of memory\n      - ESP_FAIL: Create MCPWM software sync failed because of other error"]
    pub fn mcpwm_new_soft_sync_src(
        config: *const mcpwm_soft_sync_config_t,
        ret_sync: *mut mcpwm_sync_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM sync source\n\n @param[in] sync MCPWM sync handle, allocated by `mcpwm_new_timer_sync_src()` or `mcpwm_new_gpio_sync_src()` or `mcpwm_new_soft_sync_src()`\n @return\n      - ESP_OK: Delete MCPWM sync source successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM sync source failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM sync source failed because of other error"]
    pub fn mcpwm_del_sync_src(sync: mcpwm_sync_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Activate the software sync, trigger the sync event for once\n\n @param[in] sync MCPWM soft sync handle, allocated by `mcpwm_new_soft_sync_src()`\n @return\n      - ESP_OK: Trigger MCPWM software sync event successfully\n      - ESP_ERR_INVALID_ARG: Trigger MCPWM software sync event failed because of invalid argument\n      - ESP_FAIL: Trigger MCPWM software sync event failed because of other error"]
    pub fn mcpwm_soft_sync_activate(sync: mcpwm_sync_handle_t) -> esp_err_t;
}
#[doc = " @brief MCPWM capture timer configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_capture_timer_config_t {
    #[doc = "< Specify from which group to allocate the capture timer"]
    pub group_id: ::core::ffi::c_int,
    #[doc = "< MCPWM capture timer clock source"]
    pub clk_src: mcpwm_capture_clock_source_t,
}
extern "C" {
    #[doc = " @brief Create MCPWM capture timer\n\n @param[in] config MCPWM capture timer configuration\n @param[out] ret_cap_timer Returned MCPWM capture timer handle\n @return\n      - ESP_OK: Create MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM capture timer failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM capture timer failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM capture timer failed because can't find free resource\n      - ESP_FAIL: Create MCPWM capture timer failed because of other error"]
    pub fn mcpwm_new_capture_timer(
        config: *const mcpwm_capture_timer_config_t,
        ret_cap_timer: *mut mcpwm_cap_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`\n @return\n      - ESP_OK: Delete MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM capture timer failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM capture timer failed because of other error"]
    pub fn mcpwm_del_capture_timer(cap_timer: mcpwm_cap_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer handle, allocated by `mcpwm_new_capture_timer()`\n @return\n      - ESP_OK: Enable MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Enable MCPWM capture timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable MCPWM capture timer failed because timer is enabled already\n      - ESP_FAIL: Enable MCPWM capture timer failed because of other error"]
    pub fn mcpwm_capture_timer_enable(cap_timer: mcpwm_cap_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer handle, allocated by `mcpwm_new_capture_timer()`\n @return\n      - ESP_OK: Disable MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Disable MCPWM capture timer failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable MCPWM capture timer failed because timer is disabled already\n      - ESP_FAIL: Disable MCPWM capture timer failed because of other error"]
    pub fn mcpwm_capture_timer_disable(cap_timer: mcpwm_cap_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`\n @return\n      - ESP_OK: Start MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Start MCPWM capture timer failed because of invalid argument\n      - ESP_FAIL: Start MCPWM capture timer failed because of other error"]
    pub fn mcpwm_capture_timer_start(cap_timer: mcpwm_cap_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`\n @return\n      - ESP_OK: Stop MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Stop MCPWM capture timer failed because of invalid argument\n      - ESP_FAIL: Stop MCPWM capture timer failed because of other error"]
    pub fn mcpwm_capture_timer_stop(cap_timer: mcpwm_cap_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get MCPWM capture timer resolution, in Hz\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`\n @param[out] out_resolution Returned capture timer resolution, in Hz\n @return\n      - ESP_OK: Get capture timer resolution successfully\n      - ESP_ERR_INVALID_ARG: Get capture timer resolution failed because of invalid argument\n      - ESP_FAIL: Get capture timer resolution failed because of other error"]
    pub fn mcpwm_capture_timer_get_resolution(
        cap_timer: mcpwm_cap_timer_handle_t,
        out_resolution: *mut u32,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM Capture timer sync phase configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_capture_timer_sync_phase_config_t {
    #[doc = "< The sync event source"]
    pub sync_src: mcpwm_sync_handle_t,
    #[doc = "< The count value that should lock to upon sync event"]
    pub count_value: u32,
    #[doc = "< The count direction that should lock to upon sync event"]
    pub direction: mcpwm_timer_direction_t,
}
impl Default for mcpwm_capture_timer_sync_phase_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Set sync phase for MCPWM capture timer\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`\n @param[in] config MCPWM capture timer sync phase configuration\n @return\n      - ESP_OK: Set sync phase for MCPWM capture timer successfully\n      - ESP_ERR_INVALID_ARG: Set sync phase for MCPWM capture timer failed because of invalid argument\n      - ESP_FAIL: Set sync phase for MCPWM capture timer failed because of other error"]
    pub fn mcpwm_capture_timer_set_phase_on_sync(
        cap_timer: mcpwm_cap_timer_handle_t,
        config: *const mcpwm_capture_timer_sync_phase_config_t,
    ) -> esp_err_t;
}
#[doc = " @brief MCPWM capture channel configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_capture_channel_config_t {
    #[doc = "< GPIO used capturing input signal"]
    pub gpio_num: ::core::ffi::c_int,
    #[doc = "< Prescale of input signal, effective frequency = cap_input_clk/prescale"]
    pub prescale: u32,
    #[doc = "< Extra configuration flags for capture channel"]
    pub flags: mcpwm_capture_channel_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_capture_channel_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl mcpwm_capture_channel_config_t__bindgen_ty_1 {
    #[inline]
    pub fn pos_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pos_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn neg_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_neg_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_up(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_up(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pull_down(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pull_down(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invert_cap_signal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert_cap_signal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_loop_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_loop_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_io_conf_at_exit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_io_conf_at_exit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pos_edge: u32,
        neg_edge: u32,
        pull_up: u32,
        pull_down: u32,
        invert_cap_signal: u32,
        io_loop_back: u32,
        keep_io_conf_at_exit: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pos_edge: u32 = unsafe { ::core::mem::transmute(pos_edge) };
            pos_edge as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let neg_edge: u32 = unsafe { ::core::mem::transmute(neg_edge) };
            neg_edge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pull_up: u32 = unsafe { ::core::mem::transmute(pull_up) };
            pull_up as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pull_down: u32 = unsafe { ::core::mem::transmute(pull_down) };
            pull_down as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let invert_cap_signal: u32 = unsafe { ::core::mem::transmute(invert_cap_signal) };
            invert_cap_signal as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let io_loop_back: u32 = unsafe { ::core::mem::transmute(io_loop_back) };
            io_loop_back as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let keep_io_conf_at_exit: u32 = unsafe { ::core::mem::transmute(keep_io_conf_at_exit) };
            keep_io_conf_at_exit as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Create MCPWM capture channel\n\n @note The created capture channel won't be enabled until calling `mcpwm_capture_channel_enable`\n\n @param[in] cap_timer MCPWM capture timer, allocated by `mcpwm_new_capture_timer()`, will be connected to the new capture channel\n @param[in] config MCPWM capture channel configuration\n @param[out] ret_cap_channel Returned MCPWM capture channel\n @return\n      - ESP_OK: Create MCPWM capture channel successfully\n      - ESP_ERR_INVALID_ARG: Create MCPWM capture channel failed because of invalid argument\n      - ESP_ERR_NO_MEM: Create MCPWM capture channel failed because out of memory\n      - ESP_ERR_NOT_FOUND: Create MCPWM capture channel failed because can't find free resource\n      - ESP_FAIL: Create MCPWM capture channel failed because of other error"]
    pub fn mcpwm_new_capture_channel(
        cap_timer: mcpwm_cap_timer_handle_t,
        config: *const mcpwm_capture_channel_config_t,
        ret_cap_channel: *mut mcpwm_cap_channel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete MCPWM capture channel\n\n @param[in] cap_channel MCPWM capture channel handle, allocated by `mcpwm_new_capture_channel()`\n @return\n      - ESP_OK: Delete MCPWM capture channel successfully\n      - ESP_ERR_INVALID_ARG: Delete MCPWM capture channel failed because of invalid argument\n      - ESP_FAIL: Delete MCPWM capture channel failed because of other error"]
    pub fn mcpwm_del_capture_channel(cap_channel: mcpwm_cap_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable MCPWM capture channel\n\n @note This function will transit the channel state from init to enable.\n @note This function will enable the interrupt service, if it's lazy installed in `mcpwm_capture_channel_register_event_callbacks()`.\n\n @param[in] cap_channel MCPWM capture channel handle, allocated by `mcpwm_new_capture_channel()`\n @return\n      - ESP_OK: Enable MCPWM capture channel successfully\n      - ESP_ERR_INVALID_ARG: Enable MCPWM capture channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Enable MCPWM capture channel failed because the channel is already enabled\n      - ESP_FAIL: Enable MCPWM capture channel failed because of other error"]
    pub fn mcpwm_capture_channel_enable(cap_channel: mcpwm_cap_channel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable MCPWM capture channel\n\n @param[in] cap_channel MCPWM capture channel handle, allocated by `mcpwm_new_capture_channel()`\n @return\n      - ESP_OK: Disable MCPWM capture channel successfully\n      - ESP_ERR_INVALID_ARG: Disable MCPWM capture channel failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Disable MCPWM capture channel failed because the channel is not enabled yet\n      - ESP_FAIL: Disable MCPWM capture channel failed because of other error"]
    pub fn mcpwm_capture_channel_disable(cap_channel: mcpwm_cap_channel_handle_t) -> esp_err_t;
}
#[doc = " @brief Group of supported MCPWM capture event callbacks\n @note The callbacks are all running under ISR environment"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mcpwm_capture_event_callbacks_t {
    #[doc = "< Callback function that would be invoked when capture event occurred"]
    pub on_cap: mcpwm_capture_event_cb_t,
}
extern "C" {
    #[doc = " @brief Set event callbacks for MCPWM capture channel\n\n @note The first call to this function needs to be before the call to `mcpwm_capture_channel_enable`\n @note User can deregister a previously registered callback by calling this function and setting the callback member in the `cbs` structure to NULL.\n\n @param[in] cap_channel MCPWM capture channel handle, allocated by `mcpwm_new_capture_channel()`\n @param[in] cbs Group of callback functions\n @param[in] user_data User data, which will be passed to callback functions directly\n @return\n      - ESP_OK: Set event callbacks successfully\n      - ESP_ERR_INVALID_ARG: Set event callbacks failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Set event callbacks failed because the channel is not in init state\n      - ESP_FAIL: Set event callbacks failed because of other error"]
    pub fn mcpwm_capture_channel_register_event_callbacks(
        cap_channel: mcpwm_cap_channel_handle_t,
        cbs: *const mcpwm_capture_event_callbacks_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Trigger a catch by software\n\n @param[in] cap_channel MCPWM capture channel handle, allocated by `mcpwm_new_capture_channel()`\n @return\n      - ESP_OK: Trigger software catch successfully\n      - ESP_ERR_INVALID_ARG: Trigger software catch failed because of invalid argument\n      - ESP_ERR_INVALID_STATE: Trigger software catch failed because the channel is not enabled yet\n      - ESP_FAIL: Trigger software catch failed because of other error"]
    pub fn mcpwm_capture_channel_trigger_soft_catch(
        cap_channel: mcpwm_cap_channel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable peripheral module by un-gating the clock and de-asserting the reset signal.\n\n @param[in] periph Peripheral module\n\n @note If @c periph_module_enable() is called a number of times,\n       @c periph_module_disable() has to be called the same number of times,\n       in order to put the peripheral into disabled state."]
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief Disable peripheral module by gating the clock and asserting the reset signal.\n\n @param[in] periph Peripheral module\n\n @note If @c periph_module_enable() is called a number of times,\n       @c periph_module_disable() has to be called the same number of times,\n       in order to put the peripheral into disabled state."]
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief Reset peripheral module by asserting and de-asserting the reset signal.\n\n @param[in] periph Peripheral module\n\n @note Calling this function does not enable or disable the clock for the module."]
    pub fn periph_module_reset(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief Enable Wi-Fi and BT common module\n\n @note If @c wifi_bt_common_module_enable() is called a number of times,\n       @c wifi_bt_common_module_disable() has to be called the same number of times,\n       in order to put the peripheral into disabled state."]
    pub fn wifi_bt_common_module_enable();
}
extern "C" {
    #[doc = " @brief Disable Wi-Fi and BT common module\n\n @note If @c wifi_bt_common_module_enable() is called a number of times,\n       @c wifi_bt_common_module_disable() has to be called the same number of times,\n       in order to put the peripheral into disabled state."]
    pub fn wifi_bt_common_module_disable();
}
extern "C" {
    #[doc = " @brief Enable Wi-Fi module\n\n @note Calling this function will only enable Wi-Fi module."]
    pub fn wifi_module_enable();
}
extern "C" {
    #[doc = " @brief Disable Wi-Fi module\n\n @note Calling this function will only disable Wi-Fi module."]
    pub fn wifi_module_disable();
}
#[doc = " Type by which ring buffers are referenced. For example, a call to xRingbufferCreate()\n returns a RingbufHandle_t variable that can then be used as a parameter to\n xRingbufferSend(), xRingbufferReceive(), etc."]
pub type RingbufHandle_t = *mut ::core::ffi::c_void;
#[doc = " No-split buffers will only store an item in contiguous memory and will\n never split an item. Each item requires an 8 byte overhead for a header\n and will always internally occupy a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_NOSPLIT: RingbufferType_t = 0;
#[doc = " Allow-split buffers will split an item into two parts if necessary in\n order to store it. Each item requires an 8 byte overhead for a header,\n splitting incurs an extra header. Each item will always internally occupy\n a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_ALLOWSPLIT: RingbufferType_t = 1;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate\n items, therefore byte buffers have no overhead. All data is stored as a\n sequence of byte and any number of bytes can be sent or retrieved each\n time."]
pub const RingbufferType_t_RINGBUF_TYPE_BYTEBUF: RingbufferType_t = 2;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate\n items, therefore byte buffers have no overhead. All data is stored as a\n sequence of byte and any number of bytes can be sent or retrieved each\n time."]
pub const RingbufferType_t_RINGBUF_TYPE_MAX: RingbufferType_t = 3;
pub type RingbufferType_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_RINGBUFFER {
    #[doc = " @cond"]
    pub xDummy1: [usize; 2usize],
    pub uxDummy2: UBaseType_t,
    pub xDummy3: BaseType_t,
    pub pvDummy4: [*mut ::core::ffi::c_void; 11usize],
    pub xDummy5: [StaticSemaphore_t; 2usize],
    pub muxDummy: portMUX_TYPE,
}
impl Default for xSTATIC_RINGBUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StaticRingbuffer_t = xSTATIC_RINGBUFFER;
extern "C" {
    #[doc = " @brief       Create a ring buffer\n\n @param[in]   xBufferSize Size of the buffer in bytes. Note that items require\n              space for a header in no-split/allow-split buffers\n @param[in]   xBufferType Type of ring buffer, see documentation.\n\n @note    xBufferSize of no-split/allow-split buffers will be rounded up to the nearest 32-bit aligned size.\n\n @return  A handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreate(xBufferSize: usize, xBufferType: RingbufferType_t) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT for a fixed item_size\n\n This API is similar to xRingbufferCreate(), but it will internally allocate\n additional space for the headers.\n\n @param[in]   xItemSize   Size of each item to be put into the ring buffer\n @param[in]   xItemNum    Maximum number of items the buffer needs to hold simultaneously\n\n @return  A RingbufHandle_t handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreateNoSplit(xItemSize: usize, xItemNum: usize) -> RingbufHandle_t;
}
extern "C" {
    pub fn xRingbufferCreateStatic(
        xBufferSize: usize,
        xBufferType: RingbufferType_t,
        pucRingbufferStorage: *mut u8,
        pxStaticRingbuffer: *mut StaticRingbuffer_t,
    ) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer\n\n Attempt to insert an item into the ring buffer. This function will block until\n enough free space is available or until it times out.\n\n @param[in]   xRingbuffer     Ring buffer to insert the item into\n @param[in]   pvItem          Pointer to data to insert. NULL is allowed if xItemSize is 0.\n @param[in]   xItemSize       Size of data to insert.\n @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer.\n\n @note    For no-split/allow-split ring buffers, the actual size of memory that\n          the item will occupy will be rounded up to the nearest 32-bit aligned\n          size. This is done to ensure all items are always stored in 32-bit\n          aligned fashion.\n\n @return\n      - pdTRUE if succeeded\n      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSend(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const ::core::ffi::c_void,
        xItemSize: usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer in an ISR\n\n Attempt to insert an item into the ring buffer from an ISR. This function\n will return immediately if there is insufficient free space in the buffer.\n\n @param[in]   xRingbuffer Ring buffer to insert the item into\n @param[in]   pvItem      Pointer to data to insert. NULL is allowed if xItemSize is 0.\n @param[in]   xItemSize   Size of data to insert.\n @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE if the function woke up a higher priority task.\n\n @note    For no-split/allow-split ring buffers, the actual size of memory that\n          the item will occupy will be rounded up to the nearest 32-bit aligned\n          size. This is done to ensure all items are always stored in 32-bit\n          aligned fashion.\n\n @return\n      - pdTRUE if succeeded\n      - pdFALSE when the ring buffer does not have space."]
    pub fn xRingbufferSendFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const ::core::ffi::c_void,
        xItemSize: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief Acquire memory from the ring buffer to be written to by an external\n        source and to be sent later.\n\n Attempt to allocate buffer for an item to be sent into the ring buffer. This\n function will block until enough free space is available or until it\n times out.\n\n The item, as well as the following items ``SendAcquire`` or ``Send`` after it,\n will not be able to be read from the ring buffer until this item is actually\n sent into the ring buffer.\n\n @param[in]   xRingbuffer     Ring buffer to allocate the memory\n @param[out]  ppvItem         Double pointer to memory acquired (set to NULL if no memory were retrieved)\n @param[in]   xItemSize       Size of item to acquire.\n @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer.\n\n @note Only applicable for no-split ring buffers now, the actual size of\n       memory that the item will occupy will be rounded up to the nearest 32-bit\n       aligned size. This is done to ensure all items are always stored in 32-bit\n       aligned fashion.\n\n @return\n      - pdTRUE if succeeded\n      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSendAcquire(
        xRingbuffer: RingbufHandle_t,
        ppvItem: *mut *mut ::core::ffi::c_void,
        xItemSize: usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Actually send an item into the ring buffer allocated before by\n              ``xRingbufferSendAcquire``.\n\n @param[in]   xRingbuffer     Ring buffer to insert the item into\n @param[in]   pvItem          Pointer to item in allocated memory to insert.\n\n @note Only applicable for no-split ring buffers. Only call for items\n       allocated by ``xRingbufferSendAcquire``.\n\n @return\n      - pdTRUE if succeeded\n      - pdFALSE if fail for some reason."]
    pub fn xRingbufferSendComplete(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer\n\n Attempt to retrieve an item from the ring buffer. This function will block\n until an item is available or until it times out.\n\n @param[in]   xRingbuffer     Ring buffer to retrieve the item from\n @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written.\n @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer.\n\n @note    A call to vRingbufferReturnItem() is required after this to free the item retrieved.\n\n @return\n      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.\n      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceive(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer in an ISR\n\n Attempt to retrieve an item from the ring buffer. This function returns immediately\n if there are no items available for retrieval\n\n @param[in]   xRingbuffer     Ring buffer to retrieve the item from\n @param[out]  pxItemSize      Pointer to a variable to which the size of the\n                              retrieved item will be written.\n\n @note    A call to vRingbufferReturnItemFromISR() is required after this to free the item retrieved.\n @note    Byte buffers do not allow multiple retrievals before returning an item\n @note    Two calls to RingbufferReceiveFromISR() are required if the bytes wrap around the end of the ring buffer.\n\n @return\n      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item.\n      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer\n\n Attempt to retrieve a split item from an allow-split ring buffer. If the item\n is not split, only a single item is retried. If the item is split, both parts\n will be retrieved. This function will block until an item is available or\n until it times out.\n\n @param[in]   xRingbuffer     Ring buffer to retrieve the item from\n @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)\n @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)\n @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)\n @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)\n @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer.\n\n @note    Call(s) to vRingbufferReturnItem() is required after this to free up the item(s) retrieved.\n @note    This function should only be called on allow-split buffers\n\n @return\n      - pdTRUE if an item (split or unsplit) was retrieved\n      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplit(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut ::core::ffi::c_void,
        ppvTailItem: *mut *mut ::core::ffi::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer in an ISR\n\n Attempt to retrieve a split item from an allow-split ring buffer. If the item\n is not split, only a single item is retried. If the item is split, both parts\n will be retrieved. This function returns immediately if there are no items\n available for retrieval\n\n @param[in]   xRingbuffer     Ring buffer to retrieve the item from\n @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)\n @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)\n @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)\n @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)\n\n @note    Calls to vRingbufferReturnItemFromISR() is required after this to free up the item(s) retrieved.\n @note    This function should only be called on allow-split buffers\n\n @return\n      - pdTRUE if an item (split or unsplit) was retrieved\n      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplitFromISR(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut ::core::ffi::c_void,
        ppvTailItem: *mut *mut ::core::ffi::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve\n\n Attempt to retrieve data from a byte buffer whilst specifying a maximum number\n of bytes to retrieve. This function will block until there is data available\n for retrieval or until it times out.\n\n @param[in]   xRingbuffer     Ring buffer to retrieve the item from\n @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written.\n @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer.\n @param[in]   xMaxSize        Maximum number of bytes to return.\n\n @note    A call to vRingbufferReturnItem() is required after this to free up the data retrieved.\n @note    This function should only be called on byte buffers\n @note    Byte buffers do not allow multiple retrievals before returning an item\n @note    Two calls to RingbufferReceiveUpTo() are required if the bytes wrap around the end of the ring buffer.\n\n @return\n      - Pointer to the retrieved item on success; *pxItemSize filled with\n        the length of the item.\n      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpTo(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
        xMaxSize: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of\n          bytes to retrieve. Call this from an ISR.\n\n Attempt to retrieve bytes from a byte buffer whilst specifying a maximum number\n of bytes to retrieve. This function will return immediately if there is no data\n available for retrieval.\n\n @param[in]   xRingbuffer Ring buffer to retrieve the item from\n @param[out]  pxItemSize  Pointer to a variable to which the size of the retrieved item will be written.\n @param[in]   xMaxSize    Maximum number of bytes to return.\n\n @note    A call to vRingbufferReturnItemFromISR() is required after this to free up the data received.\n @note    This function should only be called on byte buffers\n @note    Byte buffers do not allow multiple retrievals before returning an item\n\n @return\n      - Pointer to the retrieved item on success; *pxItemSize filled with\n        the length of the item.\n      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpToFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xMaxSize: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer\n\n @param[in]   xRingbuffer Ring buffer the item was retrieved from\n @param[in]   pvItem      Item that was received earlier\n\n @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItem(xRingbuffer: RingbufHandle_t, pvItem: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer from an ISR\n\n @param[in]   xRingbuffer Ring buffer the item was retrieved from\n @param[in]   pvItem      Item that was received earlier\n @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE\n                                          if the function woke up a higher priority task.\n\n @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItemFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Delete a ring buffer\n\n @param[in]   xRingbuffer     Ring buffer to delete\n\n @note    This function will not deallocate any memory if the ring buffer was\n          created using xRingbufferCreateStatic(). Deallocation must be done\n          manually be the user."]
    pub fn vRingbufferDelete(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    #[doc = " @brief   Get maximum size of an item that can be placed in the ring buffer\n\n This function returns the maximum size an item can have if it was placed in\n an empty ring buffer.\n\n @param[in]   xRingbuffer     Ring buffer to query\n\n @note    The max item size for a no-split buffer is limited to\n          ((buffer_size/2)-header_size). This limit is imposed so that an item\n          of max item size can always be sent to an empty no-split buffer\n          regardless of the internal positions of the buffer's read/write/free\n          pointers.\n\n @return  Maximum size, in bytes, of an item that can be placed in a ring buffer."]
    pub fn xRingbufferGetMaxItemSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Get current free size available for an item/data in the buffer\n\n This gives the real time free space available for an item/data in the ring\n buffer. This represents the maximum size an item/data can have if it was\n currently sent to the ring buffer.\n\n @warning This API is not thread safe. So, if multiple threads are accessing\n          the same ring buffer, it is the application's responsibility to\n          ensure atomic access to this API and the subsequent Send\n\n @note    An empty no-split buffer has a max current free size for an item\n          that is limited to ((buffer_size/2)-header_size). See API reference\n          for xRingbufferGetMaxItemSize().\n\n @param[in]   xRingbuffer     Ring buffer to query\n\n @return  Current free size, in bytes, available for an entry"]
    pub fn xRingbufferGetCurFreeSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Add the ring buffer's read semaphore to a queue set.\n\n The ring buffer's read semaphore indicates that data has been written\n to the ring buffer. This function adds the ring buffer's read semaphore to\n a queue set.\n\n @param[in]   xRingbuffer     Ring buffer to add to the queue set\n @param[in]   xQueueSet       Queue set to add the ring buffer's read semaphore to\n\n @return\n      - pdTRUE on success, pdFALSE otherwise"]
    pub fn xRingbufferAddToQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Check if the selected queue set member is the ring buffer's read semaphore\n\n This API checks if queue set member returned from xQueueSelectFromSet()\n is the read semaphore of this ring buffer. If so, this indicates the ring buffer\n has items waiting to be retrieved.\n\n @param[in]   xRingbuffer     Ring buffer which should be checked\n @param[in]   xMember         Member returned from xQueueSelectFromSet\n\n @return\n      - pdTRUE when semaphore belongs to ring buffer\n      - pdFALSE otherwise."]
    pub fn xRingbufferCanRead(
        xRingbuffer: RingbufHandle_t,
        xMember: QueueSetMemberHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Remove the ring buffer's read semaphore from a queue set.\n\n This specifically removes a ring buffer's read semaphore from a queue set. The\n read semaphore is used to indicate when data has been written to the ring buffer\n\n @param[in]   xRingbuffer     Ring buffer to remove from the queue set\n @param[in]   xQueueSet       Queue set to remove the ring buffer's read semaphore from\n\n @return\n      - pdTRUE on success\n      - pdFALSE otherwise"]
    pub fn xRingbufferRemoveFromQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Get information about ring buffer status\n\n Get information of a ring buffer's current status such as\n free/read/write/acquire pointer positions, and number of items waiting to be retrieved.\n Arguments can be set to NULL if they are not required.\n\n @param[in]   xRingbuffer     Ring buffer to remove from the queue set\n @param[out]  uxFree          Pointer use to store free pointer position\n @param[out]  uxRead          Pointer use to store read pointer position\n @param[out]  uxWrite         Pointer use to store write pointer position\n @param[out]  uxAcquire       Pointer use to store acquire pointer position\n @param[out]  uxItemsWaiting  Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved"]
    pub fn vRingbufferGetInfo(
        xRingbuffer: RingbufHandle_t,
        uxFree: *mut UBaseType_t,
        uxRead: *mut UBaseType_t,
        uxWrite: *mut UBaseType_t,
        uxAcquire: *mut UBaseType_t,
        uxItemsWaiting: *mut UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Debugging function to print the internal pointers in the ring buffer\n\n @param   xRingbuffer Ring buffer to show"]
    pub fn xRingbufferPrintInfo(xRingbuffer: RingbufHandle_t);
}
#[doc = " @brief Definition of RMT item"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_item32_t {
    pub __bindgen_anon_1: rmt_item32_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_item32_t__bindgen_ty_1 {
    pub __bindgen_anon_1: rmt_item32_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Equivalent unsigned value for the RMT item"]
    pub val: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rmt_item32_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rmt_item32_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn duration0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_duration0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn level0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn duration1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_duration1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn level1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        duration0: u32,
        level0: u32,
        duration1: u32,
        level1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let duration0: u32 = unsafe { ::core::mem::transmute(duration0) };
            duration0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let level0: u32 = unsafe { ::core::mem::transmute(level0) };
            level0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let duration1: u32 = unsafe { ::core::mem::transmute(duration1) };
            duration1 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let level1: u32 = unsafe { ::core::mem::transmute(level1) };
            level1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rmt_item32_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rmt_item32_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief RMT hardware memory layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_mem_t {
    pub chan: [rmt_mem_t__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_mem_t__bindgen_ty_1 {
    pub data32: [rmt_item32_t; 48usize],
}
impl Default for rmt_mem_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rmt_mem_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< RMT channel number 0"]
pub const rmt_channel_t_RMT_CHANNEL_0: rmt_channel_t = 0;
#[doc = "< RMT channel number 1"]
pub const rmt_channel_t_RMT_CHANNEL_1: rmt_channel_t = 1;
#[doc = "< RMT channel number 2"]
pub const rmt_channel_t_RMT_CHANNEL_2: rmt_channel_t = 2;
#[doc = "< RMT channel number 3"]
pub const rmt_channel_t_RMT_CHANNEL_3: rmt_channel_t = 3;
#[doc = "< Number of RMT channels"]
pub const rmt_channel_t_RMT_CHANNEL_MAX: rmt_channel_t = 4;
#[doc = " @brief RMT channel ID"]
pub type rmt_channel_t = ::core::ffi::c_uint;
#[doc = "< RMT RX mode, RMT transmitter owns the memory block"]
pub const rmt_mem_owner_t_RMT_MEM_OWNER_TX: rmt_mem_owner_t = 0;
#[doc = "< RMT RX mode, RMT receiver owns the memory block"]
pub const rmt_mem_owner_t_RMT_MEM_OWNER_RX: rmt_mem_owner_t = 1;
pub const rmt_mem_owner_t_RMT_MEM_OWNER_MAX: rmt_mem_owner_t = 2;
#[doc = " @brief RMT Internal Memory Owner"]
pub type rmt_mem_owner_t = ::core::ffi::c_uint;
#[doc = " @brief Type of RMT clock source, reserved for the legacy RMT driver"]
pub use self::soc_periph_rmt_clk_src_legacy_t as rmt_source_clk_t;
pub const rmt_data_mode_t_RMT_DATA_MODE_FIFO: rmt_data_mode_t = 0;
pub const rmt_data_mode_t_RMT_DATA_MODE_MEM: rmt_data_mode_t = 1;
pub const rmt_data_mode_t_RMT_DATA_MODE_MAX: rmt_data_mode_t = 2;
#[doc = " @brief RMT Data Mode\n\n @note We highly recommended to use MEM mode not FIFO mode since there will be some gotcha in FIFO mode."]
pub type rmt_data_mode_t = ::core::ffi::c_uint;
#[doc = "< RMT TX mode"]
pub const rmt_mode_t_RMT_MODE_TX: rmt_mode_t = 0;
#[doc = "< RMT RX mode"]
pub const rmt_mode_t_RMT_MODE_RX: rmt_mode_t = 1;
pub const rmt_mode_t_RMT_MODE_MAX: rmt_mode_t = 2;
#[doc = " @brief RMT Channel Working Mode (TX or RX)"]
pub type rmt_mode_t = ::core::ffi::c_uint;
#[doc = "< RMT TX idle level: low Level"]
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_LOW: rmt_idle_level_t = 0;
#[doc = "< RMT TX idle level: high Level"]
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_HIGH: rmt_idle_level_t = 1;
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_MAX: rmt_idle_level_t = 2;
#[doc = " @brief RMT Idle Level\n"]
pub type rmt_idle_level_t = ::core::ffi::c_uint;
#[doc = "< RMT carrier wave is modulated for low Level output"]
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_LOW: rmt_carrier_level_t = 0;
#[doc = "< RMT carrier wave is modulated for high Level output"]
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_HIGH: rmt_carrier_level_t = 1;
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_MAX: rmt_carrier_level_t = 2;
#[doc = " @brief RMT Carrier Level"]
pub type rmt_carrier_level_t = ::core::ffi::c_uint;
#[doc = "< RMT channel uninitialized"]
pub const rmt_channel_status_t_RMT_CHANNEL_UNINIT: rmt_channel_status_t = 0;
#[doc = "< RMT channel status idle"]
pub const rmt_channel_status_t_RMT_CHANNEL_IDLE: rmt_channel_status_t = 1;
#[doc = "< RMT channel status busy"]
pub const rmt_channel_status_t_RMT_CHANNEL_BUSY: rmt_channel_status_t = 2;
#[doc = " @brief RMT Channel Status"]
pub type rmt_channel_status_t = ::core::ffi::c_uint;
#[doc = " @brief Data struct of RMT channel status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_channel_status_result_t {
    #[doc = "< Store the current status of each channel"]
    pub status: [rmt_channel_status_t; 4usize],
}
impl Default for rmt_channel_status_result_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Data struct of RMT TX configure parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_tx_config_t {
    #[doc = "< RMT carrier frequency"]
    pub carrier_freq_hz: u32,
    #[doc = "< Level of the RMT output, when the carrier is applied"]
    pub carrier_level: rmt_carrier_level_t,
    #[doc = "< RMT idle level"]
    pub idle_level: rmt_idle_level_t,
    #[doc = "< RMT carrier duty (%)"]
    pub carrier_duty_percent: u8,
    #[doc = "< Maximum loop count"]
    pub loop_count: u32,
    #[doc = "< RMT carrier enable"]
    pub carrier_en: bool,
    #[doc = "< Enable sending RMT items in a loop"]
    pub loop_en: bool,
    #[doc = "< RMT idle level output enable"]
    pub idle_output_en: bool,
}
impl Default for rmt_tx_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Data struct of RMT RX configure parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_rx_config_t {
    #[doc = "< RMT RX idle threshold"]
    pub idle_threshold: u16,
    #[doc = "< RMT filter tick number"]
    pub filter_ticks_thresh: u8,
    #[doc = "< RMT receiver filter enable"]
    pub filter_en: bool,
    #[doc = "< RMT receiver remove carrier enable"]
    pub rm_carrier: bool,
    #[doc = "< RMT carrier frequency"]
    pub carrier_freq_hz: u32,
    #[doc = "< RMT carrier duty (%)"]
    pub carrier_duty_percent: u8,
    #[doc = "< The level to remove the carrier"]
    pub carrier_level: rmt_carrier_level_t,
}
impl Default for rmt_rx_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Data struct of RMT configure parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_config_t {
    #[doc = "< RMT mode: transmitter or receiver"]
    pub rmt_mode: rmt_mode_t,
    #[doc = "< RMT channel"]
    pub channel: rmt_channel_t,
    #[doc = "< RMT GPIO number"]
    pub gpio_num: gpio_num_t,
    #[doc = "< RMT channel counter divider"]
    pub clk_div: u8,
    #[doc = "< RMT memory block number"]
    pub mem_block_num: u8,
    #[doc = "< RMT channel extra configurations, OR'd with RMT_CHANNEL_FLAGS_[*]"]
    pub flags: u32,
    pub __bindgen_anon_1: rmt_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_config_t__bindgen_ty_1 {
    #[doc = "< RMT TX parameter"]
    pub tx_config: rmt_tx_config_t,
    #[doc = "< RMT RX parameter"]
    pub rx_config: rmt_rx_config_t,
}
impl Default for rmt_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rmt_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief RMT interrupt handle"]
pub type rmt_isr_handle_t = intr_handle_t;
#[doc = " @brief Type of RMT Tx End callback function"]
pub type rmt_tx_end_fn_t = ::core::option::Option<
    unsafe extern "C" fn(channel: rmt_channel_t, arg: *mut ::core::ffi::c_void),
>;
#[doc = " @brief Structure encapsulating a RMT TX end callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_tx_end_callback_t {
    #[doc = "< Function which is called on RMT TX end"]
    pub function: rmt_tx_end_fn_t,
    #[doc = "< Optional argument passed to function"]
    pub arg: *mut ::core::ffi::c_void,
}
impl Default for rmt_tx_end_callback_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief User callback function to convert uint8_t type data to rmt format(rmt_item32_t).\n\n        This function may be called from an ISR, so, the code should be short and efficient.\n\n @param  src Pointer to the buffer storing the raw data that needs to be converted to rmt format.\n @param[out] dest Pointer to the buffer storing the rmt format data.\n @param  src_size The raw data size.\n @param  wanted_num The number of rmt format data that wanted to get.\n @param[out] translated_size The size of the raw data that has been converted to rmt format,\n             it should return 0 if no data is converted in user callback.\n @param[out] item_num The number of the rmt format data that actually converted to,\n             it can be less than wanted_num if there is not enough raw data, but cannot exceed wanted_num.\n             it should return 0 if no data was converted.\n\n @note\n       In fact, item_num should be a multiple of translated_size, e.g. :\n       When we convert each byte of uint8_t type data to rmt format data,\n       the relation between item_num and translated_size should be `item_num = translated_size*8`."]
pub type sample_to_rmt_t = ::core::option::Option<
    unsafe extern "C" fn(
        src: *const ::core::ffi::c_void,
        dest: *mut rmt_item32_t,
        src_size: usize,
        wanted_num: usize,
        translated_size: *mut usize,
        item_num: *mut usize,
    ),
>;
extern "C" {
    #[doc = " @brief Set RMT clock divider, channel clock is divided from source clock.\n\n @param channel RMT channel\n @param div_cnt RMT counter clock divider\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_clk_div(channel: rmt_channel_t, div_cnt: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT clock divider, channel clock is divided from source clock.\n\n @param channel RMT channel\n @param div_cnt pointer to accept RMT counter divider\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_clk_div(channel: rmt_channel_t, div_cnt: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX idle threshold value\n\n        In receive mode, when no edge is detected on the input signal\n        for longer than idle_thres channel clock cycles,\n        the receive process is finished.\n\n @param channel RMT channel\n @param thresh RMT RX idle threshold\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_rx_idle_thresh(channel: rmt_channel_t, thresh: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT idle threshold value.\n\n        In receive mode, when no edge is detected on the input signal\n        for longer than idle_thres channel clock cycles,\n        the receive process is finished.\n\n @param channel RMT channel\n @param thresh pointer to accept RMT RX idle threshold value\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_rx_idle_thresh(channel: rmt_channel_t, thresh: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory block number for RMT channel\n\n        This function is used to configure the amount of memory blocks allocated to channel n\n        The 8 channels share a 512x32-bit RAM block which can be read and written\n        by the processor cores over the APB bus, as well as read by the transmitters\n        and written by the receivers.\n\n        The RAM address range for channel n is start_addr_CHn to end_addr_CHn, which are defined by:\n        Memory block start address is RMT_CHANNEL_MEM(n) (in soc/rmt_reg.h),\n        that is, start_addr_chn = RMT base address + 0x800 + 64 ∗ 4 ∗ n, and\n        end_addr_chn = RMT base address + 0x800 +  64 ∗ 4 ∗ n + 64 ∗ 4 ∗ RMT_MEM_SIZE_CHn mod 512 ∗ 4\n\n        @note\n        If memory block number of one channel is set to a value greater than 1, this channel will occupy the memory\n        block of the next channel.\n        Channel 0 can use at most 8 blocks of memory, accordingly channel 7 can only use one memory block.\n\n @param channel RMT channel\n @param rmt_mem_num RMT RX memory block number, one block has 64 * 32 bits.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_mem_block_num(channel: rmt_channel_t, rmt_mem_num: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory block number\n\n @param channel RMT channel\n @param rmt_mem_num Pointer to accept RMT RX memory block number\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_mem_block_num(channel: rmt_channel_t, rmt_mem_num: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure RMT carrier for TX signal.\n\n        Set different values for carrier_high and carrier_low to set different frequency of carrier.\n        The unit of carrier_high/low is the source clock tick, not the divided channel counter clock.\n\n @param channel RMT channel\n @param carrier_en Whether to enable output carrier.\n @param high_level High level duration of carrier\n @param low_level Low level duration of carrier.\n @param carrier_level Configure the way carrier wave is modulated for channel.\n     - 1'b1:transmit on low output level\n     - 1'b0:transmit on high output level\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_tx_carrier(
        channel: rmt_channel_t,
        carrier_en: bool,
        high_level: u16,
        low_level: u16,
        carrier_level: rmt_carrier_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory in low power mode.\n\n        Reduce power consumed by memory. 1:memory is in low power state.\n\n @param channel RMT channel\n @param pd_en RMT memory low power enable.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_mem_pd(channel: rmt_channel_t, pd_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory low power mode.\n\n @param channel RMT channel\n @param pd_en Pointer to accept RMT memory low power mode.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_mem_pd(channel: rmt_channel_t, pd_en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT start sending data from memory.\n\n @param channel RMT channel\n @param tx_idx_rst Set true to reset memory index for TX.\n                   Otherwise, transmitter will continue sending from the last index in memory.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_tx_start(channel: rmt_channel_t, tx_idx_rst: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT stop sending.\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_tx_stop(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT start receiving data.\n\n @param channel RMT channel\n @param rx_idx_rst Set true to reset memory index for receiver.\n                   Otherwise, receiver will continue receiving data to the last index in memory.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_rx_start(channel: rmt_channel_t, rx_idx_rst: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT stop receiving data.\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_rx_stop(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset RMT TX memory\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_tx_memory_reset(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset RMT RX memory\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_rx_memory_reset(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory owner.\n @note Setting memory is only valid for RX channel.\n\n @param channel RMT channel\n @param owner To set when the transmitter or receiver can process the memory of channel.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_memory_owner(channel: rmt_channel_t, owner: rmt_mem_owner_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory owner.\n\n @param channel RMT channel\n @param owner Pointer to get memory owner.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_memory_owner(channel: rmt_channel_t, owner: *mut rmt_mem_owner_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT tx loop mode.\n\n @param channel RMT channel\n @param loop_en Enable RMT transmitter loop sending mode.\n                If set true, transmitter will continue sending from the first data\n                to the last data in channel over and over again in a loop.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_tx_loop_mode(channel: rmt_channel_t, loop_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT tx loop mode.\n\n @param channel RMT channel\n @param loop_en Pointer to accept RMT transmitter loop sending mode.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_tx_loop_mode(channel: rmt_channel_t, loop_en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX filter.\n\n        In receive mode, channel will ignore input pulse when the pulse width is smaller than threshold.\n        Counted in source clock, not divided counter clock.\n\n @param channel RMT channel\n @param rx_filter_en To enable RMT receiver filter.\n @param thresh Threshold of pulse width for receiver.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_rx_filter(channel: rmt_channel_t, rx_filter_en: bool, thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT source clock\n\n        RMT module has two clock sources:\n        1. APB clock which is 80Mhz\n        2. REF tick clock, which would be 1Mhz (not supported in this version).\n\n @param channel RMT channel\n @param base_clk To choose source clock for RMT module.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_source_clk(channel: rmt_channel_t, base_clk: rmt_source_clk_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT source clock\n\n        RMT module has two clock sources:\n        1. APB clock which is 80Mhz\n        2. REF tick clock, which would be 1Mhz (not supported in this version).\n\n @param channel RMT channel\n @param src_clk Pointer to accept source clock for RMT module.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_source_clk(channel: rmt_channel_t, src_clk: *mut rmt_source_clk_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT idle output level for transmitter\n\n @param channel RMT channel\n @param idle_out_en To enable idle level output.\n @param level To set the output signal's level for channel in idle state.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_idle_level(
        channel: rmt_channel_t,
        idle_out_en: bool,
        level: rmt_idle_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT idle output level for transmitter\n\n @param channel RMT channel\n @param idle_out_en Pointer to accept value of enable idle.\n @param level Pointer to accept value of output signal's level in idle state for specified channel.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_idle_level(
        channel: rmt_channel_t,
        idle_out_en: *mut bool,
        level: *mut rmt_idle_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT status\n\n @param channel RMT channel\n @param status Pointer to accept channel status.\n        Please refer to RMT_CHnSTATUS_REG(n=0~7) in `rmt_reg.h` for more details of each field.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_status(channel: rmt_channel_t, status: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX interrupt enable\n\n @param channel RMT channel\n @param en enable or disable RX interrupt.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_rx_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX error interrupt enable\n\n @param channel RMT channel\n @param en enable or disable RX err interrupt.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_err_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT TX interrupt enable\n\n @param channel RMT channel\n @param en enable or disable TX interrupt.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_tx_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT TX threshold event interrupt enable\n\n An interrupt will be triggered when the number of transmitted items reaches the threshold value\n\n @param channel RMT channel\n @param en enable or disable TX event interrupt.\n @param evt_thresh RMT event interrupt threshold value\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_tx_thr_intr_en(channel: rmt_channel_t, en: bool, evt_thresh: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure the GPIO used by RMT channel\n\n @param channel RMT channel\n @param mode RMT mode, either RMT_MODE_TX or RMT_MODE_RX\n @param gpio_num GPIO number, which is connected with certain RMT signal\n @param invert_signal Invert RMT signal physically by GPIO matrix\n\n @return\n     - ESP_ERR_INVALID_ARG Configure RMT GPIO failed because of wrong parameter\n     - ESP_OK Configure RMT GPIO successfully"]
    pub fn rmt_set_gpio(
        channel: rmt_channel_t,
        mode: rmt_mode_t,
        gpio_num: gpio_num_t,
        invert_signal: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure RMT parameters\n\n @param rmt_param RMT parameter struct\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_config(rmt_param: *const rmt_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register RMT interrupt handler, the handler is an ISR.\n\n        The handler will be attached to the same CPU core that this function is running on.\n\n @note  If you already called rmt_driver_install to use system RMT driver,\n        please do not register ISR handler again.\n\n @param fn Interrupt handler function.\n @param arg Parameter for the handler function\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n @param handle If non-zero, a handle to later clean up the ISR gets stored here.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Function pointer error.\n     - ESP_FAIL System driver installed, can not register ISR handler for RMT"]
    pub fn rmt_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::core::ffi::c_int,
        handle: *mut rmt_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Deregister previously registered RMT interrupt handler\n\n @param handle Handle obtained from rmt_isr_register\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Handle invalid"]
    pub fn rmt_isr_deregister(handle: rmt_isr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Fill memory data of channel with given RMT items.\n\n @param channel RMT channel\n @param item Pointer of items.\n @param item_num RMT sending items number.\n @param mem_offset Index offset of memory.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_fill_tx_items(
        channel: rmt_channel_t,
        item: *const rmt_item32_t,
        item_num: u16,
        mem_offset: u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize RMT driver\n\n @param channel RMT channel\n @param rx_buf_size Size of RMT RX ringbuffer. Can be 0 if the RX ringbuffer is not used.\n @param intr_alloc_flags Flags for the RMT driver interrupt handler. Pass 0 for default flags. See esp_intr_alloc.h for details.\n        If ESP_INTR_FLAG_IRAM is used, please do not use the memory allocated from psram when calling rmt_write_items.\n\n @return\n     - ESP_ERR_INVALID_STATE Driver is already installed, call rmt_driver_uninstall first.\n     - ESP_ERR_NO_MEM Memory allocation failure\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_driver_install(
        channel: rmt_channel_t,
        rx_buf_size: usize,
        intr_alloc_flags: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall RMT driver.\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_driver_uninstall(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the current status of eight channels.\n\n @note Do not call this function if it is possible that `rmt_driver_uninstall` will be called at the same time.\n\n @param[out] channel_status store the current status of each channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter is NULL\n     - ESP_OK Success"]
    pub fn rmt_get_channel_status(channel_status: *mut rmt_channel_status_result_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get speed of channel's internal counter clock.\n\n @param channel RMT channel\n @param[out] clock_hz counter clock speed, in hz\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter is NULL\n     - ESP_OK Success"]
    pub fn rmt_get_counter_clock(channel: rmt_channel_t, clock_hz: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief RMT send waveform from rmt_item array.\n\n        This API allows user to send waveform with any length.\n\n @param channel RMT channel\n @param rmt_item head point of RMT items array.\n        If ESP_INTR_FLAG_IRAM is used, please do not use the memory allocated from psram when calling rmt_write_items.\n @param item_num RMT data item number.\n @param wait_tx_done\n        - If set 1, it will block the task and wait for sending done.\n        - If set 0, it will not wait and return immediately.\n\n         @note\n         This function will not copy data, instead, it will point to the original items,\n         and send the waveform items.\n         If wait_tx_done is set to true, this function will block and will not return until\n         all items have been sent out.\n         If wait_tx_done is set to false, this function will return immediately, and the driver\n         interrupt will continue sending the items. We must make sure the item data will not be\n         damaged when the driver is still sending items in driver interrupt.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_write_items(
        channel: rmt_channel_t,
        rmt_item: *const rmt_item32_t,
        item_num: ::core::ffi::c_int,
        wait_tx_done: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait RMT TX finished.\n\n @param channel RMT channel\n @param wait_time Maximum time in ticks to wait for transmission to be complete.  If set 0, return immediately with ESP_ERR_TIMEOUT if TX is busy (polling).\n\n @return\n     - ESP_OK RMT Tx done successfully\n     - ESP_ERR_TIMEOUT Exceeded the 'wait_time' given\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_FAIL Driver not installed"]
    pub fn rmt_wait_tx_done(channel: rmt_channel_t, wait_time: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get ringbuffer from RMT.\n\n        Users can get the RMT RX ringbuffer handle, and process the RX data.\n\n @param channel RMT channel\n @param buf_handle Pointer to buffer handle to accept RX ringbuffer handle.\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_get_ringbuf_handle(
        channel: rmt_channel_t,
        buf_handle: *mut RingbufHandle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init rmt translator and register user callback.\n        The callback will convert the raw data that needs to be sent to rmt format.\n        If a channel is initialized more than once, the user callback will be replaced by the later.\n\n @param channel RMT channel .\n @param fn Point to the data conversion function.\n\n @return\n     - ESP_FAIL Init fail.\n     - ESP_OK Init success."]
    pub fn rmt_translator_init(channel: rmt_channel_t, fn_: sample_to_rmt_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set user context for the translator of specific channel\n\n @param channel RMT channel number\n @param context User context\n\n @return\n     - ESP_FAIL Set context fail\n     - ESP_OK Set context success"]
    pub fn rmt_translator_set_context(
        channel: rmt_channel_t,
        context: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the user context set by 'rmt_translator_set_context'\n\n @note This API must be invoked in the RMT translator callback function,\n       and the first argument must be the actual parameter 'item_num' you got in that callback function.\n\n @param item_num Address of the memory which contains the number of translated items (It's from driver's internal memory)\n @param context Returned User context\n\n @return\n     - ESP_FAIL Get context fail\n     - ESP_OK Get context success"]
    pub fn rmt_translator_get_context(
        item_num: *const usize,
        context: *mut *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Translate uint8_t type of data into rmt format and send it out.\n        Requires rmt_translator_init to init the translator first.\n\n @param channel RMT channel .\n @param src Pointer to the raw data.\n @param src_size The size of the raw data.\n @param wait_tx_done Set true to wait all data send done.\n\n @return\n     - ESP_FAIL Send fail\n     - ESP_OK Send success"]
    pub fn rmt_write_sample(
        channel: rmt_channel_t,
        src: *const u8,
        src_size: usize,
        wait_tx_done: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Registers a callback that will be called when transmission ends.\n\n        Called by rmt_driver_isr_default in interrupt context.\n\n @note Requires rmt_driver_install to install the default ISR handler.\n\n @param function Function to be called from the default interrupt handler or NULL.\n @param arg Argument which will be provided to the callback when it is called.\n\n @return the previous callback settings (members will be set to NULL if there was none)"]
    pub fn rmt_register_tx_end_callback(
        function: rmt_tx_end_fn_t,
        arg: *mut ::core::ffi::c_void,
    ) -> rmt_tx_end_callback_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX threshold event interrupt enable\n\n An interrupt will be triggered when the number of received items reaches the threshold value\n\n @param channel RMT channel\n @param en enable or disable RX event interrupt.\n @param evt_thresh RMT event interrupt threshold value\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_set_rx_thr_intr_en(channel: rmt_channel_t, en: bool, evt_thresh: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Add channel into a synchronous group (channels in the same group can start transaction simultaneously)\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_add_channel_to_group(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove channel out of a group\n\n @param channel RMT channel\n\n @return\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_OK Success"]
    pub fn rmt_remove_channel_from_group(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set loop count threshold value for RMT TX channel\n\n When tx loop count reaches this value, an ISR callback will notify user\n\n @param channel RMT channel\n @param count loop count, 1 ~ 1023\n @return\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_OK Success"]
    pub fn rmt_set_tx_loop_count(channel: rmt_channel_t, count: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable the feature that when loop count reaches the threshold, RMT will stop transmitting.\n\n - When the loop auto-stop feature is enabled will halt RMT transmission after the loop count reaches a certain threshold\n - When disabled, the RMT transmission continue indefinitely until halted by the users\n\n @note The auto-stop feature is implemented in hardware on particular targets (i.e. those with SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP defined).\n       Otherwise, the auto-stop feature is implemented in software via the interrupt.\n\n @param channel RMT channel\n @param en enable bit\n @return\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_OK Success"]
    pub fn rmt_enable_tx_loop_autostop(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register a handler for specific RTC_CNTL interrupts\n\n Multiple handlers can be registered using this function. Whenever an\n RTC interrupt happens, all handlers with matching rtc_intr_mask values\n will be called.\n\n @param handler  handler function to call\n @param handler_arg  argument to be passed to the handler\n @param rtc_intr_mask  combination of RTC_CNTL_*_INT_ENA bits indicating the\n                       sources to call the handler for\n @param flags  An ORred mask of the RTC_INTR_FLAG_* defines. You can pass different\n               flags to it to realize different purpose. If 0, the interrupt will\n               not handle anything special. If you pass `RTC_INTR_FLAG_IRAM`, means\n               the interrupt can be triggered with cache disabled.\n @return\n      - ESP_OK on success\n      - ESP_ERR_NO_MEM not enough memory to allocate handler structure\n      - other errors returned by esp_intr_alloc"]
    pub fn rtc_isr_register(
        handler: intr_handler_t,
        handler_arg: *mut ::core::ffi::c_void,
        rtc_intr_mask: u32,
        flags: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the handler previously registered using rtc_isr_register\n @param handler  handler function to call (as passed to rtc_isr_register)\n @param handler_arg  argument of the handler (as passed to rtc_isr_register)\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_STATE if a handler matching both handler and\n        handler_arg isn't registered"]
    pub fn rtc_isr_deregister(
        handler: intr_handler_t,
        handler_arg: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable the RTC interrupt that is allowed to be executed when cache is disabled.\n cache disabled. Internal interrupt handle function will call this function in interrupt\n handler function. Disable bits when `esp_intr_noniram_disable` is called.\n\n @param cpu CPU number."]
    pub fn rtc_isr_noniram_disable(cpu: u32);
}
extern "C" {
    #[doc = " @brief Enable the RTC interrupt that is allowed to be executed when cache is disabled.\n cache disabled. Internal interrupt handle function will call this function in interrupt\n handler function. Enable bits when `esp_intr_noniram_enable` is called.\n\n @param cpu CPU number."]
    pub fn rtc_isr_noniram_enable(cpu: u32);
}
#[doc = "< Pad input"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_ONLY: rtc_gpio_mode_t = 0;
#[doc = "< Pad output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_OUTPUT_ONLY: rtc_gpio_mode_t = 1;
#[doc = "< Pad input + output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_OUTPUT: rtc_gpio_mode_t = 2;
#[doc = "< Pad (output + input) disable"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_DISABLED: rtc_gpio_mode_t = 3;
#[doc = "< Pad open-drain output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_OUTPUT_OD: rtc_gpio_mode_t = 4;
#[doc = "< Pad input + open-drain output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_OUTPUT_OD: rtc_gpio_mode_t = 5;
#[doc = " RTCIO output/input mode type."]
pub type rtc_gpio_mode_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Determine if the specified GPIO is a valid RTC GPIO.\n\n @param gpio_num GPIO number\n @return true if GPIO is valid for RTC GPIO use. false otherwise."]
    pub fn rtc_gpio_is_valid_gpio(gpio_num: gpio_num_t) -> bool;
}
#[doc = "< SIGMADELTA port 0"]
pub const sigmadelta_port_t_SIGMADELTA_PORT_0: sigmadelta_port_t = 0;
#[doc = "< SIGMADELTA port max"]
pub const sigmadelta_port_t_SIGMADELTA_PORT_MAX: sigmadelta_port_t = 1;
#[doc = " @brief SIGMADELTA port number, the max port number is (SIGMADELTA_NUM_MAX -1)."]
pub type sigmadelta_port_t = ::core::ffi::c_uint;
#[doc = "< Sigma-delta channel 0"]
pub const sigmadelta_channel_t_SIGMADELTA_CHANNEL_0: sigmadelta_channel_t = 0;
#[doc = "< Sigma-delta channel 1"]
pub const sigmadelta_channel_t_SIGMADELTA_CHANNEL_1: sigmadelta_channel_t = 1;
#[doc = "< Sigma-delta channel 2"]
pub const sigmadelta_channel_t_SIGMADELTA_CHANNEL_2: sigmadelta_channel_t = 2;
#[doc = "< Sigma-delta channel 3"]
pub const sigmadelta_channel_t_SIGMADELTA_CHANNEL_3: sigmadelta_channel_t = 3;
#[doc = "< Sigma-delta channel max"]
pub const sigmadelta_channel_t_SIGMADELTA_CHANNEL_MAX: sigmadelta_channel_t = 4;
#[doc = " @brief Sigma-delta channel list"]
pub type sigmadelta_channel_t = ::core::ffi::c_uint;
#[doc = " @brief Sigma-delta configure struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigmadelta_config_t {
    #[doc = "< Sigma-delta channel number"]
    pub channel: sigmadelta_channel_t,
    #[doc = "< Sigma-delta duty, duty ranges from -128 to 127."]
    pub sigmadelta_duty: i8,
    #[doc = "< Sigma-delta prescale, prescale ranges from 0 to 255."]
    pub sigmadelta_prescale: u8,
    #[doc = "< Sigma-delta output io number, refer to gpio.h for more details."]
    pub sigmadelta_gpio: gpio_num_t,
}
impl Default for sigmadelta_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Configure Sigma-delta channel\n\n @param  config Pointer of Sigma-delta channel configuration struct\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE sigmadelta driver already initialized\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_config(config: *const sigmadelta_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta channel duty.\n\n        This function is used to set Sigma-delta channel duty,\n        If you add a capacitor between the output pin and ground,\n        the average output voltage will be Vdc = VDDIO / 256 * duty + VDDIO/2,\n        where VDDIO is the power supply voltage.\n\n @param channel Sigma-delta channel number\n @param duty Sigma-delta duty of one channel, the value ranges from -128 to 127, recommended range is -90 ~ 90.\n             The waveform is more like a random one in this range.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_duty(channel: sigmadelta_channel_t, duty: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta channel's clock pre-scale value.\n        The source clock is APP_CLK, 80MHz. The clock frequency of the sigma-delta channel is APP_CLK / pre_scale\n\n @param channel Sigma-delta channel number\n @param prescale The divider of source clock, ranges from 0 to 255\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_prescale(channel: sigmadelta_channel_t, prescale: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta signal output pin\n\n @param channel Sigma-delta channel number\n @param gpio_num GPIO number of output pin.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_pin(channel: sigmadelta_channel_t, gpio_num: gpio_num_t) -> esp_err_t;
}
pub type slave_transaction_cb_t =
    ::core::option::Option<unsafe extern "C" fn(trans: *mut spi_slave_transaction_t)>;
#[doc = " @brief This is a configuration for a SPI host acting as a slave device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_slave_interface_config_t {
    #[doc = "< CS GPIO pin for this device"]
    pub spics_io_num: ::core::ffi::c_int,
    #[doc = "< Bitwise OR of SPI_SLAVE_* flags"]
    pub flags: u32,
    #[doc = "< Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_slave_queue_trans but not yet finished using spi_slave_get_trans_result) at the same time"]
    pub queue_size: ::core::ffi::c_int,
    #[doc = "< SPI mode, representing a pair of (CPOL, CPHA) configuration:\n- 0: (0, 0)\n- 1: (0, 1)\n- 2: (1, 0)\n- 3: (1, 1)"]
    pub mode: u8,
    #[doc = "< Callback called after the SPI registers are loaded with new data.\n\n  This callback is called within interrupt\n  context should be in IRAM for best\n  performance, see \"Transferring Speed\"\n  section in the SPI Master documentation for\n  full details. If not, the callback may crash\n  during flash operation when the driver is\n  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_setup_cb: slave_transaction_cb_t,
    #[doc = "< Callback called after a transaction is done.\n\n  This callback is called within interrupt\n  context should be in IRAM for best\n  performance, see \"Transferring Speed\"\n  section in the SPI Master documentation for\n  full details. If not, the callback may crash\n  during flash operation when the driver is\n  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_trans_cb: slave_transaction_cb_t,
}
#[doc = " This structure describes one SPI transaction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_slave_transaction_t {
    #[doc = "< Total data length, in bits"]
    pub length: usize,
    #[doc = "< Transaction data length, in bits"]
    pub trans_len: usize,
    #[doc = "< Pointer to transmit buffer, or NULL for no MOSI phase"]
    pub tx_buffer: *const ::core::ffi::c_void,
    #[doc = "< Pointer to receive buffer, or NULL for no MISO phase.\n When the DMA is anabled, must start at WORD boundary (``rx_buffer%4==0``),\n and has length of a multiple of 4 bytes."]
    pub rx_buffer: *mut ::core::ffi::c_void,
    #[doc = "< User-defined variable. Can be used to store eg transaction ID."]
    pub user: *mut ::core::ffi::c_void,
}
impl Default for spi_slave_transaction_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize a SPI bus as a slave interface\n\n @warning SPI0/1 is not supported\n\n @param host          SPI peripheral to use as a SPI slave interface\n @param bus_config    Pointer to a spi_bus_config_t struct specifying how the host should be initialized\n @param slave_config  Pointer to a spi_slave_interface_config_t struct specifying the details for the slave interface\n @param dma_chan      - Selecting a DMA channel for an SPI bus allows transactions on the bus with size only limited by the amount of internal memory.\n                      - Selecting SPI_DMA_DISABLED limits the size of transactions.\n                      - Set to SPI_DMA_DISABLED if only the SPI flash uses this bus.\n                      - Set to SPI_DMA_CH_AUTO to let the driver to allocate the DMA channel.\n\n @warning If a DMA channel is selected, any transmit and receive buffer used should be allocated in\n          DMA-capable memory.\n\n @warning The ISR of SPI is always executed on the core which calls this\n          function. Never starve the ISR on this core or the SPI transactions will not\n          be handled.\n\n @return\n         - ESP_ERR_INVALID_ARG   if configuration is invalid\n         - ESP_ERR_INVALID_STATE if host already is in use\n         - ESP_ERR_NOT_FOUND     if there is no available DMA channel\n         - ESP_ERR_NO_MEM        if out of memory\n         - ESP_OK                on success"]
    pub fn spi_slave_initialize(
        host: spi_host_device_t,
        bus_config: *const spi_bus_config_t,
        slave_config: *const spi_slave_interface_config_t,
        dma_chan: spi_dma_chan_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free a SPI bus claimed as a SPI slave interface\n\n @param host SPI peripheral to free\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_ERR_INVALID_STATE if not all devices on the bus are freed\n         - ESP_OK                on success"]
    pub fn spi_slave_free(host: spi_host_device_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a SPI transaction for execution\n\n Queues a SPI transaction to be executed by this slave device. (The transaction queue size was specified when the slave\n device was initialised via spi_slave_initialize.) This function may block if the queue is full (depending on the\n ticks_to_wait parameter). No SPI operation is directly initiated by this function, the next queued transaction\n will happen when the master initiates a SPI transaction by pulling down CS and sending out clock signals.\n\n This function hands over ownership of the buffers in ``trans_desc`` to the SPI slave driver; the application is\n not to access this memory until ``spi_slave_queue_trans`` is called to hand ownership back to the application.\n\n @param host SPI peripheral that is acting as a slave\n @param trans_desc Description of transaction to execute. Not const because we may want to write status back\n                   into the transaction description.\n @param ticks_to_wait Ticks to wait until there's room in the queue; use portMAX_DELAY to\n                      never time out.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_OK                on success"]
    pub fn spi_slave_queue_trans(
        host: spi_host_device_t,
        trans_desc: *const spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the result of a SPI transaction queued earlier\n\n This routine will wait until a transaction to the given device (queued earlier with\n spi_slave_queue_trans) has succesfully completed. It will then return the description of the\n completed transaction so software can inspect the result and e.g. free the memory or\n re-use the buffers.\n\n It is mandatory to eventually use this function for any transaction queued by ``spi_slave_queue_trans``.\n\n @param host SPI peripheral to that is acting as a slave\n @param[out] trans_desc Pointer to variable able to contain a pointer to the description of the\n                   transaction that is executed\n @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time\n                      out.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_OK                on success"]
    pub fn spi_slave_get_trans_result(
        host: spi_host_device_t,
        trans_desc: *mut *mut spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Do a SPI transaction\n\n Essentially does the same as spi_slave_queue_trans followed by spi_slave_get_trans_result. Do\n not use this when there is still a transaction queued that hasn't been finalized\n using spi_slave_get_trans_result.\n\n @param host SPI peripheral to that is acting as a slave\n @param trans_desc Pointer to variable able to contain a pointer to the description of the\n                   transaction that is executed. Not const because we may want to write status back\n                   into the transaction description.\n @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time\n                      out.\n @return\n         - ESP_ERR_INVALID_ARG   if parameter is invalid\n         - ESP_OK                on success"]
    pub fn spi_slave_transmit(
        host: spi_host_device_t,
        trans_desc: *mut spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
#[doc = "< Hw timer group 0"]
pub const timer_group_t_TIMER_GROUP_0: timer_group_t = 0;
#[doc = "< Hw timer group 1"]
pub const timer_group_t_TIMER_GROUP_1: timer_group_t = 1;
#[doc = "< Maximum number of Hw timer groups"]
pub const timer_group_t_TIMER_GROUP_MAX: timer_group_t = 2;
#[doc = " @brief Timer-Group ID"]
pub type timer_group_t = ::core::ffi::c_uint;
#[doc = "< Select timer0 of GROUPx"]
pub const timer_idx_t_TIMER_0: timer_idx_t = 0;
pub const timer_idx_t_TIMER_MAX: timer_idx_t = 1;
#[doc = " @brief Timer ID"]
pub type timer_idx_t = ::core::ffi::c_uint;
#[doc = "< interrupt of timer 0"]
pub const timer_intr_t_TIMER_INTR_T0: timer_intr_t = 1;
#[doc = "< interrupt of watchdog"]
pub const timer_intr_t_TIMER_INTR_WDT: timer_intr_t = 2;
pub const timer_intr_t_TIMER_INTR_NONE: timer_intr_t = 0;
#[doc = " @brief Interrupt types of the timer."]
pub type timer_intr_t = ::core::ffi::c_uint;
#[doc = "< Descending Count from cnt.high|cnt.low"]
pub const timer_count_dir_t_TIMER_COUNT_DOWN: timer_count_dir_t = 0;
#[doc = "< Ascending Count from Zero"]
pub const timer_count_dir_t_TIMER_COUNT_UP: timer_count_dir_t = 1;
#[doc = "< Maximum number of timer count directions"]
pub const timer_count_dir_t_TIMER_COUNT_MAX: timer_count_dir_t = 2;
#[doc = " @brief Timer count direction"]
pub type timer_count_dir_t = ::core::ffi::c_uint;
#[doc = "< Pause timer counter"]
pub const timer_start_t_TIMER_PAUSE: timer_start_t = 0;
#[doc = "< Start timer counter"]
pub const timer_start_t_TIMER_START: timer_start_t = 1;
#[doc = " @brief Timer start/stop command"]
pub type timer_start_t = ::core::ffi::c_uint;
#[doc = "< Disable timer alarm"]
pub const timer_alarm_t_TIMER_ALARM_DIS: timer_alarm_t = 0;
#[doc = "< Enable timer alarm"]
pub const timer_alarm_t_TIMER_ALARM_EN: timer_alarm_t = 1;
pub const timer_alarm_t_TIMER_ALARM_MAX: timer_alarm_t = 2;
#[doc = " @brief Timer alarm command"]
pub type timer_alarm_t = ::core::ffi::c_uint;
#[doc = "< Interrupt mode: level mode"]
pub const timer_intr_mode_t_TIMER_INTR_LEVEL: timer_intr_mode_t = 0;
pub const timer_intr_mode_t_TIMER_INTR_MAX: timer_intr_mode_t = 1;
#[doc = " @brief Timer interrupt type"]
pub type timer_intr_mode_t = ::core::ffi::c_uint;
#[doc = "< Disable auto-reload: hardware will not load counter value after an alarm event"]
pub const timer_autoreload_t_TIMER_AUTORELOAD_DIS: timer_autoreload_t = 0;
#[doc = "< Enable auto-reload: hardware will load counter value after an alarm event"]
pub const timer_autoreload_t_TIMER_AUTORELOAD_EN: timer_autoreload_t = 1;
pub const timer_autoreload_t_TIMER_AUTORELOAD_MAX: timer_autoreload_t = 2;
#[doc = " @brief Timer autoreload command"]
pub type timer_autoreload_t = ::core::ffi::c_uint;
#[doc = " @brief Type of Timer Group clock source, reserved for the legacy timer group driver"]
pub use self::soc_periph_tg_clk_src_legacy_t as timer_src_clk_t;
#[doc = " @brief Interrupt handler callback function\n\n @return\n     - True Do task yield at the end of ISR\n     - False Not do task yield at the end of ISR\n\n @note If you called FreeRTOS functions in callback, you need to return true or false based on\n       the retrun value of argument `pxHigherPriorityTaskWoken`.\n       For example, `xQueueSendFromISR` is called in callback, if the return value `pxHigherPriorityTaskWoken`\n       of any FreeRTOS calls is pdTRUE, return true; otherwise return false."]
pub type timer_isr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> bool>;
#[doc = " @brief Interrupt handle, used in order to free the isr after use."]
pub type timer_isr_handle_t = intr_handle_t;
#[doc = " @brief Timer configurations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_config_t {
    #[doc = "< Timer alarm enable"]
    pub alarm_en: timer_alarm_t,
    #[doc = "< Counter enable"]
    pub counter_en: timer_start_t,
    #[doc = "< Interrupt mode"]
    pub intr_type: timer_intr_mode_t,
    #[doc = "< Counter direction"]
    pub counter_dir: timer_count_dir_t,
    #[doc = "< Timer auto-reload"]
    pub auto_reload: timer_autoreload_t,
    #[doc = "< Selects source clock."]
    pub clk_src: timer_src_clk_t,
    #[doc = "< Counter clock divider"]
    pub divider: u32,
}
impl Default for timer_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Read the counter value of hardware timer.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param timer_val Pointer to accept timer counter value.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_counter_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        timer_val: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read the counter value of hardware timer, in unit of a given scale.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param time Pointer, type of double*, to accept timer counter value, in seconds.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_counter_time_sec(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        time: *mut f64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set counter value to hardware timer.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param load_val Counter value to write to the hardware timer.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_counter_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        load_val: u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start the counter of hardware timer.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_start(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause the counter of hardware timer.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_pause(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set counting mode for hardware timer.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param counter_dir Counting direction of timer, count-up or count-down\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_counter_mode(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        counter_dir: timer_count_dir_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable counter reload function when alarm event occurs.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param reload Counter reload mode.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_auto_reload(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        reload: timer_autoreload_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware divider of the source clock to the timer group.\n By default, the source clock is APB clock running at 80 MHz.\n For more information, please check Chapter Reset and Clock in Chip Technical Reference Manual.\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param divider Timer clock divider value. The divider's range is from from 2 to 65536.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_divider(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        divider: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set timer alarm value.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param alarm_value A 64-bit value to set the alarm value.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_alarm_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_value: u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get timer alarm value.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param alarm_value Pointer of A 64-bit value to accept the alarm value.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_alarm_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable generation of timer alarm events.\n\n @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param alarm_en To enable or disable timer alarm function.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_alarm(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_en: timer_alarm_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Add ISR handle callback for the corresponding timer.\n\n @param group_num Timer group number\n @param timer_num Timer index of timer group\n @param isr_handler Interrupt handler function, it is a callback function.\n @param arg Parameter for handler function\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n\n @note This ISR handler will be called from an ISR.\n       This ISR handler do not need to handle interrupt status, and should be kept short.\n       If you want to realize some specific applications or write the whole ISR, you can\n       call timer_isr_register(...) to register ISR.\n\n       The callback should return a bool value to determine whether need to do YIELD at\n       the end of the ISR.\n\n       If the intr_alloc_flags value ESP_INTR_FLAG_IRAM is set,\n       the handler function must be declared with IRAM_ATTR attribute\n       and can only call functions in IRAM or ROM. It cannot call other timer APIs.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_callback_add(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        isr_handler: timer_isr_t,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handle callback for the corresponding timer.\n\n @param group_num Timer group number\n @param timer_num Timer index of timer group\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_callback_remove(group_num: timer_group_t, timer_num: timer_idx_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register Timer interrupt handler, the handler is an ISR.\n        The handler will be attached to the same CPU core that this function is running on.\n\n @param group_num Timer group number\n @param timer_num Timer index of timer group\n @param fn Interrupt handler function.\n @param arg Parameter for handler function\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info.\n @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will\n        be returned here.\n\n @note If use this function to reigster ISR, you need to write the whole ISR.\n       In the interrupt handler, you need to call timer_spinlock_take(..) before\n       your handling, and call timer_spinlock_give(...) after your handling.\n\n       If the intr_alloc_flags value ESP_INTR_FLAG_IRAM is set,\n       the handler function must be declared with IRAM_ATTR attribute\n       and can only call functions in IRAM or ROM. It cannot call other timer APIs.\n       Use direct register access to configure timers from inside the ISR in this case.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_register(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::core::ffi::c_int,
        handle: *mut timer_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initializes and configure the timer.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param config Pointer to timer initialization parameters.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_init(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        config: *const timer_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitializes the timer.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_deinit(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get timer configure value.\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]\n @param config Pointer of struct to accept timer parameters.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_config(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        config: *mut timer_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable timer group interrupt, by enable mask\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param intr_mask Timer interrupt enable mask.\n          - TIMER_INTR_T0: t0 interrupt\n          - TIMER_INTR_T1: t1 interrupt\n          - TIMER_INTR_WDT: watchdog interrupt\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_group_intr_enable(group_num: timer_group_t, intr_mask: timer_intr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable timer group interrupt, by disable mask\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param intr_mask Timer interrupt disable mask.\n          - TIMER_INTR_T0: t0 interrupt\n          - TIMER_INTR_T1: t1 interrupt\n          - TIMER_INTR_WDT: watchdog interrupt\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_group_intr_disable(group_num: timer_group_t, intr_mask: timer_intr_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable timer interrupt\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_enable_intr(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable timer interrupt\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_disable_intr(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear timer interrupt status, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n"]
    pub fn timer_group_clr_intr_status_in_isr(group_num: timer_group_t, timer_num: timer_idx_t);
}
extern "C" {
    #[doc = " @brief Enable alarm interrupt, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n"]
    pub fn timer_group_enable_alarm_in_isr(group_num: timer_group_t, timer_num: timer_idx_t);
}
extern "C" {
    #[doc = " @brief Get the current counter value, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n\n @return\n     - Counter value"]
    pub fn timer_group_get_counter_value_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
    ) -> u64;
}
extern "C" {
    #[doc = " @brief Set the alarm threshold for the timer, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n @param alarm_val Alarm threshold.\n"]
    pub fn timer_group_set_alarm_value_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_val: u64,
    );
}
extern "C" {
    #[doc = " @brief Enable/disable a counter, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index.\n @param counter_en Enable/disable.\n"]
    pub fn timer_group_set_counter_enable_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        counter_en: timer_start_t,
    );
}
extern "C" {
    #[doc = " @brief Get interrupt status, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n\n @return\n     - Interrupt status"]
    pub fn timer_group_get_intr_status_in_isr(group_num: timer_group_t) -> u32;
}
extern "C" {
    #[doc = " @brief Get auto reload enable status, just used in ISR\n\n @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1\n @param timer_num Timer index\n\n @return\n     - True Auto reload enabled\n     - False Auto reload disabled"]
    pub fn timer_group_get_auto_reload_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
    ) -> bool;
}
#[doc = " @brief UART port number, can be UART_NUM_0 ~ (UART_NUM_MAX -1)."]
pub type uart_port_t = ::core::ffi::c_int;
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = "< mode: half duplex RS485 UART mode control by RTS pin"]
pub const uart_mode_t_UART_MODE_RS485_HALF_DUPLEX: uart_mode_t = 1;
#[doc = "< mode: IRDA  UART mode"]
pub const uart_mode_t_UART_MODE_IRDA: uart_mode_t = 2;
#[doc = "< mode: RS485 collision detection UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_COLLISION_DETECT: uart_mode_t = 3;
#[doc = "< mode: application control RS485 UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_APP_CTRL: uart_mode_t = 4;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = ::core::ffi::c_uint;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = ::core::ffi::c_uint;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = ::core::ffi::c_uint;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = ::core::ffi::c_uint;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = ::core::ffi::c_uint;
#[doc = "< Disable UART signal inverse"]
pub const uart_signal_inv_t_UART_SIGNAL_INV_DISABLE: uart_signal_inv_t = 0;
#[doc = "< inverse the UART irda_tx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_TX_INV: uart_signal_inv_t = 1;
#[doc = "< inverse the UART irda_rx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_RX_INV: uart_signal_inv_t = 2;
#[doc = "< inverse the UART rxd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RXD_INV: uart_signal_inv_t = 4;
#[doc = "< inverse the UART cts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_CTS_INV: uart_signal_inv_t = 8;
#[doc = "< inverse the UART dsr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DSR_INV: uart_signal_inv_t = 16;
#[doc = "< inverse the UART txd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_TXD_INV: uart_signal_inv_t = 32;
#[doc = "< inverse the UART rts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RTS_INV: uart_signal_inv_t = 64;
#[doc = "< inverse the UART dtr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DTR_INV: uart_signal_inv_t = 128;
#[doc = " @brief UART signal bit map"]
pub type uart_signal_inv_t = ::core::ffi::c_uint;
#[doc = " @brief Type of UART clock source, reserved for the legacy UART driver"]
pub use self::soc_periph_uart_clk_src_legacy_t as uart_sclk_t;
#[doc = " @brief UART AT cmd char configuration parameters\n        Note that this function may different on different chip. Please refer to the TRM at confirguration."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uart_at_cmd_t {
    #[doc = "< UART AT cmd char"]
    pub cmd_char: u8,
    #[doc = "< AT cmd char repeat number"]
    pub char_num: u8,
    #[doc = "< gap time(in baud-rate) between AT cmd char"]
    pub gap_tout: u32,
    #[doc = "< the idle time(in baud-rate) between the non AT char and first AT char"]
    pub pre_idle: u32,
    #[doc = "< the idle time(in baud-rate) between the last AT char and the none AT char"]
    pub post_idle: u32,
}
#[doc = " @brief UART software flow control configuration parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uart_sw_flowctrl_t {
    #[doc = "< Xon flow control char"]
    pub xon_char: u8,
    #[doc = "< Xoff flow control char"]
    pub xoff_char: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is less than xon_thrd, an xon_char will be sent"]
    pub xon_thrd: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is more than xoff_thrd, an xoff_char will be sent"]
    pub xoff_thrd: u8,
}
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate"]
    pub baud_rate: ::core::ffi::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
    #[doc = "< UART source clock selection"]
    pub source_clk: uart_sclk_t,
}
impl Default for uart_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[doc = "< UART data event"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< UART break event"]
pub const uart_event_type_t_UART_BREAK: uart_event_type_t = 1;
#[doc = "< UART RX buffer full event"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 2;
#[doc = "< UART FIFO overflow event"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 3;
#[doc = "< UART RX frame error event"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 4;
#[doc = "< UART RX parity event"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 5;
#[doc = "< UART TX data and break event"]
pub const uart_event_type_t_UART_DATA_BREAK: uart_event_type_t = 6;
#[doc = "< UART pattern detected"]
pub const uart_event_type_t_UART_PATTERN_DET: uart_event_type_t = 7;
#[doc = "< UART wakeup event"]
pub const uart_event_type_t_UART_WAKEUP: uart_event_type_t = 8;
#[doc = "< UART event max index"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 9;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = ::core::ffi::c_uint;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: usize,
    #[doc = "< UART data read timeout flag for UART_DATA event (no new data received during configured RX TOUT)*/\n/*!< If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming."]
    pub timeout_flag: bool,
}
impl Default for uart_event_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type uart_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Install UART driver and set the UART to the default configuration.\n\n UART ISR handler will be attached to the same CPU core that this function is running on.\n\n @note  Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param rx_buffer_size UART RX ring buffer size.\n @param tx_buffer_size UART TX ring buffer size.\n        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out.\n @param queue_size UART event queue size/depth.\n @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide\n        access to UART events. If set to NULL, driver will not use an event queue.\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here\n        (the driver's ISR handler is not located in IRAM)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: ::core::ffi::c_int,
        tx_buffer_size: ::core::ffi::c_int,
        queue_size: ::core::ffi::c_int,
        uart_queue: *mut QueueHandle_t,
        intr_alloc_flags: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall UART driver.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Checks whether the driver is installed or not\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - true  driver is installed\n     - false driver is not installed"]
    pub fn uart_is_driver_installed(uart_num: uart_port_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set UART data bits.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param data_bit UART data bits\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART data bit configuration.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param data_bit Pointer to accept value of UART data bits.\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success, result will be put in (*data_bit)"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART stop bits.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param stop_bits  UART stop bits\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Fail"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART stop bit configuration.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param stop_bits  Pointer to accept value of UART stop bits.\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*stop_bit)"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART parity mode.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param parity_mode the enum of uart parity configuration\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART parity mode configuration.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param parity_mode Pointer to accept value of UART parity mode.\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success, result will be put in (*parity_mode)\n"]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the frequency of a clock source for the UART\n\n @param sclk Clock source\n @param[out] out_freq_hz Output of frequency, in Hz\n\n @return\n  - ESP_ERR_INVALID_ARG: if the clock source is not supported\n  - otherwise ESP_OK"]
    pub fn uart_get_sclk_freq(sclk: uart_sclk_t, out_freq_hz: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART baud rate.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param baudrate UART baud rate.\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART baud rate configuration.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param baudrate Pointer to accept value of UART baud rate\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*baudrate)\n"]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART line inverse mode\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param inverse_mask Choose the wires that need to be inverted. Using the ORred mask of `uart_signal_inv_t`\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware flow control.\n\n @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1).\n @param flow_ctrl Hardware flow control mode\n @param rx_thresh Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN).\n        Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set software flow control.\n\n @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2\n @param enable     switch on or off\n @param rx_thresh_xon  low water mark\n @param rx_thresh_xoff high water mark\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_sw_flow_ctrl(
        uart_num: uart_port_t,
        enable: bool,
        rx_thresh_xon: u8,
        rx_thresh_xoff: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART hardware flow control configuration.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param flow_ctrl Option for different flow control mode.\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt status\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param clr_mask  Bit mask of the interrupt status to be cleared.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, clr_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART interrupt enable\n\n @param uart_num     UART port number, the max port number is (UART_NUM_MAX -1).\n @param enable_mask  Bit mask of the enable bits.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits\n\n @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1).\n @param disable_mask  Bit mask of the disable bits.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param enable  1: enable; 0: disable\n @param thresh  Threshold of TX interrupt, 0 ~ UART_FIFO_LEN\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: ::core::ffi::c_int,
        thresh: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Assign signals of a UART peripheral to GPIO pins\n\n @note If the GPIO number configured for a UART signal matches one of the\n       IOMUX signals for that GPIO, the signal will be connected directly\n       via the IOMUX. Otherwise the GPIO and signal will be connected via\n       the GPIO Matrix. For example, if on an ESP32 the call\n       `uart_set_pin(0, 1, 3, -1, -1)` is performed, as GPIO1 is UART0's\n       default TX pin and GPIO3 is UART0's default RX pin, both will be\n       connected to respectively U0TXD and U0RXD through the IOMUX, totally\n       bypassing the GPIO matrix.\n       The check is performed on a per-pin basis. Thus, it is possible to have\n       RX pin binded to a GPIO through the GPIO matrix, whereas TX is binded\n       to its GPIO through the IOMUX.\n\n @note Internal signal can be output to multiple GPIO pads.\n       Only one GPIO pad can connect with input signal.\n\n @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1).\n @param tx_io_num  UART TX pin GPIO number.\n @param rx_io_num  UART RX pin GPIO number.\n @param rts_io_num UART RTS pin GPIO number.\n @param cts_io_num UART CTS pin GPIO number.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_pin(
        uart_num: uart_port_t,
        tx_io_num: ::core::ffi::c_int,
        rx_io_num: ::core::ffi::c_int,
        rts_io_num: ::core::ffi::c_int,
        cts_io_num: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART RTS pin level.\n @note  UART must be configured with hardware flow control disabled.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param level    1: RTS output low (active); 0: RTS output high (block)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_rts(uart_num: uart_port_t, level: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART DTR pin level.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param level    1: DTR output low; 0: DTR output high\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_dtr(uart_num: uart_port_t, level: ::core::ffi::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART idle interval after tx FIFO is empty\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param idle_num idle interval after tx FIFO is empty(unit: the time it takes to send one bit\n        under current baudrate)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_tx_idle_num(uart_num: uart_port_t, idle_num: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART configuration parameters.\n\n @param uart_num    UART port number, the max port number is (UART_NUM_MAX -1).\n @param uart_config UART parameter settings\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_config: *const uart_config_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure UART interrupts.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param intr_conf UART interrupt settings\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        intr_conf: *const uart_intr_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART TX FIFO is empty.\n\n @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1).\n @param ticks_to_wait Timeout, count in RTOS ticks\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error\n     - ESP_ERR_TIMEOUT  Timeout"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length.\n\n This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full.\n @note This function should only be used when UART TX buffer is not enabled.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param buffer data buffer address\n @param len    data length to send\n\n @return\n     - (-1)  Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(
        uart_num: uart_port_t,
        buffer: *const ::core::ffi::c_char,
        len: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,\n\n If the UART driver's parameter 'tx_buffer_size' is set to zero:\n This function will not return until all the data have been sent out, or at least pushed into TX FIFO.\n\n Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,\n UART ISR will then move data from the ring buffer to TX FIFO gradually.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param src   data buffer address\n @param size  data length to send\n\n @return\n     - (-1) Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const ::core::ffi::c_void,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,\n\n If the UART driver's parameter 'tx_buffer_size' is set to zero:\n This function will not return until all the data and the break signal have been sent out.\n After all data is sent out, send a break signal.\n\n Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,\n UART ISR will then move data from the ring buffer to TX FIFO gradually.\n After all data sent out, send a break signal.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param src   data buffer address\n @param size  data length to send\n @param brk_len break signal duration(unit: the time it takes to send one bit at current baudrate)\n\n @return\n     - (-1) Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes_with_break(
        uart_num: uart_port_t,
        src: *const ::core::ffi::c_void,
        size: usize,
        brk_len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief UART read bytes from UART buffer\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param buf     pointer to the buffer.\n @param length  data length\n @param ticks_to_wait sTimeout, count in RTOS ticks\n\n @return\n     - (-1) Error\n     - OTHERS (>=0) The number of bytes read from UART FIFO"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut ::core::ffi::c_void,
        length: u32,
        ticks_to_wait: TickType_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Alias of uart_flush_input.\n        UART ring buffer flush. This will discard all data in the UART RX buffer.\n @note  Instead of waiting the data sent out, this function will clear UART rx buffer.\n        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function.\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer.\n @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function.\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length\n\n @param   uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param   size Pointer of size_t to accept cached data length\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get TX ring buffer free space size\n\n @param   uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param   size Pointer of size_t to accept the free space size\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_tx_buffer_free_size(uart_num: uart_port_t, size: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART disable pattern detect function.\n          Designed for applications like 'AT commands'.\n          When the hardware detects a series of one same character, the interrupt will be triggered.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_pattern_det_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART enable pattern detect function.\n        Designed for applications like 'AT commands'.\n        When the hardware detect a series of one same character, the interrupt will be triggered.\n\n @param uart_num UART port number.\n @param pattern_chr character of the pattern.\n @param chr_num number of the character, 8bit value.\n @param chr_tout timeout of the interval between each pattern characters, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is more than this value, it will not take this data as at_cmd char.\n @param post_idle idle time after the last pattern character, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is less than this value, it will not take the previous data as the last at_cmd char\n @param pre_idle idle time before the first pattern character, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is less than this value, it will not take this data as the first at_cmd char.\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_pattern_det_baud_intr(
        uart_num: uart_port_t,
        pattern_chr: ::core::ffi::c_char,
        chr_num: u8,
        chr_tout: ::core::ffi::c_int,
        post_idle: ::core::ffi::c_int,
        pre_idle: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer.\n        The positions of the detected pattern are saved in a queue,\n        this function will dequeue the first pattern position and move the pointer to next pattern position.\n @note  If the RX buffer is full and flow control is not enabled,\n        the detected pattern may not be found in the rx buffer due to overflow.\n\n        The following APIs will modify the pattern position info:\n        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos\n        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer\n        when using pattern detect feature.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @return\n     - (-1) No pattern found for current index or parameter error\n     - others the pattern position in rx buffer."]
    pub fn uart_pattern_pop_pos(uart_num: uart_port_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer.\n        The positions of the detected pattern are saved in a queue,\n        This function do nothing to the queue.\n @note  If the RX buffer is full and flow control is not enabled,\n        the detected pattern may not be found in the rx buffer due to overflow.\n\n        The following APIs will modify the pattern position info:\n        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos\n        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer\n        when using pattern detect feature.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @return\n     - (-1) No pattern found for current index or parameter error\n     - others the pattern position in rx buffer."]
    pub fn uart_pattern_get_pos(uart_num: uart_port_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Allocate a new memory with the given length to save record the detected pattern position in rx buffer.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param queue_length Max queue length for the detected pattern.\n        If the queue length is not large enough, some pattern positions might be lost.\n        Set this value to the maximum number of patterns that could be saved in data buffer at the same time.\n @return\n     - ESP_ERR_NO_MEM No enough memory\n     - ESP_ERR_INVALID_STATE Driver not installed\n     - ESP_FAIL Parameter error\n     - ESP_OK Success"]
    pub fn uart_pattern_queue_reset(
        uart_num: uart_port_t,
        queue_length: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set communication mode\n\n @note  This function must be executed after uart_driver_install(), when the driver object is initialized.\n @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1).\n @param mode UART    UART mode to set\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_mode(uart_num: uart_port_t, mode: uart_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set uart threshold value for RX fifo full\n @note If application is using higher baudrate and it is observed that bytes\n       in hardware RX fifo are overwritten then this threshold can be reduced\n\n @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2\n @param threshold Threshold value above which RX fifo full interrupt is generated\n\n @return\n     - ESP_OK   Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_full_threshold(
        uart_num: uart_port_t,
        threshold: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set uart threshold values for TX fifo empty\n\n @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2\n @param threshold Threshold value below which TX fifo empty interrupt is generated\n\n @return\n     - ESP_OK   Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_tx_empty_threshold(
        uart_num: uart_port_t,
        threshold: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature\n\n @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1).\n @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126.\n        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate.\n        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,\n        the TOUT feature is disabled.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns collision detection flag for RS485 mode\n        Function returns the collision detection flag into variable pointed by collision_flag.\n        *collision_flag = true, if collision detected else it is equal to false.\n        This function should be executed when actual transmission is completed (after uart_write_bytes()).\n\n @param uart_num  Uart number to configure the max port number is (UART_NUM_MAX -1).\n @param collision_flag Pointer to variable of type bool to return collision flag.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_collision_flag(uart_num: uart_port_t, collision_flag: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the number of RX pin signal edges for light sleep wakeup\n\n UART can be used to wake up the system from light sleep. This feature works\n by counting the number of positive edges on RX pin and comparing the count to\n the threshold. When the count exceeds the threshold, system is woken up from\n light sleep. This function allows setting the threshold value.\n\n Stop bit and parity bits (if enabled) also contribute to the number of edges.\n For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire\n (with 8n1 configuration), start and stop bits included. This sequence has 3\n positive edges (transitions from 0 to 1). Therefore, to wake up the system\n when 'a' is sent, set wakeup_threshold=3.\n\n The character that triggers wakeup is not received by UART (i.e. it can not\n be obtained from UART FIFO). Depending on the baud rate, a few characters\n after that will also not be received. Note that when the chip enters and exits\n light sleep mode, APB frequency will be changing. To make sure that UART has\n correct baud rate all the time, select UART_SCLK_REF_TICK or UART_SCLK_XTAL as UART clock source in uart_config_t::source_clk.\n\n @note in ESP32, the wakeup signal can only be input via IO_MUX (i.e.\n       GPIO3 should be configured as function_1 to wake up UART0,\n       GPIO9 should be configured as function_5 to wake up UART1), UART2\n       does not support light sleep wakeup feature.\n\n @param uart_num  UART number, the max port number is (UART_NUM_MAX -1).\n @param wakeup_threshold  number of RX edges for light sleep wakeup, value is 3 .. 0x3ff.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is\n        outside of [3, 0x3ff] range."]
    pub fn uart_set_wakeup_threshold(
        uart_num: uart_port_t,
        wakeup_threshold: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the number of RX pin signal edges for light sleep wakeup.\n\n See description of uart_set_wakeup_threshold for the explanation of UART\n wakeup feature.\n\n @param uart_num  UART number, the max port number is (UART_NUM_MAX -1).\n @param[out] out_wakeup_threshold  output, set to the current value of wakeup\n                                   threshold for the given UART.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL"]
    pub fn uart_get_wakeup_threshold(
        uart_num: uart_port_t,
        out_wakeup_threshold: *mut ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART tx memory empty and the last char send ok (polling mode).\n\n @param uart_num UART number\n\n * @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL Driver not installed"]
    pub fn uart_wait_tx_idle_polling(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure TX signal loop back to RX module, just for the test usage.\n\n @param uart_num UART number\n @param loop_back_en Set ture to enable the loop back function, else set it false.\n\n * @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL Driver not installed"]
    pub fn uart_set_loop_back(uart_num: uart_port_t, loop_back_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure behavior of UART RX timeout interrupt.\n\n When always_rx_timeout is true, timeout interrupt is triggered even if FIFO is full.\n This function can cause extra timeout interrupts triggered only to send the timeout event.\n Call this function only if you want to ensure timeout interrupt will always happen after a byte stream.\n\n @param uart_num UART number\n @param always_rx_timeout_en Set to false enable the default behavior of timeout interrupt,\n                             set it to true to always trigger timeout interrupt.\n"]
    pub fn uart_set_always_rx_timeout(uart_num: uart_port_t, always_rx_timeout_en: bool);
}
pub const uart_select_notif_t_UART_SELECT_READ_NOTIF: uart_select_notif_t = 0;
pub const uart_select_notif_t_UART_SELECT_WRITE_NOTIF: uart_select_notif_t = 1;
pub const uart_select_notif_t_UART_SELECT_ERROR_NOTIF: uart_select_notif_t = 2;
pub type uart_select_notif_t = ::core::ffi::c_uint;
pub type uart_select_notif_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        uart_num: uart_port_t,
        uart_select_notif: uart_select_notif_t,
        task_woken: *mut BaseType_t,
    ),
>;
extern "C" {
    #[doc = " @brief Set notification callback function for select() events\n @param uart_num UART port number\n @param uart_select_notif_callback callback function"]
    pub fn uart_set_select_notif_callback(
        uart_num: uart_port_t,
        uart_select_notif_callback: uart_select_notif_callback_t,
    );
}
extern "C" {
    #[doc = " @brief Get mutex guarding select() notifications"]
    pub fn uart_get_selectlock() -> *mut portMUX_TYPE;
}
#[doc = " @brief Type of Temp Sensor clock source"]
pub use self::soc_periph_temperature_sensor_clk_src_t as temperature_sensor_clk_src_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct temperature_sensor_obj_t {
    _unused: [u8; 0],
}
#[doc = " @brief Type of temperature sensor driver handle"]
pub type temperature_sensor_handle_t = *mut temperature_sensor_obj_t;
#[doc = " @brief Configuration of measurement range for the temperature sensor.\n\n @note If you see the log `the boundary you gave cannot meet the range of internal temperature sensor`. You may need to refer to\n       predefined range listed doc ``api-reference/peripherals/Temperature sensor``."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct temperature_sensor_config_t {
    #[doc = "< the minimum value of the temperature you want to test"]
    pub range_min: ::core::ffi::c_int,
    #[doc = "< the maximum value of the temperature you want to test"]
    pub range_max: ::core::ffi::c_int,
    #[doc = "< the clock source of the temperature sensor."]
    pub clk_src: temperature_sensor_clk_src_t,
}
impl Default for temperature_sensor_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Install temperature sensor driver\n\n @param tsens_config Pointer to config structure.\n @param ret_tsens Return the pointer of temperature sensor handle.\n @return\n      - ESP_OK if succeed"]
    pub fn temperature_sensor_install(
        tsens_config: *const temperature_sensor_config_t,
        ret_tsens: *mut temperature_sensor_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the temperature sensor driver\n\n @param tsens The handle created by `temperature_sensor_install()`.\n @return\n      - ESP_OK if succeed."]
    pub fn temperature_sensor_uninstall(tsens: temperature_sensor_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the temperature sensor\n\n @param tsens The handle created by `temperature_sensor_install()`.\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE if temperature sensor is enabled already."]
    pub fn temperature_sensor_enable(tsens: temperature_sensor_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable temperature sensor\n\n @param tsens The handle created by `temperature_sensor_install()`.\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_STATE if temperature sensor is not enabled yet."]
    pub fn temperature_sensor_disable(tsens: temperature_sensor_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read temperature sensor data that is converted to degrees Celsius.\n @note  Should not be called from interrupt.\n\n @param tsens The handle created by `temperature_sensor_install()`.\n @param out_celsius The measure output value.\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG invalid arguments\n     - ESP_ERR_INVALID_STATE Temperature sensor is not enabled yet.\n     - ESP_FAIL Parse the sensor data into ambient temperature failed (e.g. out of the range)."]
    pub fn temperature_sensor_get_celsius(
        tsens: temperature_sensor_handle_t,
        out_celsius: *mut f32,
    ) -> esp_err_t;
}
extern "C" {
    pub static mut g_panic_abort: bool;
}
extern "C" {
    pub static mut g_exc_frames: [*mut ::core::ffi::c_void; 1usize];
}
pub type panic_info_dump_fn_t =
    ::core::option::Option<unsafe extern "C" fn(frame: *const ::core::ffi::c_void)>;
pub const panic_exception_t_PANIC_EXCEPTION_DEBUG: panic_exception_t = 0;
pub const panic_exception_t_PANIC_EXCEPTION_IWDT: panic_exception_t = 1;
pub const panic_exception_t_PANIC_EXCEPTION_TWDT: panic_exception_t = 2;
pub const panic_exception_t_PANIC_EXCEPTION_ABORT: panic_exception_t = 3;
pub const panic_exception_t_PANIC_EXCEPTION_FAULT: panic_exception_t = 4;
pub type panic_exception_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct panic_info_t {
    pub core: ::core::ffi::c_int,
    pub exception: panic_exception_t,
    pub reason: *const ::core::ffi::c_char,
    pub description: *const ::core::ffi::c_char,
    pub details: panic_info_dump_fn_t,
    pub state: panic_info_dump_fn_t,
    pub addr: *const ::core::ffi::c_void,
    pub frame: *const ::core::ffi::c_void,
    pub pseudo_excause: bool,
}
impl Default for panic_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn panic_print_char(c: ::core::ffi::c_char);
}
extern "C" {
    pub fn panic_print_str(str_: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn panic_print_dec(d: ::core::ffi::c_int);
}
extern "C" {
    pub fn panic_print_hex(h: ::core::ffi::c_int);
}
extern "C" {
    pub fn panic_abort(details: *const ::core::ffi::c_char) -> !;
}
extern "C" {
    pub fn panic_arch_fill_info(frame: *mut ::core::ffi::c_void, info: *mut panic_info_t);
}
extern "C" {
    pub fn panic_soc_fill_info(frame: *mut ::core::ffi::c_void, info: *mut panic_info_t);
}
extern "C" {
    pub fn panic_print_registers(frame: *const ::core::ffi::c_void, core: ::core::ffi::c_int);
}
extern "C" {
    pub fn panic_print_backtrace(frame: *const ::core::ffi::c_void, core: ::core::ffi::c_int);
}
extern "C" {
    pub fn panic_get_address(frame: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn panic_set_address(frame: *mut ::core::ffi::c_void, addr: u32);
}
extern "C" {
    pub fn panic_get_cause(frame: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    #[doc = " @brief  Initializes core dump module internal data.\n\n @note  Should be called at system startup."]
    pub fn esp_core_dump_init();
}
extern "C" {
    #[doc = " @brief  Saves core dump to flash.\n\n The structure of data stored in flash is as follows:\n\n |  TOTAL_LEN |  VERSION    | TASKS_NUM   | TCB_SIZE |\n | TCB_ADDR_1 | STACK_TOP_1 | STACK_END_1 | TCB_1    | STACK_1 |\n .            .       .         .\n .            .       .         .\n | TCB_ADDR_N | STACK_TOP_N | STACK_END_N | TCB_N    | STACK_N |\n |  CHECKSUM  |\n\n Core dump in flash consists of header and data for every task in the system at the moment of crash.\n For flash data integrity, a checksum is used at the end of core the dump data.\n The structure of core dump data is described below in details.\n 1) Core dump starts with header:\n 1.1) TOTAL_LEN is total length of core dump data in flash including the checksum. Size is 4 bytes.\n 1.2) VERSION field keeps 4 byte version of core dump.\n 1.2) TASKS_NUM is the number of tasks for which data are stored. Size is 4 bytes.\n 1.3) TCB_SIZE is the size of task's TCB structure. Size is 4 bytes.\n 2) Core dump header is followed by the data for every task in the system.\n    Task data are started with task header:\n 2.1) TCB_ADDR is the address of TCB in memory. Size is 4 bytes.\n 2.2) STACK_TOP is the top of task's stack (address of the topmost stack item). Size is 4 bytes.\n 2.2) STACK_END is the end of task's stack (address from which task's stack starts). Size is 4 bytes.\n 3) Task header is followed by TCB data. Size is TCB_SIZE bytes.\n 4) Task's stack is placed after TCB data. Size is (STACK_END - STACK_TOP) bytes.\n 5) The checksum is placed at the end of the data."]
    pub fn esp_core_dump_to_flash(info: *mut panic_info_t);
}
extern "C" {
    #[doc = " @brief  Print base64-encoded core dump to UART.\n\n The structure of core dump data is the same as for data stored in flash (@see esp_core_dump_to_flash) with some notes:\n 1) The checksum is not present in core dump printed to UART.\n 2) Since checksum is omitted TOTAL_LEN does not include its size.\n 3) Printed base64 data are surrounded with special messages to help user recognize the start and end of actual data."]
    pub fn esp_core_dump_to_uart(info: *mut panic_info_t);
}
extern "C" {
    #[doc = " @brief  Check integrity of coredump data in flash.\n         This function reads the coredump data while calculating their checksum. If it\n         doesn't match the checksum written on flash, it means data are corrupted,\n         an error will be returned. Else, ESP_OK is returned.\n\n @return `ESP_OK` if core dump is present and valid, `ESP_ERR_NOT_FOUND` if no core dump\n         is stored in the partition, `ESP_ERR_INVALID_SIZE` or `ESP_ERR_INVALID_CRC`\n         if the core dump is corrupted, other errors when unable to access flash, in that\n         case please refer to \\see esp_err_t"]
    pub fn esp_core_dump_image_check() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Retrieves address and size of coredump data in flash.\n         This function is always available, even when core dump is disabled in menuconfig.\n\n @param  out_addr   pointer to store image address in flash.\n @param  out_size   pointer to store image size in flash (including checksum). In bytes.\n\n @return ESP_OK on success, otherwise \\see esp_err_t"]
    pub fn esp_core_dump_image_get(out_addr: *mut usize, out_size: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Erases coredump data in flash. esp_core_dump_image_get() will then return\n         ESP_ERR_NOT_FOUND. Can be used after a coredump has been transmitted successfully.\n         This function is always available, even when core dump is disabled in menuconfig.\n\n @return ESP_OK on success, otherwise \\see esp_err_t"]
    pub fn esp_core_dump_image_erase() -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_context {
    pub _routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub _arg: *mut ::core::ffi::c_void,
    pub _canceltype: ::core::ffi::c_int,
    pub _previous: *mut _pthread_cleanup_context,
}
impl Default for _pthread_cleanup_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __attr: *const pthread_mutexattr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __timeout: *const timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut clockid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: clockid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __attr: *const pthread_condattr_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__mutex: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        attr: *mut pthread_attr_t,
        __stackaddr: *mut ::core::ffi::c_void,
        __stacksize: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::core::ffi::c_void,
        __stacksize: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_create(
        __pthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_join(
        __pthread: pthread_t,
        __value_ptr: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_detach(__pthread: pthread_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_exit(__value_ptr: *mut ::core::ffi::c_void) -> !;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__t1: pthread_t, __t2: pthread_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(thread: pthread_t, clock_id: *mut clockid_t)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(new_level: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_yield();
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __value: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_cancel(__pthread: pthread_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::core::ffi::c_int,
        __oldstate: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::core::ffi::c_int,
        __oldtype: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn _pthread_cleanup_push(
        _context: *mut _pthread_cleanup_context,
        _routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        _arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn _pthread_cleanup_pop(
        _context: *mut _pthread_cleanup_context,
        _execute: ::core::ffi::c_int,
    );
}
#[doc = " pthread configuration structure that influences pthread creation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_pthread_cfg_t {
    #[doc = "< The stack size of the pthread"]
    pub stack_size: usize,
    #[doc = "< The thread's priority"]
    pub prio: usize,
    #[doc = "< Inherit this configuration further"]
    pub inherit_cfg: bool,
    #[doc = "< The thread name."]
    pub thread_name: *const ::core::ffi::c_char,
    #[doc = "< The core id to pin the thread to. Has the same value range as xCoreId argument of xTaskCreatePinnedToCore."]
    pub pin_to_core: ::core::ffi::c_int,
}
impl Default for esp_pthread_cfg_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Creates a default pthread configuration based\n on the values set via menuconfig.\n\n @return\n      A default configuration structure."]
    pub fn esp_pthread_get_default_config() -> esp_pthread_cfg_t;
}
extern "C" {
    #[doc = " @brief Configure parameters for creating pthread\n\n This API allows you to configure how the subsequent\n pthread_create() call will behave. This call can be used to setup\n configuration parameters like stack size, priority, configuration\n inheritance etc.\n\n If the 'inherit' flag in the configuration structure is enabled,\n then the same configuration is also inherited in the thread\n subtree.\n\n @note Passing non-NULL attributes to pthread_create() will override\n       the stack_size parameter set using this API\n\n @param cfg The pthread config parameters\n\n @return\n      - ESP_OK if configuration was successfully set\n      - ESP_ERR_NO_MEM if out of memory\n      - ESP_ERR_INVALID_ARG if stack_size is less than PTHREAD_STACK_MIN"]
    pub fn esp_pthread_set_cfg(cfg: *const esp_pthread_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get current pthread creation configuration\n\n This will retrieve the current configuration that will be used for\n creating threads.\n\n @param p Pointer to the pthread config structure that will be\n updated with the currently configured parameters\n\n @return\n      - ESP_OK if the configuration was available\n      - ESP_ERR_NOT_FOUND if a configuration wasn't previously set"]
    pub fn esp_pthread_get_cfg(p: *mut esp_pthread_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize pthread library"]
    pub fn esp_pthread_init() -> esp_err_t;
}
#[doc = "< RGB data endian: RGB"]
pub const lcd_color_rgb_endian_t_LCD_RGB_ENDIAN_RGB: lcd_color_rgb_endian_t = 0;
#[doc = "< RGB data endian: BGR"]
pub const lcd_color_rgb_endian_t_LCD_RGB_ENDIAN_BGR: lcd_color_rgb_endian_t = 1;
#[doc = " @brief RGB color endian"]
pub type lcd_color_rgb_endian_t = ::core::ffi::c_uint;
#[doc = "< Color space: RGB"]
pub const lcd_color_space_t_LCD_COLOR_SPACE_RGB: lcd_color_space_t = 0;
#[doc = "< Color space: YUV"]
pub const lcd_color_space_t_LCD_COLOR_SPACE_YUV: lcd_color_space_t = 1;
#[doc = " @brief LCD color space"]
pub type lcd_color_space_t = ::core::ffi::c_uint;
#[doc = "< Limited color range"]
pub const lcd_color_range_t_LCD_COLOR_RANGE_LIMIT: lcd_color_range_t = 0;
#[doc = "< Full color range"]
pub const lcd_color_range_t_LCD_COLOR_RANGE_FULL: lcd_color_range_t = 1;
#[doc = " @brief LCD color range"]
pub type lcd_color_range_t = ::core::ffi::c_uint;
#[doc = "< YUV 4:2:2 sampling"]
pub const lcd_yuv_sample_t_LCD_YUV_SAMPLE_422: lcd_yuv_sample_t = 0;
#[doc = "< YUV 4:2:0 sampling"]
pub const lcd_yuv_sample_t_LCD_YUV_SAMPLE_420: lcd_yuv_sample_t = 1;
#[doc = "< YUV 4:1:1 sampling"]
pub const lcd_yuv_sample_t_LCD_YUV_SAMPLE_411: lcd_yuv_sample_t = 2;
#[doc = " @brief YUV sampling method"]
pub type lcd_yuv_sample_t = ::core::ffi::c_uint;
#[doc = "< YUV<->RGB conversion standard: BT.601"]
pub const lcd_yuv_conv_std_t_LCD_YUV_CONV_STD_BT601: lcd_yuv_conv_std_t = 0;
#[doc = "< YUV<->RGB conversion standard: BT.709"]
pub const lcd_yuv_conv_std_t_LCD_YUV_CONV_STD_BT709: lcd_yuv_conv_std_t = 1;
#[doc = " @brief The standard used for conversion between RGB and YUV"]
pub type lcd_yuv_conv_std_t = ::core::ffi::c_uint;
pub type esp_lcd_panel_io_handle_t = *mut esp_lcd_panel_io_t;
pub type esp_lcd_panel_handle_t = *mut esp_lcd_panel_t;
#[doc = "< Color space: RGB"]
pub const esp_lcd_color_space_t_ESP_LCD_COLOR_SPACE_RGB: esp_lcd_color_space_t = 0;
#[doc = "< Color space: BGR"]
pub const esp_lcd_color_space_t_ESP_LCD_COLOR_SPACE_BGR: esp_lcd_color_space_t = 1;
#[doc = "< Color space: monochrome"]
pub const esp_lcd_color_space_t_ESP_LCD_COLOR_SPACE_MONOCHROME: esp_lcd_color_space_t = 2;
#[doc = " @cond */\n/**\n @brief LCD color space type definition (WRONG!)\n @deprecated RGB and BGR should belong to the same color space, but this enum take them both as two different color spaces.\n             If you want to use a enum to describe a color space, please use lcd_color_space_t instead."]
pub type esp_lcd_color_space_t = ::core::ffi::c_uint;
pub type esp_lcd_spi_bus_handle_t = *mut ::core::ffi::c_void;
pub type esp_lcd_i2c_bus_handle_t = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_lcd_i80_bus_t {
    _unused: [u8; 0],
}
pub type esp_lcd_i80_bus_handle_t = *mut esp_lcd_i80_bus_t;
#[doc = " @brief Type of LCD panel IO event data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_io_event_data_t {}
#[doc = " @brief Declare the prototype of the function that will be invoked when panel IO finishes transferring color data\n\n @param[in] panel_io LCD panel IO handle, which is created by factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] edata Panel IO event data, fed by driver\n @param[in] user_ctx User data, passed from `esp_lcd_panel_io_xxx_config_t`\n @return Whether a high priority task has been waken up by this function"]
pub type esp_lcd_panel_io_color_trans_done_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        panel_io: esp_lcd_panel_io_handle_t,
        edata: *mut esp_lcd_panel_io_event_data_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief Type of LCD panel IO callbacks"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_io_callbacks_t {
    #[doc = "< Callback invoked when color data transfer has finished"]
    pub on_color_trans_done: esp_lcd_panel_io_color_trans_done_cb_t,
}
extern "C" {
    #[doc = " @brief Transmit LCD command and receive corresponding parameters\n\n @note Commands sent by this function are short, so they are sent using polling transactions.\n       The function does not return before the command transfer is completed.\n       If any queued transactions sent by `esp_lcd_panel_io_tx_color()` are still pending when this function is called,\n       this function will wait until they are finished and the queue is empty before sending the command(s).\n\n @param[in]  io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @param[in]  lcd_cmd The specific LCD command, set to -1 if no command needed\n @param[out] param Buffer for the command data\n @param[in]  param_size Size of `param` buffer\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NOT_SUPPORTED if read is not supported by transport\n          - ESP_OK                on success"]
    pub fn esp_lcd_panel_io_rx_param(
        io: esp_lcd_panel_io_handle_t,
        lcd_cmd: ::core::ffi::c_int,
        param: *mut ::core::ffi::c_void,
        param_size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Transmit LCD command and corresponding parameters\n\n @note Commands sent by this function are short, so they are sent using polling transactions.\n       The function does not return before the command transfer is completed.\n       If any queued transactions sent by `esp_lcd_panel_io_tx_color()` are still pending when this function is called,\n       this function will wait until they are finished and the queue is empty before sending the command(s).\n\n @param[in] io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] lcd_cmd The specific LCD command (set to -1 if no command needed - only in SPI and I2C)\n @param[in] param Buffer that holds the command specific parameters, set to NULL if no parameter is needed for the command\n @param[in] param_size Size of `param` in memory, in bytes, set to zero if no parameter is needed for the command\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub fn esp_lcd_panel_io_tx_param(
        io: esp_lcd_panel_io_handle_t,
        lcd_cmd: ::core::ffi::c_int,
        param: *const ::core::ffi::c_void,
        param_size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Transmit LCD RGB data\n\n @note This function will package the command and RGB data into a transaction, and push into a queue.\n       The real transmission is performed in the background (DMA+interrupt).\n       The caller should take care of the lifecycle of the `color` buffer.\n       Recycling of color buffer should be done in the callback `on_color_trans_done()`.\n\n @param[in] io LCD panel IO handle, which is created by factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] lcd_cmd The specific LCD command, set to -1 if no command needed\n @param[in] color Buffer that holds the RGB color data\n @param[in] color_size Size of `color` in memory, in bytes\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub fn esp_lcd_panel_io_tx_color(
        io: esp_lcd_panel_io_handle_t,
        lcd_cmd: ::core::ffi::c_int,
        color: *const ::core::ffi::c_void,
        color_size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Destroy LCD panel IO handle (deinitialize panel and free all corresponding resource)\n\n @param[in] io LCD panel IO handle, which is created by factory API like `esp_lcd_new_panel_io_spi()`\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub fn esp_lcd_panel_io_del(io: esp_lcd_panel_io_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register LCD panel IO callbacks\n\n @param[in] io LCD panel IO handle, which is created by factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] cbs structure with all LCD panel IO callbacks\n @param[in] user_ctx User private data, passed directly to callback's user_ctx\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub fn esp_lcd_panel_io_register_event_callbacks(
        io: esp_lcd_panel_io_handle_t,
        cbs: *const esp_lcd_panel_io_callbacks_t,
        user_ctx: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief Panel IO configuration structure, for SPI interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_lcd_panel_io_spi_config_t {
    #[doc = "< GPIO used for CS line"]
    pub cs_gpio_num: ::core::ffi::c_int,
    #[doc = "< GPIO used to select the D/C line, set this to -1 if the D/C line is not used"]
    pub dc_gpio_num: ::core::ffi::c_int,
    #[doc = "< Traditional SPI mode (0~3)"]
    pub spi_mode: ::core::ffi::c_int,
    #[doc = "< Frequency of pixel clock"]
    pub pclk_hz: ::core::ffi::c_uint,
    #[doc = "< Size of internal transaction queue"]
    pub trans_queue_depth: usize,
    #[doc = "< Callback invoked when color data transfer has finished"]
    pub on_color_trans_done: esp_lcd_panel_io_color_trans_done_cb_t,
    #[doc = "< User private data, passed directly to on_color_trans_done's user_ctx"]
    pub user_ctx: *mut ::core::ffi::c_void,
    #[doc = "< Bit-width of LCD command"]
    pub lcd_cmd_bits: ::core::ffi::c_int,
    #[doc = "< Bit-width of LCD parameter"]
    pub lcd_param_bits: ::core::ffi::c_int,
    #[doc = "< Extra flags to fine-tune the SPI device"]
    pub flags: esp_lcd_panel_io_spi_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_io_spi_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl esp_lcd_panel_io_spi_config_t__bindgen_ty_1 {
    #[inline]
    pub fn dc_low_on_data(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_low_on_data(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn octal_mode(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_octal_mode(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sio_mode(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sio_mode(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lsb_first(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsb_first(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_high_active(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_high_active(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dc_low_on_data: ::core::ffi::c_uint,
        octal_mode: ::core::ffi::c_uint,
        sio_mode: ::core::ffi::c_uint,
        lsb_first: ::core::ffi::c_uint,
        cs_high_active: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dc_low_on_data: u32 = unsafe { ::core::mem::transmute(dc_low_on_data) };
            dc_low_on_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let octal_mode: u32 = unsafe { ::core::mem::transmute(octal_mode) };
            octal_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sio_mode: u32 = unsafe { ::core::mem::transmute(sio_mode) };
            sio_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lsb_first: u32 = unsafe { ::core::mem::transmute(lsb_first) };
            lsb_first as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cs_high_active: u32 = unsafe { ::core::mem::transmute(cs_high_active) };
            cs_high_active as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for esp_lcd_panel_io_spi_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create LCD panel IO handle, for SPI interface\n\n @param[in] bus SPI bus handle\n @param[in] io_config IO configuration, for SPI interface\n @param[out] ret_io Returned IO handle\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NO_MEM        if out of memory\n          - ESP_OK                on success"]
    pub fn esp_lcd_new_panel_io_spi(
        bus: esp_lcd_spi_bus_handle_t,
        io_config: *const esp_lcd_panel_io_spi_config_t,
        ret_io: *mut esp_lcd_panel_io_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief Panel IO configuration structure, for I2C interface\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_lcd_panel_io_i2c_config_t {
    #[doc = "< I2C device address"]
    pub dev_addr: u32,
    #[doc = "< Callback invoked when color data transfer has finished"]
    pub on_color_trans_done: esp_lcd_panel_io_color_trans_done_cb_t,
    #[doc = "< User private data, passed directly to on_color_trans_done's user_ctx"]
    pub user_ctx: *mut ::core::ffi::c_void,
    #[doc = "< I2C LCD panel will encode control information (e.g. D/C selection) into control phase, in several bytes"]
    pub control_phase_bytes: usize,
    #[doc = "< Offset of the D/C selection bit in control phase"]
    pub dc_bit_offset: ::core::ffi::c_uint,
    #[doc = "< Bit-width of LCD command"]
    pub lcd_cmd_bits: ::core::ffi::c_int,
    #[doc = "< Bit-width of LCD parameter"]
    pub lcd_param_bits: ::core::ffi::c_int,
    #[doc = "< Extra flags to fine-tune the I2C device"]
    pub flags: esp_lcd_panel_io_i2c_config_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_io_i2c_config_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl esp_lcd_panel_io_i2c_config_t__bindgen_ty_1 {
    #[inline]
    pub fn dc_low_on_data(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_low_on_data(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_control_phase(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_control_phase(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dc_low_on_data: ::core::ffi::c_uint,
        disable_control_phase: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dc_low_on_data: u32 = unsafe { ::core::mem::transmute(dc_low_on_data) };
            dc_low_on_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disable_control_phase: u32 =
                unsafe { ::core::mem::transmute(disable_control_phase) };
            disable_control_phase as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for esp_lcd_panel_io_i2c_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create LCD panel IO handle, for I2C interface\n\n @param[in] bus I2C bus handle\n @param[in] io_config IO configuration, for I2C interface\n @param[out] ret_io Returned IO handle\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NO_MEM        if out of memory\n          - ESP_OK                on success"]
    pub fn esp_lcd_new_panel_io_i2c(
        bus: esp_lcd_i2c_bus_handle_t,
        io_config: *const esp_lcd_panel_io_i2c_config_t,
        ret_io: *mut esp_lcd_panel_io_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset LCD panel\n\n @note Panel reset must be called before attempting to initialize the panel using `esp_lcd_panel_init()`.\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_reset(panel: esp_lcd_panel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize LCD panel\n\n @note Before calling this function, make sure the LCD panel has finished the `reset` stage by `esp_lcd_panel_reset()`.\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_init(panel: esp_lcd_panel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize the LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_del(panel: esp_lcd_panel_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Draw bitmap on LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] x_start Start index on x-axis (x_start included)\n @param[in] y_start Start index on y-axis (y_start included)\n @param[in] x_end End index on x-axis (x_end not included)\n @param[in] y_end End index on y-axis (y_end not included)\n @param[in] color_data RGB color data that will be dumped to the specific window range\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_draw_bitmap(
        panel: esp_lcd_panel_handle_t,
        x_start: ::core::ffi::c_int,
        y_start: ::core::ffi::c_int,
        x_end: ::core::ffi::c_int,
        y_end: ::core::ffi::c_int,
        color_data: *const ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Mirror the LCD panel on specific axis\n\n @note Combined with `esp_lcd_panel_swap_xy()`, one can realize screen rotation\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] mirror_x Whether the panel will be mirrored about the x axis\n @param[in] mirror_y Whether the panel will be mirrored about the y axis\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub fn esp_lcd_panel_mirror(
        panel: esp_lcd_panel_handle_t,
        mirror_x: bool,
        mirror_y: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Swap/Exchange x and y axis\n\n @note Combined with `esp_lcd_panel_mirror()`, one can realize screen rotation\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] swap_axes Whether to swap the x and y axis\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub fn esp_lcd_panel_swap_xy(panel: esp_lcd_panel_handle_t, swap_axes: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set extra gap in x and y axis\n\n The gap is the space (in pixels) between the left/top sides of the LCD panel and the first row/column respectively of the actual contents displayed.\n\n @note Setting a gap is useful when positioning or centering a frame that is smaller than the LCD.\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] x_gap Extra gap on x axis, in pixels\n @param[in] y_gap Extra gap on y axis, in pixels\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_set_gap(
        panel: esp_lcd_panel_handle_t,
        x_gap: ::core::ffi::c_int,
        y_gap: ::core::ffi::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Invert the color (bit-wise invert the color data line)\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] invert_color_data Whether to invert the color data\n @return\n          - ESP_OK on success"]
    pub fn esp_lcd_panel_invert_color(
        panel: esp_lcd_panel_handle_t,
        invert_color_data: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Turn on or off the display\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] on_off True to turns on display, False to turns off display\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub fn esp_lcd_panel_disp_on_off(panel: esp_lcd_panel_handle_t, on_off: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Turn off the display\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] off Whether to turn off the screen\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub fn esp_lcd_panel_disp_off(panel: esp_lcd_panel_handle_t, off: bool) -> esp_err_t;
}
#[doc = " @brief Configuration structure for panel device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_lcd_panel_dev_config_t {
    #[doc = "< GPIO used to reset the LCD panel, set to -1 if it's not used"]
    pub reset_gpio_num: ::core::ffi::c_int,
    pub __bindgen_anon_1: esp_lcd_panel_dev_config_t__bindgen_ty_1,
    #[doc = "< Color depth, in bpp"]
    pub bits_per_pixel: ::core::ffi::c_uint,
    #[doc = "< LCD panel config flags"]
    pub flags: esp_lcd_panel_dev_config_t__bindgen_ty_2,
    #[doc = "< vendor specific configuration, optional, left as NULL if not used"]
    pub vendor_config: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union esp_lcd_panel_dev_config_t__bindgen_ty_1 {
    #[doc = "< @deprecated Set RGB color space, please use rgb_endian instead"]
    pub color_space: lcd_color_rgb_endian_t,
    #[doc = "< Set RGB data endian: RGB or BGR"]
    pub rgb_endian: lcd_color_rgb_endian_t,
}
impl Default for esp_lcd_panel_dev_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_dev_config_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl esp_lcd_panel_dev_config_t__bindgen_ty_2 {
    #[inline]
    pub fn reset_active_high(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset_active_high(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset_active_high: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset_active_high: u32 = unsafe { ::core::mem::transmute(reset_active_high) };
            reset_active_high as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for esp_lcd_panel_dev_config_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create LCD panel for model ST7789\n\n @param[in] io LCD panel IO handle\n @param[in] panel_dev_config general panel device configuration\n @param[out] ret_panel Returned LCD panel handle\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NO_MEM        if out of memory\n          - ESP_OK                on success"]
    pub fn esp_lcd_new_panel_st7789(
        io: esp_lcd_panel_io_handle_t,
        panel_dev_config: *const esp_lcd_panel_dev_config_t,
        ret_panel: *mut esp_lcd_panel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create LCD panel for model NT35510\n\n @param[in] io LCD panel IO handle\n @param[in] panel_dev_config general panel device configuration\n @param[out] ret_panel Returned LCD panel handle\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NO_MEM        if out of memory\n          - ESP_OK                on success"]
    pub fn esp_lcd_new_panel_nt35510(
        io: esp_lcd_panel_io_handle_t,
        panel_dev_config: *const esp_lcd_panel_dev_config_t,
        ret_panel: *mut esp_lcd_panel_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create LCD panel for model SSD1306\n\n @param[in] io LCD panel IO handle\n @param[in] panel_dev_config general panel device configuration\n @param[out] ret_panel Returned LCD panel handle\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NO_MEM        if out of memory\n          - ESP_OK                on success"]
    pub fn esp_lcd_new_panel_ssd1306(
        io: esp_lcd_panel_io_handle_t,
        panel_dev_config: *const esp_lcd_panel_dev_config_t,
        ret_panel: *mut esp_lcd_panel_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief LCD panel interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_t {
    #[doc = " @brief Reset LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub reset:
        ::core::option::Option<unsafe extern "C" fn(panel: *mut esp_lcd_panel_t) -> esp_err_t>,
    #[doc = " @brief Initialize LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub init:
        ::core::option::Option<unsafe extern "C" fn(panel: *mut esp_lcd_panel_t) -> esp_err_t>,
    #[doc = " @brief Destory LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @return\n          - ESP_OK on success"]
    pub del: ::core::option::Option<unsafe extern "C" fn(panel: *mut esp_lcd_panel_t) -> esp_err_t>,
    #[doc = " @brief Draw bitmap on LCD panel\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] x_start Start index on x-axis (x_start included)\n @param[in] y_start Start index on y-axis (y_start included)\n @param[in] x_end End index on x-axis (x_end not included)\n @param[in] y_end End index on y-axis (y_end not included)\n @param[in] color_data RGB color data that will be dumped to the specific window range\n @return\n          - ESP_OK on success"]
    pub draw_bitmap: ::core::option::Option<
        unsafe extern "C" fn(
            panel: *mut esp_lcd_panel_t,
            x_start: ::core::ffi::c_int,
            y_start: ::core::ffi::c_int,
            x_end: ::core::ffi::c_int,
            y_end: ::core::ffi::c_int,
            color_data: *const ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Mirror the LCD panel on specific axis\n\n @note Combine this function with `swap_xy`, one can realize screen rotatation\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] x_axis Whether the panel will be mirrored about the x_axis\n @param[in] y_axis Whether the panel will be mirrored about the y_axis\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub mirror: ::core::option::Option<
        unsafe extern "C" fn(panel: *mut esp_lcd_panel_t, x_axis: bool, y_axis: bool) -> esp_err_t,
    >,
    #[doc = " @brief Swap/Exchange x and y axis\n\n @note Combine this function with `mirror`, one can realize screen rotatation\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] swap_axes Whether to swap the x and y axis\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub swap_xy: ::core::option::Option<
        unsafe extern "C" fn(panel: *mut esp_lcd_panel_t, swap_axes: bool) -> esp_err_t,
    >,
    #[doc = " @brief Set extra gap in x and y axis\n\n @note The gap is only used for calculating the real coordinates.\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] x_gap Extra gap on x axis, in pixels\n @param[in] y_gap Extra gap on y axis, in pixels\n @return\n          - ESP_OK on success"]
    pub set_gap: ::core::option::Option<
        unsafe extern "C" fn(
            panel: *mut esp_lcd_panel_t,
            x_gap: ::core::ffi::c_int,
            y_gap: ::core::ffi::c_int,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Invert the color (bit 1 -> 0 for color data line, and vice versa)\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] invert_color_data Whether to invert the color data\n @return\n          - ESP_OK on success"]
    pub invert_color: ::core::option::Option<
        unsafe extern "C" fn(panel: *mut esp_lcd_panel_t, invert_color_data: bool) -> esp_err_t,
    >,
    #[doc = " @brief Turn on or off the display\n\n @param[in] panel LCD panel handle, which is created by other factory API like `esp_lcd_new_panel_st7789()`\n @param[in] on_off True to turns on display, False to turns off display\n @return\n          - ESP_OK on success\n          - ESP_ERR_NOT_SUPPORTED if this function is not supported by the panel"]
    pub disp_on_off: ::core::option::Option<
        unsafe extern "C" fn(panel: *mut esp_lcd_panel_t, on_off: bool) -> esp_err_t,
    >,
}
#[doc = " @brief LCD panel IO interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct esp_lcd_panel_io_t {
    #[doc = " @brief Transmit LCD command and receive corresponding parameters\n\n @note This is the panel-specific interface called by function `esp_lcd_panel_io_rx_param()`.\n\n @param[in]  io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @param[in]  lcd_cmd The specific LCD command, set to -1 if no command needed\n @param[out] param Buffer for the command data\n @param[in]  param_size Size of `param` buffer\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_ERR_NOT_SUPPORTED if read is not supported by transport\n          - ESP_OK                on success"]
    pub rx_param: ::core::option::Option<
        unsafe extern "C" fn(
            io: *mut esp_lcd_panel_io_t,
            lcd_cmd: ::core::ffi::c_int,
            param: *mut ::core::ffi::c_void,
            param_size: usize,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Transmit LCD command and corresponding parameters\n\n @note This is the panel-specific interface called by function `esp_lcd_panel_io_tx_param()`.\n\n @param[in] io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] lcd_cmd The specific LCD command\n @param[in] param Buffer that holds the command specific parameters, set to NULL if no parameter is needed for the command\n @param[in] param_size Size of `param` in memory, in bytes, set to zero if no parameter is needed for the command\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub tx_param: ::core::option::Option<
        unsafe extern "C" fn(
            io: *mut esp_lcd_panel_io_t,
            lcd_cmd: ::core::ffi::c_int,
            param: *const ::core::ffi::c_void,
            param_size: usize,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Transmit LCD RGB data\n\n @note This is the panel-specific interface called by function `esp_lcd_panel_io_tx_color()`.\n\n @param[in] io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] lcd_cmd The specific LCD command\n @param[in] color Buffer that holds the RGB color data\n @param[in] color_size Size of `color` in memory, in bytes\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub tx_color: ::core::option::Option<
        unsafe extern "C" fn(
            io: *mut esp_lcd_panel_io_t,
            lcd_cmd: ::core::ffi::c_int,
            color: *const ::core::ffi::c_void,
            color_size: usize,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Destory LCD panel IO handle (deinitialize all and free resource)\n\n @param[in] io LCD panel IO handle, which is created by other factory API like `esp_lcd_new_panel_io_spi()`\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub del: ::core::option::Option<unsafe extern "C" fn(io: *mut esp_lcd_panel_io_t) -> esp_err_t>,
    #[doc = " @brief Register LCD panel IO callbacks\n\n @param[in] io LCD panel IO handle, which is created by factory API like `esp_lcd_new_panel_io_spi()`\n @param[in] cbs structure with all LCD panel IO callbacks\n @param[in] user_ctx User private data, passed directly to callback's user_ctx\n @return\n          - ESP_ERR_INVALID_ARG   if parameter is invalid\n          - ESP_OK                on success"]
    pub register_event_callbacks: ::core::option::Option<
        unsafe extern "C" fn(
            io: *mut esp_lcd_panel_io_t,
            cbs: *const esp_lcd_panel_io_callbacks_t,
            user_ctx: *mut ::core::ffi::c_void,
        ) -> esp_err_t,
    >,
}
pub type __builtin_va_list = *mut ::core::ffi::c_void;
